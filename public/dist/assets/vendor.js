var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key2, value2) => key2 in obj ? __defProp2(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __spreadValues2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp2.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b2)) {
      if (__propIsEnum2.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
function makeMap(str2, expectsLowerCase) {
  const map2 = Object.create(null);
  const list = str2.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map2[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value2) {
  return !!value2 || value2 === "";
}
function normalizeStyle(value2) {
  if (isArray$9(value2)) {
    const res = {};
    for (let i2 = 0; i2 < value2.length; i2++) {
      const item = value2[i2];
      const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key2 in normalized) {
          res[key2] = normalized[key2];
        }
      }
    }
    return res;
  } else if (isString$2(value2)) {
    return value2;
  } else if (isObject$5(value2)) {
    return value2;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value2) {
  let res = "";
  if (isString$2(value2)) {
    res = value2;
  } else if (isArray$9(value2)) {
    for (let i2 = 0; i2 < value2.length; i2++) {
      const normalized = normalizeClass(value2[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$5(value2)) {
    for (const name2 in value2) {
      if (value2[name2]) {
        res += name2 + " ";
      }
    }
  }
  return res.trim();
}
const toDisplayString$1 = (val) => {
  return val == null ? "" : isArray$9(val) || isObject$5(val) && (val.toString === objectToString$3 || !isFunction$4(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key2, val2]) => {
        entries[`${key2} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$5(val) && !isArray$9(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key2) => onRE.test(key2);
const isModelListener = (key2) => key2.startsWith("onUpdate:");
const extend$4 = Object.assign;
const remove = (arr2, el) => {
  const i2 = arr2.indexOf(el);
  if (i2 > -1) {
    arr2.splice(i2, 1);
  }
};
const hasOwnProperty$8 = Object.prototype.hasOwnProperty;
const hasOwn$4 = (val, key2) => hasOwnProperty$8.call(val, key2);
const isArray$9 = Array.isArray;
const isMap = (val) => toTypeString$2(val) === "[object Map]";
const isSet = (val) => toTypeString$2(val) === "[object Set]";
const isFunction$4 = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$5 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return isObject$5(val) && isFunction$4(val.then) && isFunction$4(val.catch);
};
const objectToString$3 = Object.prototype.toString;
const toTypeString$2 = (value2) => objectToString$3.call(value2);
const toRawType = (value2) => {
  return toTypeString$2(value2).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString$2(val) === "[object Object]";
const isIntegerKey = (key2) => isString$2(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const cacheStringFunction = (fn) => {
  const cache2 = Object.create(null);
  return (str2) => {
    const hit = cache2[str2];
    return hit || (cache2[str2] = fn(str2));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str2) => {
  return str2.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str2) => str2.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str2) => str2.charAt(0).toUpperCase() + str2.slice(1));
const toHandlerKey = cacheStringFunction((str2) => str2 ? `on${capitalize(str2)}` : ``);
const hasChanged = (value2, oldValue) => !Object.is(value2, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg);
  }
};
const def = (obj, key2, value2) => {
  Object.defineProperty(obj, key2, {
    configurable: true,
    enumerable: false,
    value: value2
  });
};
const toNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
let _globalThis$1;
const getGlobalThis$1 = () => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
let activeEffectScope;
const effectScopeStack = [];
class EffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn) {
    if (this.active) {
      try {
        this.on();
        return fn();
      } finally {
        this.off();
      }
    }
  }
  on() {
    if (this.active) {
      effectScopeStack.push(this);
      activeEffectScope = this;
    }
  }
  off() {
    if (this.active) {
      effectScopeStack.pop();
      activeEffectScope = effectScopeStack[effectScopeStack.length - 1];
    }
  }
  stop(fromParent) {
    if (this.active) {
      this.effects.forEach((e2) => e2.stop());
      this.cleanups.forEach((cleanup) => cleanup());
      if (this.scopes) {
        this.scopes.forEach((e2) => e2.stop(true));
      }
      if (this.parent && !fromParent) {
        const last2 = this.parent.scopes.pop();
        if (last2 && last2 !== this) {
          this.parent.scopes[this.index] = last2;
          last2.index = this.index;
        }
      }
      this.active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect, scope) {
  scope = scope || activeEffectScope;
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i2 = 0; i2 < deps.length; i2++) {
      const dep = deps[i2];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
const effectStack = [];
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    if (!effectStack.includes(this)) {
      try {
        effectStack.push(activeEffect = this);
        enableTracking();
        trackOpBit = 1 << ++effectTrackDepth;
        if (effectTrackDepth <= maxMarkerBits) {
          initDepMarkers(this);
        } else {
          cleanupEffect(this);
        }
        return this.fn();
      } finally {
        if (effectTrackDepth <= maxMarkerBits) {
          finalizeDepMarkers(this);
        }
        trackOpBit = 1 << --effectTrackDepth;
        resetTracking();
        effectStack.pop();
        const n2 = effectStack.length;
        activeEffect = n2 > 0 ? effectStack[n2 - 1] : void 0;
      }
    }
  }
  stop() {
    if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function enableTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = true;
}
function resetTracking() {
  const last2 = trackStack.pop();
  shouldTrack = last2 === void 0 ? true : last2;
}
function track(target, type, key2) {
  if (!isTracking()) {
    return;
  }
  let depsMap = targetMap.get(target);
  if (!depsMap) {
    targetMap.set(target, depsMap = new Map());
  }
  let dep = depsMap.get(key2);
  if (!dep) {
    depsMap.set(key2, dep = createDep());
  }
  trackEffects(dep);
}
function isTracking() {
  return shouldTrack && activeEffect !== void 0;
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger$1(target, type, key2, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key2 === "length" && isArray$9(target)) {
    depsMap.forEach((dep, key3) => {
      if (key3 === "length" || key3 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key2 !== void 0) {
      deps.push(depsMap.get(key2));
    }
    switch (type) {
      case "add":
        if (!isArray$9(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key2)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$9(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  for (const effect of isArray$9(dep) ? dep : [...dep]) {
    if (effect !== activeEffect || effect.allowRecurse) {
      if (effect.scheduler) {
        effect.scheduler();
      } else {
        effect.run();
      }
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key2) => Symbol[key2]).filter(isSymbol));
const get = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      const arr2 = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr2, "get", i2 + "");
      }
      const res = arr2[key2](...args);
      if (res === -1 || res === false) {
        return arr2[key2](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key2) => {
    instrumentations[key2] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key2].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get15(target, key2, receiver) {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$9(target);
    if (!isReadonly2 && targetIsArray && hasOwn$4(arrayInstrumentations, key2)) {
      return Reflect.get(arrayInstrumentations, key2, receiver);
    }
    const res = Reflect.get(target, key2, receiver);
    if (isSymbol(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key2);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      const shouldUnwrap = !targetIsArray || !isIntegerKey(key2);
      return shouldUnwrap ? res.value : res;
    }
    if (isObject$5(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set6(target, key2, value2, receiver) {
    let oldValue = target[key2];
    if (!shallow && !isReadonly(value2)) {
      value2 = toRaw(value2);
      oldValue = toRaw(oldValue);
      if (!isArray$9(target) && isRef(oldValue) && !isRef(value2)) {
        oldValue.value = value2;
        return true;
      }
    }
    const hadKey = isArray$9(target) && isIntegerKey(key2) ? Number(key2) < target.length : hasOwn$4(target, key2);
    const result = Reflect.set(target, key2, value2, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger$1(target, "add", key2, value2);
      } else if (hasChanged(value2, oldValue)) {
        trigger$1(target, "set", key2, value2);
      }
    }
    return result;
  };
}
function deleteProperty(target, key2) {
  const hadKey = hasOwn$4(target, key2);
  target[key2];
  const result = Reflect.deleteProperty(target, key2);
  if (result && hadKey) {
    trigger$1(target, "delete", key2, void 0);
  }
  return result;
}
function has(target, key2) {
  const result = Reflect.has(target, key2);
  if (!isSymbol(key2) || !builtInSymbols.has(key2)) {
    track(target, "has", key2);
  }
  return result;
}
function ownKeys$1(target) {
  track(target, "iterate", isArray$9(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys: ownKeys$1
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key2) {
    return true;
  },
  deleteProperty(target, key2) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$4({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const toShallow = (value2) => value2;
const getProto$2 = (v2) => Reflect.getPrototypeOf(v2);
function get$1(target, key2, isReadonly2 = false, isShallow = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (key2 !== rawKey) {
    !isReadonly2 && track(rawTarget, "get", key2);
  }
  !isReadonly2 && track(rawTarget, "get", rawKey);
  const { has: has2 } = getProto$2(rawTarget);
  const wrap2 = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key2)) {
    return wrap2(target.get(key2));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap2(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key2);
  }
}
function has$1(key2, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key2);
  if (key2 !== rawKey) {
    !isReadonly2 && track(rawTarget, "has", key2);
  }
  !isReadonly2 && track(rawTarget, "has", rawKey);
  return key2 === rawKey ? target.has(key2) : target.has(key2) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value2) {
  value2 = toRaw(value2);
  const target = toRaw(this);
  const proto = getProto$2(target);
  const hadKey = proto.has.call(target, value2);
  if (!hadKey) {
    target.add(value2);
    trigger$1(target, "add", value2, value2);
  }
  return this;
}
function set$1(key2, value2) {
  value2 = toRaw(value2);
  const target = toRaw(this);
  const { has: has2, get: get15 } = getProto$2(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  }
  const oldValue = get15.call(target, key2);
  target.set(key2, value2);
  if (!hadKey) {
    trigger$1(target, "add", key2, value2);
  } else if (hasChanged(value2, oldValue)) {
    trigger$1(target, "set", key2, value2);
  }
  return this;
}
function deleteEntry(key2) {
  const target = toRaw(this);
  const { has: has2, get: get15 } = getProto$2(target);
  let hadKey = has2.call(target, key2);
  if (!hadKey) {
    key2 = toRaw(key2);
    hadKey = has2.call(target, key2);
  }
  get15 ? get15.call(target, key2) : void 0;
  const result = target.delete(key2);
  if (hadKey) {
    trigger$1(target, "delete", key2, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger$1(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow) {
  return function forEach3(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap2 = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value2, key2) => {
      return callback.call(thisArg, wrap2(value2), wrap2(key2), observed);
    });
  };
}
function createIterableMethod(method2, isReadonly2, isShallow) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method2 === "entries" || method2 === Symbol.iterator && targetIsMap;
    const isKeyOnly = method2 === "keys" && targetIsMap;
    const innerIterator = target[method2](...args);
    const wrap2 = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value: value2, done: done2 } = innerIterator.next();
        return done2 ? { value: value2, done: done2 } : {
          value: isPair ? [wrap2(value2[0]), wrap2(value2[1])] : wrap2(value2),
          done: done2
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key2) {
      return get$1(this, key2);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key2) {
      return get$1(this, key2, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key2) {
      return get$1(this, key2, true);
    },
    get size() {
      return size(this, true);
    },
    has(key2) {
      return has$1.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key2) {
      return get$1(this, key2, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key2) {
      return has$1.call(this, key2, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method2) => {
    mutableInstrumentations2[method2] = createIterableMethod(method2, false, false);
    readonlyInstrumentations2[method2] = createIterableMethod(method2, true, false);
    shallowInstrumentations2[method2] = createIterableMethod(method2, false, true);
    shallowReadonlyInstrumentations2[method2] = createIterableMethod(method2, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key2, receiver) => {
    if (key2 === "__v_isReactive") {
      return !isReadonly2;
    } else if (key2 === "__v_isReadonly") {
      return isReadonly2;
    } else if (key2 === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn$4(instrumentations, key2) && key2 in target ? instrumentations : target, key2, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = new WeakMap();
const shallowReactiveMap = new WeakMap();
const readonlyMap = new WeakMap();
const shallowReadonlyMap = new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value2) {
  return value2["__v_skip"] || !Object.isExtensible(value2) ? 0 : targetTypeMap(toRawType(value2));
}
function reactive(target) {
  if (target && target["__v_isReadonly"]) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$5(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value2) {
  if (isReadonly(value2)) {
    return isReactive(value2["__v_raw"]);
  }
  return !!(value2 && value2["__v_isReactive"]);
}
function isReadonly(value2) {
  return !!(value2 && value2["__v_isReadonly"]);
}
function isProxy(value2) {
  return isReactive(value2) || isReadonly(value2);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value2) {
  def(value2, "__v_skip", true);
  return value2;
}
const toReactive = (value2) => isObject$5(value2) ? reactive(value2) : value2;
const toReadonly = (value2) => isObject$5(value2) ? readonly(value2) : value2;
function trackRefValue(ref2) {
  if (isTracking()) {
    ref2 = toRaw(ref2);
    if (!ref2.dep) {
      ref2.dep = createDep();
    }
    {
      trackEffects(ref2.dep);
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r2) {
  return Boolean(r2 && r2.__v_isRef === true);
}
function ref(value2) {
  return createRef(value2, false);
}
function shallowRef(value2) {
  return createRef(value2, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value2, _shallow) {
    this._shallow = _shallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = _shallow ? value2 : toRaw(value2);
    this._value = _shallow ? value2 : toReactive(value2);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this._shallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this._shallow ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key2, receiver) => unref(Reflect.get(target, key2, receiver)),
  set: (target, key2, value2, receiver) => {
    const oldValue = target[key2];
    if (isRef(oldValue) && !isRef(value2)) {
      oldValue.value = value2;
      return true;
    } else {
      return Reflect.set(target, key2, value2, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object2) {
  const ret = isArray$9(object2) ? new Array(object2.length) : {};
  for (const key2 in object2) {
    ret[key2] = toRef(object2, key2);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
}
function toRef(object2, key2, defaultValue) {
  const val = object2[key2];
  return isRef(val) ? val : new ObjectRefImpl(object2, key2, defaultValue);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2) {
    this._setter = _setter;
    this.dep = void 0;
    this._dirty = true;
    this.__v_isRef = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed(getterOrOptions, debugOptions) {
  let getter;
  let setter;
  const onlyGetter = isFunction$4(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter);
  return cRef;
}
Promise.resolve();
function emit$1(instance, event, ...rawArgs) {
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number2, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a2) => a2.trim());
    } else if (number2) {
      args = rawArgs.map(toNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$4(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$4(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    cache2.set(comp, null);
    return null;
  }
  if (isArray$9(raw)) {
    raw.forEach((key2) => normalized[key2] = null);
  } else {
    extend$4(normalized, raw);
  }
  cache2.set(comp, normalized);
  return normalized;
}
function isEmitListener(options, key2) {
  if (!options || !isOn(key2)) {
    return false;
  }
  key2 = key2.slice(2).replace(/Once$/, "");
  return hasOwn$4(options, key2[0].toLowerCase() + key2.slice(1)) || hasOwn$4(options, hyphenate(key2)) || hasOwn$4(options, key2);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn(...args);
    setCurrentRenderingInstance(prevInstance);
    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render: render3, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render3.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render4 = Component;
      if (false)
        ;
      result = normalizeVNode(render4.length > 1 ? render4(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit: emit2
      } : { attrs, slots, emit: emit2 }) : render4(props, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root2 = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root2;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root2 = cloneVNode(root2, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root2.transition = vnode.transition;
  }
  {
    result = root2;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key2 in attrs) {
    if (key2 === "class" || key2 === "style" || isOn(key2)) {
      (res || (res = {}))[key2] = attrs[key2];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key2 in attrs) {
    if (!isModelListener(key2) || !(key2.slice(9) in props)) {
      res[key2] = attrs[key2];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key2 = dynamicProps[i2];
        if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emits, key2)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key2 = nextKeys[i2];
    if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emitsOptions, key2)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$9(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function provide(key2, value2) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key2] = value2;
  }
}
function inject(key2, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key2 in provides) {
      return provides[key2];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$4(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
function useTransitionState() {
  const state2 = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: new Map()
  };
  onMounted(() => {
    state2.isMounted = true;
  });
  onBeforeUnmount(() => {
    state2.isUnmounting = true;
  });
  return state2;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state2 = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const rawProps = toRaw(props);
      const { mode: mode2 } = rawProps;
      const child = children[0];
      if (state2.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state2, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key2 = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key2;
        } else if (key2 !== prevTransitionKey) {
          prevTransitionKey = key2;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state2, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode2 === "out-in") {
          state2.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state2.isLeaving = false;
            instance.update();
          };
          return emptyPlaceholder(child);
        } else if (mode2 === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state2, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state2, vnode) {
  const { leavingVNodes } = state2;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state2, instance) {
  const { appear, mode: mode2, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key2 = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state2, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const hooks = {
    mode: mode2,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state2.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key2];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state2.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done2 = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        hook(el, done2);
        if (hook.length <= 1) {
          done2();
        }
      } else {
        done2();
      }
    },
    leave(el, remove2) {
      const key3 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(true);
      }
      if (state2.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done2 = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key3] === vnode) {
          delete leavingVNodesCache[key3];
        }
      };
      leavingVNodesCache[key3] = vnode;
      if (onLeave) {
        onLeave(el, done2);
        if (onLeave.length <= 1) {
          done2();
        }
      } else {
        done2();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state2, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (child.type === Fragment$1) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
    } else if (keepComment || child.type !== Comment) {
      ret.push(child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction$4(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render3,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters: filters2
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key2 in methods) {
      const methodHandler = methods[key2];
      if (isFunction$4(methodHandler)) {
        {
          ctx[key2] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$5(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key2 in computedOptions) {
      const opt = computedOptions[key2];
      const get15 = isFunction$4(opt) ? opt.bind(publicThis, publicThis) : isFunction$4(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set6 = !isFunction$4(opt) && isFunction$4(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get15,
        set: set6
      });
      Object.defineProperty(ctx, key2, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key2 in watchOptions) {
      createWatcher(watchOptions[key2], ctx, publicThis, key2);
    }
  }
  if (provideOptions) {
    const provides = isFunction$4(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key2) => {
      provide(key2, provides[key2]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$9(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$9(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key2) => {
        Object.defineProperty(exposed, key2, {
          get: () => publicThis[key2],
          set: (val) => publicThis[key2] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render3 && instance.render === NOOP) {
    instance.render = render3;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$9(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key2 in injectOptions) {
    const opt = injectOptions[key2];
    let injected;
    if (isObject$5(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key2, opt.default, true);
      } else {
        injected = inject(opt.from || key2);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        ctx[key2] = injected;
      }
    } else {
      ctx[key2] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(isArray$9(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key2) {
  const getter = key2.includes(".") ? createPathGetter(publicThis, key2) : () => publicThis[key2];
  if (isString$2(raw)) {
    const handler = ctx[raw];
    if (isFunction$4(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$4(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$5(raw)) {
    if (isArray$9(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key2));
    } else {
      const handler = isFunction$4(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$4(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base2 = instance.type;
  const { mixins, extends: extendsOptions } = base2;
  const { mixins: globalMixins, optionsCache: cache2, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache2.get(base2);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base2;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true));
    }
    mergeOptions$1(resolved, base2, optionMergeStrategies);
  }
  cache2.set(base2, resolved);
  return resolved;
}
function mergeOptions$1(to, from2, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from2;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m2) => mergeOptions$1(to, m2, strats, true));
  }
  for (const key2 in from2) {
    if (asMixin && key2 === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key2] || strats && strats[key2];
      to[key2] = strat ? strat(to[key2], from2[key2]) : from2[key2];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from2) {
  if (!from2) {
    return to;
  }
  if (!to) {
    return from2;
  }
  return function mergedDataFn() {
    return extend$4(isFunction$4(to) ? to.call(this, this) : to, isFunction$4(from2) ? from2.call(this, this) : from2);
  };
}
function mergeInject(to, from2) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from2));
}
function normalizeInject(raw) {
  if (isArray$9(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from2) {
  return to ? [...new Set([].concat(to, from2))] : from2;
}
function mergeObjectOptions(to, from2) {
  return to ? extend$4(extend$4(Object.create(null), to), from2) : from2;
}
function mergeWatchOptions(to, from2) {
  if (!to)
    return from2;
  if (!from2)
    return to;
  const merged = extend$4(Object.create(null), to);
  for (const key2 in from2) {
    merged[key2] = mergeAsArray(to[key2], from2[key2]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key2 in instance.propsOptions[0]) {
    if (!(key2 in props)) {
      props[key2] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key2 = propsToUpdate[i2];
        const value2 = rawProps[key2];
        if (options) {
          if (hasOwn$4(attrs, key2)) {
            if (value2 !== attrs[key2]) {
              attrs[key2] = value2;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key2);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value2, instance, false);
          }
        } else {
          if (value2 !== attrs[key2]) {
            attrs[key2] = value2;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key2 in rawCurrentProps) {
      if (!rawProps || !hasOwn$4(rawProps, key2) && ((kebabKey = hyphenate(key2)) === key2 || !hasOwn$4(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key2] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key2] = resolvePropValue(options, rawCurrentProps, key2, void 0, instance, true);
          }
        } else {
          delete props[key2];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key2 in attrs) {
        if (!rawProps || !hasOwn$4(rawProps, key2)) {
          delete attrs[key2];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger$1(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key2 in rawProps) {
      if (isReservedProp(key2)) {
        continue;
      }
      const value2 = rawProps[key2];
      let camelKey;
      if (options && hasOwn$4(options, camelKey = camelize(key2))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value2;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value2;
        }
      } else if (!isEmitListener(instance.emitsOptions, key2)) {
        if (!(key2 in attrs) || value2 !== attrs[key2]) {
          attrs[key2] = value2;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key2 = needCastKeys[i2];
      props[key2] = resolvePropValue(options, rawCurrentProps, key2, castValues[key2], instance, !hasOwn$4(castValues, key2));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key2, value2, instance, isAbsent) {
  const opt = options[key2];
  if (opt != null) {
    const hasDefault = hasOwn$4(opt, "default");
    if (hasDefault && value2 === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$4(defaultValue)) {
        const { propsDefaults } = instance;
        if (key2 in propsDefaults) {
          value2 = propsDefaults[key2];
        } else {
          setCurrentInstance(instance);
          value2 = propsDefaults[key2] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value2 = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value2 = false;
      } else if (opt[1] && (value2 === "" || value2 === hyphenate(key2))) {
        value2 = true;
      }
    }
  }
  return value2;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$4(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend$4(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    cache2.set(comp, EMPTY_ARR);
    return EMPTY_ARR;
  }
  if (isArray$9(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key2 in raw) {
      const normalizedKey = camelize(key2);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key2];
        const prop = normalized[normalizedKey] = isArray$9(opt) || isFunction$4(opt) ? { type: opt } : opt;
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$4(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  cache2.set(comp, res);
  return res;
}
function validatePropName(key2) {
  if (key2[0] !== "$") {
    return true;
  }
  return false;
}
function getType$1(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? "null" : "";
}
function isSameType(a2, b2) {
  return getType$1(a2) === getType$1(b2);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$9(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction$4(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key2) => key2[0] === "_" || key2 === "$stable";
const normalizeSlotValue = (value2) => isArray$9(value2) ? value2.map(normalizeVNode) : [normalizeVNode(value2)];
const normalizeSlot$1 = (key2, rawSlot, ctx) => {
  const normalized = withCtx((...args) => {
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key2 in rawSlots) {
    if (isInternalKey(key2))
      continue;
    const value2 = rawSlots[key2];
    if (isFunction$4(value2)) {
      slots[key2] = normalizeSlot$1(key2, value2, ctx);
    } else if (value2 != null) {
      const normalized = normalizeSlotValue(value2);
      slots[key2] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$4(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key2 in slots) {
      if (!isInternalKey(key2) && !(key2 in deletionComparisonTarget)) {
        delete slots[key2];
      }
    }
  }
};
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value2, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (isFunction$4(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }
    if (dir.deep) {
      traverse(value2);
    }
    bindings.push({
      dir,
      instance,
      value: value2,
      oldValue: void 0,
      arg,
      modifiers
    });
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name2) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name2];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap()
  };
}
let uid = 0;
function createAppAPI(render3, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (rootProps != null && !isObject$5(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$s,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$4(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$4(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name2, component) {
        if (!component) {
          return context.components[name2];
        }
        context.components[name2] = component;
        return app;
      },
      directive(name2, directive) {
        if (!directive) {
          return context.directives[name2];
        }
        context.directives[name2] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render3(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render3(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key2, value2) {
        context.provides[key2] = value2;
        return app;
      }
    };
    return app;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$9(rawRef)) {
    rawRef.forEach((r2, i2) => setRef(r2, oldRawRef && (isArray$9(oldRawRef) ? oldRawRef[i2] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value2 = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$2(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$4(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$4(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value2, refs]);
  } else {
    const _isString = isString$2(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$9(existing) && remove(existing, refValue);
          } else {
            if (!isArray$9(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value2;
          if (hasOwn$4(setupState, ref2)) {
            setupState[ref2] = value2;
          }
        } else if (isRef(ref2)) {
          ref2.value = value2;
          if (rawRef.k)
            refs[rawRef.k] = value2;
        } else
          ;
      };
      if (value2) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis$1();
  target.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment$1:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next3;
    while (el && el !== anchor) {
      next3 = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next3;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next3;
    while (el && el !== anchor) {
      next3 = hostNextSibling(el);
      hostRemove(el);
      el = next3;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
    if (vnode.el && hostCloneNode !== void 0 && patchFlag === -1) {
      el = vnode.el = hostCloneNode(vnode.el);
    } else {
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        for (const key2 in props) {
          if (key2 !== "value" && !isReservedProp(key2)) {
            hostPatchProp(el, key2, null, props[key2], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key2 = propsToUpdate[i2];
            const prev = oldProps[key2];
            const next3 = newProps[key2];
            if (next3 !== prev || key2 === "value") {
              hostPatchProp(el, key2, prev, next3, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = oldVNode.el && (oldVNode.type === Fragment$1 || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      for (const key2 in newProps) {
        if (isReservedProp(key2))
          continue;
        const next3 = newProps[key2];
        const prev = oldProps[key2];
        if (next3 !== prev && key2 !== "value") {
          hostPatchProp(el, key2, prev, next3, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if (oldProps !== EMPTY_OBJ) {
        for (const key2 in oldProps) {
          if (!isReservedProp(key2) && !(key2 in newProps)) {
            hostPatchProp(el, key2, oldProps[key2], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.component = n1.component;
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m2, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next: next3, bu, u: u2, parent, vnode } = instance;
        let originNext = next3;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next3) {
          next3.el = vnode.el;
          updateComponentPreRender(instance, next3, optimized);
        } else {
          next3 = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next3.props && next3.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next3, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
        next3.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next3.props && next3.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next3, vnode), parentSuspense);
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope);
    const update6 = instance.update = effect.run.bind(effect);
    update6.id = instance.uid;
    toggleRecurse(instance, true);
    update6();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(void 0, instance.update);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(c1[i2], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(null, c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex = j2;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment$1) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment$1 || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment$1 && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment$1) {
      removeFragment(el, anchor);
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next3;
    while (cur !== end) {
      next3 = hostNextSibling(cur);
      hostRemove(cur);
      cur = next3;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update: update6, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update6) {
      update6.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render3 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render3,
    hydrate,
    createApp: createAppAPI(render3, hydrate)
  };
}
function toggleRecurse({ effect, update: update6 }, allowed) {
  effect.allowRecurse = update6.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$9(ch1) && isArray$9(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
    }
  }
}
function getSequence(arr2) {
  const p2 = arr2.slice();
  const result = [0];
  let i2, j2, u2, v2, c2;
  const len2 = arr2.length;
  for (i2 = 0; i2 < len2; i2++) {
    const arrI = arr2[i2];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr2[j2] < arrI) {
        p2[i2] = j2;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c2 = u2 + v2 >> 1;
        if (arr2[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr2[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$2(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target, targetAnchor, internals, 1);
        }
      }
    }
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        vnode.targetAnchor = hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
      target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name2, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDirective(name2) {
  return resolveAsset(DIRECTIVES, name2);
}
function resolveAsset(type, name2, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component);
      if (selfName && (selfName === name2 || selfName === camelize(name2) || selfName === capitalize(camelize(name2)))) {
        return Component;
      }
    }
    const res = resolve(instance[type] || Component[type], name2) || resolve(instance.appContext[type], name2);
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name2) {
  return registry && (registry[name2] || registry[camelize(name2)] || registry[capitalize(camelize(name2))]);
}
const Fragment$1 = Symbol(void 0);
const Text = Symbol(void 0);
const Comment = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value2) {
  isBlockTreeEnabled += value2;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value2) {
  return value2 ? value2.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key: key2 }) => key2 != null ? key2 : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString$2(ref2) || isRef(ref2) || isFunction$4(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment$1 ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$2(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$2(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$5(style)) {
      if (isProxy(style) && !isArray$9(style)) {
        style = extend$4({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$5(type) ? 4 : isFunction$4(type) ? 2 : 0;
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$4({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$9(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment$1 ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
function createTextVNode(text2 = " ", flag = 0) {
  return createVNode(Text, null, text2, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text2 = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text2)) : createVNode(Comment, null, text2);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$9(child)) {
    return createVNode(Fragment$1, null, child.slice());
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$9(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$4(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key2 in toMerge) {
      if (key2 === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key2 === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key2)) {
        const existing = ret[key2];
        const incoming = toMerge[key2];
        if (existing !== incoming && !(isArray$9(existing) && existing.includes(incoming))) {
          ret[key2] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key2 !== "") {
        ret[key2] = toMerge[key2];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
function renderList(source, renderItem, cache2, index2) {
  let ret;
  const cached = cache2 && cache2[index2];
  if (isArray$9(source) || isString$2(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$5(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i2) => renderItem(item, i2, void 0, cached && cached[i2]));
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
        const key2 = keys2[i2];
        ret[i2] = renderItem(source[key2], key2, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index2] = ret;
  }
  return ret;
}
function renderSlot(slots, name2, props = {}, fallback2, noSlotted) {
  if (currentRenderingInstance.isCE) {
    return createVNode("slot", name2 === "default" ? null : { name: name2 }, fallback2 && fallback2());
  }
  let slot = slots[name2];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment$1, { key: props.key || `_${name2}` }, validSlotContent || (fallback2 ? fallback2() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment$1 && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = extend$4(Object.create(null), {
  $: (i2) => i2,
  $el: (i2) => i2.vnode.el,
  $data: (i2) => i2.data,
  $props: (i2) => i2.props,
  $attrs: (i2) => i2.attrs,
  $slots: (i2) => i2.slots,
  $refs: (i2) => i2.refs,
  $parent: (i2) => getPublicInstance(i2.parent),
  $root: (i2) => getPublicInstance(i2.root),
  $emit: (i2) => i2.emit,
  $options: (i2) => resolveMergedOptions(i2),
  $forceUpdate: (i2) => () => queueJob(i2.update),
  $nextTick: (i2) => nextTick.bind(i2.proxy),
  $watch: (i2) => instanceWatch.bind(i2)
});
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key2) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key2[0] !== "$") {
      const n2 = accessCache[key2];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key2];
          case 2:
            return data[key2];
          case 4:
            return ctx[key2];
          case 3:
            return props[key2];
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn$4(setupState, key2)) {
        accessCache[key2] = 1;
        return setupState[key2];
      } else if (data !== EMPTY_OBJ && hasOwn$4(data, key2)) {
        accessCache[key2] = 2;
        return data[key2];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn$4(normalizedProps, key2)) {
        accessCache[key2] = 3;
        return props[key2];
      } else if (ctx !== EMPTY_OBJ && hasOwn$4(ctx, key2)) {
        accessCache[key2] = 4;
        return ctx[key2];
      } else if (shouldCacheAccess) {
        accessCache[key2] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key2];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key2 === "$attrs") {
        track(instance, "get", key2);
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key2])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$4(ctx, key2)) {
      accessCache[key2] = 4;
      return ctx[key2];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn$4(globalProperties, key2)) {
      {
        return globalProperties[key2];
      }
    } else
      ;
  },
  set({ _: instance }, key2, value2) {
    const { data, setupState, ctx } = instance;
    if (setupState !== EMPTY_OBJ && hasOwn$4(setupState, key2)) {
      setupState[key2] = value2;
    } else if (data !== EMPTY_OBJ && hasOwn$4(data, key2)) {
      data[key2] = value2;
    } else if (hasOwn$4(instance.props, key2)) {
      return false;
    }
    if (key2[0] === "$" && key2.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key2] = value2;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key2) {
    let normalizedProps;
    return !!accessCache[key2] || data !== EMPTY_OBJ && hasOwn$4(data, key2) || setupState !== EMPTY_OBJ && hasOwn$4(setupState, key2) || (normalizedProps = propsOptions[0]) && hasOwn$4(normalizedProps, key2) || hasOwn$4(ctx, key2) || hasOwn$4(publicPropertiesMap, key2) || hasOwn$4(appContext.config.globalProperties, key2);
  }
};
const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e2) => {
          handleError(e2, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$4(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$5(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$4(extend$4({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key2) {
      track(instance, "get", "$attrs");
      return target[key2];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key2) {
        if (key2 in target) {
          return target[key2];
        } else if (key2 in publicPropertiesMap) {
          return publicPropertiesMap[key2](instance);
        }
      }
    }));
  }
}
function getComponentName(Component) {
  return isFunction$4(Component) ? Component.displayName || Component.name : Component.name;
}
function isClassComponent(value2) {
  return isFunction$4(value2) && "__vccOpts" in value2;
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$4(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i2 = 0; i2 < fn.length; i2++) {
    values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue$2 = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id2) {
  let start = flushIndex + 1;
  let end = queue$2.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue$2[middle]);
    middleJobId < id2 ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if ((!queue$2.length || !queue$2.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    if (job.id == null) {
      queue$2.push(job);
    } else {
      queue$2.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue$2.indexOf(job);
  if (i2 > flushIndex) {
    queue$2.splice(i2, 1);
  }
}
function queueCb(cb, activeQueue, pendingQueue, index2) {
  if (!isArray$9(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index2 + 1 : index2)) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      activePreFlushCbs[preFlushIndex]();
    }
    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    flushPreFlushCbs(seen, parentJob);
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a2, b2) => getId(a2) - getId(b2));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  flushPreFlushCbs(seen);
  queue$2.sort((a2, b2) => getId(a2) - getId(b2));
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue$2.length; flushIndex++) {
      const job = queue$2[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue$2.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue$2.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = !!source._shallow;
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$9(source)) {
    isMultiSource = true;
    forceTrigger = source.some(isReactive);
    getter = () => source.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return traverse(s2);
      } else if (isFunction$4(s2)) {
        return callWithErrorHandling(s2, instance, 2);
      } else
        ;
    });
  } else if (isFunction$4(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onInvalidate]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onInvalidate = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  if (isInSSRComponentSetup) {
    onInvalidate = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onInvalidate
      ]);
    }
    return NOOP;
  }
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onInvalidate
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    scheduler = () => {
      if (!instance || instance.isMounted) {
        queuePreFlushCb(job);
      } else {
        job();
      }
    };
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  return () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
}
function instanceWatch(source, value2, options) {
  const publicThis = this.proxy;
  const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$4(value2)) {
    cb = value2;
  } else {
    cb = value2.handler;
    options = value2;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments2 = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments2.length && cur; i2++) {
      cur = cur[segments2[i2]];
    }
    return cur;
  };
}
function traverse(value2, seen) {
  if (!isObject$5(value2) || value2["__v_skip"]) {
    return value2;
  }
  seen = seen || new Set();
  if (seen.has(value2)) {
    return value2;
  }
  seen.add(value2);
  if (isRef(value2)) {
    traverse(value2.value, seen);
  } else if (isArray$9(value2)) {
    for (let i2 = 0; i2 < value2.length; i2++) {
      traverse(value2[i2], seen);
    }
  } else if (isSet(value2) || isMap(value2)) {
    value2.forEach((v2) => {
      traverse(v2, seen);
    });
  } else if (isPlainObject$2(value2)) {
    for (const key2 in value2) {
      traverse(value2[key2], seen);
    }
  }
  return value2;
}
function h$4(type, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$5(propsOrChildren) && !isArray$9(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version$s = "3.2.26";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const staticTemplateCache = new Map();
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text2) => doc.createTextNode(text2),
  createComment: (text2) => doc.createComment(text2),
  setText: (node, text2) => {
    node.nodeValue = text2;
  },
  setElementText: (el, text2) => {
    el.textContent = text2;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id2) {
    el.setAttribute(id2, "");
  },
  cloneNode(el) {
    const cloned = el.cloneNode(true);
    if (`_value` in el) {
      cloned._value = el._value;
    }
    return cloned;
  },
  insertStaticContent(content, parent, anchor, isSVG) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    let template = staticTemplateCache.get(content);
    if (!template) {
      const t2 = doc.createElement("template");
      t2.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      template = t2.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      staticTemplateCache.set(content, template);
    }
    parent.insertBefore(template.cloneNode(true), anchor);
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value2, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value2 = (value2 ? [value2, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value2 == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value2);
  } else {
    el.className = value2;
  }
}
function patchStyle(el, prev, next3) {
  const style = el.style;
  const isCssString = isString$2(next3);
  if (next3 && !isCssString) {
    for (const key2 in next3) {
      setStyle(style, key2, next3[key2]);
    }
    if (prev && !isString$2(prev)) {
      for (const key2 in prev) {
        if (next3[key2] == null) {
          setStyle(style, key2, "");
        }
      }
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next3) {
        style.cssText = next3;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name2, val) {
  if (isArray$9(val)) {
    val.forEach((v2) => setStyle(style, name2, v2));
  } else {
    if (name2.startsWith("--")) {
      style.setProperty(name2, val);
    } else {
      const prefixed = autoPrefix(style, name2);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name2 = camelize(rawName);
  if (name2 !== "filter" && name2 in style) {
    return prefixCache[rawName] = name2;
  }
  name2 = capitalize(name2);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name2;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key2, value2, isSVG, instance) {
  if (isSVG && key2.startsWith("xlink:")) {
    if (value2 == null) {
      el.removeAttributeNS(xlinkNS, key2.slice(6, key2.length));
    } else {
      el.setAttributeNS(xlinkNS, key2, value2);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key2);
    if (value2 == null || isBoolean2 && !includeBooleanAttr(value2)) {
      el.removeAttribute(key2);
    } else {
      el.setAttribute(key2, isBoolean2 ? "" : value2);
    }
  }
}
function patchDOMProp(el, key2, value2, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key2 === "innerHTML" || key2 === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key2] = value2 == null ? "" : value2;
    return;
  }
  if (key2 === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value2;
    const newValue = value2 == null ? "" : value2;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value2 == null) {
      el.removeAttribute(key2);
    }
    return;
  }
  if (value2 === "" || value2 == null) {
    const type = typeof el[key2];
    if (type === "boolean") {
      el[key2] = includeBooleanAttr(value2);
      return;
    } else if (value2 == null && type === "string") {
      el[key2] = "";
      el.removeAttribute(key2);
      return;
    } else if (type === "number") {
      try {
        el[key2] = 0;
      } catch (_a2) {
      }
      el.removeAttribute(key2);
      return;
    }
  }
  try {
    el[key2] = value2;
  } catch (e2) {
  }
}
let _getNow = Date.now;
let skipTimestampCheck = false;
if (typeof window !== "undefined") {
  if (_getNow() > document.createEvent("Event").timeStamp) {
    _getNow = () => performance.now();
  }
  const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
  skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
}
let cachedNow = 0;
const p$4 = Promise.resolve();
const reset = () => {
  cachedNow = 0;
};
const getNow = () => cachedNow || (p$4.then(reset), cachedNow = _getNow());
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name2, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name2, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name2, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name2) {
  let options;
  if (optionsModifierRE.test(name2)) {
    options = {};
    let m2;
    while (m2 = name2.match(optionsModifierRE)) {
      name2 = name2.slice(0, name2.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  return [hyphenate(name2.slice(2)), options];
}
function createInvoker(initialValue, instance) {
  const invoker = (e2) => {
    const timeStamp = e2.timeStamp || _getNow();
    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e2, invoker.value), instance, 5, [e2]);
    }
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e2, value2) {
  if (isArray$9(value2)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop.call(e2);
      e2._stopped = true;
    };
    return value2.map((fn) => (e3) => !e3._stopped && fn(e3));
  } else {
    return value2;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key2, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key2 === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key2 === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key2)) {
    if (!isModelListener(key2)) {
      patchEvent(el, key2, prevValue, nextValue, parentComponent);
    }
  } else if (key2[0] === "." ? (key2 = key2.slice(1), true) : key2[0] === "^" ? (key2 = key2.slice(1), false) : shouldSetAsProp(el, key2, nextValue, isSVG)) {
    patchDOMProp(el, key2, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key2 === "true-value") {
      el._trueValue = nextValue;
    } else if (key2 === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key2, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key2, value2, isSVG) {
  if (isSVG) {
    if (key2 === "innerHTML" || key2 === "textContent") {
      return true;
    }
    if (key2 in el && nativeOnRE.test(key2) && isFunction$4(value2)) {
      return true;
    }
    return false;
  }
  if (key2 === "spellcheck" || key2 === "draggable") {
    return false;
  }
  if (key2 === "form") {
    return false;
  }
  if (key2 === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key2 === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key2) && isString$2(value2)) {
    return false;
  }
  return key2 in el;
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h$4(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
Transition.props = /* @__PURE__ */ extend$4({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if (isArray$9(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$9(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key2 in rawProps) {
    if (!(key2 in DOMTransitionPropsValidators)) {
      baseProps[key2] = rawProps[key2];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name: name2 = "v", type, duration, enterFromClass = `${name2}-enter-from`, enterActiveClass = `${name2}-enter-active`, enterToClass = `${name2}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name2}-leave-from`, leaveActiveClass = `${name2}-leave-active`, leaveToClass = `${name2}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el, isAppear, done2) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done2 && done2();
  };
  const finishLeave = (el, done2) => {
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done2 && done2();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done2) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done2);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$4(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done2) {
      const resolve2 = () => finishLeave(el, done2);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$5(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n2 = NumberOf(duration);
    return [n2, n2];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el._vtc || (el._vtc = new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id2 = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id2 === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout: timeout2, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e2) => {
    if (e2.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout2 + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key2) => (styles[key2] || "").split(", ");
  const transitionDelays = getStyleProperties(TRANSITION + "Delay");
  const transitionDurations = getStyleProperties(TRANSITION + "Duration");
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(ANIMATION + "Delay");
  const animationDurations = getStyleProperties(ANIMATION + "Duration");
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout2 = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout2 = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout2 = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout2 = Math.max(transitionTimeout, animationTimeout);
    type = timeout2 > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + "Property"]);
  return {
    type,
    timeout: timeout2,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
}
function toMs(s2) {
  return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"];
  return isArray$9(fn) ? (value2) => invokeArrayFns(fn, value2) : fn;
};
function onCompositionStart(e2) {
  e2.target.composing = true;
}
function onCompositionEnd(e2) {
  const target = e2.target;
  if (target.composing) {
    target.composing = false;
    trigger(target, "input");
  }
}
function trigger(el, type) {
  const e2 = document.createEvent("HTMLEvents");
  e2.initEvent(type, true, true);
  el.dispatchEvent(e2);
}
const vModelText = {
  created(el, { modifiers: { lazy, trim, number: number2 } }, vnode) {
    el._assign = getModelAssigner(vnode);
    const castToNumber = number2 || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e2) => {
      if (e2.target.composing)
        return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      } else if (castToNumber) {
        domValue = toNumber(domValue);
      }
      el._assign(domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  mounted(el, { value: value2 }) {
    el.value = value2 == null ? "" : value2;
  },
  beforeUpdate(el, { value: value2, modifiers: { lazy, trim, number: number2 } }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (el.composing)
      return;
    if (document.activeElement === el) {
      if (lazy) {
        return;
      }
      if (trim && el.value.trim() === value2) {
        return;
      }
      if ((number2 || el.type === "number") && toNumber(el.value) === value2) {
        return;
      }
    }
    const newValue = value2 == null ? "" : value2;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
      return fn(event);
    }
  };
};
const rendererOptions = extend$4({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$4(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function normalizeContainer(container) {
  if (isString$2(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value2) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var PROVIDE_KEY = `usehead`;
var HEAD_COUNT_KEY = `head:count`;
var HEAD_ATTRS_KEY = `data-head-attrs`;
var createElement = (tag, attrs, document2) => {
  const el = document2.createElement(tag);
  for (const key2 of Object.keys(attrs)) {
    let value2 = attrs[key2];
    if (key2 === "key" || value2 === false) {
      continue;
    }
    if (key2 === "children") {
      el.textContent = value2;
    } else {
      el.setAttribute(key2, value2);
    }
  }
  return el;
};
function isEqualNode(oldTag, newTag) {
  if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {
    const nonce = newTag.getAttribute("nonce");
    if (nonce && !oldTag.getAttribute("nonce")) {
      const cloneTag = newTag.cloneNode(true);
      cloneTag.setAttribute("nonce", "");
      cloneTag.nonce = nonce;
      return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);
    }
  }
  return oldTag.isEqualNode(newTag);
}
var getTagKey = (props) => {
  const names2 = ["key", "id", "name", "property"];
  for (const n2 of names2) {
    const value2 = typeof props.getAttribute === "function" ? props.getAttribute(n2) : props[n2];
    if (value2 !== void 0) {
      return { name: n2, value: value2 };
    }
  }
};
var injectHead = () => {
  const head = inject(PROVIDE_KEY);
  if (!head) {
    throw new Error(`You may forget to apply app.use(head)`);
  }
  return head;
};
var acceptFields = [
  "title",
  "meta",
  "link",
  "base",
  "style",
  "script",
  "htmlAttrs",
  "bodyAttrs"
];
var headObjToTags = (obj) => {
  const tags = [];
  for (const key2 of Object.keys(obj)) {
    if (obj[key2] == null)
      continue;
    if (key2 === "title") {
      tags.push({ tag: key2, props: { children: obj[key2] } });
    } else if (key2 === "base") {
      tags.push({ tag: key2, props: __spreadValues({ key: "default" }, obj[key2]) });
    } else if (acceptFields.includes(key2)) {
      const value2 = obj[key2];
      if (Array.isArray(value2)) {
        value2.forEach((item) => {
          tags.push({ tag: key2, props: item });
        });
      } else if (value2) {
        tags.push({ tag: key2, props: value2 });
      }
    }
  }
  return tags;
};
var setAttrs = (el, attrs) => {
  const existingAttrs = el.getAttribute(HEAD_ATTRS_KEY);
  if (existingAttrs) {
    for (const key2 of existingAttrs.split(",")) {
      if (!(key2 in attrs)) {
        el.removeAttribute(key2);
      }
    }
  }
  const keys2 = [];
  for (const key2 in attrs) {
    const value2 = attrs[key2];
    if (value2 == null)
      continue;
    if (value2 === false) {
      el.removeAttribute(key2);
    } else {
      el.setAttribute(key2, value2);
    }
    keys2.push(key2);
  }
  if (keys2.length) {
    el.setAttribute(HEAD_ATTRS_KEY, keys2.join(","));
  } else {
    el.removeAttribute(HEAD_ATTRS_KEY);
  }
};
var updateElements = (document2 = window.document, type, tags) => {
  var _a2;
  const head = document2.head;
  let headCountEl = head.querySelector(`meta[name="${HEAD_COUNT_KEY}"]`);
  const headCount = headCountEl ? Number(headCountEl.getAttribute("content")) : 0;
  const oldElements = [];
  if (headCountEl) {
    for (let i2 = 0, j2 = headCountEl.previousElementSibling; i2 < headCount; i2++, j2 = j2.previousElementSibling) {
      if (((_a2 = j2 == null ? void 0 : j2.tagName) == null ? void 0 : _a2.toLowerCase()) === type) {
        oldElements.push(j2);
      }
    }
  } else {
    headCountEl = document2.createElement("meta");
    headCountEl.setAttribute("name", HEAD_COUNT_KEY);
    headCountEl.setAttribute("content", "0");
    head.append(headCountEl);
  }
  let newElements = tags.map((tag) => createElement(tag.tag, tag.props, document2));
  newElements = newElements.filter((newEl) => {
    for (let i2 = 0; i2 < oldElements.length; i2++) {
      const oldEl = oldElements[i2];
      if (isEqualNode(oldEl, newEl)) {
        oldElements.splice(i2, 1);
        return false;
      }
    }
    return true;
  });
  oldElements.forEach((t2) => {
    var _a22;
    return (_a22 = t2.parentNode) == null ? void 0 : _a22.removeChild(t2);
  });
  newElements.forEach((t2) => {
    var _a22;
    const key2 = getTagKey(t2);
    if (key2) {
      const uncontrolled = head.querySelector(`${t2.tagName.toLowerCase()}[${key2.name}="${key2.value}"]`);
      if (uncontrolled) {
        (_a22 = uncontrolled.parentNode) == null ? void 0 : _a22.removeChild(uncontrolled);
      }
    }
    head.insertBefore(t2, headCountEl);
  });
  headCountEl.setAttribute("content", "" + (headCount - oldElements.length + newElements.length));
};
var createHead = () => {
  let allHeadObjs = [];
  const head = {
    install(app) {
      app.config.globalProperties.$head = head;
      app.provide(PROVIDE_KEY, head);
    },
    get headTags() {
      const deduped = [];
      allHeadObjs.forEach((objs) => {
        const tags = headObjToTags(objs.value);
        tags.forEach((tag) => {
          if (tag.tag === "meta" || tag.tag === "base" || tag.tag === "script") {
            const key2 = getTagKey(tag.props);
            if (key2) {
              let index2 = -1;
              for (let i2 = 0; i2 < deduped.length; i2++) {
                const prev = deduped[i2];
                const prevValue = prev.props[key2.name];
                const nextValue = tag.props[key2.name];
                if (prev.tag === tag.tag && prevValue === nextValue) {
                  index2 = i2;
                  break;
                }
              }
              if (index2 !== -1) {
                deduped.splice(index2, 1);
              }
            }
          }
          deduped.push(tag);
        });
      });
      return deduped;
    },
    addHeadObjs(objs) {
      allHeadObjs.push(objs);
    },
    removeHeadObjs(objs) {
      allHeadObjs = allHeadObjs.filter((_objs) => _objs !== objs);
    },
    updateDOM(document2 = window.document) {
      let title;
      let htmlAttrs = {};
      let bodyAttrs = {};
      const actualTags = {};
      for (const tag of head.headTags) {
        if (tag.tag === "title") {
          title = tag.props.children;
          continue;
        }
        if (tag.tag === "htmlAttrs") {
          Object.assign(htmlAttrs, tag.props);
          continue;
        }
        if (tag.tag === "bodyAttrs") {
          Object.assign(bodyAttrs, tag.props);
          continue;
        }
        actualTags[tag.tag] = actualTags[tag.tag] || [];
        actualTags[tag.tag].push(tag);
      }
      if (title !== void 0) {
        document2.title = title;
      }
      setAttrs(document2.documentElement, htmlAttrs);
      setAttrs(document2.body, bodyAttrs);
      for (const name2 of Object.keys(actualTags)) {
        updateElements(document2, name2, actualTags[name2]);
      }
    }
  };
  return head;
};
var IS_BROWSER = typeof window !== "undefined";
var useHead = (obj) => {
  const headObj = ref(obj);
  const head = injectHead();
  head.addHeadObjs(headObj);
  if (IS_BROWSER) {
    watchEffect(() => {
      head.updateDOM();
    });
    onBeforeUnmount(() => {
      head.removeHeadObjs(headObj);
      head.updateDOM();
    });
  }
};
/*!
  * @intlify/shared v9.1.9
  * (c) 2021 kazuya kawaguchi
  * Released under the MIT License.
  */
const hasSymbol$1 = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
const makeSymbol = (name2) => hasSymbol$1 ? Symbol(name2) : name2;
const generateFormatCacheKey = (locale, key2, source) => friendlyJSONstringify({ l: locale, k: key2, s: source });
const friendlyJSONstringify = (json2) => JSON.stringify(json2).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber = (val) => typeof val === "number" && isFinite(val);
const isDate$1 = (val) => toTypeString$1(val) === "[object Date]";
const isRegExp = (val) => toTypeString$1(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject$1(val) && Object.keys(val).length === 0;
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
const assign$2 = Object.assign;
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const hasOwnProperty$7 = Object.prototype.hasOwnProperty;
function hasOwn$3(obj, key2) {
  return hasOwnProperty$7.call(obj, key2);
}
const isArray$8 = Array.isArray;
const isFunction$3 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isObject$4 = (val) => val !== null && typeof val === "object";
const objectToString$2 = Object.prototype.toString;
const toTypeString$1 = (value2) => objectToString$2.call(value2);
const isPlainObject$1 = (val) => toTypeString$1(val) === "[object Object]";
const toDisplayString = (val) => {
  return val == null ? "" : isArray$8(val) || isPlainObject$1(val) && val.toString === objectToString$2 ? JSON.stringify(val, null, 2) : String(val);
};
/*!
  * @intlify/message-resolver v9.1.9
  * (c) 2021 kazuya kawaguchi
  * Released under the MIT License.
  */
const hasOwnProperty$6 = Object.prototype.hasOwnProperty;
function hasOwn$2(obj, key2) {
  return hasOwnProperty$6.call(obj, key2);
}
const isObject$3 = (val) => val !== null && typeof val === "object";
const pathStateMachine = [];
pathStateMachine[0] = {
  ["w"]: [0],
  ["i"]: [3, 0],
  ["["]: [4],
  ["o"]: [7]
};
pathStateMachine[1] = {
  ["w"]: [1],
  ["."]: [2],
  ["["]: [4],
  ["o"]: [7]
};
pathStateMachine[2] = {
  ["w"]: [2],
  ["i"]: [3, 0],
  ["0"]: [3, 0]
};
pathStateMachine[3] = {
  ["i"]: [3, 0],
  ["0"]: [3, 0],
  ["w"]: [1, 1],
  ["."]: [2, 1],
  ["["]: [4, 1],
  ["o"]: [7, 1]
};
pathStateMachine[4] = {
  ["'"]: [5, 0],
  ['"']: [6, 0],
  ["["]: [
    4,
    2
  ],
  ["]"]: [1, 3],
  ["o"]: 8,
  ["l"]: [4, 0]
};
pathStateMachine[5] = {
  ["'"]: [4, 0],
  ["o"]: 8,
  ["l"]: [5, 0]
};
pathStateMachine[6] = {
  ['"']: [4, 0],
  ["o"]: 8,
  ["l"]: [6, 0]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp2) {
  return literalValueRE.test(exp2);
}
function stripQuotes(str2) {
  const a2 = str2.charCodeAt(0);
  const b2 = str2.charCodeAt(str2.length - 1);
  return a2 === b2 && (a2 === 34 || a2 === 39) ? str2.slice(1, -1) : str2;
}
function getPathCharType(ch2) {
  if (ch2 === void 0 || ch2 === null) {
    return "o";
  }
  const code2 = ch2.charCodeAt(0);
  switch (code2) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch2;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse$2(path) {
  const keys2 = [];
  let index2 = -1;
  let mode2 = 0;
  let subPathDepth = 0;
  let c2;
  let key2;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[0] = () => {
    if (key2 === void 0) {
      key2 = newChar;
    } else {
      key2 += newChar;
    }
  };
  actions[1] = () => {
    if (key2 !== void 0) {
      keys2.push(key2);
      key2 = void 0;
    }
  };
  actions[2] = () => {
    actions[0]();
    subPathDepth++;
  };
  actions[3] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode2 = 4;
      actions[0]();
    } else {
      subPathDepth = 0;
      if (key2 === void 0) {
        return false;
      }
      key2 = formatSubPath(key2);
      if (key2 === false) {
        return false;
      } else {
        actions[1]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index2 + 1];
    if (mode2 === 5 && nextChar === "'" || mode2 === 6 && nextChar === '"') {
      index2++;
      newChar = "\\" + nextChar;
      actions[0]();
      return true;
    }
  }
  while (mode2 !== null) {
    index2++;
    c2 = path[index2];
    if (c2 === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c2);
    typeMap = pathStateMachine[mode2];
    transition = typeMap[type] || typeMap["l"] || 8;
    if (transition === 8) {
      return;
    }
    mode2 = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c2;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode2 === 7) {
      return keys2;
    }
  }
}
const cache$1 = new Map();
function resolveValue(obj, path) {
  if (!isObject$3(obj)) {
    return null;
  }
  let hit = cache$1.get(path);
  if (!hit) {
    hit = parse$2(path);
    if (hit) {
      cache$1.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len2 = hit.length;
  let last2 = obj;
  let i2 = 0;
  while (i2 < len2) {
    const val = last2[hit[i2]];
    if (val === void 0) {
      return null;
    }
    last2 = val;
    i2++;
  }
  return last2;
}
function handleFlatJson(obj) {
  if (!isObject$3(obj)) {
    return obj;
  }
  for (const key2 in obj) {
    if (!hasOwn$2(obj, key2)) {
      continue;
    }
    if (!key2.includes(".")) {
      if (isObject$3(obj[key2])) {
        handleFlatJson(obj[key2]);
      }
    } else {
      const subKeys = key2.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      for (let i2 = 0; i2 < lastIndex; i2++) {
        if (!(subKeys[i2] in currentObj)) {
          currentObj[subKeys[i2]] = {};
        }
        currentObj = currentObj[subKeys[i2]];
      }
      currentObj[subKeys[lastIndex]] = obj[key2];
      delete obj[key2];
      if (isObject$3(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
/*!
  * @intlify/runtime v9.1.9
  * (c) 2021 kazuya kawaguchi
  * Released under the MIT License.
  */
const DEFAULT_MODIFIER = (str2) => str2;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : values.join("");
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
  const index2 = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index2 : index2;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject$4(options.pluralRules) && isString$1(locale) && isFunction$3(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject$4(options.pluralRules) && isString$1(locale) && isFunction$3(options.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages) => messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
  const _list = options.list || [];
  const list = (index2) => _list[index2];
  const _named = options.named || {};
  isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key2) => _named[key2];
  function message(key2) {
    const msg = isFunction$3(options.messages) ? options.messages(key2) : isObject$4(options.messages) ? options.messages[key2] : false;
    return !msg ? options.parent ? options.parent.message(key2) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name2) => options.modifiers ? options.modifiers[name2] : DEFAULT_MODIFIER;
  const normalize3 = isPlainObject$1(options.processor) && isFunction$3(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject$1(options.processor) && isFunction$3(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject$1(options.processor) && isString$1(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const ctx = {
    ["list"]: list,
    ["named"]: named,
    ["plural"]: plural,
    ["linked"]: (key2, modifier) => {
      const msg = message(key2)(ctx);
      return isString$1(modifier) ? _modifier(modifier)(msg) : msg;
    },
    ["message"]: message,
    ["type"]: type,
    ["interpolate"]: interpolate,
    ["normalize"]: normalize3
  };
  return ctx;
}
/*!
  * @intlify/message-compiler v9.1.9
  * (c) 2021 kazuya kawaguchi
  * Released under the MIT License.
  */
function createCompileError(code2, loc, options = {}) {
  const { domain: domain2, messages, args } = options;
  const msg = code2;
  const error2 = new SyntaxError(String(msg));
  error2.code = code2;
  if (loc) {
    error2.location = loc;
  }
  error2.domain = domain2;
  return error2;
}
/*!
  * @intlify/devtools-if v9.1.9
  * (c) 2021 kazuya kawaguchi
  * Released under the MIT License.
  */
const IntlifyDevToolsHooks = {
  I18nInit: "i18n:init",
  FunctionTranslate: "function:translate"
};
/*!
  * @intlify/core-base v9.1.9
  * (c) 2021 kazuya kawaguchi
  * Released under the MIT License.
  */
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n, version2, meta2) {
  devtools && devtools.emit(IntlifyDevToolsHooks.I18nInit, {
    timestamp: Date.now(),
    i18n,
    version: version2,
    meta: meta2
  });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(IntlifyDevToolsHooks.FunctionTranslate);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
const VERSION$1 = "9.1.9";
const NOT_REOSLVED = -1;
const MISSING_RESOLVE_VALUE = "";
function getDefaultLinkedModifiers() {
  return {
    upper: (val) => isString$1(val) ? val.toUpperCase() : val,
    lower: (val) => isString$1(val) ? val.toLowerCase() : val,
    capitalize: (val) => isString$1(val) ? `${val.charAt(0).toLocaleUpperCase()}${val.substr(1)}` : val
  };
}
let _compiler;
let _additionalMeta = null;
const setAdditionalMeta = (meta2) => {
  _additionalMeta = meta2;
};
const getAdditionalMeta = () => _additionalMeta;
let _cid = 0;
function createCoreContext(options = {}) {
  const version2 = isString$1(options.version) ? options.version : VERSION$1;
  const locale = isString$1(options.locale) ? options.locale : "en-US";
  const fallbackLocale = isArray$8(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || isString$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const messages = isPlainObject$1(options.messages) ? options.messages : { [locale]: {} };
  const datetimeFormats = isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [locale]: {} };
  const numberFormats = isPlainObject$1(options.numberFormats) ? options.numberFormats : { [locale]: {} };
  const modifiers = assign$2({}, options.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || {};
  const missing = isFunction$3(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction$3(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject$1(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction$3(options.messageCompiler) ? options.messageCompiler : _compiler;
  const onWarn = isFunction$3(options.onWarn) ? options.onWarn : warn;
  const internalOptions = options;
  const __datetimeFormatters = isObject$4(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : new Map();
  const __numberFormatters = isObject$4(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : new Map();
  const __meta = isObject$4(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version2,
    cid: _cid,
    locale,
    fallbackLocale,
    messages,
    datetimeFormats,
    numberFormats,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    onWarn,
    __datetimeFormatters,
    __numberFormatters,
    __meta
  };
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version2, __meta);
  }
  return context;
}
function handleMissing(context, key2, locale, missingWarn, type) {
  const { missing, onWarn } = context;
  if (missing !== null) {
    const ret = missing(context, locale, key2, type);
    return isString$1(ret) ? ret : key2;
  } else {
    return key2;
  }
}
function getLocaleChain(ctx, fallback2, start) {
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = new Map();
  }
  let chain = context.__localeChainCache.get(start);
  if (!chain) {
    chain = [];
    let block = [start];
    while (isArray$8(block)) {
      block = appendBlockToChain(chain, block, fallback2);
    }
    const defaults = isArray$8(fallback2) ? fallback2 : isPlainObject$1(fallback2) ? fallback2["default"] ? fallback2["default"] : null : fallback2;
    block = isString$1(defaults) ? [defaults] : defaults;
    if (isArray$8(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(start, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks2) {
  let follow = true;
  for (let i2 = 0; i2 < block.length && isBoolean(follow); i2++) {
    const locale = block[i2];
    if (isString$1(locale)) {
      follow = appendLocaleToChain(chain, block[i2], blocks2);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks2) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks2);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target, blocks2) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale = target.replace(/!/g, "");
      chain.push(locale);
      if ((isArray$8(blocks2) || isPlainObject$1(blocks2)) && blocks2[locale]) {
        follow = blocks2[locale];
      }
    }
  }
  return follow;
}
function updateFallbackLocale(ctx, locale, fallback2) {
  const context = ctx;
  context.__localeChainCache = new Map();
  getLocaleChain(ctx, fallback2, locale);
}
function createCoreError(code2) {
  return createCompileError(code2, null, void 0);
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction$3(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, fallbackLocale, messages } = context;
  const [key2, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString$1(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : key2 : fallbackFormat ? key2 : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = isString$1(options.locale) ? options.locale : context.locale;
  escapeParameter && escapeParams(options);
  let [format2, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key2, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key2,
    locale,
    messages[locale] || {}
  ];
  let cacheBaseKey = key2;
  if (!resolvedMessage && !(isString$1(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString$1(format2) || isMessageFunction(format2)) || !isString$1(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key2;
  }
  let occurred = false;
  const errorDetector = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key2, targetLocale, format2, cacheBaseKey, errorDetector) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged) : messaged;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$1(key2) ? key2 : isMessageFunction(format2) ? format2.key : "",
      locale: targetLocale || (isMessageFunction(format2) ? format2.locale : ""),
      format: isString$1(format2) ? format2 : isMessageFunction(format2) ? format2.source : "",
      message: ret
    };
    payloads.meta = assign$2({}, context.__meta, getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray$8(options.list)) {
    options.list = options.list.map((item) => isString$1(item) ? escapeHtml(item) : item);
  } else if (isObject$4(options.named)) {
    Object.keys(options.named).forEach((key2) => {
      if (isString$1(options.named[key2])) {
        options.named[key2] = escapeHtml(options.named[key2]);
      }
    });
  }
}
function resolveMessageFormat(context, key2, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages, onWarn } = context;
  const locales = getLocaleChain(context, fallbackLocale, locale);
  let message = {};
  let targetLocale;
  let format2 = null;
  const type = "translate";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = locales[i2];
    message = messages[targetLocale] || {};
    if ((format2 = resolveValue(message, key2)) === null) {
      format2 = message[key2];
    }
    if (isString$1(format2) || isFunction$3(format2))
      break;
    const missingRet = handleMissing(context, key2, targetLocale, missingWarn, type);
    if (missingRet !== key2) {
      format2 = missingRet;
    }
  }
  return [format2, targetLocale, message];
}
function compileMessageFormat(context, key2, targetLocale, format2, cacheBaseKey, errorDetector) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key2;
    return msg2;
  }
  const msg = messageCompiler(format2, getCompileOptions(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, errorDetector));
  msg.locale = targetLocale;
  msg.key = key2;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  const messaged = msg(msgCtx);
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = {};
  if (!isString$1(arg1) && !isNumber(arg1) && !isMessageFunction(arg1)) {
    throw createCoreError(14);
  }
  const key2 = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber(arg2)) {
    options.plural = arg2;
  } else if (isString$1(arg2)) {
    options.default = arg2;
  } else if (isPlainObject$1(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray$8(arg2)) {
    options.list = arg2;
  }
  if (isNumber(arg3)) {
    options.plural = arg3;
  } else if (isString$1(arg3)) {
    options.default = arg3;
  } else if (isPlainObject$1(arg3)) {
    assign$2(options, arg3);
  }
  return [key2, options];
}
function getCompileOptions(context, locale, key2, source, warnHtmlMessage, errorDetector) {
  return {
    warnHtmlMessage,
    onError: (err) => {
      errorDetector && errorDetector(err);
      {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key2, source2)
  };
}
function getMessageContextOptions(context, locale, message, options) {
  const { modifiers, pluralRules } = context;
  const resolveMessage = (key2) => {
    const val = resolveValue(message, key2);
    if (isString$1(val)) {
      let occurred = false;
      const errorDetector = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key2, locale, val, key2, errorDetector);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn } = context;
  const { __datetimeFormatters } = context;
  const [key2, value2, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = isString$1(options.locale) ? options.locale : context.locale;
  const locales = getLocaleChain(context, fallbackLocale, locale);
  if (!isString$1(key2) || key2 === "") {
    return new Intl.DateTimeFormat(locale).format(value2);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "datetime format";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = locales[i2];
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key2];
    if (isPlainObject$1(format2))
      break;
    handleMissing(context, key2, targetLocale, missingWarn, type);
  }
  if (!isPlainObject$1(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key2;
  }
  let id2 = `${targetLocale}__${key2}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign$2({}, format2, overrides));
    __datetimeFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value2) : formatter.formatToParts(value2);
}
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  let options = {};
  let overrides = {};
  let value2;
  if (isString$1(arg1)) {
    if (!/\d{4}-\d{2}-\d{2}(T.*)?/.test(arg1)) {
      throw createCoreError(16);
    }
    value2 = new Date(arg1);
    try {
      value2.toISOString();
    } catch (e2) {
      throw createCoreError(16);
    }
  } else if (isDate$1(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(15);
    }
    value2 = arg1;
  } else if (isNumber(arg1)) {
    value2 = arg1;
  } else {
    throw createCoreError(14);
  }
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject$1(arg2)) {
    options = arg2;
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject$1(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject$1(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value2, options, overrides];
}
function clearDateTimeFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key2 in format2) {
    const id2 = `${locale}__${key2}`;
    if (!context.__datetimeFormatters.has(id2)) {
      continue;
    }
    context.__datetimeFormatters.delete(id2);
  }
}
function number$1(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn } = context;
  const { __numberFormatters } = context;
  const [key2, value2, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = isString$1(options.locale) ? options.locale : context.locale;
  const locales = getLocaleChain(context, fallbackLocale, locale);
  if (!isString$1(key2) || key2 === "") {
    return new Intl.NumberFormat(locale).format(value2);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "number format";
  for (let i2 = 0; i2 < locales.length; i2++) {
    targetLocale = locales[i2];
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key2];
    if (isPlainObject$1(format2))
      break;
    handleMissing(context, key2, targetLocale, missingWarn, type);
  }
  if (!isPlainObject$1(format2) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key2;
  }
  let id2 = `${targetLocale}__${key2}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign$2({}, format2, overrides));
    __numberFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value2) : formatter.formatToParts(value2);
}
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  let options = {};
  let overrides = {};
  if (!isNumber(arg1)) {
    throw createCoreError(14);
  }
  const value2 = arg1;
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject$1(arg2)) {
    options = arg2;
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject$1(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject$1(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value2, options, overrides];
}
function clearNumberFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key2 in format2) {
    const id2 = `${locale}__${key2}`;
    if (!context.__numberFormatters.has(id2)) {
      continue;
    }
    context.__numberFormatters.delete(id2);
  }
}
{
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
/*!
  * vue-i18n v9.1.9
  * (c) 2021 kazuya kawaguchi
  * Released under the MIT License.
  */
const VERSION = "9.1.9";
function initFeatureFlags() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, void 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
const TransrateVNodeSymbol = makeSymbol("__transrateVNode");
const DatetimePartsSymbol = makeSymbol("__datetimeParts");
const NumberPartsSymbol = makeSymbol("__numberParts");
makeSymbol("__enableEmitter");
makeSymbol("__disableEmitter");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
makeSymbol("__intlifyMeta");
const InejctWithOption = makeSymbol("__injectWithOption");
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale, key2, type) => {
    return missing(locale, key2, getCurrentInstance() || void 0, type);
  };
}
function getLocaleMessages(locale, options) {
  const { messages, __i18n } = options;
  const ret = isPlainObject$1(messages) ? messages : isArray$8(__i18n) ? {} : { [locale]: {} };
  if (isArray$8(__i18n)) {
    __i18n.forEach(({ locale: locale2, resource }) => {
      if (locale2) {
        ret[locale2] = ret[locale2] || {};
        deepCopy$1(resource, ret[locale2]);
      } else {
        deepCopy$1(resource, ret);
      }
    });
  }
  if (options.flatJson) {
    for (const key2 in ret) {
      if (hasOwn$3(ret, key2)) {
        handleFlatJson(ret[key2]);
      }
    }
  }
  return ret;
}
const isNotObjectOrIsArray = (val) => !isObject$4(val) || isArray$8(val);
function deepCopy$1(src2, des) {
  if (isNotObjectOrIsArray(src2) || isNotObjectOrIsArray(des)) {
    throw createI18nError(20);
  }
  for (const key2 in src2) {
    if (hasOwn$3(src2, key2)) {
      if (isNotObjectOrIsArray(src2[key2]) || isNotObjectOrIsArray(des[key2])) {
        des[key2] = src2[key2];
      } else {
        deepCopy$1(src2[key2], des[key2]);
      }
    }
  }
}
const getMetaInfo = () => {
  const instance = getCurrentInstance();
  return instance && instance.type[DEVTOOLS_META] ? { [DEVTOOLS_META]: instance.type[DEVTOOLS_META] } : null;
};
function createComposer(options = {}) {
  const { __root } = options;
  const _isGlobal = __root === void 0;
  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = ref(__root && _inheritLocale ? __root.locale.value : isString$1(options.locale) ? options.locale : "en-US");
  const _fallbackLocale = ref(__root && _inheritLocale ? __root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray$8(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value);
  const _messages = ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = ref(isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject$1(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction$3(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction$3(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction$3(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject$1(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  function getCoreContext() {
    return createCoreContext({
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      datetimeFormats: _datetimeFormats.value,
      numberFormats: _numberFormats.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      __datetimeFormatters: isPlainObject$1(_context) ? _context.__datetimeFormatters : void 0,
      __numberFormatters: isPlainObject$1(_context) ? _context.__numberFormatters : void 0,
      __v_emitter: isPlainObject$1(_context) ? _context.__v_emitter : void 0,
      __meta: { framework: "vue" }
    });
  }
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages = computed(() => _messages.value);
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction$3(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  function wrapWithDeps(fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) {
    trackReactivityValues();
    let ret;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      try {
        setAdditionalMeta(getMetaInfo());
        ret = fn(_context);
      } finally {
        setAdditionalMeta(null);
      }
    } else {
      ret = fn(_context);
    }
    if (isNumber(ret) && ret === NOT_REOSLVED) {
      const [key2, arg2] = argumentParser();
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key2);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(14);
    }
  }
  function t2(...args) {
    return wrapWithDeps((context) => translate(context, ...args), () => parseTranslateArgs(...args), "translate", (root2) => root2.t(...args), (key2) => key2, (val) => isString$1(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$4(arg3)) {
      throw createI18nError(15);
    }
    return t2(...[arg1, arg2, assign$2({ resolvedMessage: true }, arg3 || {})]);
  }
  function d2(...args) {
    return wrapWithDeps((context) => datetime(context, ...args), () => parseDateTimeArgs(...args), "datetime format", (root2) => root2.d(...args), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function n2(...args) {
    return wrapWithDeps((context) => number$1(context, ...args), () => parseNumberArgs(...args), "number format", (root2) => root2.n(...args), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function normalize3(values) {
    return values.map((val) => isString$1(val) ? createVNode(Text, null, val, 0) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize: normalize3,
    interpolate,
    type: "vnode"
  };
  function transrateVNode(...args) {
    return wrapWithDeps((context) => {
      let ret;
      const _context2 = context;
      try {
        _context2.processor = processor;
        ret = translate(_context2, ...args);
      } finally {
        _context2.processor = null;
      }
      return ret;
    }, () => parseTranslateArgs(...args), "translate", (root2) => root2[TransrateVNodeSymbol](...args), (key2) => [createVNode(Text, null, key2, 0)], (val) => isArray$8(val));
  }
  function numberParts(...args) {
    return wrapWithDeps((context) => number$1(context, ...args), () => parseNumberArgs(...args), "number format", (root2) => root2[NumberPartsSymbol](...args), () => [], (val) => isString$1(val) || isArray$8(val));
  }
  function datetimeParts(...args) {
    return wrapWithDeps((context) => datetime(context, ...args), () => parseDateTimeArgs(...args), "datetime format", (root2) => root2[DatetimePartsSymbol](...args), () => [], (val) => isString$1(val) || isArray$8(val));
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te(key2, locale2) {
    const targetLocale = isString$1(locale2) ? locale2 : _locale.value;
    const message = getLocaleMessage(targetLocale);
    return resolveValue(message, key2) !== null;
  }
  function resolveMessages(key2) {
    let messages2 = null;
    const locales = getLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i2 = 0; i2 < locales.length; i2++) {
      const targetLocaleMessages = _messages.value[locales[i2]] || {};
      const messageValue = resolveValue(targetLocaleMessages, key2);
      if (messageValue != null) {
        messages2 = messageValue;
        break;
      }
    }
    return messages2;
  }
  function tm(key2) {
    const messages2 = resolveMessages(key2);
    return messages2 != null ? messages2 : __root ? __root.tm(key2) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message) {
    _messages.value[locale2] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    deepCopy$1(message, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function mergeDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = assign$2(_datetimeFormats.value[locale2] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  function mergeNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = assign$2(_numberFormats.value[locale2] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  composerID++;
  if (__root) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages,
    datetimeFormats,
    numberFormats,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t: t2,
    rt,
    d: d2,
    n: n2,
    te,
    tm,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [TransrateVNodeSymbol]: transrateVNode,
    [NumberPartsSymbol]: numberParts,
    [DatetimePartsSymbol]: datetimeParts,
    [SetPluralRulesSymbol]: setPluralRules,
    [InejctWithOption]: options.__injectWithOption
  };
  return composer;
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
  },
  i18n: {
    type: Object
  }
};
const Translation = {
  name: "i18n-t",
  props: assign$2({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      validator: (val) => isNumber(val) || !isNaN(val)
    }
  }, baseFormatProps),
  setup(props, context) {
    const { slots, attrs } = context;
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    const keys2 = Object.keys(slots).filter((key2) => key2 !== "_");
    return () => {
      const options = {};
      if (props.locale) {
        options.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options.plural = isString$1(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys2);
      const children = i18n[TransrateVNodeSymbol](props.keypath, arg, options);
      const assignedAttrs = assign$2({}, attrs);
      return isString$1(props.tag) ? h$4(props.tag, assignedAttrs, children) : isObject$4(props.tag) ? h$4(props.tag, assignedAttrs, children) : h$4(Fragment$1, assignedAttrs, children);
    };
  }
};
function getInterpolateArg({ slots }, keys2) {
  if (keys2.length === 1 && keys2[0] === "default") {
    return slots.default ? slots.default() : [];
  } else {
    return keys2.reduce((arg, key2) => {
      const slot = slots[key2];
      if (slot) {
        arg[key2] = slot();
      }
      return arg;
    }, {});
  }
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options = { part: true };
    let overrides = {};
    if (props.locale) {
      options.locale = props.locale;
    }
    if (isString$1(props.format)) {
      options.key = props.format;
    } else if (isObject$4(props.format)) {
      if (isString$1(props.format.key)) {
        options.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign$2({}, options2, { [prop]: props.format[prop] }) : options2;
      }, {});
    }
    const parts = partFormatter(...[props.value, options, overrides]);
    let children = [options.key];
    if (isArray$8(parts)) {
      children = parts.map((part, index2) => {
        const slot = slots[part.type];
        return slot ? slot({ [part.type]: part.value, index: index2, parts }) : [part.value];
      });
    } else if (isString$1(parts)) {
      children = [parts];
    }
    const assignedAttrs = assign$2({}, attrs);
    return isString$1(props.tag) ? h$4(props.tag, assignedAttrs, children) : isObject$4(props.tag) ? h$4(props.tag, assignedAttrs, children) : h$4(Fragment$1, assignedAttrs, children);
  };
}
const NUMBER_FORMAT_KEYS = [
  "localeMatcher",
  "style",
  "unit",
  "unitDisplay",
  "currency",
  "currencyDisplay",
  "useGrouping",
  "numberingSystem",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "notation",
  "formatMatcher"
];
const NumberFormat = {
  name: "i18n-n",
  props: assign$2({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  setup(props, context) {
    const i18n = props.i18n || useI18n({ useScope: "parent", __useComponent: true });
    return renderFormatter(props, context, NUMBER_FORMAT_KEYS, (...args) => i18n[NumberPartsSymbol](...args));
  }
};
const DATETIME_FORMAT_KEYS = [
  "dateStyle",
  "timeStyle",
  "fractionalSecondDigits",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "localeMatcher",
  "timeZone",
  "hour12",
  "hourCycle",
  "formatMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName"
];
const DatetimeFormat = {
  name: "i18n-d",
  props: assign$2({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  setup(props, context) {
    const i18n = props.i18n || useI18n({ useScope: "parent", __useComponent: true });
    return renderFormatter(props, context, DATETIME_FORMAT_KEYS, (...args) => i18n[DatetimePartsSymbol](...args));
  }
};
function getComposer$2(i18n, instance) {
  const i18nInternal = i18n;
  if (i18n.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n.global.__composer;
  }
}
function vTDirective(i18n) {
  const bind3 = (el, { instance, value: value2, modifiers }) => {
    if (!instance || !instance.$) {
      throw createI18nError(22);
    }
    const composer = getComposer$2(i18n, instance.$);
    const parsedValue = parseValue(value2);
    el.textContent = composer.t(...makeParams(parsedValue));
  };
  return {
    beforeMount: bind3,
    beforeUpdate: bind3
  };
}
function parseValue(value2) {
  if (isString$1(value2)) {
    return { path: value2 };
  } else if (isPlainObject$1(value2)) {
    if (!("path" in value2)) {
      throw createI18nError(19, "path");
    }
    return value2;
  } else {
    throw createI18nError(20);
  }
}
function makeParams(value2) {
  const { path, locale, args, choice, plural } = value2;
  const options = {};
  const named = args || {};
  if (isString$1(locale)) {
    options.locale = locale;
  }
  if (isNumber(choice)) {
    options.plural = choice;
  }
  if (isNumber(plural)) {
    options.plural = plural;
  }
  return [path, named, options];
}
function apply(app, i18n, ...options) {
  const pluginOptions = isPlainObject$1(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall) {
    app.component(!useI18nComponentName ? Translation.name : "i18n", Translation);
    app.component(NumberFormat.name, NumberFormat);
    app.component(DatetimeFormat.name, DatetimeFormat);
  }
  app.directive("t", vTDirective(i18n));
}
function createI18n(options = {}) {
  const __globalInjection = !!options.globalInjection;
  const __instances = new Map();
  const __global = createComposer(options);
  const symbol = makeSymbol("");
  const i18n = {
    get mode() {
      return "composition";
    },
    async install(app, ...options2) {
      app.__VUE_I18N_SYMBOL__ = symbol;
      app.provide(app.__VUE_I18N_SYMBOL__, i18n);
      if (__globalInjection) {
        injectGlobalFields(app, i18n.global);
      }
      {
        apply(app, i18n, ...options2);
      }
    },
    get global() {
      return __global;
    },
    __instances,
    __getInstance(component) {
      return __instances.get(component) || null;
    },
    __setInstance(component, instance) {
      __instances.set(component, instance);
    },
    __deleteInstance(component) {
      __instances.delete(component);
    }
  };
  return i18n;
}
function useI18n(options = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(16);
  }
  if (!instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(17);
  }
  const i18n = inject(instance.appContext.app.__VUE_I18N_SYMBOL__);
  if (!i18n) {
    throw createI18nError(22);
  }
  const global2 = i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
  const scope = isEmptyObject(options) ? "__i18n" in instance.type ? "local" : "global" : !options.useScope ? "local" : options.useScope;
  if (scope === "global") {
    let messages = isObject$4(options.messages) ? options.messages : {};
    if ("__i18nGlobal" in instance.type) {
      messages = getLocaleMessages(global2.locale.value, {
        messages,
        __i18n: instance.type.__i18nGlobal
      });
    }
    const locales = Object.keys(messages);
    if (locales.length) {
      locales.forEach((locale) => {
        global2.mergeLocaleMessage(locale, messages[locale]);
      });
    }
    if (isObject$4(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          global2.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    }
    if (isObject$4(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          global2.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
    return global2;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n, instance, options.__useComponent);
    if (composer2 == null) {
      composer2 = global2;
    }
    return composer2;
  }
  if (i18n.mode === "legacy") {
    throw createI18nError(18);
  }
  const i18nInternal = i18n;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const type = instance.type;
    const composerOptions = assign$2({}, options);
    if (type.__i18n) {
      composerOptions.__i18n = type.__i18n;
    }
    if (global2) {
      composerOptions.__root = global2;
    }
    composer = createComposer(composerOptions);
    setupLifeCycle(i18nInternal, instance);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function getComposer(i18n, target, useComponent = false) {
  let composer = null;
  const root2 = target.root;
  let current = target.parent;
  while (current != null) {
    const i18nInternal = i18n;
    if (i18n.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      const vueI18n = i18nInternal.__getInstance(current);
      if (vueI18n != null) {
        composer = vueI18n.__composer;
      }
      if (useComponent && composer && !composer[InejctWithOption]) {
        composer = null;
      }
    }
    if (composer != null) {
      break;
    }
    if (root2 === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function setupLifeCycle(i18n, target, composer) {
  onMounted(() => {
  }, target);
  onUnmounted(() => {
    i18n.__deleteInstance(target);
  }, target);
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm"];
function injectGlobalFields(app, composer) {
  const i18n = Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(22);
    }
    const wrap2 = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n, prop, wrap2);
  });
  app.config.globalProperties.$i18n = i18n;
  globalExportMethods.forEach((method2) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method2);
    if (!desc || !desc.value) {
      throw createI18nError(22);
    }
    Object.defineProperty(app.config.globalProperties, `$${method2}`, desc);
  });
}
{
  initFeatureFlags();
}
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var nprogress = { exports: {} };
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
(function(module2, exports2) {
  (function(root2, factory) {
    {
      module2.exports = factory();
    }
  })(commonjsGlobal, function() {
    var NProgress2 = {};
    NProgress2.version = "0.2.0";
    var Settings = NProgress2.settings = {
      minimum: 0.08,
      easing: "ease",
      positionUsing: "",
      speed: 200,
      trickle: true,
      trickleRate: 0.02,
      trickleSpeed: 800,
      showSpinner: true,
      barSelector: '[role="bar"]',
      spinnerSelector: '[role="spinner"]',
      parent: "body",
      template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
    };
    NProgress2.configure = function(options) {
      var key2, value2;
      for (key2 in options) {
        value2 = options[key2];
        if (value2 !== void 0 && options.hasOwnProperty(key2))
          Settings[key2] = value2;
      }
      return this;
    };
    NProgress2.status = null;
    NProgress2.set = function(n2) {
      var started = NProgress2.isStarted();
      n2 = clamp(n2, Settings.minimum, 1);
      NProgress2.status = n2 === 1 ? null : n2;
      var progress = NProgress2.render(!started), bar = progress.querySelector(Settings.barSelector), speed = Settings.speed, ease = Settings.easing;
      progress.offsetWidth;
      queue2(function(next3) {
        if (Settings.positionUsing === "")
          Settings.positionUsing = NProgress2.getPositioningCSS();
        css(bar, barPositionCSS(n2, speed, ease));
        if (n2 === 1) {
          css(progress, {
            transition: "none",
            opacity: 1
          });
          progress.offsetWidth;
          setTimeout(function() {
            css(progress, {
              transition: "all " + speed + "ms linear",
              opacity: 0
            });
            setTimeout(function() {
              NProgress2.remove();
              next3();
            }, speed);
          }, speed);
        } else {
          setTimeout(next3, speed);
        }
      });
      return this;
    };
    NProgress2.isStarted = function() {
      return typeof NProgress2.status === "number";
    };
    NProgress2.start = function() {
      if (!NProgress2.status)
        NProgress2.set(0);
      var work = function() {
        setTimeout(function() {
          if (!NProgress2.status)
            return;
          NProgress2.trickle();
          work();
        }, Settings.trickleSpeed);
      };
      if (Settings.trickle)
        work();
      return this;
    };
    NProgress2.done = function(force) {
      if (!force && !NProgress2.status)
        return this;
      return NProgress2.inc(0.3 + 0.5 * Math.random()).set(1);
    };
    NProgress2.inc = function(amount) {
      var n2 = NProgress2.status;
      if (!n2) {
        return NProgress2.start();
      } else {
        if (typeof amount !== "number") {
          amount = (1 - n2) * clamp(Math.random() * n2, 0.1, 0.95);
        }
        n2 = clamp(n2 + amount, 0, 0.994);
        return NProgress2.set(n2);
      }
    };
    NProgress2.trickle = function() {
      return NProgress2.inc(Math.random() * Settings.trickleRate);
    };
    (function() {
      var initial = 0, current = 0;
      NProgress2.promise = function($promise) {
        if (!$promise || $promise.state() === "resolved") {
          return this;
        }
        if (current === 0) {
          NProgress2.start();
        }
        initial++;
        current++;
        $promise.always(function() {
          current--;
          if (current === 0) {
            initial = 0;
            NProgress2.done();
          } else {
            NProgress2.set((initial - current) / initial);
          }
        });
        return this;
      };
    })();
    NProgress2.render = function(fromStart) {
      if (NProgress2.isRendered())
        return document.getElementById("nprogress");
      addClass(document.documentElement, "nprogress-busy");
      var progress = document.createElement("div");
      progress.id = "nprogress";
      progress.innerHTML = Settings.template;
      var bar = progress.querySelector(Settings.barSelector), perc = fromStart ? "-100" : toBarPerc(NProgress2.status || 0), parent = document.querySelector(Settings.parent), spinner;
      css(bar, {
        transition: "all 0 linear",
        transform: "translate3d(" + perc + "%,0,0)"
      });
      if (!Settings.showSpinner) {
        spinner = progress.querySelector(Settings.spinnerSelector);
        spinner && removeElement(spinner);
      }
      if (parent != document.body) {
        addClass(parent, "nprogress-custom-parent");
      }
      parent.appendChild(progress);
      return progress;
    };
    NProgress2.remove = function() {
      removeClass(document.documentElement, "nprogress-busy");
      removeClass(document.querySelector(Settings.parent), "nprogress-custom-parent");
      var progress = document.getElementById("nprogress");
      progress && removeElement(progress);
    };
    NProgress2.isRendered = function() {
      return !!document.getElementById("nprogress");
    };
    NProgress2.getPositioningCSS = function() {
      var bodyStyle = document.body.style;
      var vendorPrefix = "WebkitTransform" in bodyStyle ? "Webkit" : "MozTransform" in bodyStyle ? "Moz" : "msTransform" in bodyStyle ? "ms" : "OTransform" in bodyStyle ? "O" : "";
      if (vendorPrefix + "Perspective" in bodyStyle) {
        return "translate3d";
      } else if (vendorPrefix + "Transform" in bodyStyle) {
        return "translate";
      } else {
        return "margin";
      }
    };
    function clamp(n2, min2, max2) {
      if (n2 < min2)
        return min2;
      if (n2 > max2)
        return max2;
      return n2;
    }
    function toBarPerc(n2) {
      return (-1 + n2) * 100;
    }
    function barPositionCSS(n2, speed, ease) {
      var barCSS;
      if (Settings.positionUsing === "translate3d") {
        barCSS = { transform: "translate3d(" + toBarPerc(n2) + "%,0,0)" };
      } else if (Settings.positionUsing === "translate") {
        barCSS = { transform: "translate(" + toBarPerc(n2) + "%,0)" };
      } else {
        barCSS = { "margin-left": toBarPerc(n2) + "%" };
      }
      barCSS.transition = "all " + speed + "ms " + ease;
      return barCSS;
    }
    var queue2 = function() {
      var pending = [];
      function next3() {
        var fn = pending.shift();
        if (fn) {
          fn(next3);
        }
      }
      return function(fn) {
        pending.push(fn);
        if (pending.length == 1)
          next3();
      };
    }();
    var css = function() {
      var cssPrefixes = ["Webkit", "O", "Moz", "ms"], cssProps = {};
      function camelCase(string2) {
        return string2.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(match, letter) {
          return letter.toUpperCase();
        });
      }
      function getVendorProp(name2) {
        var style = document.body.style;
        if (name2 in style)
          return name2;
        var i2 = cssPrefixes.length, capName = name2.charAt(0).toUpperCase() + name2.slice(1), vendorName;
        while (i2--) {
          vendorName = cssPrefixes[i2] + capName;
          if (vendorName in style)
            return vendorName;
        }
        return name2;
      }
      function getStyleProp(name2) {
        name2 = camelCase(name2);
        return cssProps[name2] || (cssProps[name2] = getVendorProp(name2));
      }
      function applyCss(element, prop, value2) {
        prop = getStyleProp(prop);
        element.style[prop] = value2;
      }
      return function(element, properties) {
        var args = arguments, prop, value2;
        if (args.length == 2) {
          for (prop in properties) {
            value2 = properties[prop];
            if (value2 !== void 0 && properties.hasOwnProperty(prop))
              applyCss(element, prop, value2);
          }
        } else {
          applyCss(element, args[1], args[2]);
        }
      };
    }();
    function hasClass(element, name2) {
      var list = typeof element == "string" ? element : classList(element);
      return list.indexOf(" " + name2 + " ") >= 0;
    }
    function addClass(element, name2) {
      var oldList = classList(element), newList = oldList + name2;
      if (hasClass(oldList, name2))
        return;
      element.className = newList.substring(1);
    }
    function removeClass(element, name2) {
      var oldList = classList(element), newList;
      if (!hasClass(element, name2))
        return;
      newList = oldList.replace(" " + name2 + " ", " ");
      element.className = newList.substring(1, newList.length - 1);
    }
    function classList(element) {
      return (" " + (element.className || "") + " ").replace(/\s+/gi, " ");
    }
    function removeElement(element) {
      element && element.parentNode && element.parentNode.removeChild(element);
    }
    return NProgress2;
  });
})(nprogress);
var NProgress = nprogress.exports;
var isVue2 = false;
/*!
  * pinia v2.0.9
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */
let activePinia;
const setActivePinia = (pinia) => activePinia = pinia;
const piniaSymbol = Symbol();
function isPlainObject(o2) {
  return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state2 = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia = markRaw({
    install(app) {
      setActivePinia(pinia);
      {
        pinia._a = app;
        app.provide(piniaSymbol, pinia);
        app.config.globalProperties.$pinia = pinia;
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      }
    },
    use(plugin) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    _a: null,
    _e: scope,
    _s: new Map(),
    state: state2
  });
  return pinia;
}
const noop$9 = () => {
};
function addSubscription(subscriptions2, callback, detached, onCleanup = noop$9) {
  subscriptions2.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions2.indexOf(callback);
    if (idx > -1) {
      subscriptions2.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentInstance()) {
    onUnmounted(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions2, ...args) {
  subscriptions2.forEach((callback) => {
    callback(...args);
  });
}
function mergeReactiveObjects(target, patchToApply) {
  for (const key2 in patchToApply) {
    const subPatch = patchToApply[key2];
    const targetValue = target[key2];
    if (isPlainObject(targetValue) && isPlainObject(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key2] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key2] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = Symbol();
function shouldHydrate(obj) {
  return !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign: assign$1 } = Object;
function isComputed(o2) {
  return !!(isRef(o2) && o2.effect);
}
function createOptionsStore(id2, options, pinia, hot) {
  const { state: state2, actions, getters } = options;
  const initialState = pinia.state.value[id2];
  let store;
  function setup() {
    if (!initialState && true) {
      {
        pinia.state.value[id2] = state2 ? state2() : {};
      }
    }
    const localState = toRefs(pinia.state.value[id2]);
    return assign$1(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name2) => {
      computedGetters[name2] = markRaw(computed(() => {
        setActivePinia(pinia);
        const store2 = pinia._s.get(id2);
        return getters[name2].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id2, setup, options, pinia);
  store.$reset = function $reset() {
    const newState = state2 ? state2() : {};
    this.$patch(($state) => {
      assign$1($state, newState);
    });
  };
  return store;
}
function createSetupStore($id, setup, options = {}, pinia, hot) {
  let scope;
  const buildState2 = options.state;
  const optionsForPlugin = assign$1({ actions: {} }, options);
  const $subscribeOptions = {
    deep: true
  };
  let isListening;
  let isSyncListening;
  let subscriptions2 = markRaw([]);
  let actionSubscriptions = markRaw([]);
  let debuggerEvents;
  const initialState = pinia.state.value[$id];
  if (!buildState2 && !initialState && true) {
    {
      pinia.state.value[$id] = {};
    }
  }
  ref({});
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    nextTick().then(() => {
      isListening = true;
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions2, subscriptionMutation, pinia.state.value[$id]);
  }
  const $reset = noop$9;
  function $dispose() {
    scope.stop();
    subscriptions2 = [];
    actionSubscriptions = [];
    pinia._s.delete($id);
  }
  function wrapAction(name2, action) {
    return function() {
      setActivePinia(pinia);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name: name2,
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store, args);
      } catch (error2) {
        triggerSubscriptions(onErrorCallbackList, error2);
        throw error2;
      }
      if (ret instanceof Promise) {
        return ret.then((value2) => {
          triggerSubscriptions(afterCallbackList, value2);
          return value2;
        }).catch((error2) => {
          triggerSubscriptions(onErrorCallbackList, error2);
          return Promise.reject(error2);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  const partialStore = {
    _p: pinia,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions2, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state2) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state2);
        }
      }, assign$1({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(assign$1({}, partialStore));
  pinia._s.set($id, store);
  const setupStore = pinia._e.run(() => {
    scope = effectScope();
    return scope.run(() => setup());
  });
  for (const key2 in setupStore) {
    const prop = setupStore[key2];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (!buildState2) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key2];
          } else {
            mergeReactiveObjects(prop, initialState[key2]);
          }
        }
        {
          pinia.state.value[$id][key2] = prop;
        }
      }
    } else if (typeof prop === "function") {
      const actionValue = wrapAction(key2, prop);
      {
        setupStore[key2] = actionValue;
      }
      optionsForPlugin.actions[key2] = prop;
    } else
      ;
  }
  {
    assign$1(store, setupStore);
    assign$1(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => pinia.state.value[$id],
    set: (state2) => {
      $patch(($state) => {
        assign$1($state, state2);
      });
    }
  });
  pinia._p.forEach((extender) => {
    {
      assign$1(store, scope.run(() => extender({
        store,
        app: pinia._a,
        pinia,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && buildState2 && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
function defineStore(idOrOptions, setup, setupOptions) {
  let id2;
  let options;
  const isSetupStore = typeof setup === "function";
  if (typeof idOrOptions === "string") {
    id2 = idOrOptions;
    options = isSetupStore ? setupOptions : setup;
  } else {
    options = idOrOptions;
    id2 = idOrOptions.id;
  }
  function useStore(pinia, hot) {
    const currentInstance2 = getCurrentInstance();
    pinia = pinia || currentInstance2 && inject(piniaSymbol);
    if (pinia)
      setActivePinia(pinia);
    pinia = activePinia;
    if (!pinia._s.has(id2)) {
      if (isSetupStore) {
        createSetupStore(id2, setup, options, pinia);
      } else {
        createOptionsStore(id2, options, pinia);
      }
    }
    const store = pinia._s.get(id2);
    return store;
  }
  useStore.$id = id2;
  return useStore;
}
/*!
  * vue-router v4.0.12
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */
const hasSymbol = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
const PolySymbol = (name2) => hasSymbol ? Symbol(name2) : "_vr_" + name2;
const matchedRouteKey = /* @__PURE__ */ PolySymbol("rvlm");
const viewDepthKey = /* @__PURE__ */ PolySymbol("rvd");
const routerKey = /* @__PURE__ */ PolySymbol("r");
const routeLocationKey = /* @__PURE__ */ PolySymbol("rl");
const routerViewLocationKey = /* @__PURE__ */ PolySymbol("rvl");
const isBrowser$2 = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === "Module";
}
const assign = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key2 in params) {
    const value2 = params[key2];
    newParams[key2] = Array.isArray(value2) ? value2.map(fn) : fn(value2);
  }
  return newParams;
}
const noop$8 = () => {
};
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query2 = {}, searchString = "", hash3 = "";
  const searchPos = location2.indexOf("?");
  const hashPos = location2.indexOf("#", searchPos > -1 ? searchPos : 0);
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query2 = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash3 = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash3,
    path,
    query: query2,
    hash: hash3
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query2 = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query2 && "?") + query2 + (location2.hash || "");
}
function stripBase(pathname, base2) {
  if (!base2 || !pathname.toLowerCase().startsWith(base2.toLowerCase()))
    return pathname;
  return pathname.slice(base2.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a2, b2) {
  const aLastIndex = a2.matched.length - 1;
  const bLastIndex = b2.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a2.matched[aLastIndex], b2.matched[bLastIndex]) && isSameRouteLocationParams(a2.params, b2.params) && stringifyQuery2(a2.query) === stringifyQuery2(b2.query) && a2.hash === b2.hash;
}
function isSameRouteRecord(a2, b2) {
  return (a2.aliasOf || a2) === (b2.aliasOf || b2);
}
function isSameRouteLocationParams(a2, b2) {
  if (Object.keys(a2).length !== Object.keys(b2).length)
    return false;
  for (const key2 in a2) {
    if (!isSameRouteLocationParamsValue(a2[key2], b2[key2]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a2, b2) {
  return Array.isArray(a2) ? isEquivalentArray(a2, b2) : Array.isArray(b2) ? isEquivalentArray(b2, a2) : a2 === b2;
}
function isEquivalentArray(a2, b2) {
  return Array.isArray(b2) ? a2.length === b2.length && a2.every((value2, i2) => value2 === b2[i2]) : a2.length === 1 && a2[0] === b2;
}
function resolveRelativePath(to, from2) {
  if (to.startsWith("/"))
    return to;
  if (!to)
    return from2;
  const fromSegments = from2.split("/");
  const toSegments = to.split("/");
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (position === 1 || segment === ".")
      continue;
    if (segment === "..")
      position--;
    else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base2) {
  if (!base2) {
    if (isBrowser$2) {
      const baseEl = document.querySelector("base");
      base2 = baseEl && baseEl.getAttribute("href") || "/";
      base2 = base2.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base2 = "/";
    }
  }
  if (base2[0] !== "/" && base2[0] !== "#")
    base2 = "/" + base2;
  return removeTrailingSlash(base2);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base2, location2) {
  return base2.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path, delta) {
  const position = history.state ? history.state.position - delta : -1;
  return position + path;
}
const scrollPositions = new Map();
function saveScrollPosition(key2, scrollPosition) {
  scrollPositions.set(key2, scrollPosition);
}
function getSavedScrollPosition(key2) {
  const scroll = scrollPositions.get(key2);
  scrollPositions.delete(key2);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base2, location2) {
  const { pathname, search, hash: hash3 } = location2;
  const hashPos = base2.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash3.includes(base2.slice(hashPos)) ? base2.slice(hashPos).length : 1;
    let pathFromHash = hash3.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base2);
  return path + search + hash3;
}
function useHistoryListeners(base2, historyState, currentLocation, replace) {
  let listeners2 = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state: state2 }) => {
    const to = createCurrentLocation(base2, location);
    const from2 = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state2) {
      currentLocation.value = to;
      historyState.value = state2;
      if (pauseState && pauseState === from2) {
        pauseState = null;
        return;
      }
      delta = fromState ? state2.position - fromState.position : 0;
    } else {
      replace(to);
    }
    listeners2.forEach((listener) => {
      listener(currentLocation.value, from2, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners2.push(callback);
    const teardown = () => {
      const index2 = listeners2.indexOf(callback);
      if (index2 > -1)
        listeners2.splice(index2, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy2() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener);
  return {
    pauseListeners,
    listen,
    destroy: destroy2
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base2) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base2, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      position: history2.length - 1,
      replaced: true,
      scroll: null
    }, true);
  }
  function changeLocation(to, state2, replace2) {
    const hashIndex = base2.indexOf("#");
    const url2 = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base2 : base2.slice(hashIndex)) + to : createBaseLocation() + base2 + to;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state2, "", url2);
      historyState.value = state2;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url2);
    }
  }
  function replace(to, data) {
    const state2 = assign({}, history2.state, buildState(historyState.value.back, to, historyState.value.forward, true), data, { position: historyState.value.position });
    changeLocation(to, state2, true);
    currentLocation.value = to;
  }
  function push(to, data) {
    const currentState = assign({}, historyState.value, history2.state, {
      forward: to,
      scroll: computeScrollPosition()
    });
    changeLocation(currentState.current, currentState, true);
    const state2 = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
    changeLocation(to, state2, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace
  };
}
function createWebHistory(base2) {
  base2 = normalizeBase(base2);
  const historyNavigation = useHistoryStateNavigation(base2);
  const historyListeners = useHistoryListeners(base2, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign({
    location: "",
    base: base2,
    go,
    createHref: createHref.bind(null, base2)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function createWebHashHistory(base2) {
  base2 = location.host ? base2 || location.pathname + location.search : "";
  if (!base2.includes("#"))
    base2 += "#";
  return createWebHistory(base2);
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name2) {
  return typeof name2 === "string" || typeof name2 === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = /* @__PURE__ */ PolySymbol("nf");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type, params) {
  {
    return assign(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error2, type) {
  return error2 instanceof Error && NavigationFailureSymbol in error2 && (type == null || !!(error2.type & type));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments2, extraOptions) {
  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys2 = [];
  for (const segment of segments2) {
    const segmentScores = segment.length ? [] : [90];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token2 = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token2.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token2.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token2.type === 1) {
        const { value: value2, repeatable, optional, regexp } = token2;
        keys2.push({
          name: value2,
          repeatable,
          optional
        });
        const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re2 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re2})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value2}" (${re2}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
        if (!tokenIndex)
          subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re2 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i2 = score.length - 1;
    score[i2][score[i2].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse2(path) {
    const match = path.match(re);
    const params = {};
    if (!match)
      return null;
    for (let i2 = 1; i2 < match.length; i2++) {
      const value2 = match[i2] || "";
      const key2 = keys2[i2 - 1];
      params[key2.name] = value2 && key2.repeatable ? value2.split("/") : value2;
    }
    return params;
  }
  function stringify2(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments2) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token2 of segment) {
        if (token2.type === 0) {
          path += token2.value;
        } else if (token2.type === 1) {
          const { value: value2, repeatable, optional } = token2;
          const param = value2 in params ? params[value2] : "";
          if (Array.isArray(param) && !repeatable)
            throw new Error(`Provided param "${value2}" is an array but it is not repeatable (* or + modifiers)`);
          const text2 = Array.isArray(param) ? param.join("/") : param;
          if (!text2) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value2}"`);
          }
          path += text2;
        }
      }
    }
    return path;
  }
  return {
    re,
    score,
    keys: keys2,
    parse: parse2,
    stringify: stringify2
  };
}
function compareScoreArray(a2, b2) {
  let i2 = 0;
  while (i2 < a2.length && i2 < b2.length) {
    const diff = b2[i2] - a2[i2];
    if (diff)
      return diff;
    i2++;
  }
  if (a2.length < b2.length) {
    return a2.length === 1 && a2[0] === 40 + 40 ? -1 : 1;
  } else if (a2.length > b2.length) {
    return b2.length === 1 && b2[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a2, b2) {
  let i2 = 0;
  const aScore = a2.score;
  const bScore = b2.score;
  while (i2 < aScore.length && i2 < bScore.length) {
    const comp = compareScoreArray(aScore[i2], bScore[i2]);
    if (comp)
      return comp;
    i2++;
  }
  return bScore.length - aScore.length;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state2})/"${buffer2}": ${message}`);
  }
  let state2 = 0;
  let previousState = state2;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i2 = 0;
  let char;
  let buffer2 = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer2)
      return;
    if (state2 === 0) {
      segment.push({
        type: 0,
        value: buffer2
      });
    } else if (state2 === 1 || state2 === 2 || state2 === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer2}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer2,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer2 = "";
  }
  function addCharToBuffer() {
    buffer2 += char;
  }
  while (i2 < path.length) {
    char = path[i2++];
    if (char === "\\" && state2 !== 2) {
      previousState = state2;
      state2 = 4;
      continue;
    }
    switch (state2) {
      case 0:
        if (char === "/") {
          if (buffer2) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state2 = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state2 = previousState;
        break;
      case 1:
        if (char === "(") {
          state2 = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state2 = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i2--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state2 = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state2 = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i2--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state2 === 2)
    crash(`Unfinished custom RegExp for param "${buffer2}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign(parser, {
    record,
    parent,
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes, globalOptions) {
  const matchers2 = [];
  const matcherMap = new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name2) {
    return matcherMap.get(name2);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(assign({}, mainNormalizedRecord, {
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if ("children" in mainNormalizedRecord) {
        const children = mainNormalizedRecord.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
        }
      }
      originalRecord = originalRecord || matcher;
      insertMatcher(matcher);
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop$8;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers2.splice(matchers2.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index2 = matchers2.indexOf(matcherRef);
      if (index2 > -1) {
        matchers2.splice(index2, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers2;
  }
  function insertMatcher(matcher) {
    let i2 = 0;
    while (i2 < matchers2.length && comparePathParserScore(matcher, matchers2[i2]) >= 0)
      i2++;
    matchers2.splice(i2, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve2(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name2;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name2 = matcher.record.name;
      params = assign(paramsFromLocation(currentLocation.params, matcher.keys.filter((k2) => !k2.optional).map((k2) => k2.name)), location2.params);
      path = matcher.stringify(params);
    } else if ("path" in location2) {
      path = location2.path;
      matcher = matchers2.find((m2) => m2.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name2 = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers2.find((m2) => m2.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name2 = matcher.record.name;
      params = assign({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name: name2,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes.forEach((route) => addRoute(route));
  return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys2) {
  const newParams = {};
  for (const key2 of keys2) {
    if (key2 in params)
      newParams[key2] = params[key2];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: new Set(),
    updateGuards: new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || {} : { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name2 in record.components)
      propsObject[name2] = typeof props === "boolean" ? props : props[name2];
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta2, record) => assign(meta2, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
  const options = {};
  for (const key2 in defaults) {
    options[key2] = key2 in partialOptions ? partialOptions[key2] : defaults[key2];
  }
  return options;
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text2) {
  return encodeURI("" + text2).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text2) {
  return commonEncode(text2).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text2) {
  return commonEncode(text2).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text2) {
  return encodeQueryValue(text2).replace(EQUAL_RE, "%3D");
}
function encodePath(text2) {
  return commonEncode(text2).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text2) {
  return text2 == null ? "" : encodePath(text2).replace(SLASH_RE, "%2F");
}
function decode$6(text2) {
  try {
    return decodeURIComponent("" + text2);
  } catch (err) {
  }
  return "" + text2;
}
function parseQuery(search) {
  const query2 = {};
  if (search === "" || search === "?")
    return query2;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i2 = 0; i2 < searchParams.length; ++i2) {
    const searchParam = searchParams[i2].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key2 = decode$6(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value2 = eqPos < 0 ? null : decode$6(searchParam.slice(eqPos + 1));
    if (key2 in query2) {
      let currentValue = query2[key2];
      if (!Array.isArray(currentValue)) {
        currentValue = query2[key2] = [currentValue];
      }
      currentValue.push(value2);
    } else {
      query2[key2] = value2;
    }
  }
  return query2;
}
function stringifyQuery(query2) {
  let search = "";
  for (let key2 in query2) {
    const value2 = query2[key2];
    key2 = encodeQueryKey(key2);
    if (value2 == null) {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key2;
      }
      continue;
    }
    const values = Array.isArray(value2) ? value2.map((v2) => v2 && encodeQueryValue(v2)) : [value2 && encodeQueryValue(value2)];
    values.forEach((value3) => {
      if (value3 !== void 0) {
        search += (search.length ? "&" : "") + key2;
        if (value3 != null)
          search += "=" + value3;
      }
    });
  }
  return search;
}
function normalizeQuery(query2) {
  const normalizedQuery = {};
  for (const key2 in query2) {
    const value2 = query2[key2];
    if (value2 !== void 0) {
      normalizedQuery[key2] = Array.isArray(value2) ? value2.map((v2) => v2 == null ? null : "" + v2) : value2 == null ? value2 : "" + value2;
    }
  }
  return normalizedQuery;
}
function useCallbacks() {
  let handlers2 = [];
  function add8(handler) {
    handlers2.push(handler);
    return () => {
      const i2 = handlers2.indexOf(handler);
      if (i2 > -1)
        handlers2.splice(i2, 1);
    };
  }
  function reset2() {
    handlers2 = [];
  }
  return {
    add: add8,
    list: () => handlers2,
    reset: reset2
  };
}
function guardToPromiseFn(guard, to, from2, record, name2) {
  const enterCallbackArray = record && (record.enterCallbacks[name2] = record.enterCallbacks[name2] || []);
  return () => new Promise((resolve2, reject) => {
    const next3 = (valid) => {
      if (valid === false)
        reject(createRouterError(4, {
          from: from2,
          to
        }));
      else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && record.enterCallbacks[name2] === enterCallbackArray && typeof valid === "function")
          enterCallbackArray.push(valid);
        resolve2();
      }
    };
    const guardReturn = guard.call(record && record.instances[name2], to, from2, next3);
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next3);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to, from2) {
  const guards = [];
  for (const record of matched) {
    for (const name2 in record.components) {
      let rawComponent = record.components[name2];
      if (guardType !== "beforeRouteEnter" && !record.instances[name2])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from2, record, name2));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name2}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name2] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from2, record, name2)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink(props) {
  const router = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => router.resolve(unref(props.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index2 = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index2 > -1)
      return index2;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index2;
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e2 = {}) {
    if (guardEvent(e2)) {
      return router[unref(props.replace) ? "replace" : "push"](unref(props.to)).catch(noop$8);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props.custom ? children : h$4("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e2) {
  if (e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey)
    return;
  if (e2.defaultPrevented)
    return;
  if (e2.button !== void 0 && e2.button !== 0)
    return;
  if (e2.currentTarget && e2.currentTarget.getAttribute) {
    const target = e2.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e2.preventDefault)
    e2.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key2 in inner) {
    const innerValue = inner[key2];
    const outerValue = outer[key2];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value2, i2) => value2 !== outerValue[i2]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  setup(props, { attrs, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const depth = inject(viewDepthKey, 0);
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);
    provide(viewDepthKey, depth + 1);
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name2], [oldInstance, from2, oldName]) => {
      if (to) {
        to.instances[name2] = instance;
        if (from2 && from2 !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from2.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from2.updateGuards;
          }
        }
      }
      if (instance && to && (!from2 || !isSameRouteRecord(to, from2) || !oldInstance)) {
        (to.enterCallbacks[name2] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[props.name];
      const currentName = props.name;
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[props.name];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h$4(ViewComponent, assign({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return normalizeSlot(slots.default, { Component: component, route }) || component;
    };
  }
});
function normalizeSlot(slot, data) {
  if (!slot)
    return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser$2 && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = applyToParams.bind(null, decode$6);
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name2) {
    const recordMatcher = matcher.getRecordMatcher(name2);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name2) {
    return !!matcher.getRecordMatcher(name2);
  }
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode$6(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      matcherLocation = assign({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign({}, rawLocation.params);
      for (const key2 in targetParams) {
        if (targetParams[key2] == null) {
          delete targetParams[key2];
        }
      }
      matcherLocation = assign({}, rawLocation, {
        params: encodeParams(rawLocation.params)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash3 = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
      hash: encodeHash(hash3),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign({
      fullPath,
      hash: hash3,
      query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
  }
  function checkCanceledNavigation(to, from2) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from: from2,
        to
      });
    }
  }
  function push(to) {
    return pushWithRedirect(to);
  }
  function replace(to) {
    return push(assign(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
        newTargetLocation.params = {};
      }
      return assign({
        query: to.query,
        hash: to.hash,
        params: to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to);
    const from2 = currentRoute.value;
    const data = to.state;
    const force = to.force;
    const replace2 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
        state: data,
        force,
        replace: replace2
      }), redirectedFrom || targetLocation);
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from2, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from: from2 });
      handleScroll(from2, from2, true, false);
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from2)).catch((error2) => isNavigationFailure(error2) ? error2 : triggerError(error2, toLocation, from2)).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(failure2, 2)) {
          return pushWithRedirect(assign(locationAsObject(failure2.to), {
            state: data,
            force,
            replace: replace2
          }), redirectedFrom || toLocation);
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from2, true, replace2, data);
      }
      triggerAfterEach(toLocation, from2, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from2) {
    const error2 = checkCanceledNavigation(to, from2);
    return error2 ? Promise.reject(error2) : Promise.resolve();
  }
  function navigate(to, from2) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from2);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from2);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from2));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from2);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from2));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from2);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from2));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of to.matched) {
        if (record.beforeEnter && !from2.matched.includes(record)) {
          if (Array.isArray(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from2));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from2));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from2);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from2));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from2, failure) {
    for (const guard of afterGuards.list())
      guard(to, from2, failure);
  }
  function finalizeNavigation(toLocation, from2, isPush, replace2, data) {
    const error2 = checkCanceledNavigation(toLocation, from2);
    if (error2)
      return error2;
    const isFirstNavigation = from2 === START_LOCATION_NORMALIZED;
    const state2 = !isBrowser$2 ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign({
          scroll: isFirstNavigation && state2 && state2.scroll
        }, data));
      else
        routerHistory.push(toLocation.fullPath, data);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from2, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      const toLocation = resolve2(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop$8);
        return;
      }
      pendingLocation = toLocation;
      const from2 = currentRoute.value;
      if (isBrowser$2) {
        saveScrollPosition(getScrollKey(from2.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from2).catch((error2) => {
        if (isNavigationFailure(error2, 4 | 8)) {
          return error2;
        }
        if (isNavigationFailure(error2, 2)) {
          pushWithRedirect(error2.to, toLocation).then((failure) => {
            if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop$8);
          return Promise.reject();
        }
        if (info.delta)
          routerHistory.go(-info.delta, false);
        return triggerError(error2, toLocation, from2);
      }).then((failure) => {
        failure = failure || finalizeNavigation(toLocation, from2, false);
        if (failure) {
          if (info.delta) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from2, failure);
      }).catch(noop$8);
    });
  }
  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  function triggerError(error2, to, from2) {
    markAsReady(error2);
    const list = errorHandlers.list();
    if (list.length) {
      list.forEach((handler) => handler(error2, to, from2));
    } else {
      console.error(error2);
    }
    return Promise.reject(error2);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve3, reject) => {
      readyHandlers.add([resolve3, reject]);
    });
  }
  function markAsReady(err) {
    if (ready)
      return;
    ready = true;
    setupListeners();
    readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
    readyHandlers.reset();
  }
  function handleScroll(to, from2, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser$2 || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from2, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from2));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = new Set();
  const router = {
    currentRoute,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options,
    push,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,
    install(app) {
      const router2 = this;
      app.component("RouterLink", RouterLink);
      app.component("RouterView", RouterView);
      app.config.globalProperties.$router = router2;
      Object.defineProperty(app.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser$2 && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key2 in START_LOCATION_NORMALIZED) {
        reactiveRoute[key2] = computed(() => currentRoute.value[key2]);
      }
      app.provide(routerKey, router2);
      app.provide(routeLocationKey, reactive(reactiveRoute));
      app.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app.unmount;
      installedApps.add(app);
      app.unmount = function() {
        installedApps.delete(app);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  return router;
}
function runGuardQueue(guards) {
  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
}
function extractChangingRecords(to, from2) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len2 = Math.max(from2.matched.length, to.matched.length);
  for (let i2 = 0; i2 < len2; i2++) {
    const recordFrom = from2.matched[i2];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i2];
    if (recordTo) {
      if (!from2.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
function useRouter() {
  return inject(routerKey);
}
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
const isClient = typeof window !== "undefined";
const isString = (val) => typeof val === "string";
const noop$7 = () => {
};
function createFilterWrapper(filter2, fn) {
  function wrapper(...args) {
    filter2(() => fn.apply(this, args), { fn, thisArg: this, args });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$9.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$9.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchWithFilter(source, cb, options = {}) {
  const _a2 = options, {
    eventFilter = bypassFilter
  } = _a2, watchOptions = __objRest$5(_a2, [
    "eventFilter"
  ]);
  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
function tryOnMounted(fn, sync = true) {
  if (getCurrentInstance())
    onMounted(fn);
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function useCounter(initialValue = 0, options = {}) {
  const count2 = ref(initialValue);
  const {
    max: max2 = Infinity,
    min: min2 = -Infinity
  } = options;
  const inc = (delta = 1) => count2.value = Math.min(max2, count2.value + delta);
  const dec = (delta = 1) => count2.value = Math.max(min2, count2.value - delta);
  const get15 = () => count2.value;
  const set6 = (val) => count2.value = val;
  const reset2 = (val = initialValue) => {
    initialValue = val;
    return set6(val);
  };
  return { count: count2, inc, dec, get: get15, set: set6, reset: reset2 };
}
function useToggle(initialValue = false) {
  if (isRef(initialValue)) {
    return (value2) => {
      initialValue.value = typeof value2 === "boolean" ? value2 : !initialValue.value;
    };
  } else {
    const boolean = ref(initialValue);
    const toggle = (value2) => {
      boolean.value = typeof value2 === "boolean" ? value2 : !boolean.value;
    };
    return [boolean, toggle];
  }
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options;
  if (isString(args[0])) {
    [event, listener, options] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options] = args;
  }
  if (!target)
    return noop$7;
  let cleanup = noop$7;
  const stopWatch = watch(() => unref(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options);
    cleanup = () => {
      el.removeEventListener(event, listener, options);
      cleanup = noop$7;
    };
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function useMediaQuery(query2, options = {}) {
  const { window: window2 = defaultWindow } = options;
  let mediaQuery;
  const matches = ref(false);
  const update6 = () => {
    if (!window2)
      return;
    if (!mediaQuery)
      mediaQuery = window2.matchMedia(query2);
    matches.value = mediaQuery.matches;
  };
  tryOnMounted(() => {
    update6();
    if (!mediaQuery)
      return;
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", update6);
    else
      mediaQuery.addListener(update6);
    tryOnScopeDispose(() => {
      if ("removeEventListener" in update6)
        mediaQuery.removeEventListener("change", update6);
      else
        mediaQuery.removeListener(update6);
    });
  });
  return matches;
}
const globalKey = "__vueuse_ssr_handlers__";
globalThis[globalKey] = globalThis[globalKey] || {};
const handlers = globalThis[globalKey];
function getSSRHandler(key2, fallback2) {
  return handlers[key2] || fallback2;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v2) => v2 === "true",
    write: (v2) => String(v2)
  },
  object: {
    read: (v2) => JSON.parse(v2),
    write: (v2) => JSON.stringify(v2)
  },
  number: {
    read: (v2) => Number.parseFloat(v2),
    write: (v2) => String(v2)
  },
  any: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  string: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  map: {
    read: (v2) => new Map(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  },
  set: {
    read: (v2) => new Set(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  }
};
function useStorage(key2, initialValue, storage = getSSRHandler("getDefaultStorage", () => {
  var _a2;
  return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
})(), options = {}) {
  var _a2;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e2) => {
      console.error(e2);
    }
  } = options;
  const rawInit = unref(initialValue);
  const type = guessSerializerType(rawInit);
  const data = (shallow ? shallowRef : ref)(initialValue);
  const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type];
  function read(event) {
    if (!storage || event && event.key !== key2)
      return;
    try {
      const rawValue = event ? event.newValue : storage.getItem(key2);
      if (rawValue == null) {
        data.value = rawInit;
        if (writeDefaults && rawInit !== null)
          storage.setItem(key2, serializer.write(rawInit));
      } else if (typeof rawValue !== "string") {
        data.value = rawValue;
      } else {
        data.value = serializer.read(rawValue);
      }
    } catch (e2) {
      onError(e2);
    }
  }
  read();
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", (e2) => setTimeout(() => read(e2), 0));
  if (storage) {
    watchWithFilter(data, () => {
      try {
        if (data.value == null)
          storage.removeItem(key2);
        else
          storage.setItem(key2, serializer.write(data.value));
      } catch (e2) {
        onError(e2);
      }
    }, {
      flush,
      deep,
      eventFilter
    });
  }
  return data;
}
function usePreferredDark(options) {
  return useMediaQuery("(prefers-color-scheme: dark)", options);
}
var __defProp$e = Object.defineProperty;
var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
var __hasOwnProp$g = Object.prototype.hasOwnProperty;
var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
var __defNormalProp$e = (obj, key2, value2) => key2 in obj ? __defProp$e(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __spreadValues$e = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$g.call(b2, prop))
      __defNormalProp$e(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$g)
    for (var prop of __getOwnPropSymbols$g(b2)) {
      if (__propIsEnum$g.call(b2, prop))
        __defNormalProp$e(a2, prop, b2[prop]);
    }
  return a2;
};
function useColorMode(options = {}) {
  const {
    selector = "html",
    attribute = "class",
    window: window2 = defaultWindow,
    storage = getSSRHandler("getDefaultStorage", () => {
      var _a2;
      return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;
    })(),
    storageKey = "vueuse-color-scheme",
    listenToStorageChanges = true,
    storageRef
  } = options;
  const modes = __spreadValues$e({
    auto: "",
    light: "light",
    dark: "dark"
  }, options.modes || {});
  const preferredDark = usePreferredDark({ window: window2 });
  const preferredMode = computed(() => preferredDark.value ? "dark" : "light");
  const store = storageRef || (storageKey == null ? ref("auto") : useStorage(storageKey, "auto", storage, { window: window2, listenToStorageChanges }));
  const state2 = computed({
    get() {
      return store.value === "auto" ? preferredMode.value : store.value;
    },
    set(v2) {
      store.value = v2;
    }
  });
  const updateHTMLAttrs = getSSRHandler("updateHTMLAttrs", (selector2, attribute2, value2) => {
    const el = window2 == null ? void 0 : window2.document.querySelector(selector2);
    if (!el)
      return;
    if (attribute2 === "class") {
      const current = value2.split(/\s/g);
      Object.values(modes).flatMap((i2) => (i2 || "").split(/\s/g)).filter(Boolean).forEach((v2) => {
        if (current.includes(v2))
          el.classList.add(v2);
        else
          el.classList.remove(v2);
      });
    } else {
      el.setAttribute(attribute2, value2);
    }
  });
  function defaultOnChanged(mode2) {
    var _a2;
    updateHTMLAttrs(selector, attribute, (_a2 = modes[mode2]) != null ? _a2 : mode2);
  }
  function onChanged(mode2) {
    if (options.onChanged)
      options.onChanged(mode2, defaultOnChanged);
    else
      defaultOnChanged(mode2);
  }
  watch(state2, onChanged, { flush: "post", immediate: true });
  tryOnMounted(() => onChanged(state2.value));
  return state2;
}
var __defProp$d = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
var __defNormalProp$d = (obj, key2, value2) => key2 in obj ? __defProp$d(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __spreadValues$d = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$f.call(b2, prop))
      __defNormalProp$d(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(b2)) {
      if (__propIsEnum$f.call(b2, prop))
        __defNormalProp$d(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$7 = (a2, b2) => __defProps$7(a2, __getOwnPropDescs$7(b2));
function useDark(options = {}) {
  const {
    valueDark = "dark",
    valueLight = "",
    window: window2 = defaultWindow
  } = options;
  const mode2 = useColorMode(__spreadProps$7(__spreadValues$d({}, options), {
    onChanged: (mode22, defaultHandler) => {
      var _a2;
      if (options.onChanged)
        (_a2 = options.onChanged) == null ? void 0 : _a2.call(options, mode22 === "dark");
      else
        defaultHandler(mode22);
    },
    modes: {
      dark: valueDark,
      light: valueLight
    }
  }));
  const preferredDark = usePreferredDark({ window: window2 });
  const isDark = computed({
    get() {
      return mode2.value === "dark";
    },
    set(v2) {
      if (v2 === preferredDark.value)
        mode2.value = "auto";
      else
        mode2.value = v2 ? "dark" : "light";
    }
  });
  return isDark;
}
function useMouse(options = {}) {
  const {
    type = "page",
    touch = true,
    resetOnTouchEnds = false,
    initialValue = { x: 0, y: 0 },
    window: window2 = defaultWindow
  } = options;
  const x2 = ref(initialValue.x);
  const y2 = ref(initialValue.y);
  const sourceType = ref(null);
  const mouseHandler = (event) => {
    if (type === "page") {
      x2.value = event.pageX;
      y2.value = event.pageY;
    } else if (type === "client") {
      x2.value = event.clientX;
      y2.value = event.clientY;
    }
    sourceType.value = "mouse";
  };
  const reset2 = () => {
    x2.value = initialValue.x;
    y2.value = initialValue.y;
  };
  const touchHandler = (event) => {
    if (event.touches.length > 0) {
      const touch2 = event.touches[0];
      if (type === "page") {
        x2.value = touch2.pageX;
        y2.value = touch2.pageY;
      } else if (type === "client") {
        x2.value = touch2.clientX;
        y2.value = touch2.clientY;
      }
      sourceType.value = "touch";
    }
  };
  if (window2) {
    useEventListener(window2, "mousemove", mouseHandler, { passive: true });
    useEventListener(window2, "dragover", mouseHandler, { passive: true });
    if (touch) {
      useEventListener(window2, "touchstart", touchHandler, { passive: true });
      useEventListener(window2, "touchmove", touchHandler, { passive: true });
      if (resetOnTouchEnds)
        useEventListener(window2, "touchend", reset2, { passive: true });
    }
  }
  return {
    x: x2,
    y: y2,
    sourceType
  };
}
var _a, _b;
isClient && (window == null ? void 0 : window.navigator) && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.platform) && /iP(ad|hone|od)/.test((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.platform);
var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key2, value2) => key2 in obj ? __defProp$3(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __spreadValues$3 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$3.call(b2, prop))
      __defNormalProp$3(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b2)) {
      if (__propIsEnum$3.call(b2, prop))
        __defNormalProp$3(a2, prop, b2[prop]);
    }
  return a2;
};
const initialRect = {
  top: 0,
  left: 0,
  bottom: 0,
  right: 0,
  height: 0,
  width: 0
};
__spreadValues$3({
  text: ""
}, initialRect);
var bn$2 = { exports: {} };
(function(module2) {
  (function(module3, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base2, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number2 || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module3 === "object") {
      module3.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require("buffer").Buffer;
      }
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max2(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min2(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init5(number2, base2, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base2, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base2 === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base2, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base2, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base2, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j2, w2;
      var off = 0;
      if (endian === "be") {
        for (i2 = number2.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
          w2 = number2[i2] | number2[i2 - 1] << 8 | number2[i2 - 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i2 = 0, j2 = 0; i2 < number2.length; i2 += 3) {
          w2 = number2[i2] | number2[i2 + 1] << 8 | number2[i2 + 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      }
      return this.strip();
    };
    function parseHex4Bits(string2, index2) {
      var c2 = string2.charCodeAt(index2);
      if (c2 >= 65 && c2 <= 70) {
        return c2 - 55;
      } else if (c2 >= 97 && c2 <= 102) {
        return c2 - 87;
      } else {
        return c2 - 48 & 15;
      }
    }
    function parseHexByte(string2, lowerBound, index2) {
      var r2 = parseHex4Bits(string2, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var off = 0;
      var j2 = 0;
      var w2;
      if (endian === "be") {
        for (i2 = number2.length - 1; i2 >= start; i2 -= 2) {
          w2 = parseHexByte(number2, start, i2) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number2.length; i2 += 2) {
          w2 = parseHexByte(number2, start, i2) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this.strip();
    };
    function parseBase(str2, start, end, mul8) {
      var r2 = 0;
      var len2 = Math.min(str2.length, end);
      for (var i2 = start; i2 < len2; i2++) {
        var c2 = str2.charCodeAt(i2) - 48;
        r2 *= mul8;
        if (c2 >= 49) {
          r2 += c2 - 49 + 10;
        } else if (c2 >= 17) {
          r2 += c2 - 17 + 10;
        } else {
          r2 += c2;
        }
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number2.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word2 = 0;
      for (var i2 = start; i2 < end; i2 += limbLen) {
        word2 = parseBase(number2, i2, i2 + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word2 < 67108864) {
          this.words[0] += word2;
        } else {
          this._iaddn(word2);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word2 = parseBase(number2, i2, number2.length, base2);
        for (i2 = 0; i2 < mod; i2++) {
          pow *= base2;
        }
        this.imuln(pow);
        if (this.words[0] + word2 < 67108864) {
          this.words[0] += word2;
        } else {
          this._iaddn(word2);
        }
      }
      this.strip();
    };
    BN2.prototype.copy = function copy3(dest) {
      dest.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        dest.words[i2] = this.words[i2];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN2.prototype.clone = function clone() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size2) {
      while (this.length < size2) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN2.prototype.inspect = function inspect10() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base2, padding2) {
      base2 = base2 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = this.words[i2];
          var word2 = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          if (carry !== 0 || i2 !== this.length - 1) {
            out = zeros2[6 - word2.length] + word2 + out;
          } else {
            out = word2 + out;
          }
          off += 2;
          if (off >= 26) {
            off -= 26;
            i2--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modn(groupBase).toString(base2);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber2() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON3() {
      return this.toString(16);
    };
    BN2.prototype.toBuffer = function toBuffer2(endian, length) {
      assert2(typeof Buffer2 !== "undefined");
      return this.toArrayLike(Buffer2, endian, length);
    };
    BN2.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength2 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b2, i2;
      var q2 = this.clone();
      if (!littleEndian) {
        for (i2 = 0; i2 < reqLength - byteLength2; i2++) {
          res[i2] = 0;
        }
        for (i2 = 0; !q2.isZero(); i2++) {
          b2 = q2.andln(255);
          q2.iushrn(8);
          res[reqLength - i2 - 1] = b2;
        }
      } else {
        for (i2 = 0; !q2.isZero(); i2++) {
          b2 = q2.andln(255);
          q2.iushrn(8);
          res[i2] = b2;
        }
        for (; i2 < reqLength; i2++) {
          res[i2] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi = this._countBits(w2);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var b2 = this._zeroBits(this.words[i2]);
        r2 += b2;
        if (b2 !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg6() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i2 = 0; i2 < num.length; i2++) {
        this.words[i2] = this.words[i2] | num.words[i2];
      }
      return this.strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = this.words[i2] & num.words[i2];
      }
      this.length = b2.length;
      return this.strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = a2.words[i2] ^ b2.words[i2];
      }
      if (this !== a2) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = a2.length;
      return this.strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i2 = 0; i2 < bytesNeeded; i2++) {
        this.words[i2] = ~this.words[i2] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
      }
      return this.strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      return this;
    };
    BN2.prototype.add = function add8(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b2;
      if (cmp > 0) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      if (carry === 0 && i2 < a2.length && a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = Math.max(this.length, i2);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len2 = self2.length + num.length | 0;
      out.length = len2;
      len2 = len2 - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r2 = a2 * b2;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k2 = 1; k2 < len2; k2++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k2 - j2 | 0;
          a2 = self2.words[i2] | 0;
          b2 = num.words[j2] | 0;
          r2 = a2 * b2 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k2] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k2] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b2 = num.words;
      var o2 = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o2[0] = w0;
      o2[1] = w1;
      o2[2] = w2;
      o2[3] = w3;
      o2[4] = w4;
      o2[5] = w5;
      o2[6] = w6;
      o2[7] = w7;
      o2[8] = w8;
      o2[9] = w9;
      o2[10] = w10;
      o2[11] = w11;
      o2[12] = w12;
      o2[13] = w13;
      o2[14] = w14;
      o2[15] = w15;
      o2[16] = w16;
      o2[17] = w17;
      o2[18] = w18;
      if (c2 !== 0) {
        o2[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k2 = 0; k2 < out.length - 1; k2++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k2 - j2;
          var a2 = self2.words[i2] | 0;
          var b2 = num.words[j2] | 0;
          var r2 = a2 * b2;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k2] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k2] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo(self2, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len2 = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len2 < 63) {
        res = smallMulTo(this, num, out);
      } else if (len2 < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x2, y2) {
      this.x = x2;
      this.y = y2;
    }
    FFTM.prototype.makeRBT = function makeRBT(N2) {
      var t2 = new Array(N2);
      var l2 = BN2.prototype._countBits(N2) - 1;
      for (var i2 = 0; i2 < N2; i2++) {
        t2[i2] = this.revBin(i2, l2, N2);
      }
      return t2;
    };
    FFTM.prototype.revBin = function revBin(x2, l2, N2) {
      if (x2 === 0 || x2 === N2 - 1)
        return x2;
      var rb = 0;
      for (var i2 = 0; i2 < l2; i2++) {
        rb |= (x2 & 1) << l2 - i2 - 1;
        x2 >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
      for (var i2 = 0; i2 < N2; i2++) {
        rtws[i2] = rws[rbt[i2]];
        itws[i2] = iws[rbt[i2]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N2);
      for (var s2 = 1; s2 < N2; s2 <<= 1) {
        var l2 = s2 << 1;
        var rtwdf = Math.cos(2 * Math.PI / l2);
        var itwdf = Math.sin(2 * Math.PI / l2);
        for (var p2 = 0; p2 < N2; p2 += l2) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j2 = 0; j2 < s2; j2++) {
            var re = rtws[p2 + j2];
            var ie = itws[p2 + j2];
            var ro = rtws[p2 + j2 + s2];
            var io = itws[p2 + j2 + s2];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p2 + j2] = re + ro;
            itws[p2 + j2] = ie + io;
            rtws[p2 + j2 + s2] = re - ro;
            itws[p2 + j2 + s2] = ie - io;
            if (j2 !== l2) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n2, m2) {
      var N2 = Math.max(m2, n2) | 1;
      var odd = N2 & 1;
      var i2 = 0;
      for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
        i2++;
      }
      return 1 << i2 + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
      if (N2 <= 1)
        return;
      for (var i2 = 0; i2 < N2 / 2; i2++) {
        var t2 = rws[i2];
        rws[i2] = rws[N2 - i2 - 1];
        rws[N2 - i2 - 1] = t2;
        t2 = iws[i2];
        iws[i2] = -iws[N2 - i2 - 1];
        iws[N2 - i2 - 1] = -t2;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
      var carry = 0;
      for (var i2 = 0; i2 < N2 / 2; i2++) {
        var w2 = Math.round(ws[2 * i2 + 1] / N2) * 8192 + Math.round(ws[2 * i2] / N2) + carry;
        ws[i2] = w2 & 67108863;
        if (w2 < 67108864) {
          carry = 0;
        } else {
          carry = w2 / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N2) {
      var carry = 0;
      for (var i2 = 0; i2 < len2; i2++) {
        carry = carry + (ws[i2] | 0);
        rws[2 * i2] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i2 + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i2 = 2 * len2; i2 < N2; ++i2) {
        rws[i2] = 0;
      }
      assert2(carry === 0);
      assert2((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N2) {
      var ph = new Array(N2);
      for (var i2 = 0; i2 < N2; i2++) {
        ph[i2] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x2, y2, out) {
      var N2 = 2 * this.guessLen13b(x2.length, y2.length);
      var rbt = this.makeRBT(N2);
      var _2 = this.stub(N2);
      var rws = new Array(N2);
      var rwst = new Array(N2);
      var iwst = new Array(N2);
      var nrws = new Array(N2);
      var nrwst = new Array(N2);
      var niwst = new Array(N2);
      var rmws = out.words;
      rmws.length = N2;
      this.convert13b(x2.words, x2.length, rws, N2);
      this.convert13b(y2.words, y2.length, nrws, N2);
      this.transform(rws, _2, rwst, iwst, N2, rbt);
      this.transform(nrws, _2, nrwst, niwst, N2, rbt);
      for (var i2 = 0; i2 < N2; i2++) {
        var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
        iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
        rwst[i2] = rx;
      }
      this.conjugate(rwst, iwst, N2);
      this.transform(rwst, iwst, rmws, _2, N2, rbt);
      this.conjugate(rmws, _2, N2);
      this.normalize13b(rmws, N2);
      out.negative = x2.negative ^ y2.negative;
      out.length = x2.length + y2.length;
      return out.strip();
    };
    BN2.prototype.mul = function mul8(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var w2 = (this.words[i2] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i2] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
        if (w2[i2] !== 0)
          break;
      }
      if (++i2 < w2.length) {
        for (var q2 = res.sqr(); i2 < w2.length; i2++, q2 = q2.sqr()) {
          if (w2[i2] === 0)
            continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i2;
      if (r2 !== 0) {
        var carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          var newCarry = this.words[i2] & carryMask;
          var c2 = (this.words[i2] | 0) - newCarry << r2;
          this.words[i2] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i2] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i2 = this.length - 1; i2 >= 0; i2--) {
          this.words[i2 + s2] = this.words[i2];
        }
        for (i2 = 0; i2 < s2; i2++) {
          this.words[i2] = 0;
        }
        this.length += s2;
      }
      return this.strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i2 = 0; i2 < s2; i2++) {
          maskedWords.words[i2] = this.words[i2];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = this.words[i2 + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
        var word2 = this.words[i2] | 0;
        this.words[i2] = carry << 26 - r2 | word2 >>> r2;
        carry = word2 & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2)
        return false;
      var w2 = this.words[s2];
      return !!(w2 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this.strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
        this.words[i2] -= 67108864;
        if (i2 === this.length - 1) {
          this.words[i2 + 1] = 1;
        } else {
          this.words[i2 + 1]++;
        }
      }
      this.length = Math.max(this.length, i2 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
          this.words[i2] += 67108864;
          this.words[i2 + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul8, shift) {
      var len2 = num.length + shift;
      var i2;
      this._expand(len2);
      var w2;
      var carry = 0;
      for (i2 = 0; i2 < num.length; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        var right = (num.words[i2] | 0) * mul8;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i2 + shift] = w2 & 67108863;
      }
      for (; i2 < this.length - shift; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2 + shift] = w2 & 67108863;
      }
      if (carry === 0)
        return this.strip();
      assert2(carry === -1);
      carry = 0;
      for (i2 = 0; i2 < this.length; i2++) {
        w2 = -(this.words[i2] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2] = w2 & 67108863;
      }
      this.negative = 1;
      return this.strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
      var shift = this.length - num.length;
      var a2 = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a2.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m2 = a2.length - b2.length;
      var q2;
      if (mode2 !== "mod") {
        q2 = new BN2(null);
        q2.length = m2 + 1;
        q2.words = new Array(q2.length);
        for (var i2 = 0; i2 < q2.length; i2++) {
          q2.words[i2] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
      if (diff.negative === 0) {
        a2 = diff;
        if (q2) {
          q2.words[m2] = 1;
        }
      }
      for (var j2 = m2 - 1; j2 >= 0; j2--) {
        var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a2._ishlnsubmul(b2, qj, j2);
        while (a2.negative !== 0) {
          qj--;
          a2.negative = 0;
          a2._ishlnsubmul(b2, 1, j2);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j2] = qj;
        }
      }
      if (q2) {
        q2.strip();
      }
      a2.strip();
      if (mode2 !== "div" && shift !== 0) {
        a2.iushrn(shift);
      }
      return {
        div: q2 || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode2, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode2);
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode2 === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode2 === "mod") {
          return {
            div: null,
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode2);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modn = function modn(num) {
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        acc = (p2 * acc + (this.words[i2] | 0)) % num;
      }
      return acc;
    };
    BN2.prototype.idivn = function idivn(num) {
      assert2(num <= 67108863);
      var carry = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var w2 = (this.words[i2] | 0) + carry * 67108864;
        this.words[i2] = w2 / num | 0;
        carry = w2 % num;
      }
      return this.strip();
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y2 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B2 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g2 = 0;
      while (x2.isEven() && y2.isEven()) {
        x2.iushrn(1);
        y2.iushrn(1);
        ++g2;
      }
      var yp = y2.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          x2.iushrn(i2);
          while (i2-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          y2.iushrn(j2);
          while (j2-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x2.cmp(y2) >= 0) {
          x2.isub(y2);
          A2.isub(C2);
          B2.isub(D2);
        } else {
          y2.isub(x2);
          C2.isub(A2);
          D2.isub(B2);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y2.iushln(g2)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b2 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          a2.iushrn(i2);
          while (i2-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          b2.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b2) >= 0) {
          a2.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a2 = this.clone();
      var b2 = num.clone();
      a2.negative = 0;
      b2.negative = 0;
      for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
        a2.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r2 = a2.cmp(b2);
        if (r2 < 0) {
          var t2 = a2;
          a2 = b2;
          b2 = t2;
        } else if (r2 === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a2.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q2;
        return this;
      }
      var carry = q2;
      for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
        var w2 = this.words[i2] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i2] = w2;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var a2 = this.words[i2] | 0;
        var b2 = num.words[i2] | 0;
        if (a2 === b2)
          continue;
        if (a2 < b2) {
          res = -1;
        } else if (a2 > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq9(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p2) {
      this.name = name2;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i2 = 0; i2 < outLen; i2++) {
        output.words[i2] = input.words[i2];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i2 = 10; i2 < input.length; i2++) {
        var next3 = input.words[i2] | 0;
        input.words[i2 - 10] = (next3 & mask) << 4 | prev >>> 22;
        prev = next3;
      }
      prev >>>= 22;
      input.words[i2 - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var w2 = num.words[i2] | 0;
        lo += w2 * 977;
        num.words[i2] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var hi = (num.words[i2] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i2] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b2) {
      assert2((a2.negative | b2.negative) === 0, "red works only with positives");
      assert2(a2.red && a2.red === b2.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime)
        return this.prime.ireduce(a2)._forceRed(this);
      return a2.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg6(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add8(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.imul(b2));
    };
    Red.prototype.mul = function mul8(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.mul(b2));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero())
        return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow);
      }
      var q2 = this.m.subn(1);
      var s2 = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s2++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c2 = this.pow(z2, q2);
      var r2 = this.pow(a2, q2.addn(1).iushrn(1));
      var t2 = this.pow(a2, q2);
      var m2 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
          tmp = tmp.redSqr();
        }
        assert2(i2 < m2);
        var b2 = this.pow(c2, new BN2(1).iushln(m2 - i2 - 1));
        r2 = r2.redMul(b2);
        c2 = b2.redSqr();
        t2 = t2.redMul(c2);
        m2 = i2;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a2, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i2 = 2; i2 < wnd.length; i2++) {
        wnd[i2] = this.mul(wnd[i2 - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i2 = num.length - 1; i2 >= 0; i2--) {
        var word2 = num.words[i2];
        for (var j2 = start - 1; j2 >= 0; j2--) {
          var bit = word2 >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b2) {
      if (a2.isZero() || b2.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t2 = a2.imul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul8(a2, b2) {
      if (a2.isZero() || b2.isZero())
        return new BN2(0)._forceRed(this);
      var t2 = a2.mul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module2, commonjsGlobal);
})(bn$2);
var BN$i = bn$2.exports;
const version$r = "logger/5.5.0";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
  try {
    const missing = [];
    ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error2) {
        missing.push(form);
      }
    });
    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
      throw new Error("broken implementation");
    }
  } catch (error2) {
    return error2.message;
  }
  return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel2) {
  LogLevel2["DEBUG"] = "DEBUG";
  LogLevel2["INFO"] = "INFO";
  LogLevel2["WARNING"] = "WARNING";
  LogLevel2["ERROR"] = "ERROR";
  LogLevel2["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
  ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ErrorCode2["TIMEOUT"] = "TIMEOUT";
  ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
  ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
  constructor(version2) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version2,
      writable: false
    });
  }
  _log(logLevel, args) {
    const level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  }
  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }
  info(...args) {
    this._log(Logger.levels.INFO, args);
  }
  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }
  makeError(message, code2, params) {
    if (_censorErrors) {
      return this.makeError("censored error", code2, {});
    }
    if (!code2) {
      code2 = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    const messageDetails = [];
    Object.keys(params).forEach((key2) => {
      const value2 = params[key2];
      try {
        if (value2 instanceof Uint8Array) {
          let hex = "";
          for (let i2 = 0; i2 < value2.length; i2++) {
            hex += HEX[value2[i2] >> 4];
            hex += HEX[value2[i2] & 15];
          }
          messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key2 + "=" + JSON.stringify(value2));
        }
      } catch (error3) {
        messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
      }
    });
    messageDetails.push(`code=${code2}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    const error2 = new Error(message);
    error2.reason = reason;
    error2.code = code2;
    Object.keys(params).forEach(function(key2) {
      error2[key2] = params[key2];
    });
    return error2;
  }
  throwError(message, code2, params) {
    throw this.makeError(message, code2, params);
  }
  throwArgumentError(message, name2, value2) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name2,
      value: value2
    });
  }
  assert(condition, message, code2, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code2, params);
  }
  assertArgument(condition, message, name2, value2) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name2, value2);
  }
  checkNormalize(message) {
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }
  checkSafeUint53(value2, message) {
    if (typeof value2 !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value2 < 0 || value2 >= 9007199254740991) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value: value2
      });
    }
    if (value2 % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value: value2
      });
    }
  }
  checkArgumentCount(count2, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count2 < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
    if (count2 > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count: count2,
        expectedCount
      });
    }
  }
  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
    }
  }
  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(version$r);
    }
    return _globalLogger;
  }
  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }
  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  }
  static from(version2) {
    return new Logger(version2);
  }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
var lib_esm$k = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get LogLevel() {
    return LogLevel;
  },
  get ErrorCode() {
    return ErrorCode;
  },
  Logger
});
const version$q = "bytes/5.5.0";
const logger$x = new Logger(version$q);
function isHexable(value2) {
  return !!value2.toHexString;
}
function addSlice(array2) {
  if (array2.slice) {
    return array2;
  }
  array2.slice = function() {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array2, args)));
  };
  return array2;
}
function isBytesLike(value2) {
  return isHexString$5(value2) && !(value2.length % 2) || isBytes(value2);
}
function isInteger(value2) {
  return typeof value2 === "number" && value2 == value2 && value2 % 1 === 0;
}
function isBytes(value2) {
  if (value2 == null) {
    return false;
  }
  if (value2.constructor === Uint8Array) {
    return true;
  }
  if (typeof value2 === "string") {
    return false;
  }
  if (!isInteger(value2.length) || value2.length < 0) {
    return false;
  }
  for (let i2 = 0; i2 < value2.length; i2++) {
    const v2 = value2[i2];
    if (!isInteger(v2) || v2 < 0 || v2 >= 256) {
      return false;
    }
  }
  return true;
}
function arrayify(value2, options) {
  if (!options) {
    options = {};
  }
  if (typeof value2 === "number") {
    logger$x.checkSafeUint53(value2, "invalid arrayify value");
    const result = [];
    while (value2) {
      result.unshift(value2 & 255);
      value2 = parseInt(String(value2 / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value2 === "string" && value2.substring(0, 2) !== "0x") {
    value2 = "0x" + value2;
  }
  if (isHexable(value2)) {
    value2 = value2.toHexString();
  }
  if (isHexString$5(value2)) {
    let hex = value2.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0x0" + hex.substring(2);
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger$x.throwArgumentError("hex data is odd-length", "value", value2);
      }
    }
    const result = [];
    for (let i2 = 0; i2 < hex.length; i2 += 2) {
      result.push(parseInt(hex.substring(i2, i2 + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value2)) {
    return addSlice(new Uint8Array(value2));
  }
  return logger$x.throwArgumentError("invalid arrayify value", "value", value2);
}
function concat$2(items) {
  const objects = items.map((item) => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object2) => {
    result.set(object2, offset);
    return offset + object2.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value2) {
  let result = arrayify(value2);
  if (result.length === 0) {
    return result;
  }
  let start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  if (start) {
    result = result.slice(start);
  }
  return result;
}
function zeroPad(value2, length) {
  value2 = arrayify(value2);
  if (value2.length > length) {
    logger$x.throwArgumentError("value out of range", "value", arguments[0]);
  }
  const result = new Uint8Array(length);
  result.set(value2, length - value2.length);
  return addSlice(result);
}
function isHexString$5(value2, length) {
  if (typeof value2 !== "string" || !value2.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value2.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value2, options) {
  if (!options) {
    options = {};
  }
  if (typeof value2 === "number") {
    logger$x.checkSafeUint53(value2, "invalid hexlify value");
    let hex = "";
    while (value2) {
      hex = HexCharacters[value2 & 15] + hex;
      value2 = Math.floor(value2 / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value2 === "bigint") {
    value2 = value2.toString(16);
    if (value2.length % 2) {
      return "0x0" + value2;
    }
    return "0x" + value2;
  }
  if (options.allowMissingPrefix && typeof value2 === "string" && value2.substring(0, 2) !== "0x") {
    value2 = "0x" + value2;
  }
  if (isHexable(value2)) {
    return value2.toHexString();
  }
  if (isHexString$5(value2)) {
    if (value2.length % 2) {
      if (options.hexPad === "left") {
        value2 = "0x0" + value2.substring(2);
      } else if (options.hexPad === "right") {
        value2 += "0";
      } else {
        logger$x.throwArgumentError("hex data is odd-length", "value", value2);
      }
    }
    return value2.toLowerCase();
  }
  if (isBytes(value2)) {
    let result = "0x";
    for (let i2 = 0; i2 < value2.length; i2++) {
      let v2 = value2[i2];
      result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
    }
    return result;
  }
  return logger$x.throwArgumentError("invalid hexlify value", "value", value2);
}
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString$5(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString$5(data) || data.length % 2) {
    logger$x.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach((item) => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value2) {
  const trimmed = hexStripZeros(hexlify(value2, { hexPad: "left" }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
function hexStripZeros(value2) {
  if (typeof value2 !== "string") {
    value2 = hexlify(value2);
  }
  if (!isHexString$5(value2)) {
    logger$x.throwArgumentError("invalid hex string", "value", value2);
  }
  value2 = value2.substring(2);
  let offset = 0;
  while (offset < value2.length && value2[offset] === "0") {
    offset++;
  }
  return "0x" + value2.substring(offset);
}
function hexZeroPad(value2, length) {
  if (typeof value2 !== "string") {
    value2 = hexlify(value2);
  } else if (!isHexString$5(value2)) {
    logger$x.throwArgumentError("invalid hex string", "value", value2);
  }
  if (value2.length > 2 * length + 2) {
    logger$x.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value2.length < 2 * length + 2) {
    value2 = "0x0" + value2.substring(2);
  }
  return value2;
}
function splitSignature(signature2) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0
  };
  if (isBytesLike(signature2)) {
    const bytes3 = arrayify(signature2);
    if (bytes3.length !== 65) {
      logger$x.throwArgumentError("invalid signature string; must be 65 bytes", "signature", signature2);
    }
    result.r = hexlify(bytes3.slice(0, 32));
    result.s = hexlify(bytes3.slice(32, 64));
    result.v = bytes3[64];
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger$x.throwArgumentError("signature invalid v byte", "signature", signature2);
      }
    }
    result.recoveryParam = 1 - result.v % 2;
    if (result.recoveryParam) {
      bytes3[32] |= 128;
    }
    result._vs = hexlify(bytes3.slice(32, 64));
  } else {
    result.r = signature2.r;
    result.s = signature2.s;
    result.v = signature2.v;
    result.recoveryParam = signature2.recoveryParam;
    result._vs = signature2._vs;
    if (result._vs != null) {
      const vs2 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs2);
      const recoveryParam = vs2[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger$x.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
      }
      vs2[0] &= 127;
      const s2 = hexlify(vs2);
      if (result.s == null) {
        result.s = s2;
      } else if (result.s !== s2) {
        logger$x.throwArgumentError("signature v mismatch _vs", "signature", signature2);
      }
    }
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger$x.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger$x.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
        }
      }
    }
    if (result.r == null || !isHexString$5(result.r)) {
      logger$x.throwArgumentError("signature missing or invalid r", "signature", signature2);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString$5(result.s)) {
      logger$x.throwArgumentError("signature missing or invalid s", "signature", signature2);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    const vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger$x.throwArgumentError("signature s out of range", "signature", signature2);
    }
    if (result.recoveryParam) {
      vs[0] |= 128;
    }
    const _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString$5(result._vs)) {
        logger$x.throwArgumentError("signature invalid _vs", "signature", signature2);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger$x.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
    }
  }
  return result;
}
function joinSignature(signature2) {
  signature2 = splitSignature(signature2);
  return hexlify(concat$2([
    signature2.r,
    signature2.s,
    signature2.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
var lib_esm$j = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  isBytesLike,
  isBytes,
  arrayify,
  concat: concat$2,
  stripZeros,
  zeroPad,
  isHexString: isHexString$5,
  hexlify,
  hexDataLength,
  hexDataSlice,
  hexConcat,
  hexValue,
  hexStripZeros,
  hexZeroPad,
  splitSignature,
  joinSignature
});
const version$p = "bignumber/5.5.0";
var BN$h = BN$i.BN;
const logger$w = new Logger(version$p);
const _constructorGuard$4 = {};
const MAX_SAFE = 9007199254740991;
function isBigNumberish(value2) {
  return value2 != null && (BigNumber.isBigNumber(value2) || typeof value2 === "number" && value2 % 1 === 0 || typeof value2 === "string" && !!value2.match(/^-?[0-9]+$/) || isHexString$5(value2) || typeof value2 === "bigint" || isBytes(value2));
}
let _warnedToStringRadix = false;
class BigNumber {
  constructor(constructorGuard, hex) {
    logger$w.checkNew(new.target, BigNumber);
    if (constructorGuard !== _constructorGuard$4) {
      logger$w.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  fromTwos(value2) {
    return toBigNumber(toBN(this).fromTwos(value2));
  }
  toTwos(value2) {
    return toBigNumber(toBN(this).toTwos(value2));
  }
  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  }
  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }
  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }
  div(other) {
    const o2 = BigNumber.from(other);
    if (o2.isZero()) {
      throwFault$1("division by zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  }
  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }
  mod(other) {
    const value2 = toBN(other);
    if (value2.isNeg()) {
      throwFault$1("cannot modulo negative values", "mod");
    }
    return toBigNumber(toBN(this).umod(value2));
  }
  pow(other) {
    const value2 = toBN(other);
    if (value2.isNeg()) {
      throwFault$1("cannot raise to negative values", "pow");
    }
    return toBigNumber(toBN(this).pow(value2));
  }
  and(other) {
    const value2 = toBN(other);
    if (this.isNegative() || value2.isNeg()) {
      throwFault$1("cannot 'and' negative values", "and");
    }
    return toBigNumber(toBN(this).and(value2));
  }
  or(other) {
    const value2 = toBN(other);
    if (this.isNegative() || value2.isNeg()) {
      throwFault$1("cannot 'or' negative values", "or");
    }
    return toBigNumber(toBN(this).or(value2));
  }
  xor(other) {
    const value2 = toBN(other);
    if (this.isNegative() || value2.isNeg()) {
      throwFault$1("cannot 'xor' negative values", "xor");
    }
    return toBigNumber(toBN(this).xor(value2));
  }
  mask(value2) {
    if (this.isNegative() || value2 < 0) {
      throwFault$1("cannot mask negative values", "mask");
    }
    return toBigNumber(toBN(this).maskn(value2));
  }
  shl(value2) {
    if (this.isNegative() || value2 < 0) {
      throwFault$1("cannot shift negative values", "shl");
    }
    return toBigNumber(toBN(this).shln(value2));
  }
  shr(value2) {
    if (this.isNegative() || value2 < 0) {
      throwFault$1("cannot shift negative values", "shr");
    }
    return toBigNumber(toBN(this).shrn(value2));
  }
  eq(other) {
    return toBN(this).eq(toBN(other));
  }
  lt(other) {
    return toBN(this).lt(toBN(other));
  }
  lte(other) {
    return toBN(this).lte(toBN(other));
  }
  gt(other) {
    return toBN(this).gt(toBN(other));
  }
  gte(other) {
    return toBN(this).gte(toBN(other));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return toBN(this).isZero();
  }
  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error2) {
      throwFault$1("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e2) {
    }
    return logger$w.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger$w.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger$w.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger$w.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(key2) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(value2) {
    if (value2 instanceof BigNumber) {
      return value2;
    }
    if (typeof value2 === "string") {
      if (value2.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard$4, toHex$1(value2));
      }
      if (value2.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard$4, toHex$1(new BN$h(value2)));
      }
      return logger$w.throwArgumentError("invalid BigNumber string", "value", value2);
    }
    if (typeof value2 === "number") {
      if (value2 % 1) {
        throwFault$1("underflow", "BigNumber.from", value2);
      }
      if (value2 >= MAX_SAFE || value2 <= -MAX_SAFE) {
        throwFault$1("overflow", "BigNumber.from", value2);
      }
      return BigNumber.from(String(value2));
    }
    const anyValue = value2;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if (isBytes(anyValue)) {
      return BigNumber.from(hexlify(anyValue));
    }
    if (anyValue) {
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        let hex = anyValue._hex;
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if (isHexString$5(hex) || hex[0] === "-" && isHexString$5(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }
    return logger$w.throwArgumentError("invalid BigNumber value", "value", value2);
  }
  static isBigNumber(value2) {
    return !!(value2 && value2._isBigNumber);
  }
}
function toHex$1(value2) {
  if (typeof value2 !== "string") {
    return toHex$1(value2.toString(16));
  }
  if (value2[0] === "-") {
    value2 = value2.substring(1);
    if (value2[0] === "-") {
      logger$w.throwArgumentError("invalid hex", "value", value2);
    }
    value2 = toHex$1(value2);
    if (value2 === "0x00") {
      return value2;
    }
    return "-" + value2;
  }
  if (value2.substring(0, 2) !== "0x") {
    value2 = "0x" + value2;
  }
  if (value2 === "0x") {
    return "0x00";
  }
  if (value2.length % 2) {
    value2 = "0x0" + value2.substring(2);
  }
  while (value2.length > 4 && value2.substring(0, 4) === "0x00") {
    value2 = "0x" + value2.substring(4);
  }
  return value2;
}
function toBigNumber(value2) {
  return BigNumber.from(toHex$1(value2));
}
function toBN(value2) {
  const hex = BigNumber.from(value2).toHexString();
  if (hex[0] === "-") {
    return new BN$h("-" + hex.substring(3), 16);
  }
  return new BN$h(hex.substring(2), 16);
}
function throwFault$1(fault, operation, value2) {
  const params = { fault, operation };
  if (value2 != null) {
    params.value = value2;
  }
  return logger$w.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
}
function _base36To16(value2) {
  return new BN$h(value2, 36).toString(16);
}
function _base16To36(value2) {
  return new BN$h(value2, 16).toString(36);
}
const logger$v = new Logger(version$p);
const _constructorGuard$3 = {};
const Zero$2 = BigNumber.from(0);
const NegativeOne$2 = BigNumber.from(-1);
function throwFault(message, fault, operation, value2) {
  const params = { fault, operation };
  if (value2 !== void 0) {
    params.value = value2;
  }
  return logger$v.throwError(message, Logger.errors.NUMERIC_FAULT, params);
}
let zeros$1 = "0";
while (zeros$1.length < 256) {
  zeros$1 += zeros$1;
}
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = BigNumber.from(decimals).toNumber();
    } catch (e2) {
    }
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros$1.substring(0, decimals);
  }
  return logger$v.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value2, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  value2 = BigNumber.from(value2);
  const negative = value2.lt(Zero$2);
  if (negative) {
    value2 = value2.mul(NegativeOne$2);
  }
  let fraction = value2.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value2.div(multiplier).toString();
  if (multiplier.length === 1) {
    value2 = whole;
  } else {
    value2 = whole + "." + fraction;
  }
  if (negative) {
    value2 = "-" + value2;
  }
  return value2;
}
function parseFixed(value2, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  const multiplier = getMultiplier(decimals);
  if (typeof value2 !== "string" || !value2.match(/^-?[0-9.]+$/)) {
    logger$v.throwArgumentError("invalid decimal value", "value", value2);
  }
  const negative = value2.substring(0, 1) === "-";
  if (negative) {
    value2 = value2.substring(1);
  }
  if (value2 === ".") {
    logger$v.throwArgumentError("missing value", "value", value2);
  }
  const comps = value2.split(".");
  if (comps.length > 2) {
    logger$v.throwArgumentError("too many decimal points", "value", value2);
  }
  let whole = comps[0], fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  if (fraction.length > multiplier.length - 1) {
    throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  if (fraction === "") {
    fraction = "0";
  }
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  const wholeValue = BigNumber.from(whole);
  const fractionValue = BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne$2);
  }
  return wei;
}
class FixedFormat {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard$3) {
      logger$v.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  static from(value2) {
    if (value2 instanceof FixedFormat) {
      return value2;
    }
    if (typeof value2 === "number") {
      value2 = `fixed128x${value2}`;
    }
    let signed = true;
    let width = 128;
    let decimals = 18;
    if (typeof value2 === "string") {
      if (value2 === "fixed")
        ;
      else if (value2 === "ufixed") {
        signed = false;
      } else {
        const match = value2.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger$v.throwArgumentError("invalid fixed format", "format", value2);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value2) {
      const check = (key2, type, defaultValue) => {
        if (value2[key2] == null) {
          return defaultValue;
        }
        if (typeof value2[key2] !== type) {
          logger$v.throwArgumentError("invalid fixed format (" + key2 + " not " + type + ")", "format." + key2, value2[key2]);
        }
        return value2[key2];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger$v.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger$v.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard$3, signed, width, decimals);
  }
}
class FixedNumber {
  constructor(constructorGuard, hex, value2, format2) {
    logger$v.checkNew(new.target, FixedNumber);
    if (constructorGuard !== _constructorGuard$3) {
      logger$v.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format2;
    this._hex = hex;
    this._value = value2;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger$v.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }
  addUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.add(b2), this.format.decimals, this.format);
  }
  subUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.sub(b2), this.format.decimals, this.format);
  }
  mulUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(b2).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(other) {
    this._checkFormat(other);
    const a2 = parseFixed(this._value, this.format.decimals);
    const b2 = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a2.mul(this.format._multiplier).div(b2), this.format.decimals, this.format);
  }
  floor() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  ceiling() {
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger$v.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    const factor = FixedNumber.from("1" + zeros$1.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger$v.throwArgumentError("invalid byte width", "width", width);
    }
    const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return hexZeroPad(hex, width / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format2) {
    return FixedNumber.fromString(this._value, format2);
  }
  static fromValue(value2, decimals, format2) {
    if (format2 == null && decimals != null && !isBigNumberish(decimals)) {
      format2 = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format2 == null) {
      format2 = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value2, decimals), FixedFormat.from(format2));
  }
  static fromString(value2, format2) {
    if (format2 == null) {
      format2 = "fixed";
    }
    const fixedFormat = FixedFormat.from(format2);
    const numeric2 = parseFixed(value2, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric2.lt(Zero$2)) {
      throwFault("unsigned value cannot be negative", "overflow", "value", value2);
    }
    let hex = null;
    if (fixedFormat.signed) {
      hex = numeric2.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric2.toHexString();
      hex = hexZeroPad(hex, fixedFormat.width / 8);
    }
    const decimal = formatFixed(numeric2, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$3, hex, decimal, fixedFormat);
  }
  static fromBytes(value2, format2) {
    if (format2 == null) {
      format2 = "fixed";
    }
    const fixedFormat = FixedFormat.from(format2);
    if (arrayify(value2).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    let numeric2 = BigNumber.from(value2);
    if (fixedFormat.signed) {
      numeric2 = numeric2.fromTwos(fixedFormat.width);
    }
    const hex = numeric2.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric2, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard$3, hex, decimal, fixedFormat);
  }
  static from(value2, format2) {
    if (typeof value2 === "string") {
      return FixedNumber.fromString(value2, format2);
    }
    if (isBytes(value2)) {
      return FixedNumber.fromBytes(value2, format2);
    }
    try {
      return FixedNumber.fromValue(value2, 0, format2);
    } catch (error2) {
      if (error2.code !== Logger.errors.INVALID_ARGUMENT) {
        throw error2;
      }
    }
    return logger$v.throwArgumentError("invalid FixedNumber value", "value", value2);
  }
  static isFixedNumber(value2) {
    return !!(value2 && value2._isFixedNumber);
  }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");
const version$o = "properties/5.5.0";
var __awaiter$a = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$u = new Logger(version$o);
function defineReadOnly(object2, name2, value2) {
  Object.defineProperty(object2, name2, {
    enumerable: true,
    value: value2,
    writable: false
  });
}
function getStatic(ctor, key2) {
  for (let i2 = 0; i2 < 32; i2++) {
    if (ctor[key2]) {
      return ctor[key2];
    }
    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
function resolveProperties(object2) {
  return __awaiter$a(this, void 0, void 0, function* () {
    const promises = Object.keys(object2).map((key2) => {
      const value2 = object2[key2];
      return Promise.resolve(value2).then((v2) => ({ key: key2, value: v2 }));
    });
    const results2 = yield Promise.all(promises);
    return results2.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object2, properties) {
  if (!object2 || typeof object2 !== "object") {
    logger$u.throwArgumentError("invalid object", "object", object2);
  }
  Object.keys(object2).forEach((key2) => {
    if (!properties[key2]) {
      logger$u.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object2);
    }
  });
}
function shallowCopy(object2) {
  const result = {};
  for (const key2 in object2) {
    result[key2] = object2[key2];
  }
  return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object2) {
  if (object2 === void 0 || object2 === null || opaque[typeof object2]) {
    return true;
  }
  if (Array.isArray(object2) || typeof object2 === "object") {
    if (!Object.isFrozen(object2)) {
      return false;
    }
    const keys2 = Object.keys(object2);
    for (let i2 = 0; i2 < keys2.length; i2++) {
      let value2 = null;
      try {
        value2 = object2[keys2[i2]];
      } catch (error2) {
        continue;
      }
      if (!_isFrozen(value2)) {
        return false;
      }
    }
    return true;
  }
  return logger$u.throwArgumentError(`Cannot deepCopy ${typeof object2}`, "object", object2);
}
function _deepCopy(object2) {
  if (_isFrozen(object2)) {
    return object2;
  }
  if (Array.isArray(object2)) {
    return Object.freeze(object2.map((item) => deepCopy(item)));
  }
  if (typeof object2 === "object") {
    const result = {};
    for (const key2 in object2) {
      const value2 = object2[key2];
      if (value2 === void 0) {
        continue;
      }
      defineReadOnly(result, key2, deepCopy(value2));
    }
    return result;
  }
  return logger$u.throwArgumentError(`Cannot deepCopy ${typeof object2}`, "object", object2);
}
function deepCopy(object2) {
  return _deepCopy(object2);
}
class Description {
  constructor(info) {
    for (const key2 in info) {
      this[key2] = deepCopy(info[key2]);
    }
  }
}
var lib_esm$i = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  defineReadOnly,
  getStatic,
  resolveProperties,
  checkProperties,
  shallowCopy,
  deepCopy,
  Description
});
const version$n = "abi/5.5.0";
const logger$t = new Logger(version$n);
const _constructorGuard$2 = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name2) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name2]) {
      return true;
    }
  } else if (type === "address") {
    if (name2 === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name2]) {
      return true;
    }
  }
  if (ModifiersBytes[name2] || name2 === "payable") {
    logger$t.throwArgumentError("invalid modifier", "name", name2);
  }
  return false;
}
function parseParamType(param, allowIndexed) {
  let originalParam = param;
  function throwError2(i2) {
    logger$t.throwArgumentError(`unexpected character at position ${i2}`, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent2) {
    let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
    if (allowIndexed) {
      node2.indexed = false;
    }
    return node2;
  }
  let parent = { type: "", name: "", state: { allowType: true } };
  let node = parent;
  for (let i2 = 0; i2 < param.length; i2++) {
    let c2 = param[i2];
    switch (c2) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError2(i2);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i2);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;
        if (!node) {
          throwError2(i2);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError2(i2);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        let sibling = newNode(node.parent);
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      case " ":
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError2(i2);
              }
              if (node.indexed) {
                throwError2(i2);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError2(i2);
        }
        node.type += c2;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError2(i2);
        }
        node.type += c2;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c2;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c2;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c2;
        } else {
          throwError2(i2);
        }
    }
  }
  if (node.parent) {
    logger$t.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError2(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError2(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object2, params) {
  for (let key2 in params) {
    defineReadOnly(object2, key2, params[key2]);
  }
}
const FormatTypes = Object.freeze({
  sighash: "sighash",
  minimal: "minimal",
  full: "full",
  json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$t.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    let match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$t.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      let result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.components) {
        result2.components = this.components.map((comp) => JSON.parse(comp.format(format2)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format2);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format2 !== FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format2 !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format2 === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  static from(value2, allowIndexed) {
    if (typeof value2 === "string") {
      return ParamType.fromString(value2, allowIndexed);
    }
    return ParamType.fromObject(value2);
  }
  static fromObject(value2) {
    if (ParamType.isParamType(value2)) {
      return value2;
    }
    return new ParamType(_constructorGuard$2, {
      name: value2.name || null,
      type: verifyType(value2.type),
      indexed: value2.indexed == null ? null : !!value2.indexed,
      components: value2.components ? value2.components.map(ParamType.fromObject) : null
    });
  }
  static fromString(value2, allowIndexed) {
    function ParamTypify(node) {
      return ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }
    return ParamTypify(parseParamType(value2, !!allowIndexed));
  }
  static isParamType(value2) {
    return !!(value2 != null && value2._isParamType);
  }
}
function parseParams(value2, allowIndex) {
  return splitNesting(value2).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard$2) {
      logger$t.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  static from(value2) {
    if (Fragment.isFragment(value2)) {
      return value2;
    }
    if (typeof value2 === "string") {
      return Fragment.fromString(value2);
    }
    return Fragment.fromObject(value2);
  }
  static fromObject(value2) {
    if (Fragment.isFragment(value2)) {
      return value2;
    }
    switch (value2.type) {
      case "function":
        return FunctionFragment.fromObject(value2);
      case "event":
        return EventFragment.fromObject(value2);
      case "constructor":
        return ConstructorFragment.fromObject(value2);
      case "error":
        return ErrorFragment.fromObject(value2);
      case "fallback":
      case "receive":
        return null;
    }
    return logger$t.throwArgumentError("invalid fragment object", "value", value2);
  }
  static fromString(value2) {
    value2 = value2.replace(/\s/g, " ");
    value2 = value2.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value2 = value2.trim();
    if (value2.split(" ")[0] === "event") {
      return EventFragment.fromString(value2.substring(5).trim());
    } else if (value2.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value2.substring(8).trim());
    } else if (value2.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value2.trim());
    } else if (value2.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value2.substring(5).trim());
    }
    return logger$t.throwArgumentError("unsupported fragment", "value", value2);
  }
  static isFragment(value2) {
    return !!(value2 && value2._isFragment);
  }
}
class EventFragment extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$t.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (format2 !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  }
  static from(value2) {
    if (typeof value2 === "string") {
      return EventFragment.fromString(value2);
    }
    return EventFragment.fromObject(value2);
  }
  static fromObject(value2) {
    if (EventFragment.isEventFragment(value2)) {
      return value2;
    }
    if (value2.type !== "event") {
      logger$t.throwArgumentError("invalid event object", "value", value2);
    }
    const params = {
      name: verifyIdentifier(value2.name),
      anonymous: value2.anonymous,
      inputs: value2.inputs ? value2.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard$2, params);
  }
  static fromString(value2) {
    let match = value2.match(regexParen);
    if (!match) {
      logger$t.throwArgumentError("invalid event string", "value", value2);
    }
    let anonymous = false;
    match[3].split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger$t.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match[1].trim(),
      anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  }
  static isEventFragment(value2) {
    return value2 && value2._isFragment && value2.type === "event";
  }
}
function parseGas(value2, params) {
  params.gas = null;
  let comps = value2.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger$t.throwArgumentError("invalid human-readable ABI signature", "value", value2);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger$t.throwArgumentError("invalid human-readable ABI signature gas", "value", value2);
    }
    params.gas = BigNumber.from(comps[1]);
    return comps[0];
  }
  return value2;
}
function parseModifiers(value2, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value2.split(" ").forEach((modifier) => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value2) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value2.stateMutability != null) {
    result.stateMutability = value2.stateMutability;
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value2.constant != null) {
      if (!!value2.constant !== result.constant) {
        logger$t.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value2);
      }
    }
    result.payable = result.stateMutability === "payable";
    if (value2.payable != null) {
      if (!!value2.payable !== result.payable) {
        logger$t.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value2);
      }
    }
  } else if (value2.payable != null) {
    result.payable = !!value2.payable;
    if (value2.constant == null && !result.payable && value2.type !== "constructor") {
      logger$t.throwArgumentError("unable to determine stateMutability", "value", value2);
    }
    result.constant = !!value2.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger$t.throwArgumentError("cannot have constant payable function", "value", value2);
    }
  } else if (value2.constant != null) {
    result.constant = !!value2.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value2.type !== "constructor") {
    logger$t.throwArgumentError("unable to determine stateMutability", "value", value2);
  }
  return result;
}
class ConstructorFragment extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$t.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    if (format2 === FormatTypes.sighash) {
      logger$t.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    let result = "constructor(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  }
  static from(value2) {
    if (typeof value2 === "string") {
      return ConstructorFragment.fromString(value2);
    }
    return ConstructorFragment.fromObject(value2);
  }
  static fromObject(value2) {
    if (ConstructorFragment.isConstructorFragment(value2)) {
      return value2;
    }
    if (value2.type !== "constructor") {
      logger$t.throwArgumentError("invalid constructor object", "value", value2);
    }
    let state2 = verifyState(value2);
    if (state2.constant) {
      logger$t.throwArgumentError("constructor cannot be constant", "value", value2);
    }
    const params = {
      name: null,
      type: value2.type,
      inputs: value2.inputs ? value2.inputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value2.gas ? BigNumber.from(value2.gas) : null
    };
    return new ConstructorFragment(_constructorGuard$2, params);
  }
  static fromString(value2) {
    let params = { type: "constructor" };
    value2 = parseGas(value2, params);
    let parens = value2.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger$t.throwArgumentError("invalid constructor string", "value", value2);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }
  static isConstructorFragment(value2) {
    return value2 && value2._isFragment && value2.type === "constructor";
  }
}
class FunctionFragment extends ConstructorFragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$t.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2))),
        outputs: this.outputs.map((output) => JSON.parse(output.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    if (format2 !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map((output) => output.format(format2)).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  }
  static from(value2) {
    if (typeof value2 === "string") {
      return FunctionFragment.fromString(value2);
    }
    return FunctionFragment.fromObject(value2);
  }
  static fromObject(value2) {
    if (FunctionFragment.isFunctionFragment(value2)) {
      return value2;
    }
    if (value2.type !== "function") {
      logger$t.throwArgumentError("invalid function object", "value", value2);
    }
    let state2 = verifyState(value2);
    const params = {
      type: value2.type,
      name: verifyIdentifier(value2.name),
      constant: state2.constant,
      inputs: value2.inputs ? value2.inputs.map(ParamType.fromObject) : [],
      outputs: value2.outputs ? value2.outputs.map(ParamType.fromObject) : [],
      payable: state2.payable,
      stateMutability: state2.stateMutability,
      gas: value2.gas ? BigNumber.from(value2.gas) : null
    };
    return new FunctionFragment(_constructorGuard$2, params);
  }
  static fromString(value2) {
    let params = { type: "function" };
    value2 = parseGas(value2, params);
    let comps = value2.split(" returns ");
    if (comps.length > 2) {
      logger$t.throwArgumentError("invalid function string", "value", value2);
    }
    let parens = comps[0].match(regexParen);
    if (!parens) {
      logger$t.throwArgumentError("invalid function signature", "value", value2);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger$t.throwArgumentError("unexpected tokens", "value", value2);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  }
  static isFunctionFragment(value2) {
    return value2 && value2._isFragment && value2.type === "function";
  }
}
function checkForbidden(fragment) {
  const sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger$t.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }
  return fragment;
}
class ErrorFragment extends Fragment {
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.sighash;
    }
    if (!FormatTypes[format2]) {
      logger$t.throwArgumentError("invalid format type", "format", format2);
    }
    if (format2 === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    let result = "";
    if (format2 !== FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }
  static from(value2) {
    if (typeof value2 === "string") {
      return ErrorFragment.fromString(value2);
    }
    return ErrorFragment.fromObject(value2);
  }
  static fromObject(value2) {
    if (ErrorFragment.isErrorFragment(value2)) {
      return value2;
    }
    if (value2.type !== "error") {
      logger$t.throwArgumentError("invalid error object", "value", value2);
    }
    const params = {
      type: value2.type,
      name: verifyIdentifier(value2.name),
      inputs: value2.inputs ? value2.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard$2, params));
  }
  static fromString(value2) {
    let params = { type: "error" };
    let parens = value2.match(regexParen);
    if (!parens) {
      logger$t.throwArgumentError("invalid error signature", "value", value2);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }
  static isErrorFragment(value2) {
    return value2 && value2._isFragment && value2.type === "error";
  }
}
function verifyType(type) {
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  return type;
}
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value2) {
  if (!value2 || !value2.match(regexIdentifier)) {
    logger$t.throwArgumentError(`invalid identifier "${value2}"`, "value", value2);
  }
  return value2;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value2) {
  value2 = value2.trim();
  let result = [];
  let accum = "";
  let depth = 0;
  for (let offset = 0; offset < value2.length; offset++) {
    let c2 = value2[offset];
    if (c2 === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c2;
      if (c2 === "(") {
        depth++;
      } else if (c2 === ")") {
        depth--;
        if (depth === -1) {
          logger$t.throwArgumentError("unbalanced parenthesis", "value", value2);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}
const logger$s = new Logger(version$n);
function checkResultErrors(result) {
  const errors2 = [];
  const checkErrors = function(path, object2) {
    if (!Array.isArray(object2)) {
      return;
    }
    for (let key2 in object2) {
      const childPath = path.slice();
      childPath.push(key2);
      try {
        checkErrors(childPath, object2[key2]);
      } catch (error2) {
        errors2.push({ path: childPath, error: error2 });
      }
    }
  };
  checkErrors([], result);
  return errors2;
}
class Coder {
  constructor(name2, type, localName, dynamic) {
    this.name = name2;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  _throwError(message, value2) {
    logger$s.throwArgumentError(message, this.localName, value2);
  }
}
class Writer {
  constructor(wordSize) {
    defineReadOnly(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  get data() {
    return hexConcat(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(data) {
    this._data.push(data);
    this._dataLength += data.length;
    return data.length;
  }
  appendWriter(writer) {
    return this._writeData(concat$2(writer._data));
  }
  writeBytes(value2) {
    let bytes3 = arrayify(value2);
    const paddingOffset = bytes3.length % this.wordSize;
    if (paddingOffset) {
      bytes3 = concat$2([bytes3, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes3);
  }
  _getValue(value2) {
    let bytes3 = arrayify(BigNumber.from(value2));
    if (bytes3.length > this.wordSize) {
      logger$s.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes3.length
      });
    }
    if (bytes3.length % this.wordSize) {
      bytes3 = concat$2([this._padding.slice(bytes3.length % this.wordSize), bytes3]);
    }
    return bytes3;
  }
  writeValue(value2) {
    return this._writeData(this._getValue(value2));
  }
  writeUpdatableValue() {
    const offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return (value2) => {
      this._data[offset] = this._getValue(value2);
    };
  }
}
class Reader {
  constructor(data, wordSize, coerceFunc, allowLoose) {
    defineReadOnly(this, "_data", arrayify(data));
    defineReadOnly(this, "wordSize", wordSize || 32);
    defineReadOnly(this, "_coerceFunc", coerceFunc);
    defineReadOnly(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  get data() {
    return hexlify(this._data);
  }
  get consumed() {
    return this._offset;
  }
  static coerce(name2, value2) {
    let match = name2.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value2 = value2.toNumber();
    }
    return value2;
  }
  coerce(name2, value2) {
    if (this._coerceFunc) {
      return this._coerceFunc(name2, value2);
    }
    return Reader.coerce(name2, value2);
  }
  _peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length <= this._data.length) {
        alignedLength = length;
      } else {
        logger$s.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  }
  subReader(offset) {
    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(length, loose) {
    let bytes3 = this._peekBytes(0, length, !!loose);
    this._offset += bytes3.length;
    return bytes3.slice(0, length);
  }
  readValue() {
    return BigNumber.from(this.readBytes(this.wordSize));
  }
}
var sha3$1 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(module2) {
  (function() {
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW2 = typeof window === "object";
    var root2 = WINDOW2 ? window : {};
    if (root2.JS_SHA3_NO_WINDOW) {
      WINDOW2 = false;
    }
    var WEB_WORKER2 = !WINDOW2 && typeof self === "object";
    var NODE_JS2 = !root2.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS2) {
      root2 = commonjsGlobal;
    } else if (WEB_WORKER2) {
      root2 = self;
    }
    var COMMON_JS2 = !root2.JS_SHA3_NO_COMMON_JS && true && module2.exports;
    var ARRAY_BUFFER2 = !root2.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS2 = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT2 = [0, 8, 16, 24];
    var RC = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES2 = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    if (root2.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER2 && (root2.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod2 = function(bits2, padding2, outputType) {
      return function(message) {
        return new Keccak2(bits2, padding2, bits2).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits) {
        return new Keccak2(bits2, padding2, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding2, outputType) {
      return function(message, outputBits, n2, s2) {
        return methods["cshake" + bits2].update(message, outputBits, n2, s2)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding2, outputType) {
      return function(key2, message, outputBits, s2) {
        return methods["kmac" + bits2].update(key2, message, outputBits, s2)[outputType]();
      };
    };
    var createOutputMethods = function(method2, createMethod3, bits2, padding2) {
      for (var i3 = 0; i3 < OUTPUT_TYPES2.length; ++i3) {
        var type = OUTPUT_TYPES2[i3];
        method2[type] = createMethod3(bits2, padding2, type);
      }
      return method2;
    };
    var createMethod2 = function(bits2, padding2) {
      var method2 = createOutputMethod2(bits2, padding2, "hex");
      method2.create = function() {
        return new Keccak2(bits2, padding2, bits2);
      };
      method2.update = function(message) {
        return method2.create().update(message);
      };
      return createOutputMethods(method2, createOutputMethod2, bits2, padding2);
    };
    var createShakeMethod = function(bits2, padding2) {
      var method2 = createShakeOutputMethod(bits2, padding2, "hex");
      method2.create = function(outputBits) {
        return new Keccak2(bits2, padding2, outputBits);
      };
      method2.update = function(message, outputBits) {
        return method2.create(outputBits).update(message);
      };
      return createOutputMethods(method2, createShakeOutputMethod, bits2, padding2);
    };
    var createCshakeMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method2 = createCshakeOutputMethod(bits2, padding2, "hex");
      method2.create = function(outputBits, n2, s2) {
        if (!n2 && !s2) {
          return methods["shake" + bits2].create(outputBits);
        } else {
          return new Keccak2(bits2, padding2, outputBits).bytepad([n2, s2], w2);
        }
      };
      method2.update = function(message, outputBits, n2, s2) {
        return method2.create(outputBits, n2, s2).update(message);
      };
      return createOutputMethods(method2, createCshakeOutputMethod, bits2, padding2);
    };
    var createKmacMethod = function(bits2, padding2) {
      var w2 = CSHAKE_BYTEPAD[bits2];
      var method2 = createKmacOutputMethod(bits2, padding2, "hex");
      method2.create = function(key2, outputBits, s2) {
        return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s2], w2).bytepad([key2], w2);
      };
      method2.update = function(key2, message, outputBits, s2) {
        return method2.create(key2, outputBits, s2).update(message);
      };
      return createOutputMethods(method2, createKmacOutputMethod, bits2, padding2);
    };
    var algorithms = [
      { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod2 },
      { name: "sha3", padding: PADDING, bits: BITS, createMethod: createMethod2 },
      { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];
    var methods = {}, methodNames = [];
    for (var i2 = 0; i2 < algorithms.length; ++i2) {
      var algorithm2 = algorithms[i2];
      var bits = algorithm2.bits;
      for (var j2 = 0; j2 < bits.length; ++j2) {
        var methodName = algorithm2.name + "_" + bits[j2];
        methodNames.push(methodName);
        methods[methodName] = algorithm2.createMethod(bits[j2], algorithm2.padding);
        if (algorithm2.name !== "sha3") {
          var newMethodName = algorithm2.name + bits[j2];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak2(bits2, padding2, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding2;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i3 = 0; i3 < 50; ++i3) {
        this.s[i3] = 0;
      }
    }
    Keccak2.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER2 && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks2 = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index2 = 0, s2 = this.s, i3, code2;
      while (index2 < length) {
        if (this.reset) {
          this.reset = false;
          blocks2[0] = this.block;
          for (i3 = 1; i3 < blockCount + 1; ++i3) {
            blocks2[i3] = 0;
          }
        }
        if (notString) {
          for (i3 = this.start; index2 < length && i3 < byteCount; ++index2) {
            blocks2[i3 >> 2] |= message[index2] << SHIFT2[i3++ & 3];
          }
        } else {
          for (i3 = this.start; index2 < length && i3 < byteCount; ++index2) {
            code2 = message.charCodeAt(index2);
            if (code2 < 128) {
              blocks2[i3 >> 2] |= code2 << SHIFT2[i3++ & 3];
            } else if (code2 < 2048) {
              blocks2[i3 >> 2] |= (192 | code2 >> 6) << SHIFT2[i3++ & 3];
              blocks2[i3 >> 2] |= (128 | code2 & 63) << SHIFT2[i3++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks2[i3 >> 2] |= (224 | code2 >> 12) << SHIFT2[i3++ & 3];
              blocks2[i3 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT2[i3++ & 3];
              blocks2[i3 >> 2] |= (128 | code2 & 63) << SHIFT2[i3++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks2[i3 >> 2] |= (240 | code2 >> 18) << SHIFT2[i3++ & 3];
              blocks2[i3 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT2[i3++ & 3];
              blocks2[i3 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT2[i3++ & 3];
              blocks2[i3 >> 2] |= (128 | code2 & 63) << SHIFT2[i3++ & 3];
            }
          }
        }
        this.lastByteIndex = i3;
        if (i3 >= byteCount) {
          this.start = i3 - byteCount;
          this.block = blocks2[blockCount];
          for (i3 = 0; i3 < blockCount; ++i3) {
            s2[i3] ^= blocks2[i3];
          }
          f2(s2);
          this.reset = true;
        } else {
          this.start = i3;
        }
      }
      return this;
    };
    Keccak2.prototype.encode = function(x2, right) {
      var o2 = x2 & 255, n2 = 1;
      var bytes3 = [o2];
      x2 = x2 >> 8;
      o2 = x2 & 255;
      while (o2 > 0) {
        bytes3.unshift(o2);
        x2 = x2 >> 8;
        o2 = x2 & 255;
        ++n2;
      }
      if (right) {
        bytes3.push(n2);
      } else {
        bytes3.unshift(n2);
      }
      this.update(bytes3);
      return bytes3.length;
    };
    Keccak2.prototype.encodeString = function(str2) {
      var notString, type = typeof str2;
      if (type !== "string") {
        if (type === "object") {
          if (str2 === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER2 && str2.constructor === ArrayBuffer) {
            str2 = new Uint8Array(str2);
          } else if (!Array.isArray(str2)) {
            if (!ARRAY_BUFFER2 || !ArrayBuffer.isView(str2)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes3 = 0, length = str2.length;
      if (notString) {
        bytes3 = length;
      } else {
        for (var i3 = 0; i3 < str2.length; ++i3) {
          var code2 = str2.charCodeAt(i3);
          if (code2 < 128) {
            bytes3 += 1;
          } else if (code2 < 2048) {
            bytes3 += 2;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes3 += 3;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | str2.charCodeAt(++i3) & 1023);
            bytes3 += 4;
          }
        }
      }
      bytes3 += this.encode(bytes3 * 8);
      this.update(str2);
      return bytes3;
    };
    Keccak2.prototype.bytepad = function(strs, w2) {
      var bytes3 = this.encode(w2);
      for (var i3 = 0; i3 < strs.length; ++i3) {
        bytes3 += this.encodeString(strs[i3]);
      }
      var paddingBytes = w2 - bytes3 % w2;
      var zeros2 = [];
      zeros2.length = paddingBytes;
      this.update(zeros2);
      return this;
    };
    Keccak2.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks2 = this.blocks, i3 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
      blocks2[i3 >> 2] |= this.padding[i3 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks2[0] = blocks2[blockCount];
        for (i3 = 1; i3 < blockCount + 1; ++i3) {
          blocks2[i3] = 0;
        }
      }
      blocks2[blockCount - 1] |= 2147483648;
      for (i3 = 0; i3 < blockCount; ++i3) {
        s2[i3] ^= blocks2[i3];
      }
      f2(s2);
    };
    Keccak2.prototype.toString = Keccak2.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
      var hex = "", block;
      while (j3 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
          block = s2[i3];
          hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15] + HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15] + HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15] + HEX_CHARS2[block >> 28 & 15] + HEX_CHARS2[block >> 24 & 15];
        }
        if (j3 % blockCount === 0) {
          f2(s2);
          i3 = 0;
        }
      }
      if (extraBytes) {
        block = s2[i3];
        hex += HEX_CHARS2[block >> 4 & 15] + HEX_CHARS2[block & 15];
        if (extraBytes > 1) {
          hex += HEX_CHARS2[block >> 12 & 15] + HEX_CHARS2[block >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex += HEX_CHARS2[block >> 20 & 15] + HEX_CHARS2[block >> 16 & 15];
        }
      }
      return hex;
    };
    Keccak2.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
      var bytes3 = this.outputBits >> 3;
      var buffer2;
      if (extraBytes) {
        buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer2 = new ArrayBuffer(bytes3);
      }
      var array2 = new Uint32Array(buffer2);
      while (j3 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
          array2[j3] = s2[i3];
        }
        if (j3 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        array2[i3] = s2[i3];
        buffer2 = buffer2.slice(0, bytes3);
      }
      return buffer2;
    };
    Keccak2.prototype.buffer = Keccak2.prototype.arrayBuffer;
    Keccak2.prototype.digest = Keccak2.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
      var array2 = [], offset, block;
      while (j3 < outputBlocks) {
        for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
          offset = j3 << 2;
          block = s2[i3];
          array2[offset] = block & 255;
          array2[offset + 1] = block >> 8 & 255;
          array2[offset + 2] = block >> 16 & 255;
          array2[offset + 3] = block >> 24 & 255;
        }
        if (j3 % blockCount === 0) {
          f2(s2);
        }
      }
      if (extraBytes) {
        offset = j3 << 2;
        block = s2[i3];
        array2[offset] = block & 255;
        if (extraBytes > 1) {
          array2[offset + 1] = block >> 8 & 255;
        }
        if (extraBytes > 2) {
          array2[offset + 2] = block >> 16 & 255;
        }
      }
      return array2;
    };
    function Kmac(bits2, padding2, outputBits) {
      Keccak2.call(this, bits2, padding2, outputBits);
    }
    Kmac.prototype = new Keccak2();
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak2.prototype.finalize.call(this);
    };
    var f2 = function(s2) {
      var h2, l2, n2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n2 = 0; n2 < 48; n2 += 2) {
        c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
        c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
        c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
        c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
        c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
        c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
        c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
        c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
        c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
        c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
        h2 = c8 ^ (c2 << 1 | c3 >>> 31);
        l2 = c9 ^ (c3 << 1 | c2 >>> 31);
        s2[0] ^= h2;
        s2[1] ^= l2;
        s2[10] ^= h2;
        s2[11] ^= l2;
        s2[20] ^= h2;
        s2[21] ^= l2;
        s2[30] ^= h2;
        s2[31] ^= l2;
        s2[40] ^= h2;
        s2[41] ^= l2;
        h2 = c0 ^ (c4 << 1 | c5 >>> 31);
        l2 = c1 ^ (c5 << 1 | c4 >>> 31);
        s2[2] ^= h2;
        s2[3] ^= l2;
        s2[12] ^= h2;
        s2[13] ^= l2;
        s2[22] ^= h2;
        s2[23] ^= l2;
        s2[32] ^= h2;
        s2[33] ^= l2;
        s2[42] ^= h2;
        s2[43] ^= l2;
        h2 = c2 ^ (c6 << 1 | c7 >>> 31);
        l2 = c3 ^ (c7 << 1 | c6 >>> 31);
        s2[4] ^= h2;
        s2[5] ^= l2;
        s2[14] ^= h2;
        s2[15] ^= l2;
        s2[24] ^= h2;
        s2[25] ^= l2;
        s2[34] ^= h2;
        s2[35] ^= l2;
        s2[44] ^= h2;
        s2[45] ^= l2;
        h2 = c4 ^ (c8 << 1 | c9 >>> 31);
        l2 = c5 ^ (c9 << 1 | c8 >>> 31);
        s2[6] ^= h2;
        s2[7] ^= l2;
        s2[16] ^= h2;
        s2[17] ^= l2;
        s2[26] ^= h2;
        s2[27] ^= l2;
        s2[36] ^= h2;
        s2[37] ^= l2;
        s2[46] ^= h2;
        s2[47] ^= l2;
        h2 = c6 ^ (c0 << 1 | c1 >>> 31);
        l2 = c7 ^ (c1 << 1 | c0 >>> 31);
        s2[8] ^= h2;
        s2[9] ^= l2;
        s2[18] ^= h2;
        s2[19] ^= l2;
        s2[28] ^= h2;
        s2[29] ^= l2;
        s2[38] ^= h2;
        s2[39] ^= l2;
        s2[48] ^= h2;
        s2[49] ^= l2;
        b0 = s2[0];
        b1 = s2[1];
        b32 = s2[11] << 4 | s2[10] >>> 28;
        b33 = s2[10] << 4 | s2[11] >>> 28;
        b14 = s2[20] << 3 | s2[21] >>> 29;
        b15 = s2[21] << 3 | s2[20] >>> 29;
        b46 = s2[31] << 9 | s2[30] >>> 23;
        b47 = s2[30] << 9 | s2[31] >>> 23;
        b28 = s2[40] << 18 | s2[41] >>> 14;
        b29 = s2[41] << 18 | s2[40] >>> 14;
        b20 = s2[2] << 1 | s2[3] >>> 31;
        b21 = s2[3] << 1 | s2[2] >>> 31;
        b2 = s2[13] << 12 | s2[12] >>> 20;
        b3 = s2[12] << 12 | s2[13] >>> 20;
        b34 = s2[22] << 10 | s2[23] >>> 22;
        b35 = s2[23] << 10 | s2[22] >>> 22;
        b16 = s2[33] << 13 | s2[32] >>> 19;
        b17 = s2[32] << 13 | s2[33] >>> 19;
        b48 = s2[42] << 2 | s2[43] >>> 30;
        b49 = s2[43] << 2 | s2[42] >>> 30;
        b40 = s2[5] << 30 | s2[4] >>> 2;
        b41 = s2[4] << 30 | s2[5] >>> 2;
        b22 = s2[14] << 6 | s2[15] >>> 26;
        b23 = s2[15] << 6 | s2[14] >>> 26;
        b4 = s2[25] << 11 | s2[24] >>> 21;
        b5 = s2[24] << 11 | s2[25] >>> 21;
        b36 = s2[34] << 15 | s2[35] >>> 17;
        b37 = s2[35] << 15 | s2[34] >>> 17;
        b18 = s2[45] << 29 | s2[44] >>> 3;
        b19 = s2[44] << 29 | s2[45] >>> 3;
        b10 = s2[6] << 28 | s2[7] >>> 4;
        b11 = s2[7] << 28 | s2[6] >>> 4;
        b42 = s2[17] << 23 | s2[16] >>> 9;
        b43 = s2[16] << 23 | s2[17] >>> 9;
        b24 = s2[26] << 25 | s2[27] >>> 7;
        b25 = s2[27] << 25 | s2[26] >>> 7;
        b6 = s2[36] << 21 | s2[37] >>> 11;
        b7 = s2[37] << 21 | s2[36] >>> 11;
        b38 = s2[47] << 24 | s2[46] >>> 8;
        b39 = s2[46] << 24 | s2[47] >>> 8;
        b30 = s2[8] << 27 | s2[9] >>> 5;
        b31 = s2[9] << 27 | s2[8] >>> 5;
        b12 = s2[18] << 20 | s2[19] >>> 12;
        b13 = s2[19] << 20 | s2[18] >>> 12;
        b44 = s2[29] << 7 | s2[28] >>> 25;
        b45 = s2[28] << 7 | s2[29] >>> 25;
        b26 = s2[38] << 8 | s2[39] >>> 24;
        b27 = s2[39] << 8 | s2[38] >>> 24;
        b8 = s2[48] << 14 | s2[49] >>> 18;
        b9 = s2[49] << 14 | s2[48] >>> 18;
        s2[0] = b0 ^ ~b2 & b4;
        s2[1] = b1 ^ ~b3 & b5;
        s2[10] = b10 ^ ~b12 & b14;
        s2[11] = b11 ^ ~b13 & b15;
        s2[20] = b20 ^ ~b22 & b24;
        s2[21] = b21 ^ ~b23 & b25;
        s2[30] = b30 ^ ~b32 & b34;
        s2[31] = b31 ^ ~b33 & b35;
        s2[40] = b40 ^ ~b42 & b44;
        s2[41] = b41 ^ ~b43 & b45;
        s2[2] = b2 ^ ~b4 & b6;
        s2[3] = b3 ^ ~b5 & b7;
        s2[12] = b12 ^ ~b14 & b16;
        s2[13] = b13 ^ ~b15 & b17;
        s2[22] = b22 ^ ~b24 & b26;
        s2[23] = b23 ^ ~b25 & b27;
        s2[32] = b32 ^ ~b34 & b36;
        s2[33] = b33 ^ ~b35 & b37;
        s2[42] = b42 ^ ~b44 & b46;
        s2[43] = b43 ^ ~b45 & b47;
        s2[4] = b4 ^ ~b6 & b8;
        s2[5] = b5 ^ ~b7 & b9;
        s2[14] = b14 ^ ~b16 & b18;
        s2[15] = b15 ^ ~b17 & b19;
        s2[24] = b24 ^ ~b26 & b28;
        s2[25] = b25 ^ ~b27 & b29;
        s2[34] = b34 ^ ~b36 & b38;
        s2[35] = b35 ^ ~b37 & b39;
        s2[44] = b44 ^ ~b46 & b48;
        s2[45] = b45 ^ ~b47 & b49;
        s2[6] = b6 ^ ~b8 & b0;
        s2[7] = b7 ^ ~b9 & b1;
        s2[16] = b16 ^ ~b18 & b10;
        s2[17] = b17 ^ ~b19 & b11;
        s2[26] = b26 ^ ~b28 & b20;
        s2[27] = b27 ^ ~b29 & b21;
        s2[36] = b36 ^ ~b38 & b30;
        s2[37] = b37 ^ ~b39 & b31;
        s2[46] = b46 ^ ~b48 & b40;
        s2[47] = b47 ^ ~b49 & b41;
        s2[8] = b8 ^ ~b0 & b2;
        s2[9] = b9 ^ ~b1 & b3;
        s2[18] = b18 ^ ~b10 & b12;
        s2[19] = b19 ^ ~b11 & b13;
        s2[28] = b28 ^ ~b20 & b22;
        s2[29] = b29 ^ ~b21 & b23;
        s2[38] = b38 ^ ~b30 & b32;
        s2[39] = b39 ^ ~b31 & b33;
        s2[48] = b48 ^ ~b40 & b42;
        s2[49] = b49 ^ ~b41 & b43;
        s2[0] ^= RC[n2];
        s2[1] ^= RC[n2 + 1];
      }
    };
    if (COMMON_JS2) {
      module2.exports = methods;
    } else {
      for (i2 = 0; i2 < methodNames.length; ++i2) {
        root2[methodNames[i2]] = methods[methodNames[i2]];
      }
    }
  })();
})(sha3$1);
var sha3 = sha3$1.exports;
function keccak256$1(data) {
  return "0x" + sha3.keccak_256(arrayify(data));
}
var lib_esm$h = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  keccak256: keccak256$1
});
const version$m = "rlp/5.5.0";
const logger$r = new Logger(version$m);
function arrayifyInteger(value2) {
  const result = [];
  while (value2) {
    result.unshift(value2 & 255);
    value2 >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset, length) {
  let result = 0;
  for (let i2 = 0; i2 < length; i2++) {
    result = result * 256 + data[offset + i2];
  }
  return result;
}
function _encode(object2) {
  if (Array.isArray(object2)) {
    let payload = [];
    object2.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  if (!isBytesLike(object2)) {
    logger$r.throwArgumentError("RLP object must be BytesLike", "object", object2);
  }
  const data = Array.prototype.slice.call(arrayify(object2));
  if (data.length === 1 && data[0] <= 127) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(128 + data.length);
    return data;
  }
  const length = arrayifyInteger(data.length);
  length.unshift(183 + length.length);
  return length.concat(data);
}
function encode$4(object2) {
  return hexlify(_encode(object2));
}
function _decodeChildren(data, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode$1(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger$r.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return { consumed: 1 + length, result };
}
function _decode$1(data, offset) {
  if (data.length === 0) {
    logger$r.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
  }
  if (data[offset] >= 248) {
    const lengthLength = data[offset] - 247;
    if (offset + 1 + lengthLength > data.length) {
      logger$r.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger$r.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 192) {
    const length = data[offset] - 192;
    if (offset + 1 + length > data.length) {
      logger$r.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 184) {
    const lengthLength = data[offset] - 183;
    if (offset + 1 + lengthLength > data.length) {
      logger$r.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const length = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length > data.length) {
      logger$r.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data[offset] >= 128) {
    const length = data[offset] - 128;
    if (offset + 1 + length > data.length) {
      logger$r.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    const result = hexlify(data.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlify(data[offset]) };
}
function decode$5(data) {
  const bytes3 = arrayify(data);
  const decoded = _decode$1(bytes3, 0);
  if (decoded.consumed !== bytes3.length) {
    logger$r.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}
var lib_esm$g = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  encode: encode$4,
  decode: decode$5
});
const version$l = "address/5.5.0";
const logger$q = new Logger(version$l);
function getChecksumAddress(address) {
  if (!isHexString$5(address, 20)) {
    logger$q.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i2 = 0; i2 < 40; i2++) {
    expanded[i2] = chars[i2].charCodeAt(0);
  }
  const hashed = arrayify(keccak256$1(expanded));
  for (let i2 = 0; i2 < 40; i2 += 2) {
    if (hashed[i2 >> 1] >> 4 >= 8) {
      chars[i2] = chars[i2].toUpperCase();
    }
    if ((hashed[i2 >> 1] & 15) >= 8) {
      chars[i2 + 1] = chars[i2 + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
const MAX_SAFE_INTEGER$2 = 9007199254740991;
function log10(x2) {
  if (Math.log10) {
    return Math.log10(x2);
  }
  return Math.log(x2) / Math.LN10;
}
const ibanLookup = {};
for (let i2 = 0; i2 < 10; i2++) {
  ibanLookup[String(i2)] = String(i2);
}
for (let i2 = 0; i2 < 26; i2++) {
  ibanLookup[String.fromCharCode(65 + i2)] = String(10 + i2);
}
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER$2));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map((c2) => {
    return ibanLookup[c2];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
function getAddress(address) {
  let result = null;
  if (typeof address !== "string") {
    logger$q.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger$q.throwArgumentError("bad address checksum", "address", address);
    }
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger$q.throwArgumentError("bad icap checksum", "address", address);
    }
    result = _base36To16(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger$q.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error2) {
  }
  return false;
}
function getIcapAddress(address) {
  let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getContractAddress(transaction) {
  let from2 = null;
  try {
    from2 = getAddress(transaction.from);
  } catch (error2) {
    logger$q.throwArgumentError("missing from address", "transaction", transaction);
  }
  const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
  return getAddress(hexDataSlice(keccak256$1(encode$4([from2, nonce])), 12));
}
function getCreate2Address(from2, salt, initCodeHash) {
  if (hexDataLength(salt) !== 32) {
    logger$q.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if (hexDataLength(initCodeHash) !== 32) {
    logger$q.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress(hexDataSlice(keccak256$1(concat$2(["0xff", getAddress(from2), salt, initCodeHash])), 12));
}
var lib_esm$f = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAddress,
  isAddress,
  getIcapAddress,
  getContractAddress,
  getCreate2Address
});
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, value2) {
    try {
      value2 = getAddress(value2);
    } catch (error2) {
      this._throwError(error2.message, value2);
    }
    return writer.writeValue(value2);
  }
  decode(reader) {
    return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));
  }
}
class AnonymousCoder extends Coder {
  constructor(coder) {
    super(coder.name, coder.type, void 0, coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value2) {
    return this.coder.encode(writer, value2);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}
const logger$p = new Logger(version$n);
function pack$1(writer, coders, values) {
  let arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name2 = coder.localName;
      if (!name2) {
        logger$p.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      if (unique[name2]) {
        logger$p.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder,
          value: values
        });
      }
      unique[name2] = true;
      return values[name2];
    });
  } else {
    logger$p.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger$p.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  let staticWriter = new Writer(writer.wordSize);
  let dynamicWriter = new Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index2) => {
    let value2 = arrayValues[index2];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value2);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value2);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value2 = null;
    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value2 = coder.decode(offsetReader);
      } catch (error2) {
        if (error2.code === Logger.errors.BUFFER_OVERRUN) {
          throw error2;
        }
        value2 = error2;
        value2.baseType = coder.name;
        value2.name = coder.localName;
        value2.type = coder.type;
      }
    } else {
      try {
        value2 = coder.decode(reader);
      } catch (error2) {
        if (error2.code === Logger.errors.BUFFER_OVERRUN) {
          throw error2;
        }
        value2 = error2;
        value2.baseType = coder.name;
        value2.name = coder.localName;
        value2.type = coder.type;
      }
    }
    if (value2 != void 0) {
      values.push(value2);
    }
  });
  const uniqueNames = coders.reduce((accum, coder) => {
    const name2 = coder.localName;
    if (name2) {
      if (!accum[name2]) {
        accum[name2] = 0;
      }
      accum[name2]++;
    }
    return accum;
  }, {});
  coders.forEach((coder, index2) => {
    let name2 = coder.localName;
    if (!name2 || uniqueNames[name2] !== 1) {
      return;
    }
    if (name2 === "length") {
      name2 = "_length";
    }
    if (values[name2] != null) {
      return;
    }
    const value2 = values[index2];
    if (value2 instanceof Error) {
      Object.defineProperty(values, name2, {
        enumerable: true,
        get: () => {
          throw value2;
        }
      });
    } else {
      values[name2] = value2;
    }
  });
  for (let i2 = 0; i2 < values.length; i2++) {
    const value2 = values[i2];
    if (value2 instanceof Error) {
      Object.defineProperty(values, i2, {
        enumerable: true,
        get: () => {
          throw value2;
        }
      });
    }
  }
  return Object.freeze(values);
}
class ArrayCoder extends Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length;
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i2 = 0; i2 < this.length; i2++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, value2) {
    if (!Array.isArray(value2)) {
      this._throwError("expected array value", value2);
    }
    let count2 = this.length;
    if (count2 === -1) {
      count2 = value2.length;
      writer.writeValue(value2.length);
    }
    logger$p.checkArgumentCount(value2.length, count2, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i2 = 0; i2 < value2.length; i2++) {
      coders.push(this.coder);
    }
    return pack$1(writer, coders, value2);
  }
  decode(reader) {
    let count2 = this.length;
    if (count2 === -1) {
      count2 = reader.readValue().toNumber();
      if (count2 * 32 > reader._data.length) {
        logger$p.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count: count2
        });
      }
    }
    let coders = [];
    for (let i2 = 0; i2 < count2; i2++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  }
}
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, value2) {
    return writer.writeValue(value2 ? 1 : 0);
  }
  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }
}
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value2) {
    value2 = arrayify(value2);
    let length = writer.writeValue(value2.length);
    length += writer.writeBytes(value2);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }
}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(super.decode(reader)));
  }
}
class FixedBytesCoder extends Coder {
  constructor(size2, localName) {
    let name2 = "bytes" + String(size2);
    super(name2, name2, localName, false);
    this.size = size2;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, value2) {
    let data = arrayify(value2);
    if (data.length !== this.size) {
      this._throwError("incorrect data length", value2);
    }
    return writer.writeBytes(data);
  }
  decode(reader) {
    return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
  }
}
class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value2) {
    if (value2 != null) {
      this._throwError("not null", value2);
    }
    return writer.writeBytes([]);
  }
  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }
}
const AddressZero = "0x0000000000000000000000000000000000000000";
const NegativeOne$1 = /* @__PURE__ */ BigNumber.from(-1);
const Zero$1 = /* @__PURE__ */ BigNumber.from(0);
const One$1 = /* @__PURE__ */ BigNumber.from(1);
const MaxUint256$1 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
class NumberCoder extends Coder {
  constructor(size2, signed, localName) {
    const name2 = (signed ? "int" : "uint") + size2 * 8;
    super(name2, name2, localName, false);
    this.size = size2;
    this.signed = signed;
  }
  defaultValue() {
    return 0;
  }
  encode(writer, value2) {
    let v2 = BigNumber.from(value2);
    let maxUintValue = MaxUint256$1.mask(writer.wordSize * 8);
    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v2.gt(bounds) || v2.lt(bounds.add(One$1).mul(NegativeOne$1))) {
        this._throwError("value out-of-bounds", value2);
      }
    } else if (v2.lt(Zero$1) || v2.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value2);
    }
    v2 = v2.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v2 = v2.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v2);
  }
  decode(reader) {
    let value2 = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value2 = value2.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value2);
  }
}
const version$k = "strings/5.5.0";
const logger$o = new Logger(version$k);
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm2) {
  UnicodeNormalizationForm2["current"] = "";
  UnicodeNormalizationForm2["NFC"] = "NFC";
  UnicodeNormalizationForm2["NFD"] = "NFD";
  UnicodeNormalizationForm2["NFKC"] = "NFKC";
  UnicodeNormalizationForm2["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason2) {
  Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
  Utf8ErrorReason2["OVERRUN"] = "string overrun";
  Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
  Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
  Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
  Utf8ErrorReason2["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes3, output, badCodepoint) {
  return logger$o.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes3);
}
function ignoreFunc(reason, offset, bytes3, output, badCodepoint) {
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i2 = 0;
    for (let o2 = offset + 1; o2 < bytes3.length; o2++) {
      if (bytes3[o2] >> 6 !== 2) {
        break;
      }
      i2++;
    }
    return i2;
  }
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes3.length - offset - 1;
  }
  return 0;
}
function replaceFunc(reason, offset, bytes3, output, badCodepoint) {
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  output.push(65533);
  return ignoreFunc(reason, offset, bytes3);
}
const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
function getUtf8CodePoints(bytes3, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  bytes3 = arrayify(bytes3);
  const result = [];
  let i2 = 0;
  while (i2 < bytes3.length) {
    const c2 = bytes3[i2++];
    if (c2 >> 7 === 0) {
      result.push(c2);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c2 & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c2 & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c2 & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c2 & 192) === 128) {
        i2 += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i2 - 1, bytes3, result);
      } else {
        i2 += onError(Utf8ErrorReason.BAD_PREFIX, i2 - 1, bytes3, result);
      }
      continue;
    }
    if (i2 - 1 + extraLength >= bytes3.length) {
      i2 += onError(Utf8ErrorReason.OVERRUN, i2 - 1, bytes3, result);
      continue;
    }
    let res = c2 & (1 << 8 - extraLength - 1) - 1;
    for (let j2 = 0; j2 < extraLength; j2++) {
      let nextChar = bytes3[i2];
      if ((nextChar & 192) != 128) {
        i2 += onError(Utf8ErrorReason.MISSING_CONTINUE, i2, bytes3, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i2++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i2 += onError(Utf8ErrorReason.OUT_OF_RANGE, i2 - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i2 += onError(Utf8ErrorReason.UTF16_SURROGATE, i2 - 1 - extraLength, bytes3, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i2 += onError(Utf8ErrorReason.OVERLONG, i2 - 1 - extraLength, bytes3, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
function toUtf8Bytes(str2, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger$o.checkNormalize();
    str2 = str2.normalize(form);
  }
  let result = [];
  for (let i2 = 0; i2 < str2.length; i2++) {
    const c2 = str2.charCodeAt(i2);
    if (c2 < 128) {
      result.push(c2);
    } else if (c2 < 2048) {
      result.push(c2 >> 6 | 192);
      result.push(c2 & 63 | 128);
    } else if ((c2 & 64512) == 55296) {
      i2++;
      const c22 = str2.charCodeAt(i2);
      if (i2 >= str2.length || (c22 & 64512) !== 56320) {
        throw new Error("invalid utf-8 string");
      }
      const pair = 65536 + ((c2 & 1023) << 10) + (c22 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c2 >> 12 | 224);
      result.push(c2 >> 6 & 63 | 128);
      result.push(c2 & 63 | 128);
    }
  }
  return arrayify(result);
}
function escapeChar(value2) {
  const hex = "0000" + value2.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes3, onError) {
  return '"' + getUtf8CodePoints(bytes3, onError).map((codePoint) => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 65535) {
      return escapeChar(codePoint);
    }
    codePoint -= 65536;
    return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
  }).join("") + '"';
}
function _toUtf8String(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
}
function toUtf8String(bytes3, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes3, onError));
}
function toUtf8CodePoints(str2, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str2, form));
}
function formatBytes32String(text2) {
  const bytes3 = toUtf8Bytes(text2);
  if (bytes3.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return hexlify(concat$2([bytes3, HashZero]).slice(0, 32));
}
function parseBytes32String(bytes3) {
  const data = arrayify(bytes3);
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data.slice(0, length));
}
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  let result = [];
  for (let i2 = 0; i2 < data.length; i2 += 4) {
    result.push(parseInt(data.substring(i2, i2 + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function(value2) {
      return [parseInt(value2, 16)];
    };
  }
  let lo = 0;
  let result = {};
  data.split(",").forEach((pair) => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map((v2) => {
    let comps = v2.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return { l: lo, h: hi };
  });
}
function matchMap(value2, ranges) {
  let lo = 0;
  for (let i2 = 0; i2 < ranges.length; i2++) {
    let range2 = ranges[i2];
    lo += range2.l;
    if (value2 >= lo && value2 <= lo + range2.h && (value2 - lo) % (range2.d || 1) === 0) {
      if (range2.e && range2.e.indexOf(value2 - lo) !== -1) {
        continue;
      }
      return range2;
    }
  }
  return null;
}
const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
const Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v2) => parseInt(v2, 16));
const Table_B_2_ranges = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
];
const Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
const Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
const Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
const Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
  return values.reduce((accum, value2) => {
    value2.forEach((value3) => {
      accum.push(value3);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range2 = matchMap(codepoint, Table_B_2_ranges);
  if (range2) {
    return [codepoint + range2.s];
  }
  let codes2 = Table_B_2_lut_abs[codepoint];
  if (codes2) {
    return codes2;
  }
  let shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  let complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value2) {
  if (value2.match(/^[a-z0-9-]*$/i) && value2.length <= 59) {
    return value2.toLowerCase();
  }
  let codes2 = toUtf8CodePoints(value2);
  codes2 = flatten(codes2.map((code2) => {
    if (Table_B_1_flags.indexOf(code2) >= 0) {
      return [];
    }
    if (code2 >= 65024 && code2 <= 65039) {
      return [];
    }
    let codesTableB2 = _nameprepTableB2(code2);
    if (codesTableB2) {
      return codesTableB2;
    }
    return [code2];
  }));
  codes2 = toUtf8CodePoints(_toUtf8String(codes2), UnicodeNormalizationForm.NFKC);
  codes2.forEach((code2) => {
    if (_nameprepTableC(code2)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  codes2.forEach((code2) => {
    if (_nameprepTableA1(code2)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  let name2 = _toUtf8String(codes2);
  if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  if (name2.length > 63) {
    throw new Error("too long");
  }
  return name2;
}
var lib_esm$e = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  _toEscapedUtf8String,
  toUtf8Bytes,
  toUtf8CodePoints,
  toUtf8String,
  Utf8ErrorFuncs,
  get Utf8ErrorReason() {
    return Utf8ErrorReason;
  },
  get UnicodeNormalizationForm() {
    return UnicodeNormalizationForm;
  },
  formatBytes32String,
  parseBytes32String,
  nameprep
});
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, value2) {
    return super.encode(writer, toUtf8Bytes(value2));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}
class TupleCoder extends Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types2 = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types2.push(coder.type);
    });
    const type = "tuple(" + types2.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders;
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index2) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      values[name2] = values[index2];
    });
    return Object.freeze(values);
  }
  encode(writer, value2) {
    return pack$1(writer, this.coders, value2);
  }
  decode(reader) {
    return reader.coerce(this.name, unpack(reader, this.coders));
  }
}
const logger$n = new Logger(version$n);
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(coerceFunc) {
    logger$n.checkNew(new.target, AbiCoder);
    defineReadOnly(this, "coerceFunc", coerceFunc || null);
  }
  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "array":
        return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new TupleCoder((param.components || []).map((component) => {
          return this._getCoder(component);
        }), param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size2 = parseInt(match[2] || "256");
      if (size2 === 0 || size2 > 256 || size2 % 8 !== 0) {
        logger$n.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new NumberCoder(size2 / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size2 = parseInt(match[1]);
      if (size2 === 0 || size2 > 32) {
        logger$n.throwArgumentError("invalid bytes length", "param", param);
      }
      return new FixedBytesCoder(size2, param.name);
    }
    return logger$n.throwArgumentError("invalid type", "type", param.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(data, allowLoose) {
    return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  }
  _getWriter() {
    return new Writer(this._getWordSize());
  }
  getDefaultValue(types2) {
    const coders = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types2, values) {
    if (types2.length !== values.length) {
      logger$n.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
        count: { types: types2.length, values: values.length },
        value: { types: types2, values }
      });
    }
    const coders = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types2, data, loose) {
    const coders = types2.map((type) => this._getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(this._getReader(arrayify(data), loose));
  }
}
const defaultAbiCoder = new AbiCoder();
function id(text2) {
  return keccak256$1(toUtf8Bytes(text2));
}
const version$j = "hash/5.5.0";
const logger$m = new Logger(version$j);
const Zeros$1 = new Uint8Array(32);
Zeros$1.fill(0);
const Partition = new RegExp("^((.*)\\.)?([^.]+)$");
function isValidName(name2) {
  try {
    const comps = name2.split(".");
    for (let i2 = 0; i2 < comps.length; i2++) {
      if (nameprep(comps[i2]).length === 0) {
        throw new Error("empty");
      }
    }
    return true;
  } catch (error2) {
  }
  return false;
}
function namehash(name2) {
  if (typeof name2 !== "string") {
    logger$m.throwArgumentError("invalid ENS name; not a string", "name", name2);
  }
  let current = name2;
  let result = Zeros$1;
  while (current.length) {
    const partition2 = current.match(Partition);
    if (partition2 == null || partition2[2] === "") {
      logger$m.throwArgumentError("invalid ENS address; missing component", "name", name2);
    }
    const label = toUtf8Bytes(nameprep(partition2[3]));
    result = keccak256$1(concat$2([result, keccak256$1(label)]));
    current = partition2[2] || "";
  }
  return hexlify(result);
}
const messagePrefix = "Ethereum Signed Message:\n";
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak256$1(concat$2([
    toUtf8Bytes(messagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
var __awaiter$9 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$l = new Logger(version$j);
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = BigNumber.from(-1);
const Zero = BigNumber.from(0);
const One = BigNumber.from(1);
const MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value2) {
  const bytes3 = arrayify(value2);
  const padOffset = bytes3.length % 32;
  if (padOffset) {
    return hexConcat([bytes3, padding.slice(padOffset)]);
  }
  return hexlify(bytes3);
}
const hexTrue = hexZeroPad(One.toHexString(), 32);
const hexFalse = hexZeroPad(Zero.toHexString(), 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function checkString(key2) {
  return function(value2) {
    if (typeof value2 !== "string") {
      logger$l.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value2);
    }
    return value2;
  };
}
const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(value2) {
    try {
      return BigNumber.from(value2).toString();
    } catch (error2) {
    }
    return logger$l.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value2);
  },
  verifyingContract: function(value2) {
    try {
      return getAddress(value2).toLowerCase();
    } catch (error2) {
    }
    return logger$l.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value2);
  },
  salt: function(value2) {
    try {
      const bytes3 = arrayify(value2);
      if (bytes3.length !== 32) {
        throw new Error("bad length");
      }
      return hexlify(bytes3);
    } catch (error2) {
    }
    return logger$l.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value2);
  }
};
function getBaseEncoder(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger$l.throwArgumentError("invalid numeric width", "type", type);
      }
      const boundsUpper = MaxUint256.mask(signed ? width - 1 : width);
      const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;
      return function(value2) {
        const v2 = BigNumber.from(value2);
        if (v2.lt(boundsLower) || v2.gt(boundsUpper)) {
          logger$l.throwArgumentError(`value out-of-bounds for ${type}`, "value", value2);
        }
        return hexZeroPad(v2.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger$l.throwArgumentError("invalid bytes width", "type", type);
      }
      return function(value2) {
        const bytes3 = arrayify(value2);
        if (bytes3.length !== width) {
          logger$l.throwArgumentError(`invalid length for ${type}`, "value", value2);
        }
        return hexPadRight(value2);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value2) {
        return hexZeroPad(getAddress(value2), 32);
      };
    case "bool":
      return function(value2) {
        return !value2 ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value2) {
        return keccak256$1(value2);
      };
    case "string":
      return function(value2) {
        return id(value2);
      };
  }
  return null;
}
function encodeType(name2, fields) {
  return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
}
class TypedDataEncoder {
  constructor(types2) {
    defineReadOnly(this, "types", Object.freeze(deepCopy(types2)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {});
    const links = {};
    const parents = {};
    const subtypes = {};
    Object.keys(types2).forEach((type) => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    for (const name2 in types2) {
      const uniqueNames = {};
      types2[name2].forEach((field) => {
        if (uniqueNames[field.name]) {
          logger$l.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types2);
        }
        uniqueNames[field.name] = true;
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name2) {
          logger$l.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types2);
        }
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger$l.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types2);
        }
        parents[baseType].push(name2);
        links[name2][baseType] = true;
      });
    }
    const primaryTypes = Object.keys(parents).filter((n2) => parents[n2].length === 0);
    if (primaryTypes.length === 0) {
      logger$l.throwArgumentError("missing primary type", "types", types2);
    } else if (primaryTypes.length > 1) {
      logger$l.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", types2);
    }
    defineReadOnly(this, "primaryType", primaryTypes[0]);
    function checkCircular(type, found) {
      if (found[type]) {
        logger$l.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types2);
      }
      found[type] = true;
      Object.keys(links[type]).forEach((child) => {
        if (!parents[child]) {
          return;
        }
        checkCircular(child, found);
        Object.keys(found).forEach((subtype) => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    for (const name2 in subtypes) {
      const st = Object.keys(subtypes[name2]);
      st.sort();
      this._types[name2] = encodeType(name2, types2[name2]) + st.map((t2) => encodeType(t2, types2[t2])).join("");
    }
  }
  getEncoder(type) {
    let encoder = this._encoderCache[type];
    if (!encoder) {
      encoder = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder;
  }
  _getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length = parseInt(match[3]);
      return (value2) => {
        if (length >= 0 && value2.length !== length) {
          logger$l.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value2);
        }
        let result = value2.map(subEncoder);
        if (this._types[subtype]) {
          result = result.map(keccak256$1);
        }
        return keccak256$1(hexConcat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this._types[type]);
      return (value2) => {
        const values = fields.map(({ name: name2, type: type2 }) => {
          const result = this.getEncoder(type2)(value2[name2]);
          if (this._types[type2]) {
            return keccak256$1(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return hexConcat(values);
      };
    }
    return logger$l.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  encodeType(name2) {
    const result = this._types[name2];
    if (!result) {
      logger$l.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
    }
    return result;
  }
  encodeData(type, value2) {
    return this.getEncoder(type)(value2);
  }
  hashStruct(name2, value2) {
    return keccak256$1(this.encodeData(name2, value2));
  }
  encode(value2) {
    return this.encodeData(this.primaryType, value2);
  }
  hash(value2) {
    return this.hashStruct(this.primaryType, value2);
  }
  _visit(type, value2, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value2);
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const length = parseInt(match[3]);
      if (length >= 0 && value2.length !== length) {
        logger$l.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value2);
      }
      return value2.map((v2) => this._visit(subtype, v2, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name: name2, type: type2 }) => {
        accum[name2] = this._visit(type2, value2[name2], callback);
        return accum;
      }, {});
    }
    return logger$l.throwArgumentError(`unknown type: ${type}`, "type", type);
  }
  visit(value2, callback) {
    return this._visit(this.primaryType, value2, callback);
  }
  static from(types2) {
    return new TypedDataEncoder(types2);
  }
  static getPrimaryType(types2) {
    return TypedDataEncoder.from(types2).primaryType;
  }
  static hashStruct(name2, types2, value2) {
    return TypedDataEncoder.from(types2).hashStruct(name2, value2);
  }
  static hashDomain(domain2) {
    const domainFields = [];
    for (const name2 in domain2) {
      const type = domainFieldTypes[name2];
      if (!type) {
        logger$l.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain2);
      }
      domainFields.push({ name: name2, type });
    }
    domainFields.sort((a2, b2) => {
      return domainFieldNames.indexOf(a2.name) - domainFieldNames.indexOf(b2.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain2);
  }
  static encode(domain2, types2, value2) {
    return hexConcat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain2),
      TypedDataEncoder.from(types2).hash(value2)
    ]);
  }
  static hash(domain2, types2, value2) {
    return keccak256$1(TypedDataEncoder.encode(domain2, types2, value2));
  }
  static resolveNames(domain2, types2, value2, resolveName) {
    return __awaiter$9(this, void 0, void 0, function* () {
      domain2 = shallowCopy(domain2);
      const ensCache = {};
      if (domain2.verifyingContract && !isHexString$5(domain2.verifyingContract, 20)) {
        ensCache[domain2.verifyingContract] = "0x";
      }
      const encoder = TypedDataEncoder.from(types2);
      encoder.visit(value2, (type, value3) => {
        if (type === "address" && !isHexString$5(value3, 20)) {
          ensCache[value3] = "0x";
        }
        return value3;
      });
      for (const name2 in ensCache) {
        ensCache[name2] = yield resolveName(name2);
      }
      if (domain2.verifyingContract && ensCache[domain2.verifyingContract]) {
        domain2.verifyingContract = ensCache[domain2.verifyingContract];
      }
      value2 = encoder.visit(value2, (type, value3) => {
        if (type === "address" && ensCache[value3]) {
          return ensCache[value3];
        }
        return value3;
      });
      return { domain: domain2, value: value2 };
    });
  }
  static getPayload(domain2, types2, value2) {
    TypedDataEncoder.hashDomain(domain2);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name2) => {
      const value3 = domain2[name2];
      if (value3 == null) {
        return;
      }
      domainValues[name2] = domainChecks[name2](value3);
      domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
    });
    const encoder = TypedDataEncoder.from(types2);
    const typesWithDomain = shallowCopy(types2);
    if (typesWithDomain.EIP712Domain) {
      logger$l.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types2);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    encoder.encode(value2);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value2, (type, value3) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(arrayify(value3));
        }
        if (type.match(/^u?int/)) {
          return BigNumber.from(value3).toString();
        }
        switch (type) {
          case "address":
            return value3.toLowerCase();
          case "bool":
            return !!value3;
          case "string":
            if (typeof value3 !== "string") {
              logger$l.throwArgumentError(`invalid string`, "value", value3);
            }
            return value3;
        }
        return logger$l.throwArgumentError("unsupported type", "type", type);
      })
    };
  }
}
var lib_esm$d = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  id,
  namehash,
  isValidName,
  messagePrefix,
  hashMessage,
  _TypedDataEncoder: TypedDataEncoder
});
const logger$k = new Logger(version$n);
class LogDescription extends Description {
}
class TransactionDescription extends Description {
}
class ErrorDescription extends Description {
}
class Indexed extends Description {
  static isIndexed(value2) {
    return !!(value2 && value2._isIndexed);
  }
}
const BuiltinErrors = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error2) {
  const wrap2 = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap2.error = error2;
  return wrap2;
}
class Interface {
  constructor(fragments) {
    logger$k.checkNew(new.target, Interface);
    let abi2 = [];
    if (typeof fragments === "string") {
      abi2 = JSON.parse(fragments);
    } else {
      abi2 = fragments;
    }
    defineReadOnly(this, "fragments", abi2.map((fragment) => {
      return Fragment.from(fragment);
    }).filter((fragment) => fragment != null));
    defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
    defineReadOnly(this, "functions", {});
    defineReadOnly(this, "errors", {});
    defineReadOnly(this, "events", {});
    defineReadOnly(this, "structs", {});
    this.fragments.forEach((fragment) => {
      let bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger$k.warn("duplicate definition - constructor");
            return;
          }
          defineReadOnly(this, "deploy", fragment);
          return;
        case "function":
          bucket = this.functions;
          break;
        case "event":
          bucket = this.events;
          break;
        case "error":
          bucket = this.errors;
          break;
        default:
          return;
      }
      let signature2 = fragment.format();
      if (bucket[signature2]) {
        logger$k.warn("duplicate definition - " + signature2);
        return;
      }
      bucket[signature2] = fragment;
    });
    if (!this.deploy) {
      defineReadOnly(this, "deploy", ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    defineReadOnly(this, "_isInterface", true);
  }
  format(format2) {
    if (!format2) {
      format2 = FormatTypes.full;
    }
    if (format2 === FormatTypes.sighash) {
      logger$k.throwArgumentError("interface does not support formatting sighash", "format", format2);
    }
    const abi2 = this.fragments.map((fragment) => fragment.format(format2));
    if (format2 === FormatTypes.json) {
      return JSON.stringify(abi2.map((j2) => JSON.parse(j2)));
    }
    return abi2;
  }
  static getAbiCoder() {
    return defaultAbiCoder;
  }
  static getAddress(address) {
    return getAddress(address);
  }
  static getSighash(fragment) {
    return hexDataSlice(id(fragment.format()), 0, 4);
  }
  static getEventTopic(eventFragment) {
    return id(eventFragment.format());
  }
  getFunction(nameOrSignatureOrSighash) {
    if (isHexString$5(nameOrSignatureOrSighash)) {
      for (const name2 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name2)) {
          return this.functions[name2];
        }
      }
      logger$k.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter((f2) => f2.split("(")[0] === name2);
      if (matching.length === 0) {
        logger$k.throwArgumentError("no matching function", "name", name2);
      } else if (matching.length > 1) {
        logger$k.throwArgumentError("multiple matching functions", "name", name2);
      }
      return this.functions[matching[0]];
    }
    const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$k.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getEvent(nameOrSignatureOrTopic) {
    if (isHexString$5(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();
      for (const name2 in this.events) {
        if (topichash === this.getEventTopic(name2)) {
          return this.events[name2];
        }
      }
      logger$k.throwArgumentError("no matching event", "topichash", topichash);
    }
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter((f2) => f2.split("(")[0] === name2);
      if (matching.length === 0) {
        logger$k.throwArgumentError("no matching event", "name", name2);
      } else if (matching.length > 1) {
        logger$k.throwArgumentError("multiple matching events", "name", name2);
      }
      return this.events[matching[0]];
    }
    const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger$k.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  }
  getError(nameOrSignatureOrSighash) {
    if (isHexString$5(nameOrSignatureOrSighash)) {
      const getSighash = getStatic(this.constructor, "getSighash");
      for (const name2 in this.errors) {
        const error2 = this.errors[name2];
        if (nameOrSignatureOrSighash === getSighash(error2)) {
          return this.errors[name2];
        }
      }
      logger$k.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name2 = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter((f2) => f2.split("(")[0] === name2);
      if (matching.length === 0) {
        logger$k.throwArgumentError("no matching error", "name", name2);
      } else if (matching.length > 1) {
        logger$k.throwArgumentError("multiple matching errors", "name", name2);
      }
      return this.errors[matching[0]];
    }
    const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger$k.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  }
  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error2) {
        try {
          fragment = this.getError(fragment);
        } catch (_2) {
          throw error2;
        }
      }
    }
    return getStatic(this.constructor, "getSighash")(fragment);
  }
  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return getStatic(this.constructor, "getEventTopic")(eventFragment);
  }
  _decodeParams(params, data) {
    return this._abiCoder.decode(params, data);
  }
  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    const bytes3 = arrayify(data);
    if (hexlify(bytes3.slice(0, 4)) !== this.getSighash(fragment)) {
      logger$k.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes3));
    }
    return this._decodeParams(fragment.inputs, bytes3.slice(4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return hexlify(concat$2([
      this.getSighash(fragment),
      this._encodeParams(fragment.inputs, values || [])
    ]));
  }
  decodeFunctionData(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    const bytes3 = arrayify(data);
    if (hexlify(bytes3.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger$k.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes3));
    }
    return this._decodeParams(functionFragment.inputs, bytes3.slice(4));
  }
  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(concat$2([
      this.getSighash(functionFragment),
      this._encodeParams(functionFragment.inputs, values || [])
    ]));
  }
  decodeFunctionResult(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    let bytes3 = arrayify(data);
    let reason = null;
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;
    switch (bytes3.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes3);
        } catch (error2) {
        }
        break;
      case 4: {
        const selector = hexlify(bytes3.slice(0, 4));
        const builtin = BuiltinErrors[selector];
        if (builtin) {
          errorArgs = this._abiCoder.decode(builtin.inputs, bytes3.slice(4));
          errorName = builtin.name;
          errorSignature = builtin.signature;
          if (builtin.reason) {
            reason = errorArgs[0];
          }
        } else {
          try {
            const error2 = this.getError(selector);
            errorArgs = this._abiCoder.decode(error2.inputs, bytes3.slice(4));
            errorName = error2.name;
            errorSignature = error2.format();
          } catch (error2) {
            console.log(error2);
          }
        }
        break;
      }
    }
    return logger$k.throwError("call revert exception", Logger.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  }
  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
  }
  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger$k.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    let topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    const encodeTopic = (param, value2) => {
      if (param.type === "string") {
        return id(value2);
      } else if (param.type === "bytes") {
        return keccak256$1(hexlify(value2));
      }
      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value2]);
      }
      return hexZeroPad(hexlify(value2), 32);
    };
    values.forEach((value2, index2) => {
      let param = eventFragment.inputs[index2];
      if (!param.indexed) {
        if (value2 != null) {
          logger$k.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value2);
        }
        return;
      }
      if (value2 == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger$k.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value2);
      } else if (Array.isArray(value2)) {
        topics.push(value2.map((value3) => encodeTopic(param, value3)));
      } else {
        topics.push(encodeTopic(param, value2));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger$k.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach((param, index2) => {
      const value2 = values[index2];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value2));
        } else if (param.type === "bytes") {
          topics.push(keccak256$1(value2));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value2]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value2);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  decodeEventLog(eventFragment, data, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);
      if (!isHexString$5(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger$k.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
      }
      topics = topics.slice(1);
    }
    let indexed = [];
    let nonIndexed = [];
    let dynamic = [];
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat$2(topics)) : null;
    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
    let result = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    eventFragment.inputs.forEach((param, index2) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index2] = new Indexed({ _isIndexed: true, hash: null });
        } else if (dynamic[index2]) {
          result[index2] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
        } else {
          try {
            result[index2] = resultIndexed[indexedIndex++];
          } catch (error2) {
            result[index2] = error2;
          }
        }
      } else {
        try {
          result[index2] = resultNonIndexed[nonIndexedIndex++];
        } catch (error2) {
          result[index2] = error2;
        }
      }
      if (param.name && result[param.name] == null) {
        const value2 = result[index2];
        if (value2 instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value2);
            }
          });
        } else {
          result[param.name] = value2;
        }
      }
    });
    for (let i2 = 0; i2 < result.length; i2++) {
      const value2 = result[i2];
      if (value2 instanceof Error) {
        Object.defineProperty(result, i2, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i2}`, value2);
          }
        });
      }
    }
    return Object.freeze(result);
  }
  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: BigNumber.from(tx.value || "0")
    });
  }
  parseLog(log2) {
    let fragment = this.getEvent(log2.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log2.data, log2.topics)
    });
  }
  parseError(data) {
    const hexData = hexlify(data);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  static isInterface(value2) {
    return !!(value2 && value2._isInterface);
  }
}
var lib_esm$c = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  ConstructorFragment,
  ErrorFragment,
  EventFragment,
  Fragment,
  FunctionFragment,
  ParamType,
  FormatTypes,
  AbiCoder,
  defaultAbiCoder,
  Interface,
  Indexed,
  checkResultErrors,
  LogDescription,
  TransactionDescription
});
function detectEthereumProvider({ mustBeMetaMask = false, silent = false, timeout: timeout2 = 3e3 } = {}) {
  _validateInputs();
  let handled = false;
  return new Promise((resolve2) => {
    if (window.ethereum) {
      handleEthereum();
    } else {
      window.addEventListener("ethereum#initialized", handleEthereum, { once: true });
      setTimeout(() => {
        handleEthereum();
      }, timeout2);
    }
    function handleEthereum() {
      if (handled) {
        return;
      }
      handled = true;
      window.removeEventListener("ethereum#initialized", handleEthereum);
      const { ethereum } = window;
      if (ethereum && (!mustBeMetaMask || ethereum.isMetaMask)) {
        resolve2(ethereum);
      } else {
        const message = mustBeMetaMask && ethereum ? "Non-MetaMask window.ethereum detected." : "Unable to detect window.ethereum.";
        !silent && console.error("@metamask/detect-provider:", message);
        resolve2(null);
      }
    }
  });
  function _validateInputs() {
    if (typeof mustBeMetaMask !== "boolean") {
      throw new Error(`@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.`);
    }
    if (typeof silent !== "boolean") {
      throw new Error(`@metamask/detect-provider: Expected option 'silent' to be a boolean.`);
    }
    if (typeof timeout2 !== "number") {
      throw new Error(`@metamask/detect-provider: Expected option 'timeout' to be a number.`);
    }
  }
}
var dist$6 = detectEthereumProvider;
var utils$r = {};
var require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$c);
var require$$1$3 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$f);
function decode$4(textData) {
  textData = atob(textData);
  const data = [];
  for (let i2 = 0; i2 < textData.length; i2++) {
    data.push(textData.charCodeAt(i2));
  }
  return arrayify(data);
}
function encode$3(data) {
  data = arrayify(data);
  let textData = "";
  for (let i2 = 0; i2 < data.length; i2++) {
    textData += String.fromCharCode(data[i2]);
  }
  return btoa(textData);
}
var lib_esm$b = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  decode: decode$4,
  encode: encode$3
});
var require$$2$3 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$b);
class BaseX {
  constructor(alphabet) {
    defineReadOnly(this, "alphabet", alphabet);
    defineReadOnly(this, "base", alphabet.length);
    defineReadOnly(this, "_alphabetMap", {});
    defineReadOnly(this, "_leader", alphabet.charAt(0));
    for (let i2 = 0; i2 < alphabet.length; i2++) {
      this._alphabetMap[alphabet.charAt(i2)] = i2;
    }
  }
  encode(value2) {
    let source = arrayify(value2);
    if (source.length === 0) {
      return "";
    }
    let digits = [0];
    for (let i2 = 0; i2 < source.length; ++i2) {
      let carry = source[i2];
      for (let j2 = 0; j2 < digits.length; ++j2) {
        carry += digits[j2] << 8;
        digits[j2] = carry % this.base;
        carry = carry / this.base | 0;
      }
      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }
    let string2 = "";
    for (let k2 = 0; source[k2] === 0 && k2 < source.length - 1; ++k2) {
      string2 += this._leader;
    }
    for (let q2 = digits.length - 1; q2 >= 0; --q2) {
      string2 += this.alphabet[digits[q2]];
    }
    return string2;
  }
  decode(value2) {
    if (typeof value2 !== "string") {
      throw new TypeError("Expected String");
    }
    let bytes3 = [];
    if (value2.length === 0) {
      return new Uint8Array(bytes3);
    }
    bytes3.push(0);
    for (let i2 = 0; i2 < value2.length; i2++) {
      let byte2 = this._alphabetMap[value2[i2]];
      if (byte2 === void 0) {
        throw new Error("Non-base" + this.base + " character");
      }
      let carry = byte2;
      for (let j2 = 0; j2 < bytes3.length; ++j2) {
        carry += bytes3[j2] * this.base;
        bytes3[j2] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes3.push(carry & 255);
        carry >>= 8;
      }
    }
    for (let k2 = 0; value2[k2] === this._leader && k2 < value2.length - 1; ++k2) {
      bytes3.push(0);
    }
    return arrayify(new Uint8Array(bytes3.reverse()));
  }
}
const Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var lib_esm$a = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  BaseX,
  Base32,
  Base58
});
var require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$a);
var require$$4 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$j);
var require$$5 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$d);
var hash$4 = {};
var utils$q = {};
var minimalisticAssert$1 = assert$j;
function assert$j(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$j.equal = function assertEqual(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var inherits_browser$1 = { exports: {} };
if (typeof Object.create === "function") {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  inherits_browser$1.exports = function inherits2(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
var assert$i = minimalisticAssert$1;
var inherits$j = inherits_browser$1.exports;
utils$q.inherits = inherits$j;
function isSurrogatePair(msg, i2) {
  if ((msg.charCodeAt(i2) & 64512) !== 55296) {
    return false;
  }
  if (i2 < 0 || i2 + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
}
function toArray$1(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === "string") {
    if (!enc) {
      var p2 = 0;
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        if (c2 < 128) {
          res[p2++] = c2;
        } else if (c2 < 2048) {
          res[p2++] = c2 >> 6 | 192;
          res[p2++] = c2 & 63 | 128;
        } else if (isSurrogatePair(msg, i2)) {
          c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i2) & 1023);
          res[p2++] = c2 >> 18 | 240;
          res[p2++] = c2 >> 12 & 63 | 128;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        } else {
          res[p2++] = c2 >> 12 | 224;
          res[p2++] = c2 >> 6 & 63 | 128;
          res[p2++] = c2 & 63 | 128;
        }
      }
    } else if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    }
  } else {
    for (i2 = 0; i2 < msg.length; i2++)
      res[i2] = msg[i2] | 0;
  }
  return res;
}
utils$q.toArray = toArray$1;
function toHex(msg) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++)
    res += zero2(msg[i2].toString(16));
  return res;
}
utils$q.toHex = toHex;
function htonl(w2) {
  var res = w2 >>> 24 | w2 >>> 8 & 65280 | w2 << 8 & 16711680 | (w2 & 255) << 24;
  return res >>> 0;
}
utils$q.htonl = htonl;
function toHex32(msg, endian) {
  var res = "";
  for (var i2 = 0; i2 < msg.length; i2++) {
    var w2 = msg[i2];
    if (endian === "little")
      w2 = htonl(w2);
    res += zero8(w2.toString(16));
  }
  return res;
}
utils$q.toHex32 = toHex32;
function zero2(word2) {
  if (word2.length === 1)
    return "0" + word2;
  else
    return word2;
}
utils$q.zero2 = zero2;
function zero8(word2) {
  if (word2.length === 7)
    return "0" + word2;
  else if (word2.length === 6)
    return "00" + word2;
  else if (word2.length === 5)
    return "000" + word2;
  else if (word2.length === 4)
    return "0000" + word2;
  else if (word2.length === 3)
    return "00000" + word2;
  else if (word2.length === 2)
    return "000000" + word2;
  else if (word2.length === 1)
    return "0000000" + word2;
  else
    return word2;
}
utils$q.zero8 = zero8;
function join32(msg, start, end, endian) {
  var len2 = end - start;
  assert$i(len2 % 4 === 0);
  var res = new Array(len2 / 4);
  for (var i2 = 0, k2 = start; i2 < res.length; i2++, k2 += 4) {
    var w2;
    if (endian === "big")
      w2 = msg[k2] << 24 | msg[k2 + 1] << 16 | msg[k2 + 2] << 8 | msg[k2 + 3];
    else
      w2 = msg[k2 + 3] << 24 | msg[k2 + 2] << 16 | msg[k2 + 1] << 8 | msg[k2];
    res[i2] = w2 >>> 0;
  }
  return res;
}
utils$q.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i2 = 0, k2 = 0; i2 < msg.length; i2++, k2 += 4) {
    var m2 = msg[i2];
    if (endian === "big") {
      res[k2] = m2 >>> 24;
      res[k2 + 1] = m2 >>> 16 & 255;
      res[k2 + 2] = m2 >>> 8 & 255;
      res[k2 + 3] = m2 & 255;
    } else {
      res[k2 + 3] = m2 >>> 24;
      res[k2 + 2] = m2 >>> 16 & 255;
      res[k2 + 1] = m2 >>> 8 & 255;
      res[k2] = m2 & 255;
    }
  }
  return res;
}
utils$q.split32 = split32;
function rotr32$1(w2, b2) {
  return w2 >>> b2 | w2 << 32 - b2;
}
utils$q.rotr32 = rotr32$1;
function rotl32$2(w2, b2) {
  return w2 << b2 | w2 >>> 32 - b2;
}
utils$q.rotl32 = rotl32$2;
function sum32$3(a2, b2) {
  return a2 + b2 >>> 0;
}
utils$q.sum32 = sum32$3;
function sum32_3$1(a2, b2, c2) {
  return a2 + b2 + c2 >>> 0;
}
utils$q.sum32_3 = sum32_3$1;
function sum32_4$2(a2, b2, c2, d2) {
  return a2 + b2 + c2 + d2 >>> 0;
}
utils$q.sum32_4 = sum32_4$2;
function sum32_5$2(a2, b2, c2, d2, e2) {
  return a2 + b2 + c2 + d2 + e2 >>> 0;
}
utils$q.sum32_5 = sum32_5$2;
function sum64$1(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
utils$q.sum64 = sum64$1;
function sum64_hi$1(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
utils$q.sum64_hi = sum64_hi$1;
function sum64_lo$1(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
utils$q.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(ah, al, bh, bl, ch2, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch2 + dh + carry;
  return hi >>> 0;
}
utils$q.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(ah, al, bh, bl, ch2, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
utils$q.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(ah, al, bh, bl, ch2, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch2 + dh + eh + carry;
  return hi >>> 0;
}
utils$q.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(ah, al, bh, bl, ch2, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}
utils$q.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(ah, al, num) {
  var r2 = al << 32 - num | ah >>> num;
  return r2 >>> 0;
}
utils$q.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$q.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(ah, al, num) {
  return ah >>> num;
}
utils$q.shr64_hi = shr64_hi$1;
function shr64_lo$1(ah, al, num) {
  var r2 = ah << 32 - num | al >>> num;
  return r2 >>> 0;
}
utils$q.shr64_lo = shr64_lo$1;
var common$5 = {};
var utils$p = utils$q;
var assert$h = minimalisticAssert$1;
function BlockHash$4() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = "big";
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function update(msg, enc) {
  msg = utils$p.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;
  if (this.pending.length >= this._delta8) {
    msg = this.pending;
    var r2 = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r2, msg.length);
    if (this.pending.length === 0)
      this.pending = null;
    msg = utils$p.join32(msg, 0, msg.length - r2, this.endian);
    for (var i2 = 0; i2 < msg.length; i2 += this._delta32)
      this._update(msg, i2, i2 + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert$h(this.pending === null);
  return this._digest(enc);
};
BlockHash$4.prototype._pad = function pad() {
  var len2 = this.pendingTotal;
  var bytes3 = this._delta8;
  var k2 = bytes3 - (len2 + this.padLength) % bytes3;
  var res = new Array(k2 + this.padLength);
  res[0] = 128;
  for (var i2 = 1; i2 < k2; i2++)
    res[i2] = 0;
  len2 <<= 3;
  if (this.endian === "big") {
    for (var t2 = 8; t2 < this.padLength; t2++)
      res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = len2 >>> 24 & 255;
    res[i2++] = len2 >>> 16 & 255;
    res[i2++] = len2 >>> 8 & 255;
    res[i2++] = len2 & 255;
  } else {
    res[i2++] = len2 & 255;
    res[i2++] = len2 >>> 8 & 255;
    res[i2++] = len2 >>> 16 & 255;
    res[i2++] = len2 >>> 24 & 255;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    res[i2++] = 0;
    for (t2 = 8; t2 < this.padLength; t2++)
      res[i2++] = 0;
  }
  return res;
};
var sha$2 = {};
var common$4 = {};
var utils$o = utils$q;
var rotr32 = utils$o.rotr32;
function ft_1$1(s2, x2, y2, z2) {
  if (s2 === 0)
    return ch32$1(x2, y2, z2);
  if (s2 === 1 || s2 === 3)
    return p32(x2, y2, z2);
  if (s2 === 2)
    return maj32$1(x2, y2, z2);
}
common$4.ft_1 = ft_1$1;
function ch32$1(x2, y2, z2) {
  return x2 & y2 ^ ~x2 & z2;
}
common$4.ch32 = ch32$1;
function maj32$1(x2, y2, z2) {
  return x2 & y2 ^ x2 & z2 ^ y2 & z2;
}
common$4.maj32 = maj32$1;
function p32(x2, y2, z2) {
  return x2 ^ y2 ^ z2;
}
common$4.p32 = p32;
function s0_256$1(x2) {
  return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(x2) {
  return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(x2) {
  return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(x2) {
  return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$n = utils$q;
var common$3 = common$5;
var shaCommon$1 = common$4;
var rotl32$1 = utils$n.rotl32;
var sum32$2 = utils$n.sum32;
var sum32_5$1 = utils$n.sum32_5;
var ft_1 = shaCommon$1.ft_1;
var BlockHash$3 = common$3.BlockHash;
var sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this);
  this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ];
  this.W = new Array(80);
}
utils$n.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W2[i2] = msg[start + i2];
  for (; i2 < W2.length; i2++)
    W2[i2] = rotl32$1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16], 1);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  for (i2 = 0; i2 < W2.length; i2++) {
    var s2 = ~~(i2 / 20);
    var t2 = sum32_5$1(rotl32$1(a2, 5), ft_1(s2, b2, c2, d2), e2, W2[i2], sha1_K[s2]);
    e2 = d2;
    d2 = c2;
    c2 = rotl32$1(b2, 30);
    b2 = a2;
    a2 = t2;
  }
  this.h[0] = sum32$2(this.h[0], a2);
  this.h[1] = sum32$2(this.h[1], b2);
  this.h[2] = sum32$2(this.h[2], c2);
  this.h[3] = sum32$2(this.h[3], d2);
  this.h[4] = sum32$2(this.h[4], e2);
};
SHA1.prototype._digest = function digest2(enc) {
  if (enc === "hex")
    return utils$n.toHex32(this.h, "big");
  else
    return utils$n.split32(this.h, "big");
};
var utils$m = utils$q;
var common$2 = common$5;
var shaCommon = common$4;
var assert$g = minimalisticAssert$1;
var sum32$1 = utils$m.sum32;
var sum32_4$1 = utils$m.sum32_4;
var sum32_5 = utils$m.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash$2 = common$2.BlockHash;
var sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this);
  this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils$m.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function _update2(msg, start) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 16; i2++)
    W2[i2] = msg[start + i2];
  for (; i2 < W2.length; i2++)
    W2[i2] = sum32_4$1(g1_256(W2[i2 - 2]), W2[i2 - 7], g0_256(W2[i2 - 15]), W2[i2 - 16]);
  var a2 = this.h[0];
  var b2 = this.h[1];
  var c2 = this.h[2];
  var d2 = this.h[3];
  var e2 = this.h[4];
  var f2 = this.h[5];
  var g2 = this.h[6];
  var h2 = this.h[7];
  assert$g(this.k.length === W2.length);
  for (i2 = 0; i2 < W2.length; i2++) {
    var T1 = sum32_5(h2, s1_256(e2), ch32(e2, f2, g2), this.k[i2], W2[i2]);
    var T2 = sum32$1(s0_256(a2), maj32(a2, b2, c2));
    h2 = g2;
    g2 = f2;
    f2 = e2;
    e2 = sum32$1(d2, T1);
    d2 = c2;
    c2 = b2;
    b2 = a2;
    a2 = sum32$1(T1, T2);
  }
  this.h[0] = sum32$1(this.h[0], a2);
  this.h[1] = sum32$1(this.h[1], b2);
  this.h[2] = sum32$1(this.h[2], c2);
  this.h[3] = sum32$1(this.h[3], d2);
  this.h[4] = sum32$1(this.h[4], e2);
  this.h[5] = sum32$1(this.h[5], f2);
  this.h[6] = sum32$1(this.h[6], g2);
  this.h[7] = sum32$1(this.h[7], h2);
};
SHA256$1.prototype._digest = function digest3(enc) {
  if (enc === "hex")
    return utils$m.toHex32(this.h, "big");
  else
    return utils$m.split32(this.h, "big");
};
var utils$l = utils$q;
var SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this);
  this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$l.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest4(enc) {
  if (enc === "hex")
    return utils$l.toHex32(this.h.slice(0, 7), "big");
  else
    return utils$l.split32(this.h.slice(0, 7), "big");
};
var utils$k = utils$q;
var common$1 = common$5;
var assert$f = minimalisticAssert$1;
var rotr64_hi = utils$k.rotr64_hi;
var rotr64_lo = utils$k.rotr64_lo;
var shr64_hi = utils$k.shr64_hi;
var shr64_lo = utils$k.shr64_lo;
var sum64 = utils$k.sum64;
var sum64_hi = utils$k.sum64_hi;
var sum64_lo = utils$k.sum64_lo;
var sum64_4_hi = utils$k.sum64_4_hi;
var sum64_4_lo = utils$k.sum64_4_lo;
var sum64_5_hi = utils$k.sum64_5_hi;
var sum64_5_lo = utils$k.sum64_5_lo;
var BlockHash$1 = common$1.BlockHash;
var sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$2() {
  if (!(this instanceof SHA512$2))
    return new SHA512$2();
  BlockHash$1.call(this);
  this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils$k.inherits(SHA512$2, BlockHash$1);
var _512 = SHA512$2;
SHA512$2.blockSize = 1024;
SHA512$2.outSize = 512;
SHA512$2.hmacStrength = 192;
SHA512$2.padLength = 128;
SHA512$2.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W2 = this.W;
  for (var i2 = 0; i2 < 32; i2++)
    W2[i2] = msg[start + i2];
  for (; i2 < W2.length; i2 += 2) {
    var c0_hi = g1_512_hi(W2[i2 - 4], W2[i2 - 3]);
    var c0_lo = g1_512_lo(W2[i2 - 4], W2[i2 - 3]);
    var c1_hi = W2[i2 - 14];
    var c1_lo = W2[i2 - 13];
    var c2_hi = g0_512_hi(W2[i2 - 30], W2[i2 - 29]);
    var c2_lo = g0_512_lo(W2[i2 - 30], W2[i2 - 29]);
    var c3_hi = W2[i2 - 32];
    var c3_lo = W2[i2 - 31];
    W2[i2] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    W2[i2 + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
  }
};
SHA512$2.prototype._update = function _update3(msg, start) {
  this._prepareBlock(msg, start);
  var W2 = this.W;
  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch2 = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl2 = this.h[15];
  assert$f(this.k.length === W2.length);
  for (var i2 = 0; i2 < W2.length; i2 += 2) {
    var c0_hi = hh;
    var c0_lo = hl2;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i2];
    var c3_lo = this.k[i2 + 1];
    var c4_hi = W2[i2];
    var c4_lo = W2[i2 + 1];
    var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch2);
    c1_lo = maj64_lo(ah, al, bh, bl, ch2, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl2 = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh = ch2;
    dl = cl;
    ch2 = bh;
    cl = bl;
    bh = ah;
    bl = al;
    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch2, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl2);
};
SHA512$2.prototype._digest = function digest5(enc) {
  if (enc === "hex")
    return utils$k.toHex32(this.h, "big");
  else
    return utils$k.split32(this.h, "big");
};
function ch64_hi(xh, xl, yh, yl, zh2) {
  var r2 = xh & yh ^ ~xh & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function ch64_lo(xh, xl, yh, yl, zh2, zl2) {
  var r2 = xl & yl ^ ~xl & zl2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_hi(xh, xl, yh, yl, zh2) {
  var r2 = xh & yh ^ xh & zh2 ^ yh & zh2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function maj64_lo(xh, xl, yh, yl, zh2, zl2) {
  var r2 = xl & yl ^ xl & zl2 ^ yl & zl2;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);
  var c2_hi = rotr64_hi(xl, xh, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);
  var c2_lo = rotr64_lo(xl, xh, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);
  var c2_hi = shr64_hi(xh, xl, 6);
  var r2 = c0_hi ^ c1_hi ^ c2_hi;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);
  var c2_lo = shr64_lo(xh, xl, 6);
  var r2 = c0_lo ^ c1_lo ^ c2_lo;
  if (r2 < 0)
    r2 += 4294967296;
  return r2;
}
var utils$j = utils$q;
var SHA512$1 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512$1.call(this);
  this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$j.inherits(SHA384, SHA512$1);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest6(enc) {
  if (enc === "hex")
    return utils$j.toHex32(this.h.slice(0, 12), "big");
  else
    return utils$j.split32(this.h.slice(0, 12), "big");
};
sha$2.sha1 = _1;
sha$2.sha224 = _224;
sha$2.sha256 = _256;
sha$2.sha384 = _384;
sha$2.sha512 = _512;
var ripemd = {};
var utils$i = utils$q;
var common = common$5;
var rotl32 = utils$i.rotl32;
var sum32 = utils$i.sum32;
var sum32_3 = utils$i.sum32_3;
var sum32_4 = utils$i.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160$2() {
  if (!(this instanceof RIPEMD160$2))
    return new RIPEMD160$2();
  BlockHash.call(this);
  this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  this.endian = "little";
}
utils$i.inherits(RIPEMD160$2, BlockHash);
ripemd.ripemd160 = RIPEMD160$2;
RIPEMD160$2.blockSize = 512;
RIPEMD160$2.outSize = 160;
RIPEMD160$2.hmacStrength = 192;
RIPEMD160$2.padLength = 64;
RIPEMD160$2.prototype._update = function update2(msg, start) {
  var A2 = this.h[0];
  var B2 = this.h[1];
  var C2 = this.h[2];
  var D2 = this.h[3];
  var E2 = this.h[4];
  var Ah = A2;
  var Bh = B2;
  var Ch2 = C2;
  var Dh = D2;
  var Eh = E2;
  for (var j2 = 0; j2 < 80; j2++) {
    var T2 = sum32(rotl32(sum32_4(A2, f$4(j2, B2, C2, D2), msg[r$5[j2] + start], K$5(j2)), s$4[j2]), E2);
    A2 = E2;
    E2 = D2;
    D2 = rotl32(C2, 10);
    C2 = B2;
    B2 = T2;
    T2 = sum32(rotl32(sum32_4(Ah, f$4(79 - j2, Bh, Ch2, Dh), msg[rh[j2] + start], Kh(j2)), sh[j2]), Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch2, 10);
    Ch2 = Bh;
    Bh = T2;
  }
  T2 = sum32_3(this.h[1], C2, Dh);
  this.h[1] = sum32_3(this.h[2], D2, Eh);
  this.h[2] = sum32_3(this.h[3], E2, Ah);
  this.h[3] = sum32_3(this.h[4], A2, Bh);
  this.h[4] = sum32_3(this.h[0], B2, Ch2);
  this.h[0] = T2;
};
RIPEMD160$2.prototype._digest = function digest7(enc) {
  if (enc === "hex")
    return utils$i.toHex32(this.h, "little");
  else
    return utils$i.split32(this.h, "little");
};
function f$4(j2, x2, y2, z2) {
  if (j2 <= 15)
    return x2 ^ y2 ^ z2;
  else if (j2 <= 31)
    return x2 & y2 | ~x2 & z2;
  else if (j2 <= 47)
    return (x2 | ~y2) ^ z2;
  else if (j2 <= 63)
    return x2 & z2 | y2 & ~z2;
  else
    return x2 ^ (y2 | ~z2);
}
function K$5(j2) {
  if (j2 <= 15)
    return 0;
  else if (j2 <= 31)
    return 1518500249;
  else if (j2 <= 47)
    return 1859775393;
  else if (j2 <= 63)
    return 2400959708;
  else
    return 2840853838;
}
function Kh(j2) {
  if (j2 <= 15)
    return 1352829926;
  else if (j2 <= 31)
    return 1548603684;
  else if (j2 <= 47)
    return 1836072691;
  else if (j2 <= 63)
    return 2053994217;
  else
    return 0;
}
var r$5 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var s$4 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var utils$h = utils$q;
var assert$e = minimalisticAssert$1;
function Hmac(hash3, key2, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash3, key2, enc);
  this.Hash = hash3;
  this.blockSize = hash3.blockSize / 8;
  this.outSize = hash3.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils$h.toArray(key2, enc));
}
var hmac = Hmac;
Hmac.prototype._init = function init2(key2) {
  if (key2.length > this.blockSize)
    key2 = new this.Hash().update(key2).digest();
  assert$e(key2.length <= this.blockSize);
  for (var i2 = key2.length; i2 < this.blockSize; i2++)
    key2.push(0);
  for (i2 = 0; i2 < key2.length; i2++)
    key2[i2] ^= 54;
  this.inner = new this.Hash().update(key2);
  for (i2 = 0; i2 < key2.length; i2++)
    key2[i2] ^= 106;
  this.outer = new this.Hash().update(key2);
};
Hmac.prototype.update = function update3(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest8(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};
(function(exports2) {
  var hash3 = exports2;
  hash3.utils = utils$q;
  hash3.common = common$5;
  hash3.sha = sha$2;
  hash3.ripemd = ripemd;
  hash3.hmac = hmac;
  hash3.sha1 = hash3.sha.sha1;
  hash3.sha256 = hash3.sha.sha256;
  hash3.sha224 = hash3.sha.sha224;
  hash3.sha384 = hash3.sha.sha384;
  hash3.sha512 = hash3.sha.sha512;
  hash3.ripemd160 = hash3.ripemd.ripemd160;
})(hash$4);
var SupportedAlgorithm;
(function(SupportedAlgorithm2) {
  SupportedAlgorithm2["sha256"] = "sha256";
  SupportedAlgorithm2["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));
const version$i = "sha2/5.5.0";
const logger$j = new Logger(version$i);
function ripemd160$1(data) {
  return "0x" + hash$4.ripemd160().update(arrayify(data)).digest("hex");
}
function sha256$3(data) {
  return "0x" + hash$4.sha256().update(arrayify(data)).digest("hex");
}
function sha512$1(data) {
  return "0x" + hash$4.sha512().update(arrayify(data)).digest("hex");
}
function computeHmac(algorithm2, key2, data) {
  if (!SupportedAlgorithm[algorithm2]) {
    logger$j.throwError("unsupported algorithm " + algorithm2, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm: algorithm2
    });
  }
  return "0x" + hash$4.hmac(hash$4[algorithm2], arrayify(key2)).update(arrayify(data)).digest("hex");
}
var lib_esm$9 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  computeHmac,
  ripemd160: ripemd160$1,
  sha256: sha256$3,
  sha512: sha512$1,
  get SupportedAlgorithm() {
    return SupportedAlgorithm;
  }
});
function pbkdf2$1(password, salt, iterations, keylen, hashAlgorithm) {
  password = arrayify(password);
  salt = arrayify(salt);
  let hLen;
  let l2 = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt);
  let r2;
  let T2;
  for (let i2 = 1; i2 <= l2; i2++) {
    block1[salt.length] = i2 >> 24 & 255;
    block1[salt.length + 1] = i2 >> 16 & 255;
    block1[salt.length + 2] = i2 >> 8 & 255;
    block1[salt.length + 3] = i2 & 255;
    let U2 = arrayify(computeHmac(hashAlgorithm, password, block1));
    if (!hLen) {
      hLen = U2.length;
      T2 = new Uint8Array(hLen);
      l2 = Math.ceil(keylen / hLen);
      r2 = keylen - (l2 - 1) * hLen;
    }
    T2.set(U2);
    for (let j2 = 1; j2 < iterations; j2++) {
      U2 = arrayify(computeHmac(hashAlgorithm, password, U2));
      for (let k2 = 0; k2 < hLen; k2++)
        T2[k2] ^= U2[k2];
    }
    const destPos = (i2 - 1) * hLen;
    const len2 = i2 === l2 ? r2 : hLen;
    DK.set(arrayify(T2).slice(0, len2), destPos);
  }
  return hexlify(DK);
}
function createCommonjsModule(fn, basedir, module2) {
  return module2 = {
    path: basedir,
    exports: {},
    require: function(path, base2) {
      return commonjsRequire(path, base2 === void 0 || base2 === null ? module2.path : base2);
    }
  }, fn(module2, module2.exports), module2.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var minimalisticAssert = assert$d;
function assert$d(val, msg) {
  if (!val)
    throw new Error(msg || "Assertion failed");
}
assert$d.equal = function assertEqual2(l2, r2, msg) {
  if (l2 != r2)
    throw new Error(msg || "Assertion failed: " + l2 + " != " + r2);
};
var utils_1$1 = createCommonjsModule(function(module2, exports2) {
  var utils2 = exports2;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    } else {
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word2) {
    if (word2.length === 1)
      return "0" + word2;
    else
      return word2;
  }
  utils2.zero2 = zero22;
  function toHex3(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero22(msg[i2].toString(16));
    return res;
  }
  utils2.toHex = toHex3;
  utils2.encode = function encode5(arr2, enc) {
    if (enc === "hex")
      return toHex3(arr2);
    else
      return arr2;
  };
});
var utils_1$1$1 = createCommonjsModule(function(module2, exports2) {
  var utils2 = exports2;
  utils2.assert = minimalisticAssert;
  utils2.toArray = utils_1$1.toArray;
  utils2.zero2 = utils_1$1.zero2;
  utils2.toHex = utils_1$1.toHex;
  utils2.encode = utils_1$1.encode;
  function getNAF2(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i2 = 0; i2 < naf.length; i2++) {
      var z2;
      var mod = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z2 = (ws >> 1) - mod;
        else
          z2 = mod;
        k2.isubn(z2);
      } else {
        z2 = 0;
      }
      naf[i2] = z2;
      k2.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty2(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty3() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty2;
  function parseBytes2(bytes3) {
    return typeof bytes3 === "string" ? utils2.toArray(bytes3, "hex") : bytes3;
  }
  utils2.parseBytes = parseBytes2;
  function intFromLE(bytes3) {
    return new BN$i(bytes3, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
});
var getNAF$1 = utils_1$1$1.getNAF;
var getJSF$1 = utils_1$1$1.getJSF;
var assert$1$1 = utils_1$1$1.assert;
function BaseCurve$1(type, conf) {
  this.type = type;
  this.p = new BN$i(conf.p, 16);
  this.red = conf.prime ? BN$i.red(conf.prime) : BN$i.mont(this.p);
  this.zero = new BN$i(0).toRed(this.red);
  this.one = new BN$i(1).toRed(this.red);
  this.two = new BN$i(2).toRed(this.red);
  this.n = conf.n && new BN$i(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base$2 = BaseCurve$1;
BaseCurve$1.prototype.point = function point() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype.validate = function validate() {
  throw new Error("Not implemented");
};
BaseCurve$1.prototype._fixedNafMul = function _fixedNafMul(p2, k2) {
  assert$1$1(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF$1(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i2 = I2; i2 > 0; i2--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i2)
        b2 = b2.mixedAdd(doubles.points[j2]);
      else if (nafW === -i2)
        b2 = b2.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve$1.prototype._wnafMul = function _wnafMul(p2, k2) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF$1(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i2 = naf.length - 1; i2 >= 0; i2--) {
    for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
      l2++;
    if (i2 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i2 < 0)
      break;
    var z2 = naf[i2];
    assert$1$1(z2 !== 0);
    if (p2.type === "affine") {
      if (z2 > 0)
        acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
    } else {
      if (z2 > 0)
        acc = acc.add(wnd[z2 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z2 - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve$1.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len2, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i2;
  var j2;
  var p2;
  for (i2 = 0; i2 < len2; i2++) {
    p2 = points[i2];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i2] = nafPoints.wnd;
    wnd[i2] = nafPoints.points;
  }
  for (i2 = len2 - 1; i2 >= 1; i2 -= 2) {
    var a2 = i2 - 1;
    var b2 = i2;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF$1(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF$1(coeffs[b2], wndWidth[b2], this._bitLength);
      max2 = Math.max(naf[a2].length, max2);
      max2 = Math.max(naf[b2].length, max2);
      continue;
    }
    var comb = [
      points[a2],
      null,
      null,
      points[b2]
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index2 = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF$1(coeffs[a2], coeffs[b2]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a2] = new Array(max2);
    naf[b2] = new Array(max2);
    for (j2 = 0; j2 < max2; j2++) {
      var ja = jsf[0][j2] | 0;
      var jb = jsf[1][j2] | 0;
      naf[a2][j2] = index2[(ja + 1) * 3 + (jb + 1)];
      naf[b2][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i2 = max2; i2 >= 0; i2--) {
    var k2 = 0;
    while (i2 >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len2; j2++) {
        tmp[j2] = naf[j2][i2] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k2++;
      i2--;
    }
    if (i2 >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i2 < 0)
      break;
    for (j2 = 0; j2 < len2; j2++) {
      var z2 = tmp[j2];
      if (z2 === 0)
        continue;
      else if (z2 > 0)
        p2 = wnd[j2][z2 - 1 >> 1];
      else if (z2 < 0)
        p2 = wnd[j2][-z2 - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i2 = 0; i2 < len2; i2++)
    wnd[i2] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint$1(curve2, type) {
  this.curve = curve2;
  this.type = type;
  this.precomputed = null;
}
BaseCurve$1.BasePoint = BasePoint$1;
BasePoint$1.prototype.eq = function eq() {
  throw new Error("Not implemented");
};
BasePoint$1.prototype.validate = function validate2() {
  return this.curve.validate(this);
};
BaseCurve$1.prototype.decodePoint = function decodePoint(bytes3, enc) {
  bytes3 = utils_1$1$1.toArray(bytes3, enc);
  var len2 = this.p.byteLength();
  if ((bytes3[0] === 4 || bytes3[0] === 6 || bytes3[0] === 7) && bytes3.length - 1 === 2 * len2) {
    if (bytes3[0] === 6)
      assert$1$1(bytes3[bytes3.length - 1] % 2 === 0);
    else if (bytes3[0] === 7)
      assert$1$1(bytes3[bytes3.length - 1] % 2 === 1);
    var res = this.point(bytes3.slice(1, 1 + len2), bytes3.slice(1 + len2, 1 + 2 * len2));
    return res;
  } else if ((bytes3[0] === 2 || bytes3[0] === 3) && bytes3.length - 1 === len2) {
    return this.pointFromX(bytes3.slice(1, 1 + len2), bytes3[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint$1.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint$1.prototype._encode = function _encode2(compact) {
  var len2 = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len2);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len2));
};
BasePoint$1.prototype.encode = function encode2(enc, compact) {
  return utils_1$1$1.encode(this._encode(compact), enc);
};
BasePoint$1.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint$1.prototype._hasDoubles = function _hasDoubles(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
};
BasePoint$1.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i2 = 0; i2 < power; i2 += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint$1.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl7 = max2 === 1 ? null : this.dbl();
  for (var i2 = 1; i2 < max2; i2++)
    res[i2] = res[i2 - 1].add(dbl7);
  return {
    wnd,
    points: res
  };
};
BasePoint$1.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint$1.prototype.dblp = function dblp(k2) {
  var r2 = this;
  for (var i2 = 0; i2 < k2; i2++)
    r2 = r2.dbl();
  return r2;
};
var inherits_browser = createCommonjsModule(function(module2) {
  if (typeof Object.create === "function") {
    module2.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
var assert$2$1 = utils_1$1$1.assert;
function ShortCurve$1(conf) {
  base$2.call(this, "short", conf);
  this.a = new BN$i(conf.a, 16).toRed(this.red);
  this.b = new BN$i(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve$1, base$2);
var short_1 = ShortCurve$1;
ShortCurve$1.prototype._getEndomorphism = function _getEndomorphism(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$i(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$i(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2$1(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$i(vec.a, 16),
        b: new BN$i(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve$1.prototype._getEndoRoots = function _getEndoRoots(num) {
  var red = num === this.p ? this.red : BN$i.mont(num);
  var tinv = new BN$i(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new BN$i(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve$1.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new BN$i(1);
  var y1 = new BN$i(0);
  var x2 = new BN$i(0);
  var y2 = new BN$i(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i2 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v2.div(u2);
    r2 = v2.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y3 = y2.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i2 === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y2 = y1;
    y1 = y3;
  }
  a2 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve$1.prototype._endoSplit = function _endoSplit(k2) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k2).divRound(this.n);
  var c2 = v1.b.neg().mul(k2).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve$1.prototype.pointFromX = function pointFromX(x2, odd) {
  x2 = new BN$i(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y3 = y2.redSqrt();
  if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x2, y3);
};
ShortCurve$1.prototype.validate = function validate3(point7) {
  if (point7.inf)
    return true;
  var x2 = point7.x;
  var y2 = point7.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y2.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve$1.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i2 = 0; i2 < points.length; i2++) {
    var split = this._endoSplit(coeffs[i2]);
    var p2 = points[i2];
    var beta = p2._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i2 * 2] = p2;
    npoints[i2 * 2 + 1] = beta;
    ncoeffs[i2 * 2] = split.k1;
    ncoeffs[i2 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
  for (var j2 = 0; j2 < i2 * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point$3(curve2, x2, y2, isRed) {
  base$2.BasePoint.call(this, curve2, "affine");
  if (x2 === null && y2 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$i(x2, 16);
    this.y = new BN$i(y2, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point$3, base$2.BasePoint);
ShortCurve$1.prototype.point = function point2(x2, y2, isRed) {
  return new Point$3(this, x2, y2, isRed);
};
ShortCurve$1.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point$3.fromJSON(this, obj, red);
};
Point$3.prototype._getBeta = function _getBeta2() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve2 = this.curve;
    var endoMul = function(p2) {
      return curve2.point(p2.x.redMul(curve2.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point$3.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point$3.fromJSON = function fromJSON(curve2, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve2.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve2.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point$3.prototype.inspect = function inspect2() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$3.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point$3.prototype.add = function add2(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$3.prototype.dbl = function dbl() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$3.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point$3.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point$3.prototype.mul = function mul(k2) {
  k2 = new BN$i(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
};
Point$3.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point$3.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point$3.prototype.eq = function eq2(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point$3.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point$3.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint$1(curve2, x2, y2, z2) {
  base$2.BasePoint.call(this, curve2, "jacobian");
  if (x2 === null && y2 === null && z2 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$i(0);
  } else {
    this.x = new BN$i(x2, 16);
    this.y = new BN$i(y2, 16);
    this.z = new BN$i(z2, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint$1, base$2.BasePoint);
ShortCurve$1.prototype.jpoint = function jpoint(x2, y2, z2) {
  return new JPoint$1(this, x2, y2, z2);
};
JPoint$1.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint$1.prototype.neg = function neg2() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint$1.prototype.add = function add3(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype.mixedAdd = function mixedAdd(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype.dblp = function dblp2(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i2;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i2 = 0; i2 < pow; i2++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i2 = 0; i2 < pow; i2++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i2 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint$1.prototype.dbl = function dbl2() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint$1.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e2 = a2.redAdd(a2).redIAdd(a2);
    var f2 = e2.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e2.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype._dbl = function _dbl() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e2 = e2.redIAdd(e2);
  e2 = e2.redAdd(e2).redIAdd(e2);
  e2 = e2.redISub(mm);
  var ee = e2.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m2.redIAdd(e2).redSqr().redISub(mm).redISub(ee).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint$1.prototype.mul = function mul2(k2, kbase) {
  k2 = new BN$i(k2, kbase);
  return this.curve._wnafMul(this, k2);
};
JPoint$1.prototype.eq = function eq3(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint$1.prototype.eqXToP = function eqXToP(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint$1.prototype.inspect = function inspect3() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint$1.prototype.isInfinity = function isInfinity2() {
  return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module2, exports2) {
  var curve2 = exports2;
  curve2.base = base$2;
  curve2.short = short_1;
  curve2.mont = null;
  curve2.edwards = null;
});
var curves_1 = createCommonjsModule(function(module2, exports2) {
  var curves2 = exports2;
  var assert2 = utils_1$1$1.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve_1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve_1.edwards(options);
    else
      this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves2.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves2, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve2 = new PresetCurve(options);
        Object.defineProperty(curves2, name2, {
          configurable: true,
          enumerable: true,
          value: curve2
        });
        return curve2;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash$4.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash$4.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash$4.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash$4.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash$4.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$4.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash$4.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = null.crash();
  } catch (e2) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash$4.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});
function HmacDRBG$2(options) {
  if (!(this instanceof HmacDRBG$2))
    return new HmacDRBG$2(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1$1.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils_1$1.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils_1$1.toArray(options.pers, options.persEnc || "hex");
  minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg$1 = HmacDRBG$2;
HmacDRBG$2.prototype._init = function init3(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i2 = 0; i2 < this.V.length; i2++) {
    this.K[i2] = 0;
    this.V[i2] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG$2.prototype._hmac = function hmac2() {
  return new hash$4.hmac(this.hash, this.K);
};
HmacDRBG$2.prototype._update = function update4(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG$2.prototype.reseed = function reseed(entropy, entropyEnc, add8, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add8;
    add8 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils_1$1.toArray(entropy, entropyEnc);
  add8 = utils_1$1.toArray(add8, addEnc);
  minimalisticAssert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add8 || []));
  this._reseed = 1;
};
HmacDRBG$2.prototype.generate = function generate2(len2, enc, add8, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add8;
    add8 = enc;
    enc = null;
  }
  if (add8) {
    add8 = utils_1$1.toArray(add8, addEnc || "hex");
    this._update(add8);
  }
  var temp = [];
  while (temp.length < len2) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len2);
  this._update(add8);
  this._reseed++;
  return utils_1$1.encode(res, enc);
};
var assert$3$1 = utils_1$1$1.assert;
function KeyPair$4(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key$2 = KeyPair$4;
KeyPair$4.fromPublic = function fromPublic(ec2, pub2, enc) {
  if (pub2 instanceof KeyPair$4)
    return pub2;
  return new KeyPair$4(ec2, {
    pub: pub2,
    pubEnc: enc
  });
};
KeyPair$4.fromPrivate = function fromPrivate(ec2, priv2, enc) {
  if (priv2 instanceof KeyPair$4)
    return priv2;
  return new KeyPair$4(ec2, {
    priv: priv2,
    privEnc: enc
  });
};
KeyPair$4.prototype.validate = function validate4() {
  var pub2 = this.getPublic();
  if (pub2.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub2.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub2.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair$4.prototype.getPublic = function getPublic(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair$4.prototype.getPrivate = function getPrivate(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair$4.prototype._importPrivate = function _importPrivate(key2, enc) {
  this.priv = new BN$i(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$4.prototype._importPublic = function _importPublic(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$3$1(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$3$1(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair$4.prototype.derive = function derive(pub2) {
  if (!pub2.validate()) {
    assert$3$1(pub2.validate(), "public point not validated");
  }
  return pub2.mul(this.priv).getX();
};
KeyPair$4.prototype.sign = function sign2(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair$4.prototype.verify = function verify2(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair$4.prototype.inspect = function inspect4() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var assert$4$1 = utils_1$1$1.assert;
function Signature$4(options, enc) {
  if (options instanceof Signature$4)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$4$1(options.r && options.s, "Signature without r or s");
  this.r = new BN$i(options.r, 16);
  this.s = new BN$i(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature$3 = Signature$4;
function Position$1() {
  this.place = 0;
}
function getLength$2(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding$1(buf) {
  var i2 = 0;
  var len2 = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len2) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
Signature$4.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1$1.toArray(data, enc);
  var p2 = new Position$1();
  if (data[p2.place++] !== 48) {
    return false;
  }
  var len2 = getLength$2(data, p2);
  if (len2 === false) {
    return false;
  }
  if (len2 + p2.place !== data.length) {
    return false;
  }
  if (data[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength$2(data, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength$2(data, p2);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p2.place) {
    return false;
  }
  var s2 = data.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$i(r2);
  this.s = new BN$i(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength$1(arr2, len2) {
  if (len2 < 128) {
    arr2.push(len2);
    return;
  }
  var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
  arr2.push(octets | 128);
  while (--octets) {
    arr2.push(len2 >>> (octets << 3) & 255);
  }
  arr2.push(len2);
}
Signature$4.prototype.toDER = function toDER(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding$1(r2);
  s2 = rmPadding$1(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr2 = [2];
  constructLength$1(arr2, r2.length);
  arr2 = arr2.concat(r2);
  arr2.push(2);
  constructLength$1(arr2, s2.length);
  var backHalf = arr2.concat(s2);
  var res = [48];
  constructLength$1(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1$1.encode(res, enc);
};
var rand$1 = function() {
  throw new Error("unsupported");
};
var assert$5$1 = utils_1$1$1.assert;
function EC$4(options) {
  if (!(this instanceof EC$4))
    return new EC$4(options);
  if (typeof options === "string") {
    assert$5$1(Object.prototype.hasOwnProperty.call(curves_1, options), "Unknown curve " + options);
    options = curves_1[options];
  }
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec$4 = EC$4;
EC$4.prototype.keyPair = function keyPair(options) {
  return new key$2(this, options);
};
EC$4.prototype.keyFromPrivate = function keyFromPrivate(priv2, enc) {
  return key$2.fromPrivate(this, priv2, enc);
};
EC$4.prototype.keyFromPublic = function keyFromPublic(pub2, enc) {
  return key$2.fromPublic(this, pub2, enc);
};
EC$4.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};
  var drbg = new hmacDrbg$1({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand$1(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes3 = this.n.byteLength();
  var ns2 = this.n.sub(new BN$i(2));
  for (; ; ) {
    var priv2 = new BN$i(drbg.generate(bytes3));
    if (priv2.cmp(ns2) > 0)
      continue;
    priv2.iaddn(1);
    return this.keyFromPrivate(priv2);
  }
};
EC$4.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC$4.prototype.sign = function sign3(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new BN$i(msg, 16));
  var bytes3 = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes3);
  var nonce = msg.toArray("be", bytes3);
  var drbg = new hmacDrbg$1({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN$i(1));
  for (var iter = 0; ; iter++) {
    var k2 = options.k ? options.k(iter) : new BN$i(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k2.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new signature$3({ r: r2, s: s2, recoveryParam });
  }
};
EC$4.prototype.verify = function verify3(msg, signature$12, key2, enc) {
  msg = this._truncateToN(new BN$i(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature$12 = new signature$3(signature$12, "hex");
  var r2 = signature$12.r;
  var s2 = signature$12.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC$4.prototype.recoverPubKey = function(msg, signature$12, j2, enc) {
  assert$5$1((3 & j2) === j2, "The recovery param is more than two bits");
  signature$12 = new signature$3(signature$12, enc);
  var n2 = this.n;
  var e2 = new BN$i(msg);
  var r2 = signature$12.r;
  var s2 = signature$12.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature$12.r.invm(n2);
  var s1 = n2.sub(e2).mul(rInv).umod(n2);
  var s22 = s2.mul(rInv).umod(n2);
  return this.g.mulAdd(s1, r2, s22);
};
EC$4.prototype.getKeyRecoveryParam = function(e2, signature$12, Q2, enc) {
  signature$12 = new signature$3(signature$12, enc);
  if (signature$12.recoveryParam !== null)
    return signature$12.recoveryParam;
  for (var i2 = 0; i2 < 4; i2++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e2, signature$12, i2);
    } catch (e3) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i2;
  }
  throw new Error("Unable to find valid recovery factor");
};
var elliptic_1 = createCommonjsModule(function(module2, exports2) {
  var elliptic2 = exports2;
  elliptic2.version = { version: "6.5.4" }.version;
  elliptic2.utils = utils_1$1$1;
  elliptic2.rand = function() {
    throw new Error("unsupported");
  };
  elliptic2.curve = curve_1;
  elliptic2.curves = curves_1;
  elliptic2.ec = ec$4;
  elliptic2.eddsa = null;
});
var EC$1$1 = elliptic_1.ec;
const version$h = "signing-key/5.5.0";
const logger$i = new Logger(version$h);
let _curve = null;
function getCurve() {
  if (!_curve) {
    _curve = new EC$1$1("secp256k1");
  }
  return _curve;
}
class SigningKey {
  constructor(privateKey) {
    defineReadOnly(this, "curve", "secp256k1");
    defineReadOnly(this, "privateKey", hexlify(privateKey));
    const keyPair3 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    defineReadOnly(this, "publicKey", "0x" + keyPair3.getPublic(false, "hex"));
    defineReadOnly(this, "compressedPublicKey", "0x" + keyPair3.getPublic(true, "hex"));
    defineReadOnly(this, "_isSigningKey", true);
  }
  _addPoint(other) {
    const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
    const p1 = getCurve().keyFromPublic(arrayify(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }
  signDigest(digest9) {
    const keyPair3 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const digestBytes = arrayify(digest9);
    if (digestBytes.length !== 32) {
      logger$i.throwArgumentError("bad digest length", "digest", digest9);
    }
    const signature2 = keyPair3.sign(digestBytes, { canonical: true });
    return splitSignature({
      recoveryParam: signature2.recoveryParam,
      r: hexZeroPad("0x" + signature2.r.toString(16), 32),
      s: hexZeroPad("0x" + signature2.s.toString(16), 32)
    });
  }
  computeSharedSecret(otherKey) {
    const keyPair3 = getCurve().keyFromPrivate(arrayify(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
    return hexZeroPad("0x" + keyPair3.derive(otherKeyPair.getPublic()).toString(16), 32);
  }
  static isSigningKey(value2) {
    return !!(value2 && value2._isSigningKey);
  }
}
function recoverPublicKey$1(digest9, signature2) {
  const sig = splitSignature(signature2);
  const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };
  return "0x" + getCurve().recoverPubKey(arrayify(digest9), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key2, compressed) {
  const bytes3 = arrayify(key2);
  if (bytes3.length === 32) {
    const signingKey = new SigningKey(bytes3);
    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes3).getPublic(true, "hex");
    }
    return signingKey.publicKey;
  } else if (bytes3.length === 33) {
    if (compressed) {
      return hexlify(bytes3);
    }
    return "0x" + getCurve().keyFromPublic(bytes3).getPublic(false, "hex");
  } else if (bytes3.length === 65) {
    if (!compressed) {
      return hexlify(bytes3);
    }
    return "0x" + getCurve().keyFromPublic(bytes3).getPublic(true, "hex");
  }
  return logger$i.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var lib_esm$8 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  SigningKey,
  recoverPublicKey: recoverPublicKey$1,
  computePublicKey
});
const version$g = "transactions/5.5.0";
const logger$h = new Logger(version$g);
var TransactionTypes;
(function(TransactionTypes2) {
  TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
  TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
  TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
function handleAddress(value2) {
  if (value2 === "0x") {
    return null;
  }
  return getAddress(value2);
}
function handleNumber(value2) {
  if (value2 === "0x") {
    return Zero$1;
  }
  return BigNumber.from(value2);
}
const transactionFields = [
  { name: "nonce", maxLength: 32, numeric: true },
  { name: "gasPrice", maxLength: 32, numeric: true },
  { name: "gasLimit", maxLength: 32, numeric: true },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: true },
  { name: "data" }
];
const allowedTransactionKeys$2 = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  type: true,
  value: true
};
function computeAddress(key2) {
  const publicKey = computePublicKey(key2);
  return getAddress(hexDataSlice(keccak256$1(hexDataSlice(publicKey, 1)), 12));
}
function recoverAddress(digest9, signature2) {
  return computeAddress(recoverPublicKey$1(arrayify(digest9), signature2));
}
function formatNumber(value2, name2) {
  const result = stripZeros(BigNumber.from(value2).toHexString());
  if (result.length > 32) {
    logger$h.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value2);
  }
  return result;
}
function accessSetify(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: (storageKeys || []).map((storageKey, index2) => {
      if (hexDataLength(storageKey) !== 32) {
        logger$h.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index2}]`, storageKey);
      }
      return storageKey.toLowerCase();
    })
  };
}
function accessListify(value2) {
  if (Array.isArray(value2)) {
    return value2.map((set6, index2) => {
      if (Array.isArray(set6)) {
        if (set6.length > 2) {
          logger$h.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index2}]`, set6);
        }
        return accessSetify(set6[0], set6[1]);
      }
      return accessSetify(set6.address, set6.storageKeys);
    });
  }
  const result = Object.keys(value2).map((addr) => {
    const storageKeys = value2[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a2, b2) => a2.address.localeCompare(b2.address));
  return result;
}
function formatAccessList(value2) {
  return accessListify(value2).map((set6) => [set6.address, set6.storageKeys]);
}
function _serializeEip1559(transaction, signature2) {
  if (transaction.gasPrice != null) {
    const gasPrice = BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
    if (!gasPrice.eq(maxFeePerGas)) {
      logger$h.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x02", encode$4(fields)]);
}
function _serializeEip2930(transaction, signature2) {
  const fields = [
    formatNumber(transaction.chainId || 0, "chainId"),
    formatNumber(transaction.nonce || 0, "nonce"),
    formatNumber(transaction.gasPrice || 0, "gasPrice"),
    formatNumber(transaction.gasLimit || 0, "gasLimit"),
    transaction.to != null ? getAddress(transaction.to) : "0x",
    formatNumber(transaction.value || 0, "value"),
    transaction.data || "0x",
    formatAccessList(transaction.accessList || [])
  ];
  if (signature2) {
    const sig = splitSignature(signature2);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push(stripZeros(sig.r));
    fields.push(stripZeros(sig.s));
  }
  return hexConcat(["0x01", encode$4(fields)]);
}
function _serialize(transaction, signature2) {
  checkProperties(transaction, allowedTransactionKeys$2);
  const raw = [];
  transactionFields.forEach(function(fieldInfo) {
    let value2 = transaction[fieldInfo.name] || [];
    const options = {};
    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }
    value2 = arrayify(hexlify(value2, options));
    if (fieldInfo.length && value2.length !== fieldInfo.length && value2.length > 0) {
      logger$h.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value2);
    }
    if (fieldInfo.maxLength) {
      value2 = stripZeros(value2);
      if (value2.length > fieldInfo.maxLength) {
        logger$h.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value2);
      }
    }
    raw.push(hexlify(value2));
  });
  let chainId = 0;
  if (transaction.chainId != null) {
    chainId = transaction.chainId;
    if (typeof chainId !== "number") {
      logger$h.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature2 && !isBytesLike(signature2) && signature2.v > 28) {
    chainId = Math.floor((signature2.v - 35) / 2);
  }
  if (chainId !== 0) {
    raw.push(hexlify(chainId));
    raw.push("0x");
    raw.push("0x");
  }
  if (!signature2) {
    return encode$4(raw);
  }
  const sig = splitSignature(signature2);
  let v2 = 27 + sig.recoveryParam;
  if (chainId !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v2 += chainId * 2 + 8;
    if (sig.v > 28 && sig.v !== v2) {
      logger$h.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
    }
  } else if (sig.v !== v2) {
    logger$h.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
  }
  raw.push(hexlify(v2));
  raw.push(stripZeros(arrayify(sig.r)));
  raw.push(stripZeros(arrayify(sig.s)));
  return encode$4(raw);
}
function serialize(transaction, signature2) {
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger$h.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }
    return _serialize(transaction, signature2);
  }
  switch (transaction.type) {
    case 1:
      return _serializeEip2930(transaction, signature2);
    case 2:
      return _serializeEip1559(transaction, signature2);
  }
  return logger$h.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}
function _parseEipSignature(tx, fields, serialize2) {
  try {
    const recid = handleNumber(fields[0]).toNumber();
    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }
    tx.v = recid;
  } catch (error2) {
    logger$h.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }
  tx.r = hexZeroPad(fields[1], 32);
  tx.s = hexZeroPad(fields[2], 32);
  try {
    const digest9 = keccak256$1(serialize2(tx));
    tx.from = recoverAddress(digest9, { r: tx.r, s: tx.s, recoveryParam: tx.v });
  } catch (error2) {
    console.log(error2);
  }
}
function _parseEip1559(payload) {
  const transaction = decode$5(payload.slice(1));
  if (transaction.length !== 9 && transaction.length !== 12) {
    logger$h.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
  }
  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  };
  if (transaction.length === 9) {
    return tx;
  }
  tx.hash = keccak256$1(payload);
  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
  return tx;
}
function _parseEip2930(payload) {
  const transaction = decode$5(payload.slice(1));
  if (transaction.length !== 8 && transaction.length !== 11) {
    logger$h.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
  }
  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  };
  if (transaction.length === 8) {
    return tx;
  }
  tx.hash = keccak256$1(payload);
  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
  return tx;
}
function _parse(rawTransaction) {
  const transaction = decode$5(rawTransaction);
  if (transaction.length !== 9 && transaction.length !== 6) {
    logger$h.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }
  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  };
  if (transaction.length === 6) {
    return tx;
  }
  try {
    tx.v = BigNumber.from(transaction[6]).toNumber();
  } catch (error2) {
    console.log(error2);
    return tx;
  }
  tx.r = hexZeroPad(transaction[7], 32);
  tx.s = hexZeroPad(transaction[8], 32);
  if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    tx.chainId = Math.floor((tx.v - 35) / 2);
    if (tx.chainId < 0) {
      tx.chainId = 0;
    }
    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);
    if (tx.chainId !== 0) {
      raw.push(hexlify(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }
    const digest9 = keccak256$1(encode$4(raw));
    try {
      tx.from = recoverAddress(digest9, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
    } catch (error2) {
      console.log(error2);
    }
    tx.hash = keccak256$1(rawTransaction);
  }
  tx.type = null;
  return tx;
}
function parse$1(rawTransaction) {
  const payload = arrayify(rawTransaction);
  if (payload[0] > 127) {
    return _parse(payload);
  }
  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);
    case 2:
      return _parseEip1559(payload);
  }
  return logger$h.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}
var lib_esm$7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  get TransactionTypes() {
    return TransactionTypes;
  },
  computeAddress,
  recoverAddress,
  accessListify,
  serialize,
  parse: parse$1
});
const version$f = "wordlists/5.5.0";
const logger$g = new Logger(version$f);
class Wordlist {
  constructor(locale) {
    logger$g.checkAbstract(new.target, Wordlist);
    defineReadOnly(this, "locale", locale);
  }
  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  }
  join(words2) {
    return words2.join(" ");
  }
  static check(wordlist2) {
    const words2 = [];
    for (let i2 = 0; i2 < 2048; i2++) {
      const word2 = wordlist2.getWord(i2);
      if (i2 !== wordlist2.getWordIndex(word2)) {
        return "0x";
      }
      words2.push(word2);
    }
    return id(words2.join("\n") + "\n");
  }
  static register(lang, name2) {
  }
}
const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;
function loadWords(lang) {
  if (wordlist != null) {
    return;
  }
  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
  if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}
class LangEn extends Wordlist {
  constructor() {
    super("en");
  }
  getWord(index2) {
    loadWords(this);
    return wordlist[index2];
  }
  getWordIndex(word2) {
    loadWords(this);
    return wordlist.indexOf(word2);
  }
}
const langEn = new LangEn();
Wordlist.register(langEn);
const wordlists = {
  en: langEn
};
const version$e = "hdnode/5.5.0";
const logger$f = new Logger(version$e);
const N$3 = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
const MasterSecret = toUtf8Bytes("Bitcoin seed");
const HardenedBit = 2147483648;
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
}
function getLowerMask(bits) {
  return (1 << bits) - 1;
}
function bytes32(value2) {
  return hexZeroPad(hexlify(value2), 32);
}
function base58check(data) {
  return Base58.encode(concat$2([data, hexDataSlice(sha256$3(sha256$3(data)), 0, 4)]));
}
function getWordlist(wordlist2) {
  if (wordlist2 == null) {
    return wordlists["en"];
  }
  if (typeof wordlist2 === "string") {
    const words2 = wordlists[wordlist2];
    if (words2 == null) {
      logger$f.throwArgumentError("unknown locale", "wordlist", wordlist2);
    }
    return words2;
  }
  return wordlist2;
}
const _constructorGuard$1 = {};
const defaultPath = "m/44'/60'/0'/0/0";
class HDNode {
  constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index2, depth, mnemonicOrPath) {
    logger$f.checkNew(new.target, HDNode);
    if (constructorGuard !== _constructorGuard$1) {
      throw new Error("HDNode constructor cannot be called directly");
    }
    if (privateKey) {
      const signingKey = new SigningKey(privateKey);
      defineReadOnly(this, "privateKey", signingKey.privateKey);
      defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
    } else {
      defineReadOnly(this, "privateKey", null);
      defineReadOnly(this, "publicKey", hexlify(publicKey));
    }
    defineReadOnly(this, "parentFingerprint", parentFingerprint);
    defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160$1(sha256$3(this.publicKey)), 0, 4));
    defineReadOnly(this, "address", computeAddress(this.publicKey));
    defineReadOnly(this, "chainCode", chainCode);
    defineReadOnly(this, "index", index2);
    defineReadOnly(this, "depth", depth);
    if (mnemonicOrPath == null) {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", null);
    } else if (typeof mnemonicOrPath === "string") {
      defineReadOnly(this, "mnemonic", null);
      defineReadOnly(this, "path", mnemonicOrPath);
    } else {
      defineReadOnly(this, "mnemonic", mnemonicOrPath);
      defineReadOnly(this, "path", mnemonicOrPath.path);
    }
  }
  get extendedKey() {
    if (this.depth >= 256) {
      throw new Error("Depth too large!");
    }
    return base58check(concat$2([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      hexlify(this.depth),
      this.parentFingerprint,
      hexZeroPad(hexlify(this.index), 4),
      this.chainCode,
      this.privateKey != null ? concat$2(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new HDNode(_constructorGuard$1, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(index2) {
    if (index2 > 4294967295) {
      throw new Error("invalid index - " + String(index2));
    }
    let path = this.path;
    if (path) {
      path += "/" + (index2 & ~HardenedBit);
    }
    const data = new Uint8Array(37);
    if (index2 & HardenedBit) {
      if (!this.privateKey) {
        throw new Error("cannot derive child of neutered node");
      }
      data.set(arrayify(this.privateKey), 1);
      if (path) {
        path += "'";
      }
    } else {
      data.set(arrayify(this.publicKey));
    }
    for (let i2 = 24; i2 >= 0; i2 -= 8) {
      data[33 + (i2 >> 3)] = index2 >> 24 - i2 & 255;
    }
    const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));
    const IL = I2.slice(0, 32);
    const IR = I2.slice(32);
    let ki = null;
    let Ki = null;
    if (this.privateKey) {
      ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N$3));
    } else {
      const ek = new SigningKey(hexlify(IL));
      Ki = ek._addPoint(this.publicKey);
    }
    let mnemonicOrPath = path;
    const srcMnemonic = this.mnemonic;
    if (srcMnemonic) {
      mnemonicOrPath = Object.freeze({
        phrase: srcMnemonic.phrase,
        path,
        locale: srcMnemonic.locale || "en"
      });
    }
    return new HDNode(_constructorGuard$1, ki, Ki, this.fingerprint, bytes32(IR), index2, this.depth + 1, mnemonicOrPath);
  }
  derivePath(path) {
    const components = path.split("/");
    if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
      throw new Error("invalid path - " + path);
    }
    if (components[0] === "m") {
      components.shift();
    }
    let result = this;
    for (let i2 = 0; i2 < components.length; i2++) {
      const component = components[i2];
      if (component.match(/^[0-9]+'$/)) {
        const index2 = parseInt(component.substring(0, component.length - 1));
        if (index2 >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(HardenedBit + index2);
      } else if (component.match(/^[0-9]+$/)) {
        const index2 = parseInt(component);
        if (index2 >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }
        result = result._derive(index2);
      } else {
        throw new Error("invalid path component - " + component);
      }
    }
    return result;
  }
  static _fromSeed(seed, mnemonic) {
    const seedArray = arrayify(seed);
    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new Error("invalid seed");
    }
    const I2 = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
    return new HDNode(_constructorGuard$1, bytes32(I2.slice(0, 32)), null, "0x00000000", bytes32(I2.slice(32)), 0, 0, mnemonic);
  }
  static fromMnemonic(mnemonic, password, wordlist2) {
    wordlist2 = getWordlist(wordlist2);
    mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist2), wordlist2);
    return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
      phrase: mnemonic,
      path: "m",
      locale: wordlist2.locale
    });
  }
  static fromSeed(seed) {
    return HDNode._fromSeed(seed, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes3 = Base58.decode(extendedKey);
    if (bytes3.length !== 82 || base58check(bytes3.slice(0, 78)) !== extendedKey) {
      logger$f.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
    const depth = bytes3[4];
    const parentFingerprint = hexlify(bytes3.slice(5, 9));
    const index2 = parseInt(hexlify(bytes3.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes3.slice(13, 45));
    const key2 = bytes3.slice(45, 78);
    switch (hexlify(bytes3.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode(_constructorGuard$1, null, hexlify(key2), parentFingerprint, chainCode, index2, depth, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (key2[0] !== 0) {
          break;
        }
        return new HDNode(_constructorGuard$1, hexlify(key2.slice(1)), null, parentFingerprint, chainCode, index2, depth, null);
    }
    return logger$f.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
}
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }
  const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
  return pbkdf2$1(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  logger$f.checkNormalize();
  const words2 = wordlist2.split(mnemonic);
  if (words2.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }
  const entropy = arrayify(new Uint8Array(Math.ceil(11 * words2.length / 8)));
  let offset = 0;
  for (let i2 = 0; i2 < words2.length; i2++) {
    let index2 = wordlist2.getWordIndex(words2[i2].normalize("NFKD"));
    if (index2 === -1) {
      throw new Error("invalid mnemonic");
    }
    for (let bit = 0; bit < 11; bit++) {
      if (index2 & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = arrayify(sha256$3(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }
  return hexlify(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist2) {
  wordlist2 = getWordlist(wordlist2);
  entropy = arrayify(entropy);
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i2 = 0; i2 < entropy.length; i2++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i2];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i2] >> 8 - remainingBits;
      indices.push(entropy[i2] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum = arrayify(sha256$3(entropy))[0] & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist2.join(indices.map((index2) => wordlist2.getWord(index2)));
}
function isValidMnemonic(mnemonic, wordlist2) {
  try {
    mnemonicToEntropy(mnemonic, wordlist2);
    return true;
  } catch (error2) {
  }
  return false;
}
function getAccountPath(index2) {
  if (typeof index2 !== "number" || index2 < 0 || index2 >= HardenedBit || index2 % 1) {
    logger$f.throwArgumentError("invalid account index", "index", index2);
  }
  return `m/44'/60'/${index2}'/0/0`;
}
var lib_esm$6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  defaultPath,
  HDNode,
  mnemonicToSeed,
  mnemonicToEntropy,
  entropyToMnemonic,
  isValidMnemonic,
  getAccountPath
});
var require$$6 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$6);
var aesJs = { exports: {} };
(function(module2, exports2) {
  (function(root2) {
    function checkInt(value2) {
      return parseInt(value2) === value2;
    }
    function checkInts(arrayish) {
      if (!checkInt(arrayish.length)) {
        return false;
      }
      for (var i2 = 0; i2 < arrayish.length; i2++) {
        if (!checkInt(arrayish[i2]) || arrayish[i2] < 0 || arrayish[i2] > 255) {
          return false;
        }
      }
      return true;
    }
    function coerceArray(arg, copy3) {
      if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
        if (copy3) {
          if (arg.slice) {
            arg = arg.slice();
          } else {
            arg = Array.prototype.slice.call(arg);
          }
        }
        return arg;
      }
      if (Array.isArray(arg)) {
        if (!checkInts(arg)) {
          throw new Error("Array contains invalid value: " + arg);
        }
        return new Uint8Array(arg);
      }
      if (checkInt(arg.length) && checkInts(arg)) {
        return new Uint8Array(arg);
      }
      throw new Error("unsupported array-like object");
    }
    function createArray(length) {
      return new Uint8Array(length);
    }
    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
      if (sourceStart != null || sourceEnd != null) {
        if (sourceArray.slice) {
          sourceArray = sourceArray.slice(sourceStart, sourceEnd);
        } else {
          sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
        }
      }
      targetArray.set(sourceArray, targetStart);
    }
    var convertUtf8 = function() {
      function toBytes2(text2) {
        var result = [], i2 = 0;
        text2 = encodeURI(text2);
        while (i2 < text2.length) {
          var c2 = text2.charCodeAt(i2++);
          if (c2 === 37) {
            result.push(parseInt(text2.substr(i2, 2), 16));
            i2 += 2;
          } else {
            result.push(c2);
          }
        }
        return coerceArray(result);
      }
      function fromBytes(bytes3) {
        var result = [], i2 = 0;
        while (i2 < bytes3.length) {
          var c2 = bytes3[i2];
          if (c2 < 128) {
            result.push(String.fromCharCode(c2));
            i2++;
          } else if (c2 > 191 && c2 < 224) {
            result.push(String.fromCharCode((c2 & 31) << 6 | bytes3[i2 + 1] & 63));
            i2 += 2;
          } else {
            result.push(String.fromCharCode((c2 & 15) << 12 | (bytes3[i2 + 1] & 63) << 6 | bytes3[i2 + 2] & 63));
            i2 += 3;
          }
        }
        return result.join("");
      }
      return {
        toBytes: toBytes2,
        fromBytes
      };
    }();
    var convertHex = function() {
      function toBytes2(text2) {
        var result = [];
        for (var i2 = 0; i2 < text2.length; i2 += 2) {
          result.push(parseInt(text2.substr(i2, 2), 16));
        }
        return result;
      }
      var Hex = "0123456789abcdef";
      function fromBytes(bytes3) {
        var result = [];
        for (var i2 = 0; i2 < bytes3.length; i2++) {
          var v2 = bytes3[i2];
          result.push(Hex[(v2 & 240) >> 4] + Hex[v2 & 15]);
        }
        return result.join("");
      }
      return {
        toBytes: toBytes2,
        fromBytes
      };
    }();
    var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
    var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
    var S3 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
    var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
    var T1 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
    var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
    var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
    var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
    var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
    var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
    var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
    var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
    var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
    var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
    var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
    var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function convertToInt32(bytes3) {
      var result = [];
      for (var i2 = 0; i2 < bytes3.length; i2 += 4) {
        result.push(bytes3[i2] << 24 | bytes3[i2 + 1] << 16 | bytes3[i2 + 2] << 8 | bytes3[i2 + 3]);
      }
      return result;
    }
    var AES = function(key2) {
      if (!(this instanceof AES)) {
        throw Error("AES must be instanitated with `new`");
      }
      Object.defineProperty(this, "key", {
        value: coerceArray(key2, true)
      });
      this._prepare();
    };
    AES.prototype._prepare = function() {
      var rounds = numberOfRounds[this.key.length];
      if (rounds == null) {
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      }
      this._Ke = [];
      this._Kd = [];
      for (var i2 = 0; i2 <= rounds; i2++) {
        this._Ke.push([0, 0, 0, 0]);
        this._Kd.push([0, 0, 0, 0]);
      }
      var roundKeyCount = (rounds + 1) * 4;
      var KC = this.key.length / 4;
      var tk = convertToInt32(this.key);
      var index2;
      for (var i2 = 0; i2 < KC; i2++) {
        index2 = i2 >> 2;
        this._Ke[index2][i2 % 4] = tk[i2];
        this._Kd[rounds - index2][i2 % 4] = tk[i2];
      }
      var rconpointer = 0;
      var t2 = KC, tt;
      while (t2 < roundKeyCount) {
        tt = tk[KC - 1];
        tk[0] ^= S3[tt >> 16 & 255] << 24 ^ S3[tt >> 8 & 255] << 16 ^ S3[tt & 255] << 8 ^ S3[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
        rconpointer += 1;
        if (KC != 8) {
          for (var i2 = 1; i2 < KC; i2++) {
            tk[i2] ^= tk[i2 - 1];
          }
        } else {
          for (var i2 = 1; i2 < KC / 2; i2++) {
            tk[i2] ^= tk[i2 - 1];
          }
          tt = tk[KC / 2 - 1];
          tk[KC / 2] ^= S3[tt & 255] ^ S3[tt >> 8 & 255] << 8 ^ S3[tt >> 16 & 255] << 16 ^ S3[tt >> 24 & 255] << 24;
          for (var i2 = KC / 2 + 1; i2 < KC; i2++) {
            tk[i2] ^= tk[i2 - 1];
          }
        }
        var i2 = 0, r2, c2;
        while (i2 < KC && t2 < roundKeyCount) {
          r2 = t2 >> 2;
          c2 = t2 % 4;
          this._Ke[r2][c2] = tk[i2];
          this._Kd[rounds - r2][c2] = tk[i2++];
          t2++;
        }
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var c2 = 0; c2 < 4; c2++) {
          tt = this._Kd[r2][c2];
          this._Kd[r2][c2] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
        }
      }
    };
    AES.prototype.encrypt = function(plaintext) {
      if (plaintext.length != 16) {
        throw new Error("invalid plaintext size (must be 16 bytes)");
      }
      var rounds = this._Ke.length - 1;
      var a2 = [0, 0, 0, 0];
      var t2 = convertToInt32(plaintext);
      for (var i2 = 0; i2 < 4; i2++) {
        t2[i2] ^= this._Ke[0][i2];
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var i2 = 0; i2 < 4; i2++) {
          a2[i2] = T1[t2[i2] >> 24 & 255] ^ T2[t2[(i2 + 1) % 4] >> 16 & 255] ^ T3[t2[(i2 + 2) % 4] >> 8 & 255] ^ T4[t2[(i2 + 3) % 4] & 255] ^ this._Ke[r2][i2];
        }
        t2 = a2.slice();
      }
      var result = createArray(16), tt;
      for (var i2 = 0; i2 < 4; i2++) {
        tt = this._Ke[rounds][i2];
        result[4 * i2] = (S3[t2[i2] >> 24 & 255] ^ tt >> 24) & 255;
        result[4 * i2 + 1] = (S3[t2[(i2 + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
        result[4 * i2 + 2] = (S3[t2[(i2 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
        result[4 * i2 + 3] = (S3[t2[(i2 + 3) % 4] & 255] ^ tt) & 255;
      }
      return result;
    };
    AES.prototype.decrypt = function(ciphertext) {
      if (ciphertext.length != 16) {
        throw new Error("invalid ciphertext size (must be 16 bytes)");
      }
      var rounds = this._Kd.length - 1;
      var a2 = [0, 0, 0, 0];
      var t2 = convertToInt32(ciphertext);
      for (var i2 = 0; i2 < 4; i2++) {
        t2[i2] ^= this._Kd[0][i2];
      }
      for (var r2 = 1; r2 < rounds; r2++) {
        for (var i2 = 0; i2 < 4; i2++) {
          a2[i2] = T5[t2[i2] >> 24 & 255] ^ T6[t2[(i2 + 3) % 4] >> 16 & 255] ^ T7[t2[(i2 + 2) % 4] >> 8 & 255] ^ T8[t2[(i2 + 1) % 4] & 255] ^ this._Kd[r2][i2];
        }
        t2 = a2.slice();
      }
      var result = createArray(16), tt;
      for (var i2 = 0; i2 < 4; i2++) {
        tt = this._Kd[rounds][i2];
        result[4 * i2] = (Si[t2[i2] >> 24 & 255] ^ tt >> 24) & 255;
        result[4 * i2 + 1] = (Si[t2[(i2 + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
        result[4 * i2 + 2] = (Si[t2[(i2 + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
        result[4 * i2 + 3] = (Si[t2[(i2 + 1) % 4] & 255] ^ tt) & 255;
      }
      return result;
    };
    var ModeOfOperationECB = function(key2) {
      if (!(this instanceof ModeOfOperationECB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Electronic Code Block";
      this.name = "ecb";
      this._aes = new AES(key2);
    };
    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i2 = 0; i2 < plaintext.length; i2 += 16) {
        copyArray(plaintext, block, 0, i2, i2 + 16);
        block = this._aes.encrypt(block);
        copyArray(block, ciphertext, i2);
      }
      return ciphertext;
    };
    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i2 = 0; i2 < ciphertext.length; i2 += 16) {
        copyArray(ciphertext, block, 0, i2, i2 + 16);
        block = this._aes.decrypt(block);
        copyArray(block, plaintext, i2);
      }
      return plaintext;
    };
    var ModeOfOperationCBC = function(key2, iv) {
      if (!(this instanceof ModeOfOperationCBC)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Cipher Block Chaining";
      this.name = "cbc";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      }
      this._lastCipherblock = coerceArray(iv, true);
      this._aes = new AES(key2);
    };
    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
      plaintext = coerceArray(plaintext);
      if (plaintext.length % 16 !== 0) {
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = createArray(plaintext.length);
      var block = createArray(16);
      for (var i2 = 0; i2 < plaintext.length; i2 += 16) {
        copyArray(plaintext, block, 0, i2, i2 + 16);
        for (var j2 = 0; j2 < 16; j2++) {
          block[j2] ^= this._lastCipherblock[j2];
        }
        this._lastCipherblock = this._aes.encrypt(block);
        copyArray(this._lastCipherblock, ciphertext, i2);
      }
      return ciphertext;
    };
    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
      ciphertext = coerceArray(ciphertext);
      if (ciphertext.length % 16 !== 0) {
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = createArray(ciphertext.length);
      var block = createArray(16);
      for (var i2 = 0; i2 < ciphertext.length; i2 += 16) {
        copyArray(ciphertext, block, 0, i2, i2 + 16);
        block = this._aes.decrypt(block);
        for (var j2 = 0; j2 < 16; j2++) {
          plaintext[i2 + j2] = block[j2] ^ this._lastCipherblock[j2];
        }
        copyArray(ciphertext, this._lastCipherblock, 0, i2, i2 + 16);
      }
      return plaintext;
    };
    var ModeOfOperationCFB = function(key2, iv, segmentSize) {
      if (!(this instanceof ModeOfOperationCFB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Cipher Feedback";
      this.name = "cfb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 size)");
      }
      if (!segmentSize) {
        segmentSize = 1;
      }
      this.segmentSize = segmentSize;
      this._shiftRegister = coerceArray(iv, true);
      this._aes = new AES(key2);
    };
    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
      if (plaintext.length % this.segmentSize != 0) {
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      }
      var encrypted = coerceArray(plaintext, true);
      var xorSegment;
      for (var i2 = 0; i2 < encrypted.length; i2 += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j2 = 0; j2 < this.segmentSize; j2++) {
          encrypted[i2 + j2] ^= xorSegment[j2];
        }
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i2, i2 + this.segmentSize);
      }
      return encrypted;
    };
    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
      if (ciphertext.length % this.segmentSize != 0) {
        throw new Error("invalid ciphertext size (must be segmentSize bytes)");
      }
      var plaintext = coerceArray(ciphertext, true);
      var xorSegment;
      for (var i2 = 0; i2 < plaintext.length; i2 += this.segmentSize) {
        xorSegment = this._aes.encrypt(this._shiftRegister);
        for (var j2 = 0; j2 < this.segmentSize; j2++) {
          plaintext[i2 + j2] ^= xorSegment[j2];
        }
        copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
        copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i2, i2 + this.segmentSize);
      }
      return plaintext;
    };
    var ModeOfOperationOFB = function(key2, iv) {
      if (!(this instanceof ModeOfOperationOFB)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Output Feedback";
      this.name = "ofb";
      if (!iv) {
        iv = createArray(16);
      } else if (iv.length != 16) {
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      }
      this._lastPrecipher = coerceArray(iv, true);
      this._lastPrecipherIndex = 16;
      this._aes = new AES(key2);
    };
    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i2 = 0; i2 < encrypted.length; i2++) {
        if (this._lastPrecipherIndex === 16) {
          this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
          this._lastPrecipherIndex = 0;
        }
        encrypted[i2] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      }
      return encrypted;
    };
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
    var Counter = function(initialValue) {
      if (!(this instanceof Counter)) {
        throw Error("Counter must be instanitated with `new`");
      }
      if (initialValue !== 0 && !initialValue) {
        initialValue = 1;
      }
      if (typeof initialValue === "number") {
        this._counter = createArray(16);
        this.setValue(initialValue);
      } else {
        this.setBytes(initialValue);
      }
    };
    Counter.prototype.setValue = function(value2) {
      if (typeof value2 !== "number" || parseInt(value2) != value2) {
        throw new Error("invalid counter value (must be an integer)");
      }
      for (var index2 = 15; index2 >= 0; --index2) {
        this._counter[index2] = value2 % 256;
        value2 = value2 >> 8;
      }
    };
    Counter.prototype.setBytes = function(bytes3) {
      bytes3 = coerceArray(bytes3, true);
      if (bytes3.length != 16) {
        throw new Error("invalid counter bytes size (must be 16 bytes)");
      }
      this._counter = bytes3;
    };
    Counter.prototype.increment = function() {
      for (var i2 = 15; i2 >= 0; i2--) {
        if (this._counter[i2] === 255) {
          this._counter[i2] = 0;
        } else {
          this._counter[i2]++;
          break;
        }
      }
    };
    var ModeOfOperationCTR = function(key2, counter) {
      if (!(this instanceof ModeOfOperationCTR)) {
        throw Error("AES must be instanitated with `new`");
      }
      this.description = "Counter";
      this.name = "ctr";
      if (!(counter instanceof Counter)) {
        counter = new Counter(counter);
      }
      this._counter = counter;
      this._remainingCounter = null;
      this._remainingCounterIndex = 16;
      this._aes = new AES(key2);
    };
    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
      var encrypted = coerceArray(plaintext, true);
      for (var i2 = 0; i2 < encrypted.length; i2++) {
        if (this._remainingCounterIndex === 16) {
          this._remainingCounter = this._aes.encrypt(this._counter._counter);
          this._remainingCounterIndex = 0;
          this._counter.increment();
        }
        encrypted[i2] ^= this._remainingCounter[this._remainingCounterIndex++];
      }
      return encrypted;
    };
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
    function pkcs7pad(data) {
      data = coerceArray(data, true);
      var padder = 16 - data.length % 16;
      var result = createArray(data.length + padder);
      copyArray(data, result);
      for (var i2 = data.length; i2 < result.length; i2++) {
        result[i2] = padder;
      }
      return result;
    }
    function pkcs7strip(data) {
      data = coerceArray(data, true);
      if (data.length < 16) {
        throw new Error("PKCS#7 invalid length");
      }
      var padder = data[data.length - 1];
      if (padder > 16) {
        throw new Error("PKCS#7 padding byte out of range");
      }
      var length = data.length - padder;
      for (var i2 = 0; i2 < padder; i2++) {
        if (data[length + i2] !== padder) {
          throw new Error("PKCS#7 invalid padding byte");
        }
      }
      var result = createArray(length);
      copyArray(data, result, 0, 0, length);
      return result;
    }
    var aesjs = {
      AES,
      Counter,
      ModeOfOperation: {
        ecb: ModeOfOperationECB,
        cbc: ModeOfOperationCBC,
        cfb: ModeOfOperationCFB,
        ofb: ModeOfOperationOFB,
        ctr: ModeOfOperationCTR
      },
      utils: {
        hex: convertHex,
        utf8: convertUtf8
      },
      padding: {
        pkcs7: {
          pad: pkcs7pad,
          strip: pkcs7strip
        }
      },
      _arrayTest: {
        coerceArray,
        createArray,
        copyArray
      }
    };
    {
      module2.exports = aesjs;
    }
  })();
})(aesJs);
var aes = aesJs.exports;
const version$d = "json-wallets/5.5.0";
function looseArrayify(hexString) {
  if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
    hexString = "0x" + hexString;
  }
  return arrayify(hexString);
}
function zpad(value2, length) {
  value2 = String(value2);
  while (value2.length < length) {
    value2 = "0" + value2;
  }
  return value2;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
  }
  return arrayify(password);
}
function searchPath(object2, path) {
  let currentChild = object2;
  const comps = path.toLowerCase().split("/");
  for (let i2 = 0; i2 < comps.length; i2++) {
    let matchingChild = null;
    for (const key2 in currentChild) {
      if (key2.toLowerCase() === comps[i2]) {
        matchingChild = currentChild[key2];
        break;
      }
    }
    if (matchingChild === null) {
      return null;
    }
    currentChild = matchingChild;
  }
  return currentChild;
}
function uuidV4(randomBytes2) {
  const bytes3 = arrayify(randomBytes2);
  bytes3[6] = bytes3[6] & 15 | 64;
  bytes3[8] = bytes3[8] & 63 | 128;
  const value2 = hexlify(bytes3);
  return [
    value2.substring(2, 10),
    value2.substring(10, 14),
    value2.substring(14, 18),
    value2.substring(18, 22),
    value2.substring(22, 34)
  ].join("-");
}
const logger$e = new Logger(version$d);
class CrowdsaleAccount extends Description {
  isCrowdsaleAccount(value2) {
    return !!(value2 && value2._isCrowdsaleAccount);
  }
}
function decrypt$3(json2, password) {
  const data = JSON.parse(json2);
  password = getPassword(password);
  const ethaddr = getAddress(searchPath(data, "ethaddr"));
  const encseed = looseArrayify(searchPath(data, "encseed"));
  if (!encseed || encseed.length % 16 !== 0) {
    logger$e.throwArgumentError("invalid encseed", "json", json2);
  }
  const key2 = arrayify(pbkdf2$1(password, password, 2e3, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new aes.ModeOfOperation.cbc(key2, iv);
  const seed = aes.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i2 = 0; i2 < seed.length; i2++) {
    seedHex += String.fromCharCode(seed[i2]);
  }
  const seedHexBytes = toUtf8Bytes(seedHex);
  const privateKey = keccak256$1(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey
  });
}
function isCrowdsaleWallet(json2) {
  let data = null;
  try {
    data = JSON.parse(json2);
  } catch (error2) {
    return false;
  }
  return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json2) {
  let data = null;
  try {
    data = JSON.parse(json2);
  } catch (error2) {
    return false;
  }
  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  }
  return true;
}
function getJsonWalletAddress(json2) {
  if (isCrowdsaleWallet(json2)) {
    try {
      return getAddress(JSON.parse(json2).ethaddr);
    } catch (error2) {
      return null;
    }
  }
  if (isKeystoreWallet(json2)) {
    try {
      return getAddress(JSON.parse(json2).address);
    } catch (error2) {
      return null;
    }
  }
  return null;
}
var scrypt$1 = { exports: {} };
(function(module2, exports2) {
  (function(root2) {
    const MAX_VALUE = 2147483647;
    function SHA2562(m2) {
      const K2 = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      let h0 = 1779033703, h1 = 3144134277, h2 = 1013904242, h3 = 2773480762;
      let h4 = 1359893119, h5 = 2600822924, h6 = 528734635, h7 = 1541459225;
      const w2 = new Uint32Array(64);
      function blocks2(p3) {
        let off = 0, len2 = p3.length;
        while (len2 >= 64) {
          let a2 = h0, b2 = h1, c2 = h2, d2 = h3, e2 = h4, f2 = h5, g2 = h6, h8 = h7, u2, i3, j2, t1, t2;
          for (i3 = 0; i3 < 16; i3++) {
            j2 = off + i3 * 4;
            w2[i3] = (p3[j2] & 255) << 24 | (p3[j2 + 1] & 255) << 16 | (p3[j2 + 2] & 255) << 8 | p3[j2 + 3] & 255;
          }
          for (i3 = 16; i3 < 64; i3++) {
            u2 = w2[i3 - 2];
            t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
            u2 = w2[i3 - 15];
            t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
            w2[i3] = (t1 + w2[i3 - 7] | 0) + (t2 + w2[i3 - 16] | 0) | 0;
          }
          for (i3 = 0; i3 < 64; i3++) {
            t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f2 ^ ~e2 & g2) | 0) + (h8 + (K2[i3] + w2[i3] | 0) | 0) | 0;
            t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b2 ^ a2 & c2 ^ b2 & c2) | 0;
            h8 = g2;
            g2 = f2;
            f2 = e2;
            e2 = d2 + t1 | 0;
            d2 = c2;
            c2 = b2;
            b2 = a2;
            a2 = t1 + t2 | 0;
          }
          h0 = h0 + a2 | 0;
          h1 = h1 + b2 | 0;
          h2 = h2 + c2 | 0;
          h3 = h3 + d2 | 0;
          h4 = h4 + e2 | 0;
          h5 = h5 + f2 | 0;
          h6 = h6 + g2 | 0;
          h7 = h7 + h8 | 0;
          off += 64;
          len2 -= 64;
        }
      }
      blocks2(m2);
      let i2, bytesLeft = m2.length % 64, bitLenHi = m2.length / 536870912 | 0, bitLenLo = m2.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p2 = m2.slice(m2.length - bytesLeft, m2.length);
      p2.push(128);
      for (i2 = bytesLeft + 1; i2 < numZeros; i2++) {
        p2.push(0);
      }
      p2.push(bitLenHi >>> 24 & 255);
      p2.push(bitLenHi >>> 16 & 255);
      p2.push(bitLenHi >>> 8 & 255);
      p2.push(bitLenHi >>> 0 & 255);
      p2.push(bitLenLo >>> 24 & 255);
      p2.push(bitLenLo >>> 16 & 255);
      p2.push(bitLenLo >>> 8 & 255);
      p2.push(bitLenLo >>> 0 & 255);
      blocks2(p2);
      return [
        h0 >>> 24 & 255,
        h0 >>> 16 & 255,
        h0 >>> 8 & 255,
        h0 >>> 0 & 255,
        h1 >>> 24 & 255,
        h1 >>> 16 & 255,
        h1 >>> 8 & 255,
        h1 >>> 0 & 255,
        h2 >>> 24 & 255,
        h2 >>> 16 & 255,
        h2 >>> 8 & 255,
        h2 >>> 0 & 255,
        h3 >>> 24 & 255,
        h3 >>> 16 & 255,
        h3 >>> 8 & 255,
        h3 >>> 0 & 255,
        h4 >>> 24 & 255,
        h4 >>> 16 & 255,
        h4 >>> 8 & 255,
        h4 >>> 0 & 255,
        h5 >>> 24 & 255,
        h5 >>> 16 & 255,
        h5 >>> 8 & 255,
        h5 >>> 0 & 255,
        h6 >>> 24 & 255,
        h6 >>> 16 & 255,
        h6 >>> 8 & 255,
        h6 >>> 0 & 255,
        h7 >>> 24 & 255,
        h7 >>> 16 & 255,
        h7 >>> 8 & 255,
        h7 >>> 0 & 255
      ];
    }
    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
      password = password.length <= 64 ? password : SHA2562(password);
      const innerLen = 64 + salt.length + 4;
      const inner = new Array(innerLen);
      const outerKey = new Array(64);
      let i2;
      let dk = [];
      for (i2 = 0; i2 < 64; i2++) {
        inner[i2] = 54;
      }
      for (i2 = 0; i2 < password.length; i2++) {
        inner[i2] ^= password[i2];
      }
      for (i2 = 0; i2 < salt.length; i2++) {
        inner[64 + i2] = salt[i2];
      }
      for (i2 = innerLen - 4; i2 < innerLen; i2++) {
        inner[i2] = 0;
      }
      for (i2 = 0; i2 < 64; i2++)
        outerKey[i2] = 92;
      for (i2 = 0; i2 < password.length; i2++)
        outerKey[i2] ^= password[i2];
      function incrementCounter() {
        for (let i3 = innerLen - 1; i3 >= innerLen - 4; i3--) {
          inner[i3]++;
          if (inner[i3] <= 255)
            return;
          inner[i3] = 0;
        }
      }
      while (dkLen >= 32) {
        incrementCounter();
        dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))));
        dkLen -= 32;
      }
      if (dkLen > 0) {
        incrementCounter();
        dk = dk.concat(SHA2562(outerKey.concat(SHA2562(inner))).slice(0, dkLen));
      }
      return dk;
    }
    function blockmix_salsa8(BY, Yi, r2, x2, _X) {
      let i2;
      arraycopy(BY, (2 * r2 - 1) * 16, _X, 0, 16);
      for (i2 = 0; i2 < 2 * r2; i2++) {
        blockxor(BY, i2 * 16, _X, 16);
        salsa20_8(_X, x2);
        arraycopy(_X, 0, BY, Yi + i2 * 16, 16);
      }
      for (i2 = 0; i2 < r2; i2++) {
        arraycopy(BY, Yi + i2 * 2 * 16, BY, i2 * 16, 16);
      }
      for (i2 = 0; i2 < r2; i2++) {
        arraycopy(BY, Yi + (i2 * 2 + 1) * 16, BY, (i2 + r2) * 16, 16);
      }
    }
    function R3(a2, b2) {
      return a2 << b2 | a2 >>> 32 - b2;
    }
    function salsa20_8(B2, x2) {
      arraycopy(B2, 0, x2, 0, 16);
      for (let i2 = 8; i2 > 0; i2 -= 2) {
        x2[4] ^= R3(x2[0] + x2[12], 7);
        x2[8] ^= R3(x2[4] + x2[0], 9);
        x2[12] ^= R3(x2[8] + x2[4], 13);
        x2[0] ^= R3(x2[12] + x2[8], 18);
        x2[9] ^= R3(x2[5] + x2[1], 7);
        x2[13] ^= R3(x2[9] + x2[5], 9);
        x2[1] ^= R3(x2[13] + x2[9], 13);
        x2[5] ^= R3(x2[1] + x2[13], 18);
        x2[14] ^= R3(x2[10] + x2[6], 7);
        x2[2] ^= R3(x2[14] + x2[10], 9);
        x2[6] ^= R3(x2[2] + x2[14], 13);
        x2[10] ^= R3(x2[6] + x2[2], 18);
        x2[3] ^= R3(x2[15] + x2[11], 7);
        x2[7] ^= R3(x2[3] + x2[15], 9);
        x2[11] ^= R3(x2[7] + x2[3], 13);
        x2[15] ^= R3(x2[11] + x2[7], 18);
        x2[1] ^= R3(x2[0] + x2[3], 7);
        x2[2] ^= R3(x2[1] + x2[0], 9);
        x2[3] ^= R3(x2[2] + x2[1], 13);
        x2[0] ^= R3(x2[3] + x2[2], 18);
        x2[6] ^= R3(x2[5] + x2[4], 7);
        x2[7] ^= R3(x2[6] + x2[5], 9);
        x2[4] ^= R3(x2[7] + x2[6], 13);
        x2[5] ^= R3(x2[4] + x2[7], 18);
        x2[11] ^= R3(x2[10] + x2[9], 7);
        x2[8] ^= R3(x2[11] + x2[10], 9);
        x2[9] ^= R3(x2[8] + x2[11], 13);
        x2[10] ^= R3(x2[9] + x2[8], 18);
        x2[12] ^= R3(x2[15] + x2[14], 7);
        x2[13] ^= R3(x2[12] + x2[15], 9);
        x2[14] ^= R3(x2[13] + x2[12], 13);
        x2[15] ^= R3(x2[14] + x2[13], 18);
      }
      for (let i2 = 0; i2 < 16; ++i2) {
        B2[i2] += x2[i2];
      }
    }
    function blockxor(S3, Si, D2, len2) {
      for (let i2 = 0; i2 < len2; i2++) {
        D2[i2] ^= S3[Si + i2];
      }
    }
    function arraycopy(src2, srcPos, dest, destPos, length) {
      while (length--) {
        dest[destPos++] = src2[srcPos++];
      }
    }
    function checkBufferish(o2) {
      if (!o2 || typeof o2.length !== "number") {
        return false;
      }
      for (let i2 = 0; i2 < o2.length; i2++) {
        const v2 = o2[i2];
        if (typeof v2 !== "number" || v2 % 1 || v2 < 0 || v2 >= 256) {
          return false;
        }
      }
      return true;
    }
    function ensureInteger(value2, name2) {
      if (typeof value2 !== "number" || value2 % 1) {
        throw new Error("invalid " + name2);
      }
      return value2;
    }
    function _scrypt(password, salt, N2, r2, p2, dkLen, callback) {
      N2 = ensureInteger(N2, "N");
      r2 = ensureInteger(r2, "r");
      p2 = ensureInteger(p2, "p");
      dkLen = ensureInteger(dkLen, "dkLen");
      if (N2 === 0 || (N2 & N2 - 1) !== 0) {
        throw new Error("N must be power of 2");
      }
      if (N2 > MAX_VALUE / 128 / r2) {
        throw new Error("N too large");
      }
      if (r2 > MAX_VALUE / 128 / p2) {
        throw new Error("r too large");
      }
      if (!checkBufferish(password)) {
        throw new Error("password must be an array or buffer");
      }
      password = Array.prototype.slice.call(password);
      if (!checkBufferish(salt)) {
        throw new Error("salt must be an array or buffer");
      }
      salt = Array.prototype.slice.call(salt);
      let b2 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p2 * 128 * r2);
      const B2 = new Uint32Array(p2 * 32 * r2);
      for (let i2 = 0; i2 < B2.length; i2++) {
        const j2 = i2 * 4;
        B2[i2] = (b2[j2 + 3] & 255) << 24 | (b2[j2 + 2] & 255) << 16 | (b2[j2 + 1] & 255) << 8 | (b2[j2 + 0] & 255) << 0;
      }
      const XY = new Uint32Array(64 * r2);
      const V2 = new Uint32Array(32 * r2 * N2);
      const Yi = 32 * r2;
      const x2 = new Uint32Array(16);
      const _X = new Uint32Array(16);
      const totalOps = p2 * N2 * 2;
      let currentOp = 0;
      let lastPercent10 = null;
      let stop = false;
      let state2 = 0;
      let i0 = 0, i1;
      let Bi;
      const limit = callback ? parseInt(1e3 / r2) : 4294967295;
      const nextTick2 = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
      const incrementalSMix = function() {
        if (stop) {
          return callback(new Error("cancelled"), currentOp / totalOps);
        }
        let steps;
        switch (state2) {
          case 0:
            Bi = i0 * 32 * r2;
            arraycopy(B2, Bi, XY, 0, Yi);
            state2 = 1;
            i1 = 0;
          case 1:
            steps = N2 - i1;
            if (steps > limit) {
              steps = limit;
            }
            for (let i2 = 0; i2 < steps; i2++) {
              arraycopy(XY, 0, V2, (i1 + i2) * Yi, Yi);
              blockmix_salsa8(XY, Yi, r2, x2, _X);
            }
            i1 += steps;
            currentOp += steps;
            if (callback) {
              const percent10 = parseInt(1e3 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N2) {
              break;
            }
            i1 = 0;
            state2 = 2;
          case 2:
            steps = N2 - i1;
            if (steps > limit) {
              steps = limit;
            }
            for (let i2 = 0; i2 < steps; i2++) {
              const offset = (2 * r2 - 1) * 16;
              const j2 = XY[offset] & N2 - 1;
              blockxor(V2, j2 * Yi, XY, Yi);
              blockmix_salsa8(XY, Yi, r2, x2, _X);
            }
            i1 += steps;
            currentOp += steps;
            if (callback) {
              const percent10 = parseInt(1e3 * currentOp / totalOps);
              if (percent10 !== lastPercent10) {
                stop = callback(null, currentOp / totalOps);
                if (stop) {
                  break;
                }
                lastPercent10 = percent10;
              }
            }
            if (i1 < N2) {
              break;
            }
            arraycopy(XY, 0, B2, Bi, Yi);
            i0++;
            if (i0 < p2) {
              state2 = 0;
              break;
            }
            b2 = [];
            for (let i2 = 0; i2 < B2.length; i2++) {
              b2.push(B2[i2] >> 0 & 255);
              b2.push(B2[i2] >> 8 & 255);
              b2.push(B2[i2] >> 16 & 255);
              b2.push(B2[i2] >> 24 & 255);
            }
            const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b2, dkLen);
            if (callback) {
              callback(null, 1, derivedKey);
            }
            return derivedKey;
        }
        if (callback) {
          nextTick2(incrementalSMix);
        }
      };
      if (!callback) {
        while (true) {
          const derivedKey = incrementalSMix();
          if (derivedKey != void 0) {
            return derivedKey;
          }
        }
      }
      incrementalSMix();
    }
    const lib2 = {
      scrypt: function(password, salt, N2, r2, p2, dkLen, progressCallback) {
        return new Promise(function(resolve2, reject) {
          let lastProgress = 0;
          if (progressCallback) {
            progressCallback(0);
          }
          _scrypt(password, salt, N2, r2, p2, dkLen, function(error2, progress, key2) {
            if (error2) {
              reject(error2);
            } else if (key2) {
              if (progressCallback && lastProgress !== 1) {
                progressCallback(1);
              }
              resolve2(new Uint8Array(key2));
            } else if (progressCallback && progress !== lastProgress) {
              lastProgress = progress;
              return progressCallback(progress);
            }
          });
        });
      },
      syncScrypt: function(password, salt, N2, r2, p2, dkLen) {
        return new Uint8Array(_scrypt(password, salt, N2, r2, p2, dkLen));
      }
    };
    {
      module2.exports = lib2;
    }
  })();
})(scrypt$1);
var scrypt = scrypt$1.exports;
const version$c = "random/5.5.1";
const logger$d = new Logger(version$c);
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("unable to locate global object");
}
const anyGlobal$1 = getGlobal();
let crypto$5 = anyGlobal$1.crypto || anyGlobal$1.msCrypto;
if (!crypto$5 || !crypto$5.getRandomValues) {
  logger$d.warn("WARNING: Missing strong random number source");
  crypto$5 = {
    getRandomValues: function(buffer2) {
      return logger$d.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}
function randomBytes$3(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger$d.throwArgumentError("invalid length", "length", length);
  }
  const result = new Uint8Array(length);
  crypto$5.getRandomValues(result);
  return arrayify(result);
}
var __awaiter$8 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$c = new Logger(version$d);
function hasMnemonic$1(value2) {
  return value2 != null && value2.mnemonic && value2.mnemonic.phrase;
}
class KeystoreAccount extends Description {
  isKeystoreAccount(value2) {
    return !!(value2 && value2._isKeystoreAccount);
  }
}
function _decrypt(data, key2, ciphertext) {
  const cipher = searchPath(data, "crypto/cipher");
  if (cipher === "aes-128-ctr") {
    const iv = looseArrayify(searchPath(data, "crypto/cipherparams/iv"));
    const counter = new aes.Counter(iv);
    const aesCtr = new aes.ModeOfOperation.ctr(key2, counter);
    return arrayify(aesCtr.decrypt(ciphertext));
  }
  return null;
}
function _getAccount(data, key2) {
  const ciphertext = looseArrayify(searchPath(data, "crypto/ciphertext"));
  const computedMAC = hexlify(keccak256$1(concat$2([key2.slice(16, 32), ciphertext]))).substring(2);
  if (computedMAC !== searchPath(data, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }
  const privateKey = _decrypt(data, key2.slice(0, 16), ciphertext);
  if (!privateKey) {
    logger$c.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }
  const mnemonicKey = key2.slice(32, 64);
  const address = computeAddress(privateKey);
  if (data.address) {
    let check = data.address.toLowerCase();
    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }
    if (getAddress(check) !== address) {
      throw new Error("address mismatch");
    }
  }
  const account2 = {
    _isKeystoreAccount: true,
    address,
    privateKey: hexlify(privateKey)
  };
  if (searchPath(data, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = looseArrayify(searchPath(data, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = looseArrayify(searchPath(data, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new aes.Counter(mnemonicIv);
    const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
    const path = searchPath(data, "x-ethers/path") || defaultPath;
    const locale = searchPath(data, "x-ethers/locale") || "en";
    const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
    try {
      const mnemonic = entropyToMnemonic(entropy, locale);
      const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
      if (node.privateKey != account2.privateKey) {
        throw new Error("mnemonic mismatch");
      }
      account2.mnemonic = node.mnemonic;
    } catch (error2) {
      if (error2.code !== Logger.errors.INVALID_ARGUMENT || error2.argument !== "wordlist") {
        throw error2;
      }
    }
  }
  return new KeystoreAccount(account2);
}
function pbkdf2Sync(passwordBytes, salt, count2, dkLen, prfFunc) {
  return arrayify(pbkdf2$1(passwordBytes, salt, count2, dkLen, prfFunc));
}
function pbkdf2(passwordBytes, salt, count2, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count2, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = getPassword(password);
  const kdf = searchPath(data, "crypto/kdf");
  if (kdf && typeof kdf === "string") {
    const throwError2 = function(name2, value2) {
      return logger$c.throwArgumentError("invalid key-derivation function parameters", name2, value2);
    };
    if (kdf.toLowerCase() === "scrypt") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      const N2 = parseInt(searchPath(data, "crypto/kdfparams/n"));
      const r2 = parseInt(searchPath(data, "crypto/kdfparams/r"));
      const p2 = parseInt(searchPath(data, "crypto/kdfparams/p"));
      if (!N2 || !r2 || !p2) {
        throwError2("kdf", kdf);
      }
      if ((N2 & N2 - 1) !== 0) {
        throwError2("N", N2);
      }
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return scryptFunc(passwordBytes, salt, N2, r2, p2, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = looseArrayify(searchPath(data, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = searchPath(data, "crypto/kdfparams/prf");
      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError2("prf", prf);
      }
      const count2 = parseInt(searchPath(data, "crypto/kdfparams/c"));
      const dkLen = parseInt(searchPath(data, "crypto/kdfparams/dklen"));
      if (dkLen !== 32) {
        throwError2("dklen", dkLen);
      }
      return pbkdf2Func(passwordBytes, salt, count2, dkLen, prfFunc);
    }
  }
  return logger$c.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json2, password) {
  const data = JSON.parse(json2);
  const key2 = _computeKdfKey(data, password, pbkdf2Sync, scrypt.syncScrypt);
  return _getAccount(data, key2);
}
function decrypt$2(json2, password, progressCallback) {
  return __awaiter$8(this, void 0, void 0, function* () {
    const data = JSON.parse(json2);
    const key2 = yield _computeKdfKey(data, password, pbkdf2, scrypt.scrypt, progressCallback);
    return _getAccount(data, key2);
  });
}
function encrypt$2(account2, password, options, progressCallback) {
  try {
    if (getAddress(account2.address) !== computeAddress(account2.privateKey)) {
      throw new Error("address/privateKey mismatch");
    }
    if (hasMnemonic$1(account2)) {
      const mnemonic = account2.mnemonic;
      const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
      if (node.privateKey != account2.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e2) {
    return Promise.reject(e2);
  }
  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }
  if (!options) {
    options = {};
  }
  const privateKey = arrayify(account2.privateKey);
  const passwordBytes = getPassword(password);
  let entropy = null;
  let path = null;
  let locale = null;
  if (hasMnemonic$1(account2)) {
    const srcMnemonic = account2.mnemonic;
    entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || defaultPath;
    locale = srcMnemonic.locale || "en";
  }
  let client = options.client;
  if (!client) {
    client = "ethers.js";
  }
  let salt = null;
  if (options.salt) {
    salt = arrayify(options.salt);
  } else {
    salt = randomBytes$3(32);
  }
  let iv = null;
  if (options.iv) {
    iv = arrayify(options.iv);
    if (iv.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv = randomBytes$3(16);
  }
  let uuidRandom = null;
  if (options.uuid) {
    uuidRandom = arrayify(options.uuid);
    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = randomBytes$3(16);
  }
  let N2 = 1 << 17, r2 = 8, p2 = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N2 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r2 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p2 = options.scrypt.p;
    }
  }
  return scrypt.scrypt(passwordBytes, salt, N2, r2, p2, 64, progressCallback).then((key2) => {
    key2 = arrayify(key2);
    const derivedKey = key2.slice(0, 16);
    const macPrefix = key2.slice(16, 32);
    const mnemonicKey = key2.slice(32, 64);
    const counter = new aes.Counter(iv);
    const aesCtr = new aes.ModeOfOperation.ctr(derivedKey, counter);
    const ciphertext = arrayify(aesCtr.encrypt(privateKey));
    const mac = keccak256$1(concat$2([macPrefix, ciphertext]));
    const data = {
      address: account2.address.substring(2).toLowerCase(),
      id: uuidV4(uuidRandom),
      version: 3,
      Crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: hexlify(iv).substring(2)
        },
        ciphertext: hexlify(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: hexlify(salt).substring(2),
          n: N2,
          dklen: 32,
          p: p2,
          r: r2
        },
        mac: mac.substring(2)
      }
    };
    if (entropy) {
      const mnemonicIv = randomBytes$3(16);
      const mnemonicCounter = new aes.Counter(mnemonicIv);
      const mnemonicAesCtr = new aes.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
      const now = new Date();
      const timestamp2 = now.getUTCFullYear() + "-" + zpad(now.getUTCMonth() + 1, 2) + "-" + zpad(now.getUTCDate(), 2) + "T" + zpad(now.getUTCHours(), 2) + "-" + zpad(now.getUTCMinutes(), 2) + "-" + zpad(now.getUTCSeconds(), 2) + ".0Z";
      data["x-ethers"] = {
        client,
        gethFilename: "UTC--" + timestamp2 + "--" + data.address,
        mnemonicCounter: hexlify(mnemonicIv).substring(2),
        mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
        path,
        locale,
        version: "0.1"
      };
    }
    return JSON.stringify(data);
  });
}
function decryptJsonWallet(json2, password, progressCallback) {
  if (isCrowdsaleWallet(json2)) {
    if (progressCallback) {
      progressCallback(0);
    }
    const account2 = decrypt$3(json2, password);
    if (progressCallback) {
      progressCallback(1);
    }
    return Promise.resolve(account2);
  }
  if (isKeystoreWallet(json2)) {
    return decrypt$2(json2, password, progressCallback);
  }
  return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json2, password) {
  if (isCrowdsaleWallet(json2)) {
    return decrypt$3(json2, password);
  }
  if (isKeystoreWallet(json2)) {
    return decryptSync(json2, password);
  }
  throw new Error("invalid JSON wallet");
}
var lib_esm$5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  decryptCrowdsale: decrypt$3,
  decryptKeystore: decrypt$2,
  decryptKeystoreSync: decryptSync,
  encryptKeystore: encrypt$2,
  isCrowdsaleWallet,
  isKeystoreWallet,
  getJsonWalletAddress,
  decryptJsonWallet,
  decryptJsonWalletSync
});
var require$$7$1 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$5);
var require$$8 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$h);
var require$$9 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$k);
var require$$10 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$9);
const version$b = "solidity/5.5.0";
const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
const Zeros = "0000000000000000000000000000000000000000000000000000000000000000";
const logger$b = new Logger(version$b);
function _pack(type, value2, isArray2) {
  switch (type) {
    case "address":
      if (isArray2) {
        return zeroPad(value2, 32);
      }
      return arrayify(value2);
    case "string":
      return toUtf8Bytes(value2);
    case "bytes":
      return arrayify(value2);
    case "bool":
      value2 = value2 ? "0x01" : "0x00";
      if (isArray2) {
        return zeroPad(value2, 32);
      }
      return arrayify(value2);
  }
  let match = type.match(regexNumber);
  if (match) {
    let size2 = parseInt(match[2] || "256");
    if (match[2] && String(size2) !== match[2] || size2 % 8 !== 0 || size2 === 0 || size2 > 256) {
      logger$b.throwArgumentError("invalid number type", "type", type);
    }
    if (isArray2) {
      size2 = 256;
    }
    value2 = BigNumber.from(value2).toTwos(size2);
    return zeroPad(value2, size2 / 8);
  }
  match = type.match(regexBytes);
  if (match) {
    const size2 = parseInt(match[1]);
    if (String(size2) !== match[1] || size2 === 0 || size2 > 32) {
      logger$b.throwArgumentError("invalid bytes type", "type", type);
    }
    if (arrayify(value2).byteLength !== size2) {
      logger$b.throwArgumentError(`invalid value for ${type}`, "value", value2);
    }
    if (isArray2) {
      return arrayify((value2 + Zeros).substring(0, 66));
    }
    return value2;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value2)) {
    const baseType = match[1];
    const count2 = parseInt(match[2] || String(value2.length));
    if (count2 != value2.length) {
      logger$b.throwArgumentError(`invalid array length for ${type}`, "value", value2);
    }
    const result = [];
    value2.forEach(function(value3) {
      result.push(_pack(baseType, value3, true));
    });
    return concat$2(result);
  }
  return logger$b.throwArgumentError("invalid type", "type", type);
}
function pack(types2, values) {
  if (types2.length != values.length) {
    logger$b.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }
  const tight = [];
  types2.forEach(function(type, index2) {
    tight.push(_pack(type, values[index2]));
  });
  return hexlify(concat$2(tight));
}
function keccak256(types2, values) {
  return keccak256$1(pack(types2, values));
}
function sha256$2(types2, values) {
  return sha256$3(pack(types2, values));
}
var lib_esm$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  pack,
  keccak256,
  sha256: sha256$2
});
var require$$11 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$4);
const version$a = "random/5.5.0";
const logger$a = new Logger(version$a);
let anyGlobal = null;
try {
  anyGlobal = window;
  if (anyGlobal == null) {
    throw new Error("try next");
  }
} catch (error2) {
  try {
    anyGlobal = global;
    if (anyGlobal == null) {
      throw new Error("try next");
    }
  } catch (error3) {
    anyGlobal = {};
  }
}
let crypto$4 = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto$4 || !crypto$4.getRandomValues) {
  logger$a.warn("WARNING: Missing strong random number source");
  crypto$4 = {
    getRandomValues: function(buffer2) {
      return logger$a.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}
function randomBytes$2(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger$a.throwArgumentError("invalid length", "length", length);
  }
  const result = new Uint8Array(length);
  crypto$4.getRandomValues(result);
  return arrayify(result);
}
function shuffled(array2) {
  array2 = array2.slice();
  for (let i2 = array2.length - 1; i2 > 0; i2--) {
    const j2 = Math.floor(Math.random() * (i2 + 1));
    const tmp = array2[i2];
    array2[i2] = array2[j2];
    array2[j2] = tmp;
  }
  return array2;
}
var lib_esm$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  randomBytes: randomBytes$2,
  shuffled
});
var require$$12 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$3);
var require$$13 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$i);
var require$$14 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$g);
var require$$15 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$8);
var require$$16 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$e);
var require$$17 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$7);
const version$9 = "units/5.5.0";
const logger$9 = new Logger(version$9);
const names$1 = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function commify(value2) {
  const comps = String(value2).split(".");
  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value2 === "." || value2 === "-.") {
    logger$9.throwArgumentError("invalid value", "value", value2);
  }
  let whole = comps[0];
  let negative = "";
  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  }
  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }
  if (whole === "") {
    whole = "0";
  }
  let suffix = "";
  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }
  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }
  const formatted = [];
  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index2 = whole.length - 3;
      formatted.unshift(whole.substring(index2));
      whole = whole.substring(0, index2);
    }
  }
  return negative + formatted.join(",") + suffix;
}
function formatUnits(value2, unitName) {
  if (typeof unitName === "string") {
    const index2 = names$1.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return formatFixed(value2, unitName != null ? unitName : 18);
}
function parseUnits(value2, unitName) {
  if (typeof value2 !== "string") {
    logger$9.throwArgumentError("value must be a string", "value", value2);
  }
  if (typeof unitName === "string") {
    const index2 = names$1.indexOf(unitName);
    if (index2 !== -1) {
      unitName = 3 * index2;
    }
  }
  return parseFixed(value2, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
var lib_esm$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  commify,
  formatUnits,
  parseUnits,
  formatEther,
  parseEther
});
var require$$18 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$2);
const version$8 = "abstract-provider/5.5.1";
var __awaiter$7 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$8 = new Logger(version$8);
class ForkEvent extends Description {
  static isForkEvent(value2) {
    return !!(value2 && value2._isForkEvent);
  }
}
class Provider {
  constructor() {
    logger$8.checkAbstract(new.target, Provider);
    defineReadOnly(this, "_isProvider", true);
  }
  getFeeData() {
    return __awaiter$7(this, void 0, void 0, function* () {
      const { block, gasPrice } = yield resolveProperties({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((error2) => {
          return null;
        })
      });
      let maxFeePerGas = null, maxPriorityFeePerGas = null;
      if (block && block.baseFeePerGas) {
        maxPriorityFeePerGas = BigNumber.from("2500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }
      return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };
    });
  }
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }
  static isProvider(value2) {
    return !!(value2 && value2._isProvider);
  }
}
const version$7 = "abstract-signer/5.5.0";
var __awaiter$6 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$7 = new Logger(version$7);
const allowedTransactionKeys$1 = [
  "accessList",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
];
const forwardErrors = [
  Logger.errors.INSUFFICIENT_FUNDS,
  Logger.errors.NONCE_EXPIRED,
  Logger.errors.REPLACEMENT_UNDERPRICED
];
class Signer {
  constructor() {
    logger$7.checkAbstract(new.target, Signer);
    defineReadOnly(this, "_isSigner", true);
  }
  getBalance(blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");
      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }
  getTransactionCount(blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");
      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  }
  estimateGas(transaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  }
  call(transaction, blockTag) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  }
  sendTransaction(transaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }
  getChainId() {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");
      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }
  getGasPrice() {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");
      return yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");
      return yield this.provider.getFeeData();
    });
  }
  resolveName(name2) {
    return __awaiter$6(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");
      return yield this.provider.resolveName(name2);
    });
  }
  checkTransaction(transaction) {
    for (const key2 in transaction) {
      if (allowedTransactionKeys$1.indexOf(key2) === -1) {
        logger$7.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
      }
    }
    const tx = shallowCopy(transaction);
    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      tx.from = Promise.all([
        Promise.resolve(tx.from),
        this.getAddress()
      ]).then((result) => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger$7.throwArgumentError("from address mismatch", "transaction", transaction);
        }
        return result[0];
      });
    }
    return tx;
  }
  populateTransaction(transaction) {
    return __awaiter$6(this, void 0, void 0, function* () {
      const tx = yield resolveProperties(this.checkTransaction(transaction));
      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then((to) => __awaiter$6(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }
          const address = yield this.resolveName(to);
          if (address == null) {
            logger$7.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }
          return address;
        }));
        tx.to.catch((error2) => {
        });
      }
      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger$7.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger$7.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }
      if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        const feeData = yield this.getFeeData();
        if (tx.type == null) {
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            tx.type = 2;
            if (tx.gasPrice != null) {
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }
              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            if (hasEip1559) {
              logger$7.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            }
            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            }
            tx.type = 0;
          } else {
            logger$7.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }
          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }
      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }
      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch((error2) => {
          if (forwardErrors.indexOf(error2.code) >= 0) {
            throw error2;
          }
          return logger$7.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error: error2,
            tx
          });
        });
      }
      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([
          Promise.resolve(tx.chainId),
          this.getChainId()
        ]).then((results2) => {
          if (results2[1] !== 0 && results2[0] !== results2[1]) {
            logger$7.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }
          return results2[0];
        });
      }
      return yield resolveProperties(tx);
    });
  }
  _checkProvider(operation) {
    if (!this.provider) {
      logger$7.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }
  static isSigner(value2) {
    return !!(value2 && value2._isSigner);
  }
}
const version$6 = "wallet/5.5.0";
var __awaiter$5 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$6 = new Logger(version$6);
function isAccount(value2) {
  return value2 != null && isHexString$5(value2.privateKey, 32) && value2.address != null;
}
function hasMnemonic(value2) {
  const mnemonic = value2.mnemonic;
  return mnemonic && mnemonic.phrase;
}
class Wallet extends Signer {
  constructor(privateKey, provider) {
    logger$6.checkNew(new.target, Wallet);
    super();
    if (isAccount(privateKey)) {
      const signingKey = new SigningKey(privateKey.privateKey);
      defineReadOnly(this, "_signingKey", () => signingKey);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
      if (this.address !== getAddress(privateKey.address)) {
        logger$6.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
      }
      if (hasMnemonic(privateKey)) {
        const srcMnemonic = privateKey.mnemonic;
        defineReadOnly(this, "_mnemonic", () => ({
          phrase: srcMnemonic.phrase,
          path: srcMnemonic.path || defaultPath,
          locale: srcMnemonic.locale || "en"
        }));
        const mnemonic = this.mnemonic;
        const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
        if (computeAddress(node.privateKey) !== this.address) {
          logger$6.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
        }
      } else {
        defineReadOnly(this, "_mnemonic", () => null);
      }
    } else {
      if (SigningKey.isSigningKey(privateKey)) {
        if (privateKey.curve !== "secp256k1") {
          logger$6.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
        }
        defineReadOnly(this, "_signingKey", () => privateKey);
      } else {
        if (typeof privateKey === "string") {
          if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
            privateKey = "0x" + privateKey;
          }
        }
        const signingKey = new SigningKey(privateKey);
        defineReadOnly(this, "_signingKey", () => signingKey);
      }
      defineReadOnly(this, "_mnemonic", () => null);
      defineReadOnly(this, "address", computeAddress(this.publicKey));
    }
    if (provider && !Provider.isProvider(provider)) {
      logger$6.throwArgumentError("invalid provider", "provider", provider);
    }
    defineReadOnly(this, "provider", provider || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(provider) {
    return new Wallet(this, provider);
  }
  signTransaction(transaction) {
    return resolveProperties(transaction).then((tx) => {
      if (tx.from != null) {
        if (getAddress(tx.from) !== this.address) {
          logger$6.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
        }
        delete tx.from;
      }
      const signature2 = this._signingKey().signDigest(keccak256$1(serialize(tx)));
      return serialize(tx, signature2);
    });
  }
  signMessage(message) {
    return __awaiter$5(this, void 0, void 0, function* () {
      return joinSignature(this._signingKey().signDigest(hashMessage(message)));
    });
  }
  _signTypedData(domain2, types2, value2) {
    return __awaiter$5(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain2, types2, value2, (name2) => {
        if (this.provider == null) {
          logger$6.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName",
            value: name2
          });
        }
        return this.provider.resolveName(name2);
      });
      return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types2, populated.value)));
    });
  }
  encrypt(password, options, progressCallback) {
    if (typeof options === "function" && !progressCallback) {
      progressCallback = options;
      options = {};
    }
    if (progressCallback && typeof progressCallback !== "function") {
      throw new Error("invalid callback");
    }
    if (!options) {
      options = {};
    }
    return encrypt$2(this, password, options, progressCallback);
  }
  static createRandom(options) {
    let entropy = randomBytes$3(16);
    if (!options) {
      options = {};
    }
    if (options.extraEntropy) {
      entropy = arrayify(hexDataSlice(keccak256$1(concat$2([entropy, options.extraEntropy])), 0, 16));
    }
    const mnemonic = entropyToMnemonic(entropy, options.locale);
    return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
  }
  static fromEncryptedJson(json2, password, progressCallback) {
    return decryptJsonWallet(json2, password, progressCallback).then((account2) => {
      return new Wallet(account2);
    });
  }
  static fromEncryptedJsonSync(json2, password) {
    return new Wallet(decryptJsonWalletSync(json2, password));
  }
  static fromMnemonic(mnemonic, path, wordlist2) {
    if (!path) {
      path = defaultPath;
    }
    return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist2).derivePath(path));
  }
}
function verifyMessage(message, signature2) {
  return recoverAddress(hashMessage(message), signature2);
}
function verifyTypedData(domain2, types2, value2, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain2, types2, value2), signature2);
}
var lib_esm$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  Wallet,
  verifyMessage,
  verifyTypedData
});
var require$$19 = /* @__PURE__ */ getAugmentedNamespace(lib_esm$1);
const version$5 = "web/5.5.1";
var __awaiter$4 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getUrl(href, options) {
  return __awaiter$4(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }
    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || void 0
    };
    if (options.skipFetchSetup !== true) {
      request.mode = "cors";
      request.cache = "no-cache";
      request.credentials = "same-origin";
      request.redirect = "follow";
      request.referrer = "client";
    }
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};
    if (response.headers.forEach) {
      response.headers.forEach((value2, key2) => {
        headers[key2.toLowerCase()] = value2;
      });
    } else {
      response.headers.keys().forEach((key2) => {
        headers[key2.toLowerCase()] = response.headers.get(key2);
      });
    }
    return {
      headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: arrayify(new Uint8Array(body))
    };
  });
}
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$5 = new Logger(version$5);
function staller(duration) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, duration);
  });
}
function bodyify(value2, type) {
  if (value2 == null) {
    return null;
  }
  if (typeof value2 === "string") {
    return value2;
  }
  if (isBytesLike(value2)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value2);
      } catch (error2) {
      }
    }
    return hexlify(value2);
  }
  return value2;
}
function _fetchData(connection, body, processFunc) {
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger$5.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger$5.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const headers = {};
  let url2 = null;
  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout2 = 2 * 60 * 1e3;
  if (typeof connection === "string") {
    url2 = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger$5.throwArgumentError("missing URL", "connection.url", connection);
    }
    url2 = connection.url;
    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout2 = connection.timeout;
    }
    if (connection.headers) {
      for (const key2 in connection.headers) {
        headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
        if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }
    options.allowGzip = !!connection.allowGzip;
    if (connection.user != null && connection.password != null) {
      if (url2.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger$5.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url: url2, user: connection.user, password: "[REDACTED]" });
      }
      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + encode$3(toUtf8Bytes(authorization))
      };
    }
  }
  const reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
  const dataMatch = url2 ? url2.match(reData) : null;
  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": dataMatch[1] },
        body: decode$4(dataMatch[2])
      };
      let result = response.body;
      if (processFunc) {
        result = processFunc(response.body, response);
      }
      return Promise.resolve(result);
    } catch (error2) {
      logger$5.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error: error2,
        requestBody: null,
        requestMethod: "GET",
        url: url2
      });
    }
  }
  if (body) {
    options.method = "POST";
    options.body = body;
    if (headers["content-type"] == null) {
      headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
    }
    if (headers["content-length"] == null) {
      headers["content-length"] = { key: "Content-Length", value: String(body.length) };
    }
  }
  const flatHeaders = {};
  Object.keys(headers).forEach((key2) => {
    const header = headers[key2];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;
  const runningTimeout = function() {
    let timer2 = null;
    const promise = new Promise(function(resolve2, reject) {
      if (timeout2) {
        timer2 = setTimeout(() => {
          if (timer2 == null) {
            return;
          }
          timer2 = null;
          reject(logger$5.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout: timeout2,
            url: url2
          }));
        }, timeout2);
      }
    });
    const cancel = function() {
      if (timer2 == null) {
        return;
      }
      clearTimeout(timer2);
      timer2 = null;
    };
    return { promise, cancel };
  }();
  const runningFetch = function() {
    return __awaiter$3(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;
        try {
          response = yield getUrl(url2, options);
          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              const location2 = response.headers.location || "";
              if (options.method === "GET" && location2.match(/^https:/)) {
                url2 = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url2);
              }
              if (tryAgain) {
                let stall2 = 0;
                const retryAfter = response.headers["retry-after"];
                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall2 = parseInt(retryAfter) * 1e3;
                } else {
                  stall2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                }
                yield staller(stall2);
                continue;
              }
            }
          }
        } catch (error2) {
          response = error2.response;
          if (response == null) {
            runningTimeout.cancel();
            logger$5.throwError("missing response", Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error2,
              url: url2
            });
          }
        }
        let body2 = response.body;
        if (allow304 && response.statusCode === 304) {
          body2 = null;
        } else if (response.statusCode < 200 || response.statusCode >= 300) {
          runningTimeout.cancel();
          logger$5.throwError("bad response", Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url: url2
          });
        }
        if (processFunc) {
          try {
            const result = yield processFunc(body2, response);
            runningTimeout.cancel();
            return result;
          } catch (error2) {
            if (error2.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;
              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url2);
              }
              if (tryAgain) {
                const timeout3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                yield staller(timeout3);
                continue;
              }
            }
            runningTimeout.cancel();
            logger$5.throwError("processing response error", Logger.errors.SERVER_ERROR, {
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              error: error2,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url: url2
            });
          }
        }
        runningTimeout.cancel();
        return body2;
      }
      return logger$5.throwError("failed response", Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url: url2
      });
    });
  }();
  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json2, processFunc) {
  let processJsonFunc = (value2, response) => {
    let result = null;
    if (value2 != null) {
      try {
        result = JSON.parse(toUtf8String(value2));
      } catch (error2) {
        logger$5.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value2,
          error: error2
        });
      }
    }
    if (processFunc) {
      result = processFunc(result, response);
    }
    return result;
  };
  let body = null;
  if (json2 != null) {
    body = toUtf8Bytes(json2);
    const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter((k2) => k2.toLowerCase() === "content-type").length !== 0;
      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = { "content-type": "application/json" };
    }
    connection = updated;
  }
  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }
  options = shallowCopy(options);
  if (options.floor == null) {
    options.floor = 0;
  }
  if (options.ceiling == null) {
    options.ceiling = 1e4;
  }
  if (options.interval == null) {
    options.interval = 250;
  }
  return new Promise(function(resolve2, reject) {
    let timer2 = null;
    let done2 = false;
    const cancel = () => {
      if (done2) {
        return false;
      }
      done2 = true;
      if (timer2) {
        clearTimeout(timer2);
      }
      return true;
    };
    if (options.timeout) {
      timer2 = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }
    const retryLimit = options.retryLimit;
    let attempt = 0;
    function check() {
      return func().then(function(result) {
        if (result !== void 0) {
          if (cancel()) {
            resolve2(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check);
        } else if (!done2) {
          attempt++;
          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }
            return;
          }
          let timeout2 = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
          if (timeout2 < options.floor) {
            timeout2 = options.floor;
          }
          if (timeout2 > options.ceiling) {
            timeout2 = options.ceiling;
          }
          setTimeout(check, timeout2);
        }
        return null;
      }, function(error2) {
        if (cancel()) {
          reject(error2);
        }
      });
    }
    check();
  });
}
var lib_esm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  _fetchData,
  fetchJson,
  poll
});
var require$$20 = /* @__PURE__ */ getAugmentedNamespace(lib_esm);
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k2 in mod)
        if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
          __createBinding2(result, mod, k2);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.formatBytes32String = exports2.Utf8ErrorFuncs = exports2.toUtf8String = exports2.toUtf8CodePoints = exports2.toUtf8Bytes = exports2._toEscapedUtf8String = exports2.nameprep = exports2.hexDataSlice = exports2.hexDataLength = exports2.hexZeroPad = exports2.hexValue = exports2.hexStripZeros = exports2.hexConcat = exports2.isHexString = exports2.hexlify = exports2.base64 = exports2.base58 = exports2.TransactionDescription = exports2.LogDescription = exports2.Interface = exports2.SigningKey = exports2.HDNode = exports2.defaultPath = exports2.isBytesLike = exports2.isBytes = exports2.zeroPad = exports2.stripZeros = exports2.concat = exports2.arrayify = exports2.shallowCopy = exports2.resolveProperties = exports2.getStatic = exports2.defineReadOnly = exports2.deepCopy = exports2.checkProperties = exports2.poll = exports2.fetchJson = exports2._fetchData = exports2.RLP = exports2.Logger = exports2.checkResultErrors = exports2.FormatTypes = exports2.ParamType = exports2.FunctionFragment = exports2.EventFragment = exports2.ErrorFragment = exports2.ConstructorFragment = exports2.Fragment = exports2.defaultAbiCoder = exports2.AbiCoder = void 0;
  exports2.Indexed = exports2.Utf8ErrorReason = exports2.UnicodeNormalizationForm = exports2.SupportedAlgorithm = exports2.mnemonicToSeed = exports2.isValidMnemonic = exports2.entropyToMnemonic = exports2.mnemonicToEntropy = exports2.getAccountPath = exports2.verifyTypedData = exports2.verifyMessage = exports2.recoverPublicKey = exports2.computePublicKey = exports2.recoverAddress = exports2.computeAddress = exports2.getJsonWalletAddress = exports2.TransactionTypes = exports2.serializeTransaction = exports2.parseTransaction = exports2.accessListify = exports2.joinSignature = exports2.splitSignature = exports2.soliditySha256 = exports2.solidityKeccak256 = exports2.solidityPack = exports2.shuffled = exports2.randomBytes = exports2.sha512 = exports2.sha256 = exports2.ripemd160 = exports2.keccak256 = exports2.computeHmac = exports2.commify = exports2.parseUnits = exports2.formatUnits = exports2.parseEther = exports2.formatEther = exports2.isAddress = exports2.getCreate2Address = exports2.getContractAddress = exports2.getIcapAddress = exports2.getAddress = exports2._TypedDataEncoder = exports2.id = exports2.isValidName = exports2.namehash = exports2.hashMessage = exports2.parseBytes32String = void 0;
  var abi_1 = require$$0$3;
  Object.defineProperty(exports2, "AbiCoder", { enumerable: true, get: function() {
    return abi_1.AbiCoder;
  } });
  Object.defineProperty(exports2, "checkResultErrors", { enumerable: true, get: function() {
    return abi_1.checkResultErrors;
  } });
  Object.defineProperty(exports2, "ConstructorFragment", { enumerable: true, get: function() {
    return abi_1.ConstructorFragment;
  } });
  Object.defineProperty(exports2, "defaultAbiCoder", { enumerable: true, get: function() {
    return abi_1.defaultAbiCoder;
  } });
  Object.defineProperty(exports2, "ErrorFragment", { enumerable: true, get: function() {
    return abi_1.ErrorFragment;
  } });
  Object.defineProperty(exports2, "EventFragment", { enumerable: true, get: function() {
    return abi_1.EventFragment;
  } });
  Object.defineProperty(exports2, "FormatTypes", { enumerable: true, get: function() {
    return abi_1.FormatTypes;
  } });
  Object.defineProperty(exports2, "Fragment", { enumerable: true, get: function() {
    return abi_1.Fragment;
  } });
  Object.defineProperty(exports2, "FunctionFragment", { enumerable: true, get: function() {
    return abi_1.FunctionFragment;
  } });
  Object.defineProperty(exports2, "Indexed", { enumerable: true, get: function() {
    return abi_1.Indexed;
  } });
  Object.defineProperty(exports2, "Interface", { enumerable: true, get: function() {
    return abi_1.Interface;
  } });
  Object.defineProperty(exports2, "LogDescription", { enumerable: true, get: function() {
    return abi_1.LogDescription;
  } });
  Object.defineProperty(exports2, "ParamType", { enumerable: true, get: function() {
    return abi_1.ParamType;
  } });
  Object.defineProperty(exports2, "TransactionDescription", { enumerable: true, get: function() {
    return abi_1.TransactionDescription;
  } });
  var address_1 = require$$1$3;
  Object.defineProperty(exports2, "getAddress", { enumerable: true, get: function() {
    return address_1.getAddress;
  } });
  Object.defineProperty(exports2, "getCreate2Address", { enumerable: true, get: function() {
    return address_1.getCreate2Address;
  } });
  Object.defineProperty(exports2, "getContractAddress", { enumerable: true, get: function() {
    return address_1.getContractAddress;
  } });
  Object.defineProperty(exports2, "getIcapAddress", { enumerable: true, get: function() {
    return address_1.getIcapAddress;
  } });
  Object.defineProperty(exports2, "isAddress", { enumerable: true, get: function() {
    return address_1.isAddress;
  } });
  var base64 = __importStar2(require$$2$3);
  exports2.base64 = base64;
  var basex_1 = require$$3$1;
  Object.defineProperty(exports2, "base58", { enumerable: true, get: function() {
    return basex_1.Base58;
  } });
  var bytes_12 = require$$4;
  Object.defineProperty(exports2, "arrayify", { enumerable: true, get: function() {
    return bytes_12.arrayify;
  } });
  Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
    return bytes_12.concat;
  } });
  Object.defineProperty(exports2, "hexConcat", { enumerable: true, get: function() {
    return bytes_12.hexConcat;
  } });
  Object.defineProperty(exports2, "hexDataSlice", { enumerable: true, get: function() {
    return bytes_12.hexDataSlice;
  } });
  Object.defineProperty(exports2, "hexDataLength", { enumerable: true, get: function() {
    return bytes_12.hexDataLength;
  } });
  Object.defineProperty(exports2, "hexlify", { enumerable: true, get: function() {
    return bytes_12.hexlify;
  } });
  Object.defineProperty(exports2, "hexStripZeros", { enumerable: true, get: function() {
    return bytes_12.hexStripZeros;
  } });
  Object.defineProperty(exports2, "hexValue", { enumerable: true, get: function() {
    return bytes_12.hexValue;
  } });
  Object.defineProperty(exports2, "hexZeroPad", { enumerable: true, get: function() {
    return bytes_12.hexZeroPad;
  } });
  Object.defineProperty(exports2, "isBytes", { enumerable: true, get: function() {
    return bytes_12.isBytes;
  } });
  Object.defineProperty(exports2, "isBytesLike", { enumerable: true, get: function() {
    return bytes_12.isBytesLike;
  } });
  Object.defineProperty(exports2, "isHexString", { enumerable: true, get: function() {
    return bytes_12.isHexString;
  } });
  Object.defineProperty(exports2, "joinSignature", { enumerable: true, get: function() {
    return bytes_12.joinSignature;
  } });
  Object.defineProperty(exports2, "zeroPad", { enumerable: true, get: function() {
    return bytes_12.zeroPad;
  } });
  Object.defineProperty(exports2, "splitSignature", { enumerable: true, get: function() {
    return bytes_12.splitSignature;
  } });
  Object.defineProperty(exports2, "stripZeros", { enumerable: true, get: function() {
    return bytes_12.stripZeros;
  } });
  var hash_12 = require$$5;
  Object.defineProperty(exports2, "_TypedDataEncoder", { enumerable: true, get: function() {
    return hash_12._TypedDataEncoder;
  } });
  Object.defineProperty(exports2, "hashMessage", { enumerable: true, get: function() {
    return hash_12.hashMessage;
  } });
  Object.defineProperty(exports2, "id", { enumerable: true, get: function() {
    return hash_12.id;
  } });
  Object.defineProperty(exports2, "isValidName", { enumerable: true, get: function() {
    return hash_12.isValidName;
  } });
  Object.defineProperty(exports2, "namehash", { enumerable: true, get: function() {
    return hash_12.namehash;
  } });
  var hdnode_1 = require$$6;
  Object.defineProperty(exports2, "defaultPath", { enumerable: true, get: function() {
    return hdnode_1.defaultPath;
  } });
  Object.defineProperty(exports2, "entropyToMnemonic", { enumerable: true, get: function() {
    return hdnode_1.entropyToMnemonic;
  } });
  Object.defineProperty(exports2, "getAccountPath", { enumerable: true, get: function() {
    return hdnode_1.getAccountPath;
  } });
  Object.defineProperty(exports2, "HDNode", { enumerable: true, get: function() {
    return hdnode_1.HDNode;
  } });
  Object.defineProperty(exports2, "isValidMnemonic", { enumerable: true, get: function() {
    return hdnode_1.isValidMnemonic;
  } });
  Object.defineProperty(exports2, "mnemonicToEntropy", { enumerable: true, get: function() {
    return hdnode_1.mnemonicToEntropy;
  } });
  Object.defineProperty(exports2, "mnemonicToSeed", { enumerable: true, get: function() {
    return hdnode_1.mnemonicToSeed;
  } });
  var json_wallets_1 = require$$7$1;
  Object.defineProperty(exports2, "getJsonWalletAddress", { enumerable: true, get: function() {
    return json_wallets_1.getJsonWalletAddress;
  } });
  var keccak256_1 = require$$8;
  Object.defineProperty(exports2, "keccak256", { enumerable: true, get: function() {
    return keccak256_1.keccak256;
  } });
  var logger_1 = require$$9;
  Object.defineProperty(exports2, "Logger", { enumerable: true, get: function() {
    return logger_1.Logger;
  } });
  var sha2_1 = require$$10;
  Object.defineProperty(exports2, "computeHmac", { enumerable: true, get: function() {
    return sha2_1.computeHmac;
  } });
  Object.defineProperty(exports2, "ripemd160", { enumerable: true, get: function() {
    return sha2_1.ripemd160;
  } });
  Object.defineProperty(exports2, "sha256", { enumerable: true, get: function() {
    return sha2_1.sha256;
  } });
  Object.defineProperty(exports2, "sha512", { enumerable: true, get: function() {
    return sha2_1.sha512;
  } });
  var solidity_1 = require$$11;
  Object.defineProperty(exports2, "solidityKeccak256", { enumerable: true, get: function() {
    return solidity_1.keccak256;
  } });
  Object.defineProperty(exports2, "solidityPack", { enumerable: true, get: function() {
    return solidity_1.pack;
  } });
  Object.defineProperty(exports2, "soliditySha256", { enumerable: true, get: function() {
    return solidity_1.sha256;
  } });
  var random_1 = require$$12;
  Object.defineProperty(exports2, "randomBytes", { enumerable: true, get: function() {
    return random_1.randomBytes;
  } });
  Object.defineProperty(exports2, "shuffled", { enumerable: true, get: function() {
    return random_1.shuffled;
  } });
  var properties_1 = require$$13;
  Object.defineProperty(exports2, "checkProperties", { enumerable: true, get: function() {
    return properties_1.checkProperties;
  } });
  Object.defineProperty(exports2, "deepCopy", { enumerable: true, get: function() {
    return properties_1.deepCopy;
  } });
  Object.defineProperty(exports2, "defineReadOnly", { enumerable: true, get: function() {
    return properties_1.defineReadOnly;
  } });
  Object.defineProperty(exports2, "getStatic", { enumerable: true, get: function() {
    return properties_1.getStatic;
  } });
  Object.defineProperty(exports2, "resolveProperties", { enumerable: true, get: function() {
    return properties_1.resolveProperties;
  } });
  Object.defineProperty(exports2, "shallowCopy", { enumerable: true, get: function() {
    return properties_1.shallowCopy;
  } });
  var RLP = __importStar2(require$$14);
  exports2.RLP = RLP;
  var signing_key_1 = require$$15;
  Object.defineProperty(exports2, "computePublicKey", { enumerable: true, get: function() {
    return signing_key_1.computePublicKey;
  } });
  Object.defineProperty(exports2, "recoverPublicKey", { enumerable: true, get: function() {
    return signing_key_1.recoverPublicKey;
  } });
  Object.defineProperty(exports2, "SigningKey", { enumerable: true, get: function() {
    return signing_key_1.SigningKey;
  } });
  var strings_1 = require$$16;
  Object.defineProperty(exports2, "formatBytes32String", { enumerable: true, get: function() {
    return strings_1.formatBytes32String;
  } });
  Object.defineProperty(exports2, "nameprep", { enumerable: true, get: function() {
    return strings_1.nameprep;
  } });
  Object.defineProperty(exports2, "parseBytes32String", { enumerable: true, get: function() {
    return strings_1.parseBytes32String;
  } });
  Object.defineProperty(exports2, "_toEscapedUtf8String", { enumerable: true, get: function() {
    return strings_1._toEscapedUtf8String;
  } });
  Object.defineProperty(exports2, "toUtf8Bytes", { enumerable: true, get: function() {
    return strings_1.toUtf8Bytes;
  } });
  Object.defineProperty(exports2, "toUtf8CodePoints", { enumerable: true, get: function() {
    return strings_1.toUtf8CodePoints;
  } });
  Object.defineProperty(exports2, "toUtf8String", { enumerable: true, get: function() {
    return strings_1.toUtf8String;
  } });
  Object.defineProperty(exports2, "Utf8ErrorFuncs", { enumerable: true, get: function() {
    return strings_1.Utf8ErrorFuncs;
  } });
  var transactions_1 = require$$17;
  Object.defineProperty(exports2, "accessListify", { enumerable: true, get: function() {
    return transactions_1.accessListify;
  } });
  Object.defineProperty(exports2, "computeAddress", { enumerable: true, get: function() {
    return transactions_1.computeAddress;
  } });
  Object.defineProperty(exports2, "parseTransaction", { enumerable: true, get: function() {
    return transactions_1.parse;
  } });
  Object.defineProperty(exports2, "recoverAddress", { enumerable: true, get: function() {
    return transactions_1.recoverAddress;
  } });
  Object.defineProperty(exports2, "serializeTransaction", { enumerable: true, get: function() {
    return transactions_1.serialize;
  } });
  Object.defineProperty(exports2, "TransactionTypes", { enumerable: true, get: function() {
    return transactions_1.TransactionTypes;
  } });
  var units_1 = require$$18;
  Object.defineProperty(exports2, "commify", { enumerable: true, get: function() {
    return units_1.commify;
  } });
  Object.defineProperty(exports2, "formatEther", { enumerable: true, get: function() {
    return units_1.formatEther;
  } });
  Object.defineProperty(exports2, "parseEther", { enumerable: true, get: function() {
    return units_1.parseEther;
  } });
  Object.defineProperty(exports2, "formatUnits", { enumerable: true, get: function() {
    return units_1.formatUnits;
  } });
  Object.defineProperty(exports2, "parseUnits", { enumerable: true, get: function() {
    return units_1.parseUnits;
  } });
  var wallet_1 = require$$19;
  Object.defineProperty(exports2, "verifyMessage", { enumerable: true, get: function() {
    return wallet_1.verifyMessage;
  } });
  Object.defineProperty(exports2, "verifyTypedData", { enumerable: true, get: function() {
    return wallet_1.verifyTypedData;
  } });
  var web_1 = require$$20;
  Object.defineProperty(exports2, "_fetchData", { enumerable: true, get: function() {
    return web_1._fetchData;
  } });
  Object.defineProperty(exports2, "fetchJson", { enumerable: true, get: function() {
    return web_1.fetchJson;
  } });
  Object.defineProperty(exports2, "poll", { enumerable: true, get: function() {
    return web_1.poll;
  } });
  var sha2_2 = require$$10;
  Object.defineProperty(exports2, "SupportedAlgorithm", { enumerable: true, get: function() {
    return sha2_2.SupportedAlgorithm;
  } });
  var strings_2 = require$$16;
  Object.defineProperty(exports2, "UnicodeNormalizationForm", { enumerable: true, get: function() {
    return strings_2.UnicodeNormalizationForm;
  } });
  Object.defineProperty(exports2, "Utf8ErrorReason", { enumerable: true, get: function() {
    return strings_2.Utf8ErrorReason;
  } });
})(utils$r);
var events$1 = { exports: {} };
var R$2 = typeof Reflect === "object" ? Reflect : null;
var ReflectApply$1 = R$2 && typeof R$2.apply === "function" ? R$2.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R$2 && typeof R$2.ownKeys === "function") {
  ReflectOwnKeys = R$2.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
  return value2 !== value2;
};
function EventEmitter$4() {
  EventEmitter$4.init.call(this);
}
events$1.exports = EventEmitter$4;
events$1.exports.once = once$3;
EventEmitter$4.EventEmitter = EventEmitter$4;
EventEmitter$4.prototype._events = void 0;
EventEmitter$4.prototype._eventsCount = 0;
EventEmitter$4.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter$4, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter$4.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$4.prototype.setMaxListeners = function setMaxListeners(n2) {
  if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
  }
  this._maxListeners = n2;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$4.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$4.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter$4.prototype.emit = function emit(type) {
  var args = [];
  for (var i2 = 1; i2 < arguments.length; i2++)
    args.push(arguments[i2]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply$1(handler, this, args);
  } else {
    var len2 = handler.length;
    var listeners2 = arrayClone$2(handler, len2);
    for (var i2 = 0; i2 < len2; ++i2)
      ReflectApply$1(listeners2[i2], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit("newListener", type, listener.listener ? listener.listener : listener);
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
EventEmitter$4.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter$4.prototype.on = EventEmitter$4.prototype.addListener;
EventEmitter$4.prototype.prependListener = function prependListener2(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state2 = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state2);
  wrapped.listener = listener;
  state2.wrapFn = wrapped;
  return wrapped;
}
EventEmitter$4.prototype.once = function once2(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$4.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$4.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position, i2, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length - 1; i2 >= 0; i2--) {
      if (list[i2] === listener || list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter$4.prototype.off = EventEmitter$4.prototype.removeListener;
EventEmitter$4.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i2;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys2 = Object.keys(events2);
    var key2;
    for (i2 = 0; i2 < keys2.length; ++i2) {
      key2 = keys2[i2];
      if (key2 === "removeListener")
        continue;
      this.removeAllListeners(key2);
    }
    this.removeAllListeners("removeListener");
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i2 = listeners2.length - 1; i2 >= 0; i2--) {
      this.removeListener(type, listeners2[i2]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone$2(evlistener, evlistener.length);
}
EventEmitter$4.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter$4.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter$4.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter$4.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$4.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone$2(arr2, n2) {
  var copy3 = new Array(n2);
  for (var i2 = 0; i2 < n2; ++i2)
    copy3[i2] = arr2[i2];
  return copy3;
}
function spliceOne(list, index2) {
  for (; index2 + 1 < list.length; index2++)
    list[index2] = list[index2 + 1];
  list.pop();
}
function unwrapListeners(arr2) {
  var ret = new Array(arr2.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr2[i2].listener || arr2[i2];
  }
  return ret;
}
function once$3(emitter, name2) {
  return new Promise(function(resolve2, reject) {
    function errorListener(err) {
      emitter.removeListener(name2, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve2([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
    if (name2 !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name2, listener);
    } else {
      emitter.on(name2, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name2, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name2, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var util$7 = {};
var types$2 = {};
var shams$1 = function hasSymbols2() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var hasSymbols$2 = shams$1;
var shams = function hasToStringTagShams() {
  return hasSymbols$2() && !!Symbol.toStringTag;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams$1;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice$1 = Array.prototype.slice;
var toStr$1 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$1 = function bind2(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice$1.call(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice$1.call(arguments)));
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(that, args.concat(slice$1.call(arguments)));
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i2 = 0; i2 < boundLength; i2++) {
    boundArgs.push("$" + i2);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var bind$2 = functionBind;
var src$2 = bind$2.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e2) {
  }
};
var $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1) {
  try {
    $gOPD$1({}, "");
  } catch (e2) {
    $gOPD$1 = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError();
};
var ThrowTypeError = $gOPD$1 ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = hasSymbols$1();
var getProto$1 = Object.getPrototypeOf || function(x2) {
  return x2.__proto__;
};
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto$1(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined$1 : getProto$1(new Map()[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined$1 : getProto$1(new Set()[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
var doEval = function doEval2(name2) {
  var value2;
  if (name2 === "%AsyncFunction%") {
    value2 = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value2 = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value2 = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn = doEval2("%AsyncGeneratorFunction%");
    if (fn) {
      value2 = fn.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen) {
      value2 = getProto$1(gen.prototype);
    }
  }
  INTRINSICS[name2] = value2;
  return value2;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind$1 = functionBind;
var hasOwn$1 = src$2;
var $concat = bind$1.call(Function.call, Array.prototype.concat);
var $spliceApply = bind$1.call(Function.apply, Array.prototype.splice);
var $replace = bind$1.call(Function.call, String.prototype.replace);
var $strSlice = bind$1.call(Function.call, String.prototype.slice);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string2) {
  var first2 = $strSlice(string2, 0, 1);
  var last2 = $strSlice(string2, -1);
  if (first2 === "%" && last2 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last2 === "%" && first2 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace(string2, rePropName, function(match, number2, quote2, subString) {
    result[result.length] = quote2 ? $replace(subString, reEscapeChar, "$1") : number2 || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value2 = INTRINSICS[intrinsicName];
    if (value2 === needsEval) {
      value2 = doEval(intrinsicName);
    }
    if (typeof value2 === "undefined" && !allowMissing) {
      throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value: value2
    };
  }
  throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic2(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }
  var parts = stringToPath(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value2 = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
    var part = parts[i2];
    var first2 = $strSlice(part, 0, 1);
    var last2 = $strSlice(part, -1);
    if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value2 = INTRINSICS[intrinsicRealName];
    } else if (value2 != null) {
      if (!(part in value2)) {
        if (!allowMissing) {
          throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD$1 && i2 + 1 >= parts.length) {
        var desc = $gOPD$1(value2, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value2 = desc.get;
        } else {
          value2 = value2[part];
        }
      } else {
        isOwn = hasOwn$1(value2, part);
        value2 = value2[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value2;
      }
    }
  }
  return value2;
};
var callBind$1 = { exports: {} };
(function(module2) {
  var bind3 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind3.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty = null;
    }
  }
  module2.exports = function callBind2(originalFunction) {
    var func = $reflectApply(bind3, $call, arguments);
    if ($gOPD2 && $defineProperty) {
      var desc = $gOPD2(func, "length");
      if (desc.configurable) {
        $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind3, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module2.exports, "apply", { value: applyBind });
  } else {
    module2.exports.apply = applyBind;
  }
})(callBind$1);
var GetIntrinsic$1 = getIntrinsic;
var callBind = callBind$1.exports;
var $indexOf$1 = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$3 = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = GetIntrinsic$1(name2, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf$1(name2, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
var hasToStringTag$3 = shams();
var callBound$2 = callBound$3;
var $toString$2 = callBound$2("Object.prototype.toString");
var isStandardArguments = function isArguments2(value2) {
  if (hasToStringTag$3 && value2 && typeof value2 === "object" && Symbol.toStringTag in value2) {
    return false;
  }
  return $toString$2(value2) === "[object Arguments]";
};
var isLegacyArguments = function isArguments3(value2) {
  if (isStandardArguments(value2)) {
    return true;
  }
  return value2 !== null && typeof value2 === "object" && typeof value2.length === "number" && value2.length >= 0 && $toString$2(value2) !== "[object Array]" && $toString$2(value2.callee) === "[object Function]";
};
var supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$2 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
var toStr = Object.prototype.toString;
var fnToStr = Function.prototype.toString;
var isFnRegex = /^\s*(?:function)?\*/;
var hasToStringTag$2 = shams();
var getProto = Object.getPrototypeOf;
var getGeneratorFunc = function() {
  if (!hasToStringTag$2) {
    return false;
  }
  try {
    return Function("return function*() {}")();
  } catch (e2) {
  }
};
var GeneratorFunction;
var isGeneratorFunction = function isGeneratorFunction2(fn) {
  if (typeof fn !== "function") {
    return false;
  }
  if (isFnRegex.test(fnToStr.call(fn))) {
    return true;
  }
  if (!hasToStringTag$2) {
    var str2 = toStr.call(fn);
    return str2 === "[object GeneratorFunction]";
  }
  if (!getProto) {
    return false;
  }
  if (typeof GeneratorFunction === "undefined") {
    var generatorFunc = getGeneratorFunc();
    GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
  }
  return getProto(fn) === GeneratorFunction;
};
var hasOwn = Object.prototype.hasOwnProperty;
var toString$2 = Object.prototype.toString;
var foreach = function forEach2(obj, fn, ctx) {
  if (toString$2.call(fn) !== "[object Function]") {
    throw new TypeError("iterator must be a function");
  }
  var l2 = obj.length;
  if (l2 === +l2) {
    for (var i2 = 0; i2 < l2; i2++) {
      fn.call(ctx, obj[i2], i2, obj);
    }
  } else {
    for (var k2 in obj) {
      if (hasOwn.call(obj, k2)) {
        fn.call(ctx, obj[k2], k2, obj);
      }
    }
  }
};
var possibleNames = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
];
var g$6 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var availableTypedArrays$2 = function availableTypedArrays2() {
  var out = [];
  for (var i2 = 0; i2 < possibleNames.length; i2++) {
    if (typeof g$6[possibleNames[i2]] === "function") {
      out[out.length] = possibleNames[i2];
    }
  }
  return out;
};
var GetIntrinsic = getIntrinsic;
var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
if ($gOPD) {
  try {
    $gOPD([], "length");
  } catch (e2) {
    $gOPD = null;
  }
}
var getOwnPropertyDescriptor = $gOPD;
var forEach$1 = foreach;
var availableTypedArrays$1 = availableTypedArrays$2;
var callBound$1 = callBound$3;
var $toString$1 = callBound$1("Object.prototype.toString");
var hasToStringTag$1 = shams();
var g$5 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var typedArrays$1 = availableTypedArrays$1();
var $indexOf = callBound$1("Array.prototype.indexOf", true) || function indexOf2(array2, value2) {
  for (var i2 = 0; i2 < array2.length; i2 += 1) {
    if (array2[i2] === value2) {
      return i2;
    }
  }
  return -1;
};
var $slice$1 = callBound$1("String.prototype.slice");
var toStrTags$1 = {};
var gOPD$1 = getOwnPropertyDescriptor;
var getPrototypeOf$1 = Object.getPrototypeOf;
if (hasToStringTag$1 && gOPD$1 && getPrototypeOf$1) {
  forEach$1(typedArrays$1, function(typedArray) {
    var arr2 = new g$5[typedArray]();
    if (Symbol.toStringTag in arr2) {
      var proto = getPrototypeOf$1(arr2);
      var descriptor = gOPD$1(proto, Symbol.toStringTag);
      if (!descriptor) {
        var superProto = getPrototypeOf$1(proto);
        descriptor = gOPD$1(superProto, Symbol.toStringTag);
      }
      toStrTags$1[typedArray] = descriptor.get;
    }
  });
}
var tryTypedArrays$1 = function tryAllTypedArrays(value2) {
  var anyTrue = false;
  forEach$1(toStrTags$1, function(getter, typedArray) {
    if (!anyTrue) {
      try {
        anyTrue = getter.call(value2) === typedArray;
      } catch (e2) {
      }
    }
  });
  return anyTrue;
};
var isTypedArray$6 = function isTypedArray2(value2) {
  if (!value2 || typeof value2 !== "object") {
    return false;
  }
  if (!hasToStringTag$1 || !(Symbol.toStringTag in value2)) {
    var tag = $slice$1($toString$1(value2), 8, -1);
    return $indexOf(typedArrays$1, tag) > -1;
  }
  if (!gOPD$1) {
    return false;
  }
  return tryTypedArrays$1(value2);
};
var forEach = foreach;
var availableTypedArrays = availableTypedArrays$2;
var callBound = callBound$3;
var $toString = callBound("Object.prototype.toString");
var hasToStringTag = shams();
var g$4 = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound("String.prototype.slice");
var toStrTags = {};
var gOPD = getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
if (hasToStringTag && gOPD && getPrototypeOf) {
  forEach(typedArrays, function(typedArray) {
    if (typeof g$4[typedArray] === "function") {
      var arr2 = new g$4[typedArray]();
      if (Symbol.toStringTag in arr2) {
        var proto = getPrototypeOf(arr2);
        var descriptor = gOPD(proto, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto);
          descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor.get;
      }
    }
  });
}
var tryTypedArrays = function tryAllTypedArrays2(value2) {
  var foundName = false;
  forEach(toStrTags, function(getter, typedArray) {
    if (!foundName) {
      try {
        var name2 = getter.call(value2);
        if (name2 === typedArray) {
          foundName = name2;
        }
      } catch (e2) {
      }
    }
  });
  return foundName;
};
var isTypedArray$5 = isTypedArray$6;
var whichTypedArray = function whichTypedArray2(value2) {
  if (!isTypedArray$5(value2)) {
    return false;
  }
  if (!hasToStringTag || !(Symbol.toStringTag in value2)) {
    return $slice($toString(value2), 8, -1);
  }
  return tryTypedArrays(value2);
};
(function(exports2) {
  var isArgumentsObject = isArguments$2;
  var isGeneratorFunction$1 = isGeneratorFunction;
  var whichTypedArray$1 = whichTypedArray;
  var isTypedArray3 = isTypedArray$6;
  function uncurryThis(f2) {
    return f2.call.bind(f2);
  }
  var BigIntSupported = typeof BigInt !== "undefined";
  var SymbolSupported = typeof Symbol !== "undefined";
  var ObjectToString = uncurryThis(Object.prototype.toString);
  var numberValue = uncurryThis(Number.prototype.valueOf);
  var stringValue = uncurryThis(String.prototype.valueOf);
  var booleanValue = uncurryThis(Boolean.prototype.valueOf);
  if (BigIntSupported) {
    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
  }
  if (SymbolSupported) {
    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
  }
  function checkBoxedPrimitive(value2, prototypeValueOf) {
    if (typeof value2 !== "object") {
      return false;
    }
    try {
      prototypeValueOf(value2);
      return true;
    } catch (e2) {
      return false;
    }
  }
  exports2.isArgumentsObject = isArgumentsObject;
  exports2.isGeneratorFunction = isGeneratorFunction$1;
  exports2.isTypedArray = isTypedArray3;
  function isPromise2(input) {
    return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
  }
  exports2.isPromise = isPromise2;
  function isArrayBufferView(value2) {
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      return ArrayBuffer.isView(value2);
    }
    return isTypedArray3(value2) || isDataView(value2);
  }
  exports2.isArrayBufferView = isArrayBufferView;
  function isUint8Array2(value2) {
    return whichTypedArray$1(value2) === "Uint8Array";
  }
  exports2.isUint8Array = isUint8Array2;
  function isUint8ClampedArray(value2) {
    return whichTypedArray$1(value2) === "Uint8ClampedArray";
  }
  exports2.isUint8ClampedArray = isUint8ClampedArray;
  function isUint16Array(value2) {
    return whichTypedArray$1(value2) === "Uint16Array";
  }
  exports2.isUint16Array = isUint16Array;
  function isUint32Array(value2) {
    return whichTypedArray$1(value2) === "Uint32Array";
  }
  exports2.isUint32Array = isUint32Array;
  function isInt8Array(value2) {
    return whichTypedArray$1(value2) === "Int8Array";
  }
  exports2.isInt8Array = isInt8Array;
  function isInt16Array(value2) {
    return whichTypedArray$1(value2) === "Int16Array";
  }
  exports2.isInt16Array = isInt16Array;
  function isInt32Array(value2) {
    return whichTypedArray$1(value2) === "Int32Array";
  }
  exports2.isInt32Array = isInt32Array;
  function isFloat32Array(value2) {
    return whichTypedArray$1(value2) === "Float32Array";
  }
  exports2.isFloat32Array = isFloat32Array;
  function isFloat64Array(value2) {
    return whichTypedArray$1(value2) === "Float64Array";
  }
  exports2.isFloat64Array = isFloat64Array;
  function isBigInt64Array(value2) {
    return whichTypedArray$1(value2) === "BigInt64Array";
  }
  exports2.isBigInt64Array = isBigInt64Array;
  function isBigUint64Array(value2) {
    return whichTypedArray$1(value2) === "BigUint64Array";
  }
  exports2.isBigUint64Array = isBigUint64Array;
  function isMapToString(value2) {
    return ObjectToString(value2) === "[object Map]";
  }
  isMapToString.working = typeof Map !== "undefined" && isMapToString(new Map());
  function isMap2(value2) {
    if (typeof Map === "undefined") {
      return false;
    }
    return isMapToString.working ? isMapToString(value2) : value2 instanceof Map;
  }
  exports2.isMap = isMap2;
  function isSetToString(value2) {
    return ObjectToString(value2) === "[object Set]";
  }
  isSetToString.working = typeof Set !== "undefined" && isSetToString(new Set());
  function isSet2(value2) {
    if (typeof Set === "undefined") {
      return false;
    }
    return isSetToString.working ? isSetToString(value2) : value2 instanceof Set;
  }
  exports2.isSet = isSet2;
  function isWeakMapToString(value2) {
    return ObjectToString(value2) === "[object WeakMap]";
  }
  isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap());
  function isWeakMap(value2) {
    if (typeof WeakMap === "undefined") {
      return false;
    }
    return isWeakMapToString.working ? isWeakMapToString(value2) : value2 instanceof WeakMap;
  }
  exports2.isWeakMap = isWeakMap;
  function isWeakSetToString(value2) {
    return ObjectToString(value2) === "[object WeakSet]";
  }
  isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet());
  function isWeakSet(value2) {
    return isWeakSetToString(value2);
  }
  exports2.isWeakSet = isWeakSet;
  function isArrayBufferToString(value2) {
    return ObjectToString(value2) === "[object ArrayBuffer]";
  }
  isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
  function isArrayBuffer2(value2) {
    if (typeof ArrayBuffer === "undefined") {
      return false;
    }
    return isArrayBufferToString.working ? isArrayBufferToString(value2) : value2 instanceof ArrayBuffer;
  }
  exports2.isArrayBuffer = isArrayBuffer2;
  function isDataViewToString(value2) {
    return ObjectToString(value2) === "[object DataView]";
  }
  isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
  function isDataView(value2) {
    if (typeof DataView === "undefined") {
      return false;
    }
    return isDataViewToString.working ? isDataViewToString(value2) : value2 instanceof DataView;
  }
  exports2.isDataView = isDataView;
  var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
  function isSharedArrayBufferToString(value2) {
    return ObjectToString(value2) === "[object SharedArrayBuffer]";
  }
  function isSharedArrayBuffer(value2) {
    if (typeof SharedArrayBufferCopy === "undefined") {
      return false;
    }
    if (typeof isSharedArrayBufferToString.working === "undefined") {
      isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
    }
    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value2) : value2 instanceof SharedArrayBufferCopy;
  }
  exports2.isSharedArrayBuffer = isSharedArrayBuffer;
  function isAsyncFunction(value2) {
    return ObjectToString(value2) === "[object AsyncFunction]";
  }
  exports2.isAsyncFunction = isAsyncFunction;
  function isMapIterator(value2) {
    return ObjectToString(value2) === "[object Map Iterator]";
  }
  exports2.isMapIterator = isMapIterator;
  function isSetIterator(value2) {
    return ObjectToString(value2) === "[object Set Iterator]";
  }
  exports2.isSetIterator = isSetIterator;
  function isGeneratorObject(value2) {
    return ObjectToString(value2) === "[object Generator]";
  }
  exports2.isGeneratorObject = isGeneratorObject;
  function isWebAssemblyCompiledModule(value2) {
    return ObjectToString(value2) === "[object WebAssembly.Module]";
  }
  exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
  function isNumberObject(value2) {
    return checkBoxedPrimitive(value2, numberValue);
  }
  exports2.isNumberObject = isNumberObject;
  function isStringObject(value2) {
    return checkBoxedPrimitive(value2, stringValue);
  }
  exports2.isStringObject = isStringObject;
  function isBooleanObject(value2) {
    return checkBoxedPrimitive(value2, booleanValue);
  }
  exports2.isBooleanObject = isBooleanObject;
  function isBigIntObject(value2) {
    return BigIntSupported && checkBoxedPrimitive(value2, bigIntValue);
  }
  exports2.isBigIntObject = isBigIntObject;
  function isSymbolObject(value2) {
    return SymbolSupported && checkBoxedPrimitive(value2, symbolValue);
  }
  exports2.isSymbolObject = isSymbolObject;
  function isBoxedPrimitive(value2) {
    return isNumberObject(value2) || isStringObject(value2) || isBooleanObject(value2) || isBigIntObject(value2) || isSymbolObject(value2);
  }
  exports2.isBoxedPrimitive = isBoxedPrimitive;
  function isAnyArrayBuffer(value2) {
    return typeof Uint8Array !== "undefined" && (isArrayBuffer2(value2) || isSharedArrayBuffer(value2));
  }
  exports2.isAnyArrayBuffer = isAnyArrayBuffer;
  ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method2) {
    Object.defineProperty(exports2, method2, {
      enumerable: false,
      value: function() {
        throw new Error(method2 + " is not supported in userland");
      }
    });
  });
})(types$2);
var isBufferBrowser = function isBuffer2(arg) {
  return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
};
(function(exports2) {
  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
    var keys2 = Object.keys(obj);
    var descriptors = {};
    for (var i2 = 0; i2 < keys2.length; i2++) {
      descriptors[keys2[i2]] = Object.getOwnPropertyDescriptor(obj, keys2[i2]);
    }
    return descriptors;
  };
  var formatRegExp = /%[sdj%]/g;
  exports2.format = function(f2) {
    if (!isString2(f2)) {
      var objects = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        objects.push(inspect10(arguments[i2]));
      }
      return objects.join(" ");
    }
    var i2 = 1;
    var args = arguments;
    var len2 = args.length;
    var str2 = String(f2).replace(formatRegExp, function(x3) {
      if (x3 === "%%")
        return "%";
      if (i2 >= len2)
        return x3;
      switch (x3) {
        case "%s":
          return String(args[i2++]);
        case "%d":
          return Number(args[i2++]);
        case "%j":
          try {
            return JSON.stringify(args[i2++]);
          } catch (_2) {
            return "[Circular]";
          }
        default:
          return x3;
      }
    });
    for (var x2 = args[i2]; i2 < len2; x2 = args[++i2]) {
      if (isNull(x2) || !isObject2(x2)) {
        str2 += " " + x2;
      } else {
        str2 += " " + inspect10(x2);
      }
    }
    return str2;
  };
  exports2.deprecate = function(fn, msg) {
    if (typeof process !== "undefined" && process.noDeprecation === true) {
      return fn;
    }
    if (typeof process === "undefined") {
      return function() {
        return exports2.deprecate(fn, msg).apply(this, arguments);
      };
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (process.throwDeprecation) {
          throw new Error(msg);
        } else if (process.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  };
  var debugs = {};
  var debugEnvRegex = /^$/;
  exports2.debuglog = function(set6) {
    set6 = set6.toUpperCase();
    if (!debugs[set6]) {
      if (debugEnvRegex.test(set6)) {
        var pid = process.pid;
        debugs[set6] = function() {
          var msg = exports2.format.apply(exports2, arguments);
          console.error("%s %d: %s", set6, pid, msg);
        };
      } else {
        debugs[set6] = function() {
        };
      }
    }
    return debugs[set6];
  };
  function inspect10(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean2(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      exports2._extend(ctx, opts);
    }
    if (isUndefined2(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined2(ctx.depth))
      ctx.depth = 2;
    if (isUndefined2(ctx.colors))
      ctx.colors = false;
    if (isUndefined2(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  exports2.inspect = inspect10;
  inspect10.colors = {
    "bold": [1, 22],
    "italic": [3, 23],
    "underline": [4, 24],
    "inverse": [7, 27],
    "white": [37, 39],
    "grey": [90, 39],
    "black": [30, 39],
    "blue": [34, 39],
    "cyan": [36, 39],
    "green": [32, 39],
    "magenta": [35, 39],
    "red": [31, 39],
    "yellow": [33, 39]
  };
  inspect10.styles = {
    "special": "cyan",
    "number": "yellow",
    "boolean": "yellow",
    "undefined": "grey",
    "null": "bold",
    "string": "green",
    "date": "magenta",
    "regexp": "red"
  };
  function stylizeWithColor(str2, styleType) {
    var style = inspect10.styles[styleType];
    if (style) {
      return "[" + inspect10.colors[style][0] + "m" + str2 + "[" + inspect10.colors[style][1] + "m";
    } else {
      return str2;
    }
  }
  function stylizeNoColor(str2, styleType) {
    return str2;
  }
  function arrayToHash(array2) {
    var hash3 = {};
    array2.forEach(function(val, idx) {
      hash3[val] = true;
    });
    return hash3;
  }
  function formatValue(ctx, value2, recurseTimes) {
    if (ctx.customInspect && value2 && isFunction2(value2.inspect) && value2.inspect !== exports2.inspect && !(value2.constructor && value2.constructor.prototype === value2)) {
      var ret = value2.inspect(recurseTimes, ctx);
      if (!isString2(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value2);
    if (primitive) {
      return primitive;
    }
    var keys2 = Object.keys(value2);
    var visibleKeys = arrayToHash(keys2);
    if (ctx.showHidden) {
      keys2 = Object.getOwnPropertyNames(value2);
    }
    if (isError(value2) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
      return formatError(value2);
    }
    if (keys2.length === 0) {
      if (isFunction2(value2)) {
        var name2 = value2.name ? ": " + value2.name : "";
        return ctx.stylize("[Function" + name2 + "]", "special");
      }
      if (isRegExp2(value2)) {
        return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
      }
      if (isDate2(value2)) {
        return ctx.stylize(Date.prototype.toString.call(value2), "date");
      }
      if (isError(value2)) {
        return formatError(value2);
      }
    }
    var base2 = "", array2 = false, braces = ["{", "}"];
    if (isArray2(value2)) {
      array2 = true;
      braces = ["[", "]"];
    }
    if (isFunction2(value2)) {
      var n2 = value2.name ? ": " + value2.name : "";
      base2 = " [Function" + n2 + "]";
    }
    if (isRegExp2(value2)) {
      base2 = " " + RegExp.prototype.toString.call(value2);
    }
    if (isDate2(value2)) {
      base2 = " " + Date.prototype.toUTCString.call(value2);
    }
    if (isError(value2)) {
      base2 = " " + formatError(value2);
    }
    if (keys2.length === 0 && (!array2 || value2.length == 0)) {
      return braces[0] + base2 + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp2(value2)) {
        return ctx.stylize(RegExp.prototype.toString.call(value2), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value2);
    var output;
    if (array2) {
      output = formatArray(ctx, value2, recurseTimes, visibleKeys, keys2);
    } else {
      output = keys2.map(function(key2) {
        return formatProperty(ctx, value2, recurseTimes, visibleKeys, key2, array2);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base2, braces);
  }
  function formatPrimitive(ctx, value2) {
    if (isUndefined2(value2))
      return ctx.stylize("undefined", "undefined");
    if (isString2(value2)) {
      var simple = "'" + JSON.stringify(value2).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber2(value2))
      return ctx.stylize("" + value2, "number");
    if (isBoolean2(value2))
      return ctx.stylize("" + value2, "boolean");
    if (isNull(value2))
      return ctx.stylize("null", "null");
  }
  function formatError(value2) {
    return "[" + Error.prototype.toString.call(value2) + "]";
  }
  function formatArray(ctx, value2, recurseTimes, visibleKeys, keys2) {
    var output = [];
    for (var i2 = 0, l2 = value2.length; i2 < l2; ++i2) {
      if (hasOwnProperty2(value2, String(i2))) {
        output.push(formatProperty(ctx, value2, recurseTimes, visibleKeys, String(i2), true));
      } else {
        output.push("");
      }
    }
    keys2.forEach(function(key2) {
      if (!key2.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value2, recurseTimes, visibleKeys, key2, true));
      }
    });
    return output;
  }
  function formatProperty(ctx, value2, recurseTimes, visibleKeys, key2, array2) {
    var name2, str2, desc;
    desc = Object.getOwnPropertyDescriptor(value2, key2) || { value: value2[key2] };
    if (desc.get) {
      if (desc.set) {
        str2 = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str2 = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str2 = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty2(visibleKeys, key2)) {
      name2 = "[" + key2 + "]";
    }
    if (!str2) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str2 = formatValue(ctx, desc.value, null);
        } else {
          str2 = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str2.indexOf("\n") > -1) {
          if (array2) {
            str2 = str2.split("\n").map(function(line) {
              return "  " + line;
            }).join("\n").substr(2);
          } else {
            str2 = "\n" + str2.split("\n").map(function(line) {
              return "   " + line;
            }).join("\n");
          }
        }
      } else {
        str2 = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined2(name2)) {
      if (array2 && key2.match(/^\d+$/)) {
        return str2;
      }
      name2 = JSON.stringify("" + key2);
      if (name2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name2 = name2.substr(1, name2.length - 2);
        name2 = ctx.stylize(name2, "name");
      } else {
        name2 = name2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name2 = ctx.stylize(name2, "string");
      }
    }
    return name2 + ": " + str2;
  }
  function reduceToSingleString(output, base2, braces) {
    var length = output.reduce(function(prev, cur) {
      if (cur.indexOf("\n") >= 0)
        ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) {
      return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
  }
  exports2.types = types$2;
  function isArray2(ar) {
    return Array.isArray(ar);
  }
  exports2.isArray = isArray2;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  exports2.isBoolean = isBoolean2;
  function isNull(arg) {
    return arg === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  exports2.isNumber = isNumber2;
  function isString2(arg) {
    return typeof arg === "string";
  }
  exports2.isString = isString2;
  function isSymbol2(arg) {
    return typeof arg === "symbol";
  }
  exports2.isSymbol = isSymbol2;
  function isUndefined2(arg) {
    return arg === void 0;
  }
  exports2.isUndefined = isUndefined2;
  function isRegExp2(re) {
    return isObject2(re) && objectToString2(re) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp2;
  exports2.types.isRegExp = isRegExp2;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports2.isObject = isObject2;
  function isDate2(d2) {
    return isObject2(d2) && objectToString2(d2) === "[object Date]";
  }
  exports2.isDate = isDate2;
  exports2.types.isDate = isDate2;
  function isError(e2) {
    return isObject2(e2) && (objectToString2(e2) === "[object Error]" || e2 instanceof Error);
  }
  exports2.isError = isError;
  exports2.types.isNativeError = isError;
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  exports2.isFunction = isFunction2;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports2.isPrimitive = isPrimitive;
  exports2.isBuffer = isBufferBrowser;
  function objectToString2(o2) {
    return Object.prototype.toString.call(o2);
  }
  function pad2(n2) {
    return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
  }
  var months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function timestamp2() {
    var d2 = new Date();
    var time = [
      pad2(d2.getHours()),
      pad2(d2.getMinutes()),
      pad2(d2.getSeconds())
    ].join(":");
    return [d2.getDate(), months[d2.getMonth()], time].join(" ");
  }
  exports2.log = function() {
    console.log("%s - %s", timestamp2(), exports2.format.apply(exports2, arguments));
  };
  exports2.inherits = inherits_browser$1.exports;
  exports2._extend = function(origin, add8) {
    if (!add8 || !isObject2(add8))
      return origin;
    var keys2 = Object.keys(add8);
    var i2 = keys2.length;
    while (i2--) {
      origin[keys2[i2]] = add8[keys2[i2]];
    }
    return origin;
  };
  function hasOwnProperty2(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
  exports2.promisify = function promisify(original) {
    if (typeof original !== "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn = original[kCustomPromisifiedSymbol];
      if (typeof fn !== "function") {
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      }
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return fn;
    }
    function fn() {
      var promiseResolve, promiseReject;
      var promise = new Promise(function(resolve2, reject) {
        promiseResolve = resolve2;
        promiseReject = reject;
      });
      var args = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        args.push(arguments[i2]);
      }
      args.push(function(err, value2) {
        if (err) {
          promiseReject(err);
        } else {
          promiseResolve(value2);
        }
      });
      try {
        original.apply(this, args);
      } catch (err) {
        promiseReject(err);
      }
      return promise;
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol)
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
  };
  exports2.promisify.custom = kCustomPromisifiedSymbol;
  function callbackifyOnRejected(reason, cb) {
    if (!reason) {
      var newReason = new Error("Promise was rejected with a falsy value");
      newReason.reason = reason;
      reason = newReason;
    }
    return cb(reason);
  }
  function callbackify(original) {
    if (typeof original !== "function") {
      throw new TypeError('The "original" argument must be of type Function');
    }
    function callbackified() {
      var args = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        args.push(arguments[i2]);
      }
      var maybeCb = args.pop();
      if (typeof maybeCb !== "function") {
        throw new TypeError("The last argument must be of type Function");
      }
      var self2 = this;
      var cb = function() {
        return maybeCb.apply(self2, arguments);
      };
      original.apply(this, args).then(function(ret) {
        process.nextTick(cb.bind(null, null, ret));
      }, function(rej) {
        process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
      });
    }
    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
    return callbackified;
  }
  exports2.callbackify = callbackify;
})(util$7);
var dist$5 = {};
var keccak$3 = {};
var buffer$2 = {};
var base64Js = {};
base64Js.byteLength = byteLength$1;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$5 = 0, len = code.length; i$5 < len; ++i$5) {
  lookup[i$5] = code[i$5];
  revLookup[code.charCodeAt(i$5)] = i$5;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength$1(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr2 = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len2; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr2[curByte++] = tmp >> 16 & 255;
    arr2[curByte++] = tmp >> 8 & 255;
    arr2[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr2[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr2[curByte++] = tmp >> 8 & 255;
    arr2[curByte++] = tmp & 255;
  }
  return arr2;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e2, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s2 = buffer2[offset + i2];
  i2 += d2;
  e2 = s2 & (1 << -nBits) - 1;
  s2 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e2 = e2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  m2 = e2 & (1 << -nBits) - 1;
  e2 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  if (e2 === 0) {
    e2 = 1 - eBias;
  } else if (e2 === eMax) {
    return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e2 = e2 - eBias;
  }
  return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
};
ieee754.write = function(buffer2, value2, offset, isLE, mLen, nBytes) {
  var e2, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
  value2 = Math.abs(value2);
  if (isNaN(value2) || value2 === Infinity) {
    m2 = isNaN(value2) ? 1 : 0;
    e2 = eMax;
  } else {
    e2 = Math.floor(Math.log(value2) / Math.LN2);
    if (value2 * (c2 = Math.pow(2, -e2)) < 1) {
      e2--;
      c2 *= 2;
    }
    if (e2 + eBias >= 1) {
      value2 += rt / c2;
    } else {
      value2 += rt * Math.pow(2, 1 - eBias);
    }
    if (value2 * c2 >= 2) {
      e2++;
      c2 /= 2;
    }
    if (e2 + eBias >= eMax) {
      m2 = 0;
      e2 = eMax;
    } else if (e2 + eBias >= 1) {
      m2 = (value2 * c2 - 1) * Math.pow(2, mLen);
      e2 = e2 + eBias;
    } else {
      m2 = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e2 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
  }
  e2 = e2 << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d2] |= s2 * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH2 = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH2;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport2();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport2() {
    try {
      const arr2 = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr2, proto);
      return arr2.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer2(length) {
    if (length > K_MAX_LENGTH2) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from2(value2, encodingOrOffset, length) {
    if (typeof value2 === "string") {
      return fromString2(value2, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value2)) {
      return fromArrayView(value2);
    }
    if (value2 == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2);
    }
    if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
      return fromArrayBuffer2(value2, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer2(value2, encodingOrOffset, length);
    }
    if (typeof value2 === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value2.valueOf && value2.valueOf();
    if (valueOf != null && valueOf !== value2) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject2(value2);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2);
  }
  Buffer2.from = function(value2, encodingOrOffset, length) {
    return from2(value2, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill2, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer2(size2);
    }
    if (fill2 !== void 0) {
      return typeof encoding === "string" ? createBuffer2(size2).fill(fill2, encoding) : createBuffer2(size2).fill(fill2);
    }
    return createBuffer2(size2);
  }
  Buffer2.alloc = function(size2, fill2, encoding) {
    return alloc(size2, fill2, encoding);
  };
  function allocUnsafe2(size2) {
    assertSize(size2);
    return createBuffer2(size2 < 0 ? 0 : checked2(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe2(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe2(size2);
  };
  function fromString2(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string2, encoding) | 0;
    let buf = createBuffer2(length);
    const actual = buf.write(string2, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike2(array2) {
    const length = array2.length < 0 ? 0 : checked2(array2.length) | 0;
    const buf = createBuffer2(length);
    for (let i2 = 0; i2 < length; i2 += 1) {
      buf[i2] = array2[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy3 = new Uint8Array(arrayView);
      return fromArrayBuffer2(copy3.buffer, copy3.byteOffset, copy3.byteLength);
    }
    return fromArrayLike2(arrayView);
  }
  function fromArrayBuffer2(array2, byteOffset, length) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array2);
    } else if (length === void 0) {
      buf = new Uint8Array(array2, byteOffset);
    } else {
      buf = new Uint8Array(array2, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject2(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked2(obj.length) | 0;
      const buf = createBuffer2(len2);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len2);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer2(0);
      }
      return fromArrayLike2(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike2(obj.data);
    }
  }
  function checked2(length) {
    if (length >= K_MAX_LENGTH2) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH2.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer4(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a2, b2) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a2 === b2)
      return 0;
    let x2 = a2.length;
    let y2 = b2.length;
    for (let i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
      if (a2[i2] !== b2[i2]) {
        x2 = a2[i2];
        y2 = b2[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding2(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat3(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length += list[i2].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      let buf = list[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2);
    }
    const len2 = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    const i2 = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect10() {
    let str2 = "";
    const max2 = exports2.INSPECT_MAX_BYTES;
    str2 = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2)
      str2 += " ... ";
    return "<Buffer " + str2 + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start;
    const len2 = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr2.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr2.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read(arr2, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr2, i2 + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf3(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string2.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write2(buf, string2, offset, length) {
    return blitBuffer2(utf8ToBytes2(string2, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string2, offset, length) {
    return blitBuffer2(asciiToBytes(string2), buf, offset, length);
  }
  function base64Write(buf, string2, offset, length) {
    return blitBuffer2(base64ToBytes(string2), buf, offset, length);
  }
  function ucs2Write(buf, string2, offset, length) {
    return blitBuffer2(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write4(string2, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write2(this, string2, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length);
        case "base64":
          return base64Write(this, string2, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON3() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i2 = start;
    while (i2 < end) {
      const firstByte = buf[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len2 = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len2)
      end = len2;
    let out = "";
    for (let i2 = start; i2 < end; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes3 = buf.slice(start, end);
    let res = "";
    for (let i2 = 0; i2 < bytes3.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes3[i2] + bytes3[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice3(start, end) {
    const len2 = this.length;
    start = ~~start;
    end = end === void 0 ? len2 : ~~end;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end < 0) {
      end += len2;
      if (end < 0)
        end = 0;
    } else if (end > len2) {
      end = len2;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul8 = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul8 *= 256)) {
      val += this[offset + i2] * mul8;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul8 = 1;
    while (byteLength3 > 0 && (mul8 *= 256)) {
      val += this[offset + --byteLength3] * mul8;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last2 * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul8 = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul8 *= 256)) {
      val += this[offset + i2] * mul8;
    }
    mul8 *= 128;
    if (val >= mul8)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i2 = byteLength3;
    let mul8 = 1;
    let val = this[offset + --i2];
    while (i2 > 0 && (mul8 *= 256)) {
      val += this[offset + --i2] * mul8;
    }
    mul8 *= 128;
    if (val >= mul8)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last2 << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last2 = this[offset + 7];
    if (first2 === void 0 || last2 === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first2 << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last2);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value2, offset, ext, max2, min2) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value2 > max2 || value2 < min2)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset, byteLength3, maxBytes, 0);
    }
    let mul8 = 1;
    let i2 = 0;
    this[offset] = value2 & 255;
    while (++i2 < byteLength3 && (mul8 *= 256)) {
      this[offset + i2] = value2 / mul8 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset, byteLength3, maxBytes, 0);
    }
    let i2 = byteLength3 - 1;
    let mul8 = 1;
    this[offset + i2] = value2 & 255;
    while (--i2 >= 0 && (mul8 *= 256)) {
      this[offset + i2] = value2 / mul8 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 1, 255, 0);
    this[offset] = value2 & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 65535, 0);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 65535, 0);
    this[offset] = value2 >>> 8;
    this[offset + 1] = value2 & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 4294967295, 0);
    this[offset + 3] = value2 >>> 24;
    this[offset + 2] = value2 >>> 16;
    this[offset + 1] = value2 >>> 8;
    this[offset] = value2 & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 4294967295, 0);
    this[offset] = value2 >>> 24;
    this[offset + 1] = value2 >>> 16;
    this[offset + 2] = value2 >>> 8;
    this[offset + 3] = value2 & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value2, offset, min2, max2) {
    checkIntBI(value2, min2, max2, buf, offset, 7);
    let lo = Number(value2 & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value2, offset, min2, max2) {
    checkIntBI(value2, min2, max2, buf, offset, 7);
    let lo = Number(value2 & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value2, offset = 0) {
    return wrtBigUInt64LE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value2, offset = 0) {
    return wrtBigUInt64BE(this, value2, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = 0;
    let mul8 = 1;
    let sub = 0;
    this[offset] = value2 & 255;
    while (++i2 < byteLength3 && (mul8 *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value2 / mul8 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = byteLength3 - 1;
    let mul8 = 1;
    let sub = 0;
    this[offset + i2] = value2 & 255;
    while (--i2 >= 0 && (mul8 *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value2 / mul8 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 1, 127, -128);
    if (value2 < 0)
      value2 = 255 + value2 + 1;
    this[offset] = value2 & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 32767, -32768);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 32767, -32768);
    this[offset] = value2 >>> 8;
    this[offset + 1] = value2 & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 2147483647, -2147483648);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    this[offset + 2] = value2 >>> 16;
    this[offset + 3] = value2 >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 2147483647, -2147483648);
    if (value2 < 0)
      value2 = 4294967295 + value2 + 1;
    this[offset] = value2 >>> 24;
    this[offset + 1] = value2 >>> 16;
    this[offset + 2] = value2 >>> 8;
    this[offset + 3] = value2 & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value2, offset = 0) {
    return wrtBigUInt64LE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value2, offset = 0) {
    return wrtBigUInt64BE(this, value2, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value2, offset, ext, max2, min2) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value2, offset, littleEndian, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value2, offset, 4);
    }
    ieee754$1.write(buf, value2, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
    return writeFloat(this, value2, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
    return writeFloat(this, value2, offset, false, noAssert);
  };
  function writeDouble(buf, value2, offset, littleEndian, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value2, offset, 8);
    }
    ieee754$1.write(buf, value2, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
    return writeDouble(this, value2, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
    return writeDouble(this, value2, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy3(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len2 = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill2(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      const bytes3 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len2 = bytes3.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes3[i2 % len2];
      }
    }
    return this;
  };
  const errors2 = {};
  function E2(sym, getMessage, Base2) {
    errors2[sym] = class NodeError extends Base2 {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value2) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: value2,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2) {
      return `${name2} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E2("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E2("ERR_OUT_OF_RANGE", function(str2, range2, input) {
    let msg = `The value of "${str2}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range2}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i2 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    }
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value2, min2, max2, buf, offset, byteLength3) {
    if (value2 > max2 || value2 < min2) {
      const n2 = typeof min2 === "bigint" ? "n" : "";
      let range2;
      if (byteLength3 > 3) {
        if (min2 === 0 || min2 === BigInt(0)) {
          range2 = `>= 0${n2} and < 2${n2} ** ${(byteLength3 + 1) * 8}${n2}`;
        } else {
          range2 = `>= -(2${n2} ** ${(byteLength3 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n2}`;
        }
      } else {
        range2 = `>= ${min2}${n2} and <= ${max2}${n2}`;
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range2, value2);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value2, name2) {
    if (typeof value2 !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value2);
    }
  }
  function boundsError(value2, length, type) {
    if (Math.floor(value2) !== value2) {
      validateNumber(value2, type);
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value2);
    }
    if (length < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value2);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str2) {
    str2 = str2.split("=")[0];
    str2 = str2.trim().replace(INVALID_BASE64_RE, "");
    if (str2.length < 2)
      return "";
    while (str2.length % 4 !== 0) {
      str2 = str2 + "=";
    }
    return str2;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length = string2.length;
    let leadSurrogate = null;
    const bytes3 = [];
    for (let i2 = 0; i2 < length; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes3.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1)
              bytes3.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes3.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes3.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes3.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes3.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes3.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes3;
  }
  function asciiToBytes(str2) {
    const byteArray = [];
    for (let i2 = 0; i2 < str2.length; ++i2) {
      byteArray.push(str2.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str2, units) {
    let c2, hi, lo;
    const byteArray = [];
    for (let i2 = 0; i2 < str2.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str2.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str2) {
    return base64.toByteArray(base64clean(str2));
  }
  function blitBuffer2(src2, dst, offset, length) {
    let i2;
    for (i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length)
        break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i16 = i2 * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i2] + alphabet[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer$2);
var hashUtils = {};
Object.defineProperty(hashUtils, "__esModule", { value: true });
function createHashFunction(hashConstructor) {
  return function(msg) {
    var hash3 = hashConstructor();
    hash3.update(msg);
    return buffer$2.Buffer.from(hash3.digest());
  };
}
hashUtils.createHashFunction = createHashFunction;
var readableBrowser = { exports: {} };
var streamBrowser = events$1.exports.EventEmitter;
var __viteBrowserExternal = {};
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": __viteBrowserExternal
});
var require$$2$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
function ownKeys(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key2) {
        _defineProperty$1(target, key2, source[key2]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key2) {
        Object.defineProperty(target, key2, Object.getOwnPropertyDescriptor(source, key2));
      });
    }
  }
  return target;
}
function _defineProperty$1(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
var _require$2 = buffer$2, Buffer$h = _require$2.Buffer;
var _require2 = require$$2$2, inspect = _require2.inspect;
var custom = inspect && inspect.custom || "inspect";
function copyBuffer(src2, target, offset) {
  Buffer$h.prototype.copy.call(src2, target, offset);
}
var buffer_list = /* @__PURE__ */ function() {
  function BufferList2() {
    _classCallCheck$1(this, BufferList2);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList2, [{
    key: "push",
    value: function push(v2) {
      var entry = {
        data: v2,
        next: null
      };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v2) {
      var entry = {
        data: v2,
        next: this.head
      };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear2() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s2) {
      if (this.length === 0)
        return "";
      var p2 = this.head;
      var ret = "" + p2.data;
      while (p2 = p2.next) {
        ret += s2 + p2.data;
      }
      return ret;
    }
  }, {
    key: "concat",
    value: function concat3(n2) {
      if (this.length === 0)
        return Buffer$h.alloc(0);
      var ret = Buffer$h.allocUnsafe(n2 >>> 0);
      var p2 = this.head;
      var i2 = 0;
      while (p2) {
        copyBuffer(p2.data, ret, i2);
        i2 += p2.data.length;
        p2 = p2.next;
      }
      return ret;
    }
  }, {
    key: "consume",
    value: function consume(n2, hasStrings) {
      var ret;
      if (n2 < this.head.data.length) {
        ret = this.head.data.slice(0, n2);
        this.head.data = this.head.data.slice(n2);
      } else if (n2 === this.head.data.length) {
        ret = this.shift();
      } else {
        ret = hasStrings ? this._getString(n2) : this._getBuffer(n2);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first2() {
      return this.head.data;
    }
  }, {
    key: "_getString",
    value: function _getString(n2) {
      var p2 = this.head;
      var c2 = 1;
      var ret = p2.data;
      n2 -= ret.length;
      while (p2 = p2.next) {
        var str2 = p2.data;
        var nb = n2 > str2.length ? str2.length : n2;
        if (nb === str2.length)
          ret += str2;
        else
          ret += str2.slice(0, n2);
        n2 -= nb;
        if (n2 === 0) {
          if (nb === str2.length) {
            ++c2;
            if (p2.next)
              this.head = p2.next;
            else
              this.head = this.tail = null;
          } else {
            this.head = p2;
            p2.data = str2.slice(nb);
          }
          break;
        }
        ++c2;
      }
      this.length -= c2;
      return ret;
    }
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n2) {
      var ret = Buffer$h.allocUnsafe(n2);
      var p2 = this.head;
      var c2 = 1;
      p2.data.copy(ret);
      n2 -= p2.data.length;
      while (p2 = p2.next) {
        var buf = p2.data;
        var nb = n2 > buf.length ? buf.length : n2;
        buf.copy(ret, ret.length - n2, 0, nb);
        n2 -= nb;
        if (n2 === 0) {
          if (nb === buf.length) {
            ++c2;
            if (p2.next)
              this.head = p2.next;
            else
              this.head = this.tail = null;
          } else {
            this.head = p2;
            p2.data = buf.slice(nb);
          }
          break;
        }
        ++c2;
      }
      this.length -= c2;
      return ret;
    }
  }, {
    key: custom,
    value: function value2(_2, options) {
      return inspect(this, _objectSpread({}, options, {
        depth: 0,
        customInspect: false
      }));
    }
  }]);
  return BufferList2;
}();
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }
  if (this._readableState) {
    this._readableState.destroyed = true;
  }
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function(err2) {
    if (!cb && err2) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err2);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self2, err) {
  emitErrorNT(self2, err);
  emitCloseNT(self2);
}
function emitCloseNT(self2) {
  if (self2._writableState && !self2._writableState.emitClose)
    return;
  if (self2._readableState && !self2._readableState.emitClose)
    return;
  self2.emit("close");
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self2, err) {
  self2.emit("error", err);
}
function errorOrDestroy$2(stream, err) {
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy)
    stream.destroy(err);
  else
    stream.emit("error", err);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy: errorOrDestroy$2
};
var errorsBrowser = {};
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code2, message, Base2) {
  if (!Base2) {
    Base2 = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === "string") {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /* @__PURE__ */ function(_Base) {
    _inheritsLoose(NodeError2, _Base);
    function NodeError2(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }
    return NodeError2;
  }(Base2);
  NodeError.prototype.name = Base2.name;
  NodeError.prototype.code = code2;
  codes[code2] = NodeError;
}
function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len2 = expected.length;
    expected = expected.map(function(i2) {
      return String(i2);
    });
    if (len2 > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len2 - 1).join(", "), ", or ") + expected[len2 - 1];
    } else if (len2 === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
}
function startsWith(str2, search, pos) {
  return str2.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
}
function endsWith(str2, search, this_len) {
  if (this_len === void 0 || this_len > str2.length) {
    this_len = str2.length;
  }
  return str2.substring(this_len - search.length, this_len) === search;
}
function includes(str2, search, start) {
  if (typeof start !== "number") {
    start = 0;
  }
  if (start + search.length > str2.length) {
    return false;
  } else {
    return str2.indexOf(search, start) !== -1;
  }
}
createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value2) {
  return 'The value "' + value2 + '" is invalid for option "' + name2 + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
  var determiner;
  if (typeof expected === "string" && startsWith(expected, "not ")) {
    determiner = "must not be";
    expected = expected.replace(/^not /, "");
  } else {
    determiner = "must be";
  }
  var msg;
  if (endsWith(name2, " argument")) {
    msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  } else {
    var type = includes(name2, ".") ? "property" : "argument";
    msg = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
  }
  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
  return "The " + name2 + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(name2) {
  return "Cannot call " + name2 + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
  return "Unknown encoding: " + arg;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark$2(state2, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name2 = isDuplex ? duplexKey : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(name2, hwm);
    }
    return Math.floor(hwm);
  }
  return state2.objectMode ? 16 : 16 * 1024;
}
var state = {
  getHighWaterMark: getHighWaterMark$2
};
var browser$5 = deprecate;
function deprecate(fn, msg) {
  if (config$1("noDeprecation")) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config$1("throwDeprecation")) {
        throw new Error(msg);
      } else if (config$1("traceDeprecation")) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function config$1(name2) {
  try {
    if (!commonjsGlobal.localStorage)
      return false;
  } catch (_2) {
    return false;
  }
  var val = commonjsGlobal.localStorage[name2];
  if (val == null)
    return false;
  return String(val).toLowerCase() === "true";
}
var _stream_writable = Writable$1;
function CorkedRequest(state2) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function() {
    onCorkedFinish(_this, state2);
  };
}
var Duplex$3;
Writable$1.WritableState = WritableState;
var internalUtil = {
  deprecate: browser$5
};
var Stream$1 = streamBrowser;
var Buffer$g = buffer$2.Buffer;
var OurUint8Array$1 = commonjsGlobal.Uint8Array || function() {
};
function _uint8ArrayToBuffer$1(chunk) {
  return Buffer$g.from(chunk);
}
function _isUint8Array$1(obj) {
  return Buffer$g.isBuffer(obj) || obj instanceof OurUint8Array$1;
}
var destroyImpl$1 = destroy_1;
var _require$1 = state, getHighWaterMark$1 = _require$1.getHighWaterMark;
var _require$codes$3 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE$1 = _require$codes$3.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED$2 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK$1 = _require$codes$3.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes$3.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED$1 = _require$codes$3.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes$3.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes$3.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes$3.ERR_UNKNOWN_ENCODING;
var errorOrDestroy$1 = destroyImpl$1.errorOrDestroy;
inherits_browser$1.exports(Writable$1, Stream$1);
function nop() {
}
function WritableState(options, stream, isDuplex) {
  Duplex$3 = Duplex$3 || _stream_duplex;
  options = options || {};
  if (typeof isDuplex !== "boolean")
    isDuplex = stream instanceof Duplex$3;
  this.objectMode = !!options.objectMode;
  if (isDuplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  this.highWaterMark = getHighWaterMark$1(this, options, "writableHighWaterMark", isDuplex);
  this.finalCalled = false;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  this.destroyed = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function() {
  try {
    Object.defineProperty(WritableState.prototype, "buffer", {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
    });
  } catch (_2) {
  }
})();
var realHasInstance;
if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable$1, Symbol.hasInstance, {
    value: function value2(object2) {
      if (realHasInstance.call(this, object2))
        return true;
      if (this !== Writable$1)
        return false;
      return object2 && object2._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance2(object2) {
    return object2 instanceof this;
  };
}
function Writable$1(options) {
  Duplex$3 = Duplex$3 || _stream_duplex;
  var isDuplex = this instanceof Duplex$3;
  if (!isDuplex && !realHasInstance.call(Writable$1, this))
    return new Writable$1(options);
  this._writableState = new WritableState(options, this, isDuplex);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
    if (typeof options.destroy === "function")
      this._destroy = options.destroy;
    if (typeof options.final === "function")
      this._final = options.final;
  }
  Stream$1.call(this);
}
Writable$1.prototype.pipe = function() {
  errorOrDestroy$1(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  errorOrDestroy$1(stream, er);
  process.nextTick(cb, er);
}
function validChunk(stream, state2, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== "string" && !state2.objectMode) {
    er = new ERR_INVALID_ARG_TYPE$1("chunk", ["string", "Buffer"], chunk);
  }
  if (er) {
    errorOrDestroy$1(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable$1.prototype.write = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  var ret = false;
  var isBuf = !state2.objectMode && _isUint8Array$1(chunk);
  if (isBuf && !Buffer$g.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer$1(chunk);
  }
  if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (isBuf)
    encoding = "buffer";
  else if (!encoding)
    encoding = state2.defaultEncoding;
  if (typeof cb !== "function")
    cb = nop;
  if (state2.ending)
    writeAfterEnd(this, cb);
  else if (isBuf || validChunk(this, state2, chunk, cb)) {
    state2.pendingcb++;
    ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable$1.prototype.cork = function() {
  this._writableState.corked++;
};
Writable$1.prototype.uncork = function() {
  var state2 = this._writableState;
  if (state2.corked) {
    state2.corked--;
    if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest)
      clearBuffer(this, state2);
  }
};
Writable$1.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  if (typeof encoding === "string")
    encoding = encoding.toLowerCase();
  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
    throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable$1.prototype, "writableBuffer", {
  enumerable: false,
  get: function get2() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state2, chunk, encoding) {
  if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer$g.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable$1.prototype, "writableHighWaterMark", {
  enumerable: false,
  get: function get3() {
    return this._writableState.highWaterMark;
  }
});
function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state2, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = "buffer";
      chunk = newChunk;
    }
  }
  var len2 = state2.objectMode ? 1 : chunk.length;
  state2.length += len2;
  var ret = state2.length < state2.highWaterMark;
  if (!ret)
    state2.needDrain = true;
  if (state2.writing || state2.corked) {
    var last2 = state2.lastBufferedRequest;
    state2.lastBufferedRequest = {
      chunk,
      encoding,
      isBuf,
      callback: cb,
      next: null
    };
    if (last2) {
      last2.next = state2.lastBufferedRequest;
    } else {
      state2.bufferedRequest = state2.lastBufferedRequest;
    }
    state2.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state2, false, len2, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state2, writev, len2, chunk, encoding, cb) {
  state2.writelen = len2;
  state2.writecb = cb;
  state2.writing = true;
  state2.sync = true;
  if (state2.destroyed)
    state2.onwrite(new ERR_STREAM_DESTROYED$1("write"));
  else if (writev)
    stream._writev(chunk, state2.onwrite);
  else
    stream._write(chunk, encoding, state2.onwrite);
  state2.sync = false;
}
function onwriteError(stream, state2, sync, er, cb) {
  --state2.pendingcb;
  if (sync) {
    process.nextTick(cb, er);
    process.nextTick(finishMaybe, stream, state2);
    stream._writableState.errorEmitted = true;
    errorOrDestroy$1(stream, er);
  } else {
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy$1(stream, er);
    finishMaybe(stream, state2);
  }
}
function onwriteStateUpdate(state2) {
  state2.writing = false;
  state2.writecb = null;
  state2.length -= state2.writelen;
  state2.writelen = 0;
}
function onwrite(stream, er) {
  var state2 = stream._writableState;
  var sync = state2.sync;
  var cb = state2.writecb;
  if (typeof cb !== "function")
    throw new ERR_MULTIPLE_CALLBACK$1();
  onwriteStateUpdate(state2);
  if (er)
    onwriteError(stream, state2, sync, er, cb);
  else {
    var finished2 = needFinish(state2) || stream.destroyed;
    if (!finished2 && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
      clearBuffer(stream, state2);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state2, finished2, cb);
    } else {
      afterWrite(stream, state2, finished2, cb);
    }
  }
}
function afterWrite(stream, state2, finished2, cb) {
  if (!finished2)
    onwriteDrain(stream, state2);
  state2.pendingcb--;
  cb();
  finishMaybe(stream, state2);
}
function onwriteDrain(stream, state2) {
  if (state2.length === 0 && state2.needDrain) {
    state2.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state2) {
  state2.bufferProcessing = true;
  var entry = state2.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    var l2 = state2.bufferedRequestCount;
    var buffer2 = new Array(l2);
    var holder = state2.corkedRequestsFree;
    holder.entry = entry;
    var count2 = 0;
    var allBuffers = true;
    while (entry) {
      buffer2[count2] = entry;
      if (!entry.isBuf)
        allBuffers = false;
      entry = entry.next;
      count2 += 1;
    }
    buffer2.allBuffers = allBuffers;
    doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
    state2.pendingcb++;
    state2.lastBufferedRequest = null;
    if (holder.next) {
      state2.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state2.corkedRequestsFree = new CorkedRequest(state2);
    }
    state2.bufferedRequestCount = 0;
  } else {
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len2 = state2.objectMode ? 1 : chunk.length;
      doWrite(stream, state2, false, len2, chunk, encoding, cb);
      entry = entry.next;
      state2.bufferedRequestCount--;
      if (state2.writing) {
        break;
      }
    }
    if (entry === null)
      state2.lastBufferedRequest = null;
  }
  state2.bufferedRequest = entry;
  state2.bufferProcessing = false;
}
Writable$1.prototype._write = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED$2("_write()"));
};
Writable$1.prototype._writev = null;
Writable$1.prototype.end = function(chunk, encoding, cb) {
  var state2 = this._writableState;
  if (typeof chunk === "function") {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === "function") {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== void 0)
    this.write(chunk, encoding);
  if (state2.corked) {
    state2.corked = 1;
    this.uncork();
  }
  if (!state2.ending)
    endWritable(this, state2, cb);
  return this;
};
Object.defineProperty(Writable$1.prototype, "writableLength", {
  enumerable: false,
  get: function get4() {
    return this._writableState.length;
  }
});
function needFinish(state2) {
  return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
}
function callFinal(stream, state2) {
  stream._final(function(err) {
    state2.pendingcb--;
    if (err) {
      errorOrDestroy$1(stream, err);
    }
    state2.prefinished = true;
    stream.emit("prefinish");
    finishMaybe(stream, state2);
  });
}
function prefinish$1(stream, state2) {
  if (!state2.prefinished && !state2.finalCalled) {
    if (typeof stream._final === "function" && !state2.destroyed) {
      state2.pendingcb++;
      state2.finalCalled = true;
      process.nextTick(callFinal, stream, state2);
    } else {
      state2.prefinished = true;
      stream.emit("prefinish");
    }
  }
}
function finishMaybe(stream, state2) {
  var need = needFinish(state2);
  if (need) {
    prefinish$1(stream, state2);
    if (state2.pendingcb === 0) {
      state2.finished = true;
      stream.emit("finish");
      if (state2.autoDestroy) {
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state2, cb) {
  state2.ending = true;
  finishMaybe(stream, state2);
  if (cb) {
    if (state2.finished)
      process.nextTick(cb);
    else
      stream.once("finish", cb);
  }
  state2.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state2, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state2.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  state2.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable$1.prototype, "destroyed", {
  enumerable: false,
  get: function get5() {
    if (this._writableState === void 0) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set2(value2) {
    if (!this._writableState) {
      return;
    }
    this._writableState.destroyed = value2;
  }
});
Writable$1.prototype.destroy = destroyImpl$1.destroy;
Writable$1.prototype._undestroy = destroyImpl$1.undestroy;
Writable$1.prototype._destroy = function(err, cb) {
  cb(err);
};
var objectKeys$1 = Object.keys || function(obj) {
  var keys2 = [];
  for (var key2 in obj) {
    keys2.push(key2);
  }
  return keys2;
};
var _stream_duplex = Duplex$2;
var Readable$1 = _stream_readable;
var Writable = _stream_writable;
inherits_browser$1.exports(Duplex$2, Readable$1);
{
  var keys$1 = objectKeys$1(Writable.prototype);
  for (var v$4 = 0; v$4 < keys$1.length; v$4++) {
    var method = keys$1[v$4];
    if (!Duplex$2.prototype[method])
      Duplex$2.prototype[method] = Writable.prototype[method];
  }
}
function Duplex$2(options) {
  if (!(this instanceof Duplex$2))
    return new Duplex$2(options);
  Readable$1.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false)
      this.readable = false;
    if (options.writable === false)
      this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once("end", onend);
    }
  }
}
Object.defineProperty(Duplex$2.prototype, "writableHighWaterMark", {
  enumerable: false,
  get: function get6() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex$2.prototype, "writableBuffer", {
  enumerable: false,
  get: function get7() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex$2.prototype, "writableLength", {
  enumerable: false,
  get: function get8() {
    return this._writableState.length;
  }
});
function onend() {
  if (this._writableState.ended)
    return;
  process.nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
Object.defineProperty(Duplex$2.prototype, "destroyed", {
  enumerable: false,
  get: function get9() {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set3(value2) {
    if (this._readableState === void 0 || this._writableState === void 0) {
      return;
    }
    this._readableState.destroyed = value2;
    this._writableState.destroyed = value2;
  }
});
var string_decoder = {};
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module2, exports2) {
  var buffer2 = buffer$2;
  var Buffer2 = buffer2.Buffer;
  function copyProps(src2, dst) {
    for (var key2 in src2) {
      dst[key2] = src2[key2];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer2;
  } else {
    copyProps(buffer2, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size2, fill2, encoding) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size2);
    if (fill2 !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill2, encoding);
      } else {
        buf.fill(fill2);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size2);
  };
  SafeBuffer.allocUnsafeSlow = function(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer2.SlowBuffer(size2);
  };
})(safeBuffer, safeBuffer.exports);
var Buffer$f = safeBuffer.exports.Buffer;
var isEncoding = Buffer$f.isEncoding || function(encoding) {
  encoding = "" + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function _normalizeEncoding(enc) {
  if (!enc)
    return "utf8";
  var retried;
  while (true) {
    switch (enc) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return enc;
      default:
        if (retried)
          return;
        enc = ("" + enc).toLowerCase();
        retried = true;
    }
  }
}
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== "string" && (Buffer$f.isEncoding === isEncoding || !isEncoding(enc)))
    throw new Error("Unknown encoding: " + enc);
  return nenc || enc;
}
string_decoder.StringDecoder = StringDecoder$2;
function StringDecoder$2(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case "base64":
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer$f.allocUnsafe(nb);
}
StringDecoder$2.prototype.write = function(buf) {
  if (buf.length === 0)
    return "";
  var r2;
  var i2;
  if (this.lastNeed) {
    r2 = this.fillLast(buf);
    if (r2 === void 0)
      return "";
    i2 = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i2 = 0;
  }
  if (i2 < buf.length)
    return r2 ? r2 + this.text(buf, i2) : this.text(buf, i2);
  return r2 || "";
};
StringDecoder$2.prototype.end = utf8End;
StringDecoder$2.prototype.text = utf8Text;
StringDecoder$2.prototype.fillLast = function(buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};
function utf8CheckByte(byte2) {
  if (byte2 <= 127)
    return 0;
  else if (byte2 >> 5 === 6)
    return 2;
  else if (byte2 >> 4 === 14)
    return 3;
  else if (byte2 >> 3 === 30)
    return 4;
  return byte2 >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(self2, buf, i2) {
  var j2 = buf.length - 1;
  if (j2 < i2)
    return 0;
  var nb = utf8CheckByte(buf[j2]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 1;
    return nb;
  }
  if (--j2 < i2 || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j2]);
  if (nb >= 0) {
    if (nb > 0)
      self2.lastNeed = nb - 2;
    return nb;
  }
  if (--j2 < i2 || nb === -2)
    return 0;
  nb = utf8CheckByte(buf[j2]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2)
        nb = 0;
      else
        self2.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}
function utf8CheckExtraBytes(self2, buf, p2) {
  if ((buf[0] & 192) !== 128) {
    self2.lastNeed = 0;
    return "\uFFFD";
  }
  if (self2.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 192) !== 128) {
      self2.lastNeed = 1;
      return "\uFFFD";
    }
    if (self2.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 192) !== 128) {
        self2.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
}
function utf8FillLast(buf) {
  var p2 = this.lastTotal - this.lastNeed;
  var r2 = utf8CheckExtraBytes(this, buf);
  if (r2 !== void 0)
    return r2;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p2, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p2, 0, buf.length);
  this.lastNeed -= buf.length;
}
function utf8Text(buf, i2) {
  var total = utf8CheckIncomplete(this, buf, i2);
  if (!this.lastNeed)
    return buf.toString("utf8", i2);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString("utf8", i2, end);
}
function utf8End(buf) {
  var r2 = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r2 + "\uFFFD";
  return r2;
}
function utf16Text(buf, i2) {
  if ((buf.length - i2) % 2 === 0) {
    var r2 = buf.toString("utf16le", i2);
    if (r2) {
      var c2 = r2.charCodeAt(r2.length - 1);
      if (c2 >= 55296 && c2 <= 56319) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r2.slice(0, -1);
      }
    }
    return r2;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString("utf16le", i2, buf.length - 1);
}
function utf16End(buf) {
  var r2 = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r2 + this.lastChar.toString("utf16le", 0, end);
  }
  return r2;
}
function base64Text(buf, i2) {
  var n2 = (buf.length - i2) % 3;
  if (n2 === 0)
    return buf.toString("base64", i2);
  this.lastNeed = 3 - n2;
  this.lastTotal = 3;
  if (n2 === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString("base64", i2, buf.length - n2);
}
function base64End(buf) {
  var r2 = buf && buf.length ? this.write(buf) : "";
  if (this.lastNeed)
    return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
  return r2;
}
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}
function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : "";
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$2(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop$6() {
}
function isRequest$1(stream) {
  return stream.setHeader && typeof stream.abort === "function";
}
function eos$1(stream, opts, callback) {
  if (typeof opts === "function")
    return eos$1(stream, null, opts);
  if (!opts)
    opts = {};
  callback = once$2(callback || noop$6);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish2() {
    if (!stream.writable)
      onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish2() {
    writable = false;
    writableEnded = true;
    if (!readable)
      callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend2 = function onend3() {
    readable = false;
    readableEnded = true;
    if (!writable)
      callback.call(stream);
  };
  var onerror = function onerror2(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose2() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended)
        err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest2() {
    stream.req.on("finish", onfinish);
  };
  if (isRequest$1(stream)) {
    stream.on("complete", onfinish);
    stream.on("abort", onclose);
    if (stream.req)
      onrequest();
    else
      stream.on("request", onrequest);
  } else if (writable && !stream._writableState) {
    stream.on("end", onlegacyfinish);
    stream.on("close", onlegacyfinish);
  }
  stream.on("end", onend2);
  stream.on("finish", onfinish);
  if (opts.error !== false)
    stream.on("error", onerror);
  stream.on("close", onclose);
  return function() {
    stream.removeListener("complete", onfinish);
    stream.removeListener("abort", onclose);
    stream.removeListener("request", onrequest);
    if (stream.req)
      stream.req.removeListener("finish", onfinish);
    stream.removeListener("end", onlegacyfinish);
    stream.removeListener("close", onlegacyfinish);
    stream.removeListener("finish", onfinish);
    stream.removeListener("end", onend2);
    stream.removeListener("error", onerror);
    stream.removeListener("close", onclose);
  };
}
var endOfStream = eos$1;
var _Object$setPrototypeO;
function _defineProperty(obj, key2, value2) {
  if (key2 in obj) {
    Object.defineProperty(obj, key2, { value: value2, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key2] = value2;
  }
  return obj;
}
var finished = endOfStream;
var kLastResolve = Symbol("lastResolve");
var kLastReject = Symbol("lastReject");
var kError = Symbol("error");
var kEnded = Symbol("ended");
var kLastPromise = Symbol("lastPromise");
var kHandlePromise = Symbol("handlePromise");
var kStream = Symbol("stream");
function createIterResult(value2, done2) {
  return {
    value: value2,
    done: done2
  };
}
function readAndResolve(iter) {
  var resolve2 = iter[kLastResolve];
  if (resolve2 !== null) {
    var data = iter[kStream].read();
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve2(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function(resolve2, reject) {
    lastPromise.then(function() {
      if (iter[kEnded]) {
        resolve2(createIterResult(void 0, true));
        return;
      }
      iter[kHandlePromise](resolve2, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next2() {
    var _this = this;
    var error2 = this[kError];
    if (error2 !== null) {
      return Promise.reject(error2);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(void 0, true));
    }
    if (this[kStream].destroyed) {
      return new Promise(function(resolve2, reject) {
        process.nextTick(function() {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve2(createIterResult(void 0, true));
          }
        });
      });
    }
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  return new Promise(function(resolve2, reject) {
    _this2[kStream].destroy(null, function(err) {
      if (err) {
        reject(err);
        return;
      }
      resolve2(createIterResult(void 0, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator$1 = function createReadableStreamAsyncIterator2(stream) {
  var _Object$create;
  var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value2(resolve2, reject) {
      var data = iterator2[kStream].read();
      if (data) {
        iterator2[kLastPromise] = null;
        iterator2[kLastResolve] = null;
        iterator2[kLastReject] = null;
        resolve2(createIterResult(data, false));
      } else {
        iterator2[kLastResolve] = resolve2;
        iterator2[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator2[kLastPromise] = null;
  finished(stream, function(err) {
    if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
      var reject = iterator2[kLastReject];
      if (reject !== null) {
        iterator2[kLastPromise] = null;
        iterator2[kLastResolve] = null;
        iterator2[kLastReject] = null;
        reject(err);
      }
      iterator2[kError] = err;
      return;
    }
    var resolve2 = iterator2[kLastResolve];
    if (resolve2 !== null) {
      iterator2[kLastPromise] = null;
      iterator2[kLastResolve] = null;
      iterator2[kLastReject] = null;
      resolve2(createIterResult(void 0, true));
    }
    iterator2[kEnded] = true;
  });
  stream.on("readable", onReadable.bind(null, iterator2));
  return iterator2;
};
var async_iterator = createReadableStreamAsyncIterator$1;
var fromBrowser = function() {
  throw new Error("Readable.from is not available in the browser");
};
var _stream_readable = Readable;
var Duplex$1;
Readable.ReadableState = ReadableState;
events$1.exports.EventEmitter;
var EElistenerCount = function EElistenerCount2(emitter, type) {
  return emitter.listeners(type).length;
};
var Stream = streamBrowser;
var Buffer$e = buffer$2.Buffer;
var OurUint8Array = commonjsGlobal.Uint8Array || function() {
};
function _uint8ArrayToBuffer(chunk) {
  return Buffer$e.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer$e.isBuffer(obj) || obj instanceof OurUint8Array;
}
var debugUtil = require$$2$2;
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog("stream");
} else {
  debug = function debug2() {
  };
}
var BufferList = buffer_list;
var destroyImpl = destroy_1;
var _require = state, getHighWaterMark = _require.getHighWaterMark;
var _require$codes$2 = errorsBrowser.codes, ERR_INVALID_ARG_TYPE = _require$codes$2.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes$2.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$2.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes$2.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
var StringDecoder$1;
var createReadableStreamAsyncIterator;
var from$2;
inherits_browser$1.exports(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
function prependListener(emitter, event, fn) {
  if (typeof emitter.prependListener === "function")
    return emitter.prependListener(event, fn);
  if (!emitter._events || !emitter._events[event])
    emitter.on(event, fn);
  else if (Array.isArray(emitter._events[event]))
    emitter._events[event].unshift(fn);
  else
    emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex$1 = Duplex$1 || _stream_duplex;
  options = options || {};
  if (typeof isDuplex !== "boolean")
    isDuplex = stream instanceof Duplex$1;
  this.objectMode = !!options.objectMode;
  if (isDuplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;
  this.emitClose = options.emitClose !== false;
  this.autoDestroy = !!options.autoDestroy;
  this.destroyed = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder$1)
      StringDecoder$1 = string_decoder.StringDecoder;
    this.decoder = new StringDecoder$1(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex$1 = Duplex$1 || _stream_duplex;
  if (!(this instanceof Readable))
    return new Readable(options);
  var isDuplex = this instanceof Duplex$1;
  this._readableState = new ReadableState(options, this, isDuplex);
  this.readable = true;
  if (options) {
    if (typeof options.read === "function")
      this._read = options.read;
    if (typeof options.destroy === "function")
      this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, "destroyed", {
  enumerable: false,
  get: function get10() {
    if (this._readableState === void 0) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set4(value2) {
    if (!this._readableState) {
      return;
    }
    this._readableState.destroyed = value2;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function(err, cb) {
  cb(err);
};
Readable.prototype.push = function(chunk, encoding) {
  var state2 = this._readableState;
  var skipChunkCheck;
  if (!state2.objectMode) {
    if (typeof chunk === "string") {
      encoding = encoding || state2.defaultEncoding;
      if (encoding !== state2.encoding) {
        chunk = Buffer$e.from(chunk, encoding);
        encoding = "";
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};
Readable.prototype.unshift = function(chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug("readableAddChunk", chunk);
  var state2 = stream._readableState;
  if (chunk === null) {
    state2.reading = false;
    onEofChunk(stream, state2);
  } else {
    var er;
    if (!skipChunkCheck)
      er = chunkInvalid(state2, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state2.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer$e.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state2.endEmitted)
          errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
        else
          addChunk(stream, state2, chunk, true);
      } else if (state2.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state2.destroyed) {
        return false;
      } else {
        state2.reading = false;
        if (state2.decoder && !encoding) {
          chunk = state2.decoder.write(chunk);
          if (state2.objectMode || chunk.length !== 0)
            addChunk(stream, state2, chunk, false);
          else
            maybeReadMore(stream, state2);
        } else {
          addChunk(stream, state2, chunk, false);
        }
      }
    } else if (!addToFront) {
      state2.reading = false;
      maybeReadMore(stream, state2);
    }
  }
  return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
}
function addChunk(stream, state2, chunk, addToFront) {
  if (state2.flowing && state2.length === 0 && !state2.sync) {
    state2.awaitDrain = 0;
    stream.emit("data", chunk);
  } else {
    state2.length += state2.objectMode ? 1 : chunk.length;
    if (addToFront)
      state2.buffer.unshift(chunk);
    else
      state2.buffer.push(chunk);
    if (state2.needReadable)
      emitReadable(stream);
  }
  maybeReadMore(stream, state2);
}
function chunkInvalid(state2, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
    er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder$1)
    StringDecoder$1 = string_decoder.StringDecoder;
  var decoder = new StringDecoder$1(enc);
  this._readableState.decoder = decoder;
  this._readableState.encoding = this._readableState.decoder.encoding;
  var p2 = this._readableState.buffer.head;
  var content = "";
  while (p2 !== null) {
    content += decoder.write(p2.data);
    p2 = p2.next;
  }
  this._readableState.buffer.clear();
  if (content !== "")
    this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};
var MAX_HWM = 1073741824;
function computeNewHighWaterMark(n2) {
  if (n2 >= MAX_HWM) {
    n2 = MAX_HWM;
  } else {
    n2--;
    n2 |= n2 >>> 1;
    n2 |= n2 >>> 2;
    n2 |= n2 >>> 4;
    n2 |= n2 >>> 8;
    n2 |= n2 >>> 16;
    n2++;
  }
  return n2;
}
function howMuchToRead(n2, state2) {
  if (n2 <= 0 || state2.length === 0 && state2.ended)
    return 0;
  if (state2.objectMode)
    return 1;
  if (n2 !== n2) {
    if (state2.flowing && state2.length)
      return state2.buffer.head.data.length;
    else
      return state2.length;
  }
  if (n2 > state2.highWaterMark)
    state2.highWaterMark = computeNewHighWaterMark(n2);
  if (n2 <= state2.length)
    return n2;
  if (!state2.ended) {
    state2.needReadable = true;
    return 0;
  }
  return state2.length;
}
Readable.prototype.read = function(n2) {
  debug("read", n2);
  n2 = parseInt(n2, 10);
  var state2 = this._readableState;
  var nOrig = n2;
  if (n2 !== 0)
    state2.emittedReadable = false;
  if (n2 === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
    debug("read: emitReadable", state2.length, state2.ended);
    if (state2.length === 0 && state2.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }
  n2 = howMuchToRead(n2, state2);
  if (n2 === 0 && state2.ended) {
    if (state2.length === 0)
      endReadable(this);
    return null;
  }
  var doRead = state2.needReadable;
  debug("need readable", doRead);
  if (state2.length === 0 || state2.length - n2 < state2.highWaterMark) {
    doRead = true;
    debug("length less than watermark", doRead);
  }
  if (state2.ended || state2.reading) {
    doRead = false;
    debug("reading or ended", doRead);
  } else if (doRead) {
    debug("do read");
    state2.reading = true;
    state2.sync = true;
    if (state2.length === 0)
      state2.needReadable = true;
    this._read(state2.highWaterMark);
    state2.sync = false;
    if (!state2.reading)
      n2 = howMuchToRead(nOrig, state2);
  }
  var ret;
  if (n2 > 0)
    ret = fromList(n2, state2);
  else
    ret = null;
  if (ret === null) {
    state2.needReadable = state2.length <= state2.highWaterMark;
    n2 = 0;
  } else {
    state2.length -= n2;
    state2.awaitDrain = 0;
  }
  if (state2.length === 0) {
    if (!state2.ended)
      state2.needReadable = true;
    if (nOrig !== n2 && state2.ended)
      endReadable(this);
  }
  if (ret !== null)
    this.emit("data", ret);
  return ret;
};
function onEofChunk(stream, state2) {
  debug("onEofChunk");
  if (state2.ended)
    return;
  if (state2.decoder) {
    var chunk = state2.decoder.end();
    if (chunk && chunk.length) {
      state2.buffer.push(chunk);
      state2.length += state2.objectMode ? 1 : chunk.length;
    }
  }
  state2.ended = true;
  if (state2.sync) {
    emitReadable(stream);
  } else {
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      state2.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}
function emitReadable(stream) {
  var state2 = stream._readableState;
  debug("emitReadable", state2.needReadable, state2.emittedReadable);
  state2.needReadable = false;
  if (!state2.emittedReadable) {
    debug("emitReadable", state2.flowing);
    state2.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state2 = stream._readableState;
  debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
  if (!state2.destroyed && (state2.length || state2.ended)) {
    stream.emit("readable");
    state2.emittedReadable = false;
  }
  state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
  flow(stream);
}
function maybeReadMore(stream, state2) {
  if (!state2.readingMore) {
    state2.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state2);
  }
}
function maybeReadMore_(stream, state2) {
  while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
    var len2 = state2.length;
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len2 === state2.length)
      break;
  }
  state2.readingMore = false;
}
Readable.prototype._read = function(n2) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED$1("_read()"));
};
Readable.prototype.pipe = function(dest, pipeOpts) {
  var src2 = this;
  var state2 = this._readableState;
  switch (state2.pipesCount) {
    case 0:
      state2.pipes = dest;
      break;
    case 1:
      state2.pipes = [state2.pipes, dest];
      break;
    default:
      state2.pipes.push(dest);
      break;
  }
  state2.pipesCount += 1;
  debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend2 : unpipe;
  if (state2.endEmitted)
    process.nextTick(endFn);
  else
    src2.once("end", endFn);
  dest.on("unpipe", onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug("onunpipe");
    if (readable === src2) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend2() {
    debug("onend");
    dest.end();
  }
  var ondrain = pipeOnDrain(src2);
  dest.on("drain", ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug("cleanup");
    dest.removeListener("close", onclose);
    dest.removeListener("finish", onfinish);
    dest.removeListener("drain", ondrain);
    dest.removeListener("error", onerror);
    dest.removeListener("unpipe", onunpipe);
    src2.removeListener("end", onend2);
    src2.removeListener("end", unpipe);
    src2.removeListener("data", ondata);
    cleanedUp = true;
    if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }
  src2.on("data", ondata);
  function ondata(chunk) {
    debug("ondata");
    var ret = dest.write(chunk);
    debug("dest.write", ret);
    if (ret === false) {
      if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
        debug("false write response, pause", state2.awaitDrain);
        state2.awaitDrain++;
      }
      src2.pause();
    }
  }
  function onerror(er) {
    debug("onerror", er);
    unpipe();
    dest.removeListener("error", onerror);
    if (EElistenerCount(dest, "error") === 0)
      errorOrDestroy(dest, er);
  }
  prependListener(dest, "error", onerror);
  function onclose() {
    dest.removeListener("finish", onfinish);
    unpipe();
  }
  dest.once("close", onclose);
  function onfinish() {
    debug("onfinish");
    dest.removeListener("close", onclose);
    unpipe();
  }
  dest.once("finish", onfinish);
  function unpipe() {
    debug("unpipe");
    src2.unpipe(dest);
  }
  dest.emit("pipe", src2);
  if (!state2.flowing) {
    debug("pipe resume");
    src2.resume();
  }
  return dest;
};
function pipeOnDrain(src2) {
  return function pipeOnDrainFunctionResult() {
    var state2 = src2._readableState;
    debug("pipeOnDrain", state2.awaitDrain);
    if (state2.awaitDrain)
      state2.awaitDrain--;
    if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
      state2.flowing = true;
      flow(src2);
    }
  };
}
Readable.prototype.unpipe = function(dest) {
  var state2 = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };
  if (state2.pipesCount === 0)
    return this;
  if (state2.pipesCount === 1) {
    if (dest && dest !== state2.pipes)
      return this;
    if (!dest)
      dest = state2.pipes;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    if (dest)
      dest.emit("unpipe", this, unpipeInfo);
    return this;
  }
  if (!dest) {
    var dests = state2.pipes;
    var len2 = state2.pipesCount;
    state2.pipes = null;
    state2.pipesCount = 0;
    state2.flowing = false;
    for (var i2 = 0; i2 < len2; i2++) {
      dests[i2].emit("unpipe", this, {
        hasUnpiped: false
      });
    }
    return this;
  }
  var index2 = indexOf(state2.pipes, dest);
  if (index2 === -1)
    return this;
  state2.pipes.splice(index2, 1);
  state2.pipesCount -= 1;
  if (state2.pipesCount === 1)
    state2.pipes = state2.pipes[0];
  dest.emit("unpipe", this, unpipeInfo);
  return this;
};
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state2 = this._readableState;
  if (ev === "data") {
    state2.readableListening = this.listenerCount("readable") > 0;
    if (state2.flowing !== false)
      this.resume();
  } else if (ev === "readable") {
    if (!state2.endEmitted && !state2.readableListening) {
      state2.readableListening = state2.needReadable = true;
      state2.flowing = false;
      state2.emittedReadable = false;
      debug("on readable", state2.length, state2.reading);
      if (state2.length) {
        emitReadable(this);
      } else if (!state2.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function(ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === "readable") {
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function(ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === "readable" || ev === void 0) {
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self2) {
  var state2 = self2._readableState;
  state2.readableListening = self2.listenerCount("readable") > 0;
  if (state2.resumeScheduled && !state2.paused) {
    state2.flowing = true;
  } else if (self2.listenerCount("data") > 0) {
    self2.resume();
  }
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
Readable.prototype.resume = function() {
  var state2 = this._readableState;
  if (!state2.flowing) {
    debug("resume");
    state2.flowing = !state2.readableListening;
    resume(this, state2);
  }
  state2.paused = false;
  return this;
};
function resume(stream, state2) {
  if (!state2.resumeScheduled) {
    state2.resumeScheduled = true;
    process.nextTick(resume_, stream, state2);
  }
}
function resume_(stream, state2) {
  debug("resume", state2.reading);
  if (!state2.reading) {
    stream.read(0);
  }
  state2.resumeScheduled = false;
  stream.emit("resume");
  flow(stream);
  if (state2.flowing && !state2.reading)
    stream.read(0);
}
Readable.prototype.pause = function() {
  debug("call pause flowing=%j", this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug("pause");
    this._readableState.flowing = false;
    this.emit("pause");
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state2 = stream._readableState;
  debug("flow", state2.flowing);
  while (state2.flowing && stream.read() !== null) {
  }
}
Readable.prototype.wrap = function(stream) {
  var _this = this;
  var state2 = this._readableState;
  var paused = false;
  stream.on("end", function() {
    debug("wrapped end");
    if (state2.decoder && !state2.ended) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length)
        _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on("data", function(chunk) {
    debug("wrapped data");
    if (state2.decoder)
      chunk = state2.decoder.write(chunk);
    if (state2.objectMode && (chunk === null || chunk === void 0))
      return;
    else if (!state2.objectMode && (!chunk || !chunk.length))
      return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });
  for (var i2 in stream) {
    if (this[i2] === void 0 && typeof stream[i2] === "function") {
      this[i2] = function methodWrap(method2) {
        return function methodWrapReturnFunction() {
          return stream[method2].apply(stream, arguments);
        };
      }(i2);
    }
  }
  for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
    stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
  }
  this._read = function(n3) {
    debug("wrapped _read", n3);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === "function") {
  Readable.prototype[Symbol.asyncIterator] = function() {
    if (createReadableStreamAsyncIterator === void 0) {
      createReadableStreamAsyncIterator = async_iterator;
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
  enumerable: false,
  get: function get11() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, "readableBuffer", {
  enumerable: false,
  get: function get12() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, "readableFlowing", {
  enumerable: false,
  get: function get13() {
    return this._readableState.flowing;
  },
  set: function set5(state2) {
    if (this._readableState) {
      this._readableState.flowing = state2;
    }
  }
});
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, "readableLength", {
  enumerable: false,
  get: function get14() {
    return this._readableState.length;
  }
});
function fromList(n2, state2) {
  if (state2.length === 0)
    return null;
  var ret;
  if (state2.objectMode)
    ret = state2.buffer.shift();
  else if (!n2 || n2 >= state2.length) {
    if (state2.decoder)
      ret = state2.buffer.join("");
    else if (state2.buffer.length === 1)
      ret = state2.buffer.first();
    else
      ret = state2.buffer.concat(state2.length);
    state2.buffer.clear();
  } else {
    ret = state2.buffer.consume(n2, state2.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state2 = stream._readableState;
  debug("endReadable", state2.endEmitted);
  if (!state2.endEmitted) {
    state2.ended = true;
    process.nextTick(endReadableNT, state2, stream);
  }
}
function endReadableNT(state2, stream) {
  debug("endReadableNT", state2.endEmitted, state2.length);
  if (!state2.endEmitted && state2.length === 0) {
    state2.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
    if (state2.autoDestroy) {
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === "function") {
  Readable.from = function(iterable, opts) {
    if (from$2 === void 0) {
      from$2 = fromBrowser;
    }
    return from$2(Readable, iterable, opts);
  };
}
function indexOf(xs, x2) {
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    if (xs[i2] === x2)
      return i2;
  }
  return -1;
}
var _stream_transform = Transform$5;
var _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = _stream_duplex;
inherits_browser$1.exports(Transform$5, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform$5(options) {
  if (!(this instanceof Transform$5))
    return new Transform$5(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.on("prefinish", prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === "function" && !this._readableState.destroyed) {
    this._flush(function(er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform$5.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};
Transform$5.prototype._transform = function(chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$5.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};
Transform$5.prototype._read = function(n2) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    ts.needTransform = true;
  }
};
Transform$5.prototype._destroy = function(err, cb) {
  Duplex.prototype._destroy.call(this, err, function(err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er)
    return stream.emit("error", er);
  if (data != null)
    stream.push(data);
  if (stream._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
var _stream_passthrough = PassThrough;
var Transform$4 = _stream_transform;
inherits_browser$1.exports(PassThrough, Transform$4);
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform$4.call(this, options);
}
PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};
var eos;
function once$1(callback) {
  var called = false;
  return function() {
    if (called)
      return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop$5(err) {
  if (err)
    throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === "function";
}
function destroyer(stream, reading, writing, callback) {
  callback = once$1(callback);
  var closed = false;
  stream.on("close", function() {
    closed = true;
  });
  if (eos === void 0)
    eos = endOfStream;
  eos(stream, {
    readable: reading,
    writable: writing
  }, function(err) {
    if (err)
      return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function(err) {
    if (closed)
      return;
    if (destroyed)
      return;
    destroyed = true;
    if (isRequest(stream))
      return stream.abort();
    if (typeof stream.destroy === "function")
      return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED("pipe"));
  };
}
function call(fn) {
  fn();
}
function pipe$1(from2, to) {
  return from2.pipe(to);
}
function popCallback(streams) {
  if (!streams.length)
    return noop$5;
  if (typeof streams[streams.length - 1] !== "function")
    return noop$5;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0]))
    streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS("streams");
  }
  var error2;
  var destroys = streams.map(function(stream, i2) {
    var reading = i2 < streams.length - 1;
    var writing = i2 > 0;
    return destroyer(stream, reading, writing, function(err) {
      if (!error2)
        error2 = err;
      if (err)
        destroys.forEach(call);
      if (reading)
        return;
      destroys.forEach(call);
      callback(error2);
    });
  });
  return streams.reduce(pipe$1);
}
var pipeline_1 = pipeline;
(function(module2, exports2) {
  exports2 = module2.exports = _stream_readable;
  exports2.Stream = exports2;
  exports2.Readable = exports2;
  exports2.Writable = _stream_writable;
  exports2.Duplex = _stream_duplex;
  exports2.Transform = _stream_transform;
  exports2.PassThrough = _stream_passthrough;
  exports2.finished = endOfStream;
  exports2.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
const { Transform: Transform$3 } = readableBrowser.exports;
var keccak$2 = (KeccakState) => class Keccak2 extends Transform$3 {
  constructor(rate, capacity, delimitedSuffix, hashBitLength, options) {
    super(options);
    this._rate = rate;
    this._capacity = capacity;
    this._delimitedSuffix = delimitedSuffix;
    this._hashBitLength = hashBitLength;
    this._options = options;
    this._state = new KeccakState();
    this._state.initialize(rate, capacity);
    this._finalized = false;
  }
  _transform(chunk, encoding, callback) {
    let error2 = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error2 = err;
    }
    callback(error2);
  }
  _flush(callback) {
    let error2 = null;
    try {
      this.push(this.digest());
    } catch (err) {
      error2 = err;
    }
    callback(error2);
  }
  update(data, encoding) {
    if (!buffer$2.Buffer.isBuffer(data) && typeof data !== "string")
      throw new TypeError("Data must be a string or a buffer");
    if (this._finalized)
      throw new Error("Digest already called");
    if (!buffer$2.Buffer.isBuffer(data))
      data = buffer$2.Buffer.from(data, encoding);
    this._state.absorb(data);
    return this;
  }
  digest(encoding) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = true;
    if (this._delimitedSuffix)
      this._state.absorbLastFewBits(this._delimitedSuffix);
    let digest9 = this._state.squeeze(this._hashBitLength / 8);
    if (encoding !== void 0)
      digest9 = digest9.toString(encoding);
    this._resetState();
    return digest9;
  }
  _resetState() {
    this._state.initialize(this._rate, this._capacity);
    return this;
  }
  _clone() {
    const clone = new Keccak2(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
    this._state.copy(clone._state);
    clone._finalized = this._finalized;
    return clone;
  }
};
const { Transform: Transform$2 } = readableBrowser.exports;
var shake = (KeccakState) => class Shake extends Transform$2 {
  constructor(rate, capacity, delimitedSuffix, options) {
    super(options);
    this._rate = rate;
    this._capacity = capacity;
    this._delimitedSuffix = delimitedSuffix;
    this._options = options;
    this._state = new KeccakState();
    this._state.initialize(rate, capacity);
    this._finalized = false;
  }
  _transform(chunk, encoding, callback) {
    let error2 = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error2 = err;
    }
    callback(error2);
  }
  _flush() {
  }
  _read(size2) {
    this.push(this.squeeze(size2));
  }
  update(data, encoding) {
    if (!buffer$2.Buffer.isBuffer(data) && typeof data !== "string")
      throw new TypeError("Data must be a string or a buffer");
    if (this._finalized)
      throw new Error("Squeeze already called");
    if (!buffer$2.Buffer.isBuffer(data))
      data = buffer$2.Buffer.from(data, encoding);
    this._state.absorb(data);
    return this;
  }
  squeeze(dataByteLength, encoding) {
    if (!this._finalized) {
      this._finalized = true;
      this._state.absorbLastFewBits(this._delimitedSuffix);
    }
    let data = this._state.squeeze(dataByteLength);
    if (encoding !== void 0)
      data = data.toString(encoding);
    return data;
  }
  _resetState() {
    this._state.initialize(this._rate, this._capacity);
    return this;
  }
  _clone() {
    const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
    this._state.copy(clone._state);
    clone._finalized = this._finalized;
    return clone;
  }
};
const createKeccak = keccak$2;
const createShake = shake;
var api = function(KeccakState) {
  const Keccak2 = createKeccak(KeccakState);
  const Shake = createShake(KeccakState);
  return function(algorithm2, options) {
    const hash3 = typeof algorithm2 === "string" ? algorithm2.toLowerCase() : algorithm2;
    switch (hash3) {
      case "keccak224":
        return new Keccak2(1152, 448, null, 224, options);
      case "keccak256":
        return new Keccak2(1088, 512, null, 256, options);
      case "keccak384":
        return new Keccak2(832, 768, null, 384, options);
      case "keccak512":
        return new Keccak2(576, 1024, null, 512, options);
      case "sha3-224":
        return new Keccak2(1152, 448, 6, 224, options);
      case "sha3-256":
        return new Keccak2(1088, 512, 6, 256, options);
      case "sha3-384":
        return new Keccak2(832, 768, 6, 384, options);
      case "sha3-512":
        return new Keccak2(576, 1024, 6, 512, options);
      case "shake128":
        return new Shake(1344, 256, 31, options);
      case "shake256":
        return new Shake(1088, 512, 31, options);
      default:
        throw new Error("Invald algorithm: " + algorithm2);
    }
  };
};
var keccakStateUnroll = {};
const P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
keccakStateUnroll.p1600 = function(s2) {
  for (let round = 0; round < 24; ++round) {
    const lo0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
    const hi0 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
    const lo1 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
    const hi1 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
    const lo2 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
    const hi2 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
    const lo3 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
    const hi3 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
    const lo4 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
    const hi4 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
    let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
    let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
    const t1slo0 = s2[0] ^ lo;
    const t1shi0 = s2[1] ^ hi;
    const t1slo5 = s2[10] ^ lo;
    const t1shi5 = s2[11] ^ hi;
    const t1slo10 = s2[20] ^ lo;
    const t1shi10 = s2[21] ^ hi;
    const t1slo15 = s2[30] ^ lo;
    const t1shi15 = s2[31] ^ hi;
    const t1slo20 = s2[40] ^ lo;
    const t1shi20 = s2[41] ^ hi;
    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
    hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
    const t1slo1 = s2[2] ^ lo;
    const t1shi1 = s2[3] ^ hi;
    const t1slo6 = s2[12] ^ lo;
    const t1shi6 = s2[13] ^ hi;
    const t1slo11 = s2[22] ^ lo;
    const t1shi11 = s2[23] ^ hi;
    const t1slo16 = s2[32] ^ lo;
    const t1shi16 = s2[33] ^ hi;
    const t1slo21 = s2[42] ^ lo;
    const t1shi21 = s2[43] ^ hi;
    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
    hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
    const t1slo2 = s2[4] ^ lo;
    const t1shi2 = s2[5] ^ hi;
    const t1slo7 = s2[14] ^ lo;
    const t1shi7 = s2[15] ^ hi;
    const t1slo12 = s2[24] ^ lo;
    const t1shi12 = s2[25] ^ hi;
    const t1slo17 = s2[34] ^ lo;
    const t1shi17 = s2[35] ^ hi;
    const t1slo22 = s2[44] ^ lo;
    const t1shi22 = s2[45] ^ hi;
    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
    hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
    const t1slo3 = s2[6] ^ lo;
    const t1shi3 = s2[7] ^ hi;
    const t1slo8 = s2[16] ^ lo;
    const t1shi8 = s2[17] ^ hi;
    const t1slo13 = s2[26] ^ lo;
    const t1shi13 = s2[27] ^ hi;
    const t1slo18 = s2[36] ^ lo;
    const t1shi18 = s2[37] ^ hi;
    const t1slo23 = s2[46] ^ lo;
    const t1shi23 = s2[47] ^ hi;
    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
    hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
    const t1slo4 = s2[8] ^ lo;
    const t1shi4 = s2[9] ^ hi;
    const t1slo9 = s2[18] ^ lo;
    const t1shi9 = s2[19] ^ hi;
    const t1slo14 = s2[28] ^ lo;
    const t1shi14 = s2[29] ^ hi;
    const t1slo19 = s2[38] ^ lo;
    const t1shi19 = s2[39] ^ hi;
    const t1slo24 = s2[48] ^ lo;
    const t1shi24 = s2[49] ^ hi;
    const t2slo0 = t1slo0;
    const t2shi0 = t1shi0;
    const t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
    const t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
    const t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
    const t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
    const t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
    const t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
    const t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
    const t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
    const t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
    const t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
    const t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
    const t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
    const t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
    const t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
    const t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
    const t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
    const t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
    const t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
    const t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
    const t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
    const t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
    const t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
    const t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
    const t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
    const t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
    const t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
    const t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
    const t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
    const t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
    const t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
    const t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
    const t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
    const t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
    const t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
    const t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
    const t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
    const t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
    const t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
    const t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
    const t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
    const t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
    const t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
    const t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
    const t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
    const t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
    const t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
    const t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
    const t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
    s2[0] = t2slo0 ^ ~t2slo1 & t2slo2;
    s2[1] = t2shi0 ^ ~t2shi1 & t2shi2;
    s2[10] = t2slo5 ^ ~t2slo6 & t2slo7;
    s2[11] = t2shi5 ^ ~t2shi6 & t2shi7;
    s2[20] = t2slo10 ^ ~t2slo11 & t2slo12;
    s2[21] = t2shi10 ^ ~t2shi11 & t2shi12;
    s2[30] = t2slo15 ^ ~t2slo16 & t2slo17;
    s2[31] = t2shi15 ^ ~t2shi16 & t2shi17;
    s2[40] = t2slo20 ^ ~t2slo21 & t2slo22;
    s2[41] = t2shi20 ^ ~t2shi21 & t2shi22;
    s2[2] = t2slo1 ^ ~t2slo2 & t2slo3;
    s2[3] = t2shi1 ^ ~t2shi2 & t2shi3;
    s2[12] = t2slo6 ^ ~t2slo7 & t2slo8;
    s2[13] = t2shi6 ^ ~t2shi7 & t2shi8;
    s2[22] = t2slo11 ^ ~t2slo12 & t2slo13;
    s2[23] = t2shi11 ^ ~t2shi12 & t2shi13;
    s2[32] = t2slo16 ^ ~t2slo17 & t2slo18;
    s2[33] = t2shi16 ^ ~t2shi17 & t2shi18;
    s2[42] = t2slo21 ^ ~t2slo22 & t2slo23;
    s2[43] = t2shi21 ^ ~t2shi22 & t2shi23;
    s2[4] = t2slo2 ^ ~t2slo3 & t2slo4;
    s2[5] = t2shi2 ^ ~t2shi3 & t2shi4;
    s2[14] = t2slo7 ^ ~t2slo8 & t2slo9;
    s2[15] = t2shi7 ^ ~t2shi8 & t2shi9;
    s2[24] = t2slo12 ^ ~t2slo13 & t2slo14;
    s2[25] = t2shi12 ^ ~t2shi13 & t2shi14;
    s2[34] = t2slo17 ^ ~t2slo18 & t2slo19;
    s2[35] = t2shi17 ^ ~t2shi18 & t2shi19;
    s2[44] = t2slo22 ^ ~t2slo23 & t2slo24;
    s2[45] = t2shi22 ^ ~t2shi23 & t2shi24;
    s2[6] = t2slo3 ^ ~t2slo4 & t2slo0;
    s2[7] = t2shi3 ^ ~t2shi4 & t2shi0;
    s2[16] = t2slo8 ^ ~t2slo9 & t2slo5;
    s2[17] = t2shi8 ^ ~t2shi9 & t2shi5;
    s2[26] = t2slo13 ^ ~t2slo14 & t2slo10;
    s2[27] = t2shi13 ^ ~t2shi14 & t2shi10;
    s2[36] = t2slo18 ^ ~t2slo19 & t2slo15;
    s2[37] = t2shi18 ^ ~t2shi19 & t2shi15;
    s2[46] = t2slo23 ^ ~t2slo24 & t2slo20;
    s2[47] = t2shi23 ^ ~t2shi24 & t2shi20;
    s2[8] = t2slo4 ^ ~t2slo0 & t2slo1;
    s2[9] = t2shi4 ^ ~t2shi0 & t2shi1;
    s2[18] = t2slo9 ^ ~t2slo5 & t2slo6;
    s2[19] = t2shi9 ^ ~t2shi5 & t2shi6;
    s2[28] = t2slo14 ^ ~t2slo10 & t2slo11;
    s2[29] = t2shi14 ^ ~t2shi10 & t2shi11;
    s2[38] = t2slo19 ^ ~t2slo15 & t2slo16;
    s2[39] = t2shi19 ^ ~t2shi15 & t2shi16;
    s2[48] = t2slo24 ^ ~t2slo20 & t2slo21;
    s2[49] = t2shi24 ^ ~t2shi20 & t2shi21;
    s2[0] ^= P1600_ROUND_CONSTANTS[round * 2];
    s2[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
  }
};
const keccakState = keccakStateUnroll;
function Keccak() {
  this.state = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  this.blockSize = null;
  this.count = 0;
  this.squeezing = false;
}
Keccak.prototype.initialize = function(rate, capacity) {
  for (let i2 = 0; i2 < 50; ++i2)
    this.state[i2] = 0;
  this.blockSize = rate / 8;
  this.count = 0;
  this.squeezing = false;
};
Keccak.prototype.absorb = function(data) {
  for (let i2 = 0; i2 < data.length; ++i2) {
    this.state[~~(this.count / 4)] ^= data[i2] << 8 * (this.count % 4);
    this.count += 1;
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state);
      this.count = 0;
    }
  }
};
Keccak.prototype.absorbLastFewBits = function(bits) {
  this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
  if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
    keccakState.p1600(this.state);
  this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
  keccakState.p1600(this.state);
  this.count = 0;
  this.squeezing = true;
};
Keccak.prototype.squeeze = function(length) {
  if (!this.squeezing)
    this.absorbLastFewBits(1);
  const output = buffer$2.Buffer.alloc(length);
  for (let i2 = 0; i2 < length; ++i2) {
    output[i2] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
    this.count += 1;
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state);
      this.count = 0;
    }
  }
  return output;
};
Keccak.prototype.copy = function(dest) {
  for (let i2 = 0; i2 < 50; ++i2)
    dest.state[i2] = this.state[i2];
  dest.blockSize = this.blockSize;
  dest.count = this.count;
  dest.squeezing = this.squeezing;
};
var keccak$1 = Keccak;
var js = api(keccak$1);
Object.defineProperty(keccak$3, "__esModule", { value: true });
var hash_utils_1 = hashUtils;
var createKeccakHash$1 = js;
keccak$3.keccak224 = hash_utils_1.createHashFunction(function() {
  return createKeccakHash$1("keccak224");
});
keccak$3.keccak256 = hash_utils_1.createHashFunction(function() {
  return createKeccakHash$1("keccak256");
});
keccak$3.keccak384 = hash_utils_1.createHashFunction(function() {
  return createKeccakHash$1("keccak384");
});
keccak$3.keccak512 = hash_utils_1.createHashFunction(function() {
  return createKeccakHash$1("keccak512");
});
var secp256k1$2 = {};
const errors$2 = {
  IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
  TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
  TWEAK_MUL: "The tweak was out of range or equal to zero",
  CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
  SECKEY_INVALID: "Private Key is invalid",
  PUBKEY_PARSE: "Public Key could not be parsed",
  PUBKEY_SERIALIZE: "Public Key serialization error",
  PUBKEY_COMBINE: "The sum of the public keys is not valid",
  SIG_PARSE: "Signature could not be parsed",
  SIGN: "The nonce generation function failed, or the private key was invalid",
  RECOVER: "Public key could not be recover",
  ECDH: "Scalar was invalid (zero or overflow)"
};
function assert$c(cond, msg) {
  if (!cond)
    throw new Error(msg);
}
function isUint8Array(name2, value2, length) {
  assert$c(value2 instanceof Uint8Array, `Expected ${name2} to be an Uint8Array`);
  if (length !== void 0) {
    if (Array.isArray(length)) {
      const numbers = length.join(", ");
      const msg = `Expected ${name2} to be an Uint8Array with length [${numbers}]`;
      assert$c(length.includes(value2.length), msg);
    } else {
      const msg = `Expected ${name2} to be an Uint8Array with length ${length}`;
      assert$c(value2.length === length, msg);
    }
  }
}
function isCompressed(value2) {
  assert$c(toTypeString(value2) === "Boolean", "Expected compressed to be a Boolean");
}
function getAssertedOutput(output = (len2) => new Uint8Array(len2), length) {
  if (typeof output === "function")
    output = output(length);
  isUint8Array("output", output, length);
  return output;
}
function toTypeString(value2) {
  return Object.prototype.toString.call(value2).slice(8, -1);
}
var lib$3 = (secp256k12) => {
  return {
    contextRandomize(seed) {
      assert$c(seed === null || seed instanceof Uint8Array, "Expected seed to be an Uint8Array or null");
      if (seed !== null)
        isUint8Array("seed", seed, 32);
      switch (secp256k12.contextRandomize(seed)) {
        case 1:
          throw new Error(errors$2.CONTEXT_RANDOMIZE_UNKNOW);
      }
    },
    privateKeyVerify(seckey) {
      isUint8Array("private key", seckey, 32);
      return secp256k12.privateKeyVerify(seckey) === 0;
    },
    privateKeyNegate(seckey) {
      isUint8Array("private key", seckey, 32);
      switch (secp256k12.privateKeyNegate(seckey)) {
        case 0:
          return seckey;
        case 1:
          throw new Error(errors$2.IMPOSSIBLE_CASE);
      }
    },
    privateKeyTweakAdd(seckey, tweak) {
      isUint8Array("private key", seckey, 32);
      isUint8Array("tweak", tweak, 32);
      switch (secp256k12.privateKeyTweakAdd(seckey, tweak)) {
        case 0:
          return seckey;
        case 1:
          throw new Error(errors$2.TWEAK_ADD);
      }
    },
    privateKeyTweakMul(seckey, tweak) {
      isUint8Array("private key", seckey, 32);
      isUint8Array("tweak", tweak, 32);
      switch (secp256k12.privateKeyTweakMul(seckey, tweak)) {
        case 0:
          return seckey;
        case 1:
          throw new Error(errors$2.TWEAK_MUL);
      }
    },
    publicKeyVerify(pubkey) {
      isUint8Array("public key", pubkey, [33, 65]);
      return secp256k12.publicKeyVerify(pubkey) === 0;
    },
    publicKeyCreate(seckey, compressed = true, output) {
      isUint8Array("private key", seckey, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyCreate(output, seckey)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$2.SECKEY_INVALID);
        case 2:
          throw new Error(errors$2.PUBKEY_SERIALIZE);
      }
    },
    publicKeyConvert(pubkey, compressed = true, output) {
      isUint8Array("public key", pubkey, [33, 65]);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyConvert(output, pubkey)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$2.PUBKEY_PARSE);
        case 2:
          throw new Error(errors$2.PUBKEY_SERIALIZE);
      }
    },
    publicKeyNegate(pubkey, compressed = true, output) {
      isUint8Array("public key", pubkey, [33, 65]);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyNegate(output, pubkey)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$2.PUBKEY_PARSE);
        case 2:
          throw new Error(errors$2.IMPOSSIBLE_CASE);
        case 3:
          throw new Error(errors$2.PUBKEY_SERIALIZE);
      }
    },
    publicKeyCombine(pubkeys, compressed = true, output) {
      assert$c(Array.isArray(pubkeys), "Expected public keys to be an Array");
      assert$c(pubkeys.length > 0, "Expected public keys array will have more than zero items");
      for (const pubkey of pubkeys) {
        isUint8Array("public key", pubkey, [33, 65]);
      }
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyCombine(output, pubkeys)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$2.PUBKEY_PARSE);
        case 2:
          throw new Error(errors$2.PUBKEY_COMBINE);
        case 3:
          throw new Error(errors$2.PUBKEY_SERIALIZE);
      }
    },
    publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
      isUint8Array("public key", pubkey, [33, 65]);
      isUint8Array("tweak", tweak, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyTweakAdd(output, pubkey, tweak)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$2.PUBKEY_PARSE);
        case 2:
          throw new Error(errors$2.TWEAK_ADD);
      }
    },
    publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
      isUint8Array("public key", pubkey, [33, 65]);
      isUint8Array("tweak", tweak, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.publicKeyTweakMul(output, pubkey, tweak)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$2.PUBKEY_PARSE);
        case 2:
          throw new Error(errors$2.TWEAK_MUL);
      }
    },
    signatureNormalize(sig) {
      isUint8Array("signature", sig, 64);
      switch (secp256k12.signatureNormalize(sig)) {
        case 0:
          return sig;
        case 1:
          throw new Error(errors$2.SIG_PARSE);
      }
    },
    signatureExport(sig, output) {
      isUint8Array("signature", sig, 64);
      output = getAssertedOutput(output, 72);
      const obj = { output, outputlen: 72 };
      switch (secp256k12.signatureExport(obj, sig)) {
        case 0:
          return output.slice(0, obj.outputlen);
        case 1:
          throw new Error(errors$2.SIG_PARSE);
        case 2:
          throw new Error(errors$2.IMPOSSIBLE_CASE);
      }
    },
    signatureImport(sig, output) {
      isUint8Array("signature", sig);
      output = getAssertedOutput(output, 64);
      switch (secp256k12.signatureImport(output, sig)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$2.SIG_PARSE);
        case 2:
          throw new Error(errors$2.IMPOSSIBLE_CASE);
      }
    },
    ecdsaSign(msg32, seckey, options = {}, output) {
      isUint8Array("message", msg32, 32);
      isUint8Array("private key", seckey, 32);
      assert$c(toTypeString(options) === "Object", "Expected options to be an Object");
      if (options.data !== void 0)
        isUint8Array("options.data", options.data);
      if (options.noncefn !== void 0)
        assert$c(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
      output = getAssertedOutput(output, 64);
      const obj = { signature: output, recid: null };
      switch (secp256k12.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
        case 0:
          return obj;
        case 1:
          throw new Error(errors$2.SIGN);
        case 2:
          throw new Error(errors$2.IMPOSSIBLE_CASE);
      }
    },
    ecdsaVerify(sig, msg32, pubkey) {
      isUint8Array("signature", sig, 64);
      isUint8Array("message", msg32, 32);
      isUint8Array("public key", pubkey, [33, 65]);
      switch (secp256k12.ecdsaVerify(sig, msg32, pubkey)) {
        case 0:
          return true;
        case 3:
          return false;
        case 1:
          throw new Error(errors$2.SIG_PARSE);
        case 2:
          throw new Error(errors$2.PUBKEY_PARSE);
      }
    },
    ecdsaRecover(sig, recid, msg32, compressed = true, output) {
      isUint8Array("signature", sig, 64);
      assert$c(toTypeString(recid) === "Number" && recid >= 0 && recid <= 3, "Expected recovery id to be a Number within interval [0, 3]");
      isUint8Array("message", msg32, 32);
      isCompressed(compressed);
      output = getAssertedOutput(output, compressed ? 33 : 65);
      switch (secp256k12.ecdsaRecover(output, sig, recid, msg32)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$2.SIG_PARSE);
        case 2:
          throw new Error(errors$2.RECOVER);
        case 3:
          throw new Error(errors$2.IMPOSSIBLE_CASE);
      }
    },
    ecdh(pubkey, seckey, options = {}, output) {
      isUint8Array("public key", pubkey, [33, 65]);
      isUint8Array("private key", seckey, 32);
      assert$c(toTypeString(options) === "Object", "Expected options to be an Object");
      if (options.data !== void 0)
        isUint8Array("options.data", options.data);
      if (options.hashfn !== void 0) {
        assert$c(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
        if (options.xbuf !== void 0)
          isUint8Array("options.xbuf", options.xbuf, 32);
        if (options.ybuf !== void 0)
          isUint8Array("options.ybuf", options.ybuf, 32);
        isUint8Array("output", output);
      } else {
        output = getAssertedOutput(output, 32);
      }
      switch (secp256k12.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
        case 0:
          return output;
        case 1:
          throw new Error(errors$2.PUBKEY_PARSE);
        case 2:
          throw new Error(errors$2.ECDH);
      }
    }
  };
};
var elliptic$2 = {};
const name$1 = "elliptic";
const version$4 = "6.5.4";
const description$1 = "EC cryptography";
const main$1 = "lib/elliptic.js";
const files = [
  "lib"
];
const scripts$1 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
};
const repository$1 = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
};
const keywords$1 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
];
const author$1 = "Fedor Indutny <fedor@indutny.com>";
const license$1 = "MIT";
const bugs = {
  url: "https://github.com/indutny/elliptic/issues"
};
const homepage = "https://github.com/indutny/elliptic";
const devDependencies$1 = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
};
const dependencies$1 = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
};
var require$$0$2 = {
  name: name$1,
  version: version$4,
  description: description$1,
  main: main$1,
  files,
  scripts: scripts$1,
  repository: repository$1,
  keywords: keywords$1,
  author: author$1,
  license: license$1,
  bugs,
  homepage,
  devDependencies: devDependencies$1,
  dependencies: dependencies$1
};
var utils$g = {};
var utils$f = {};
(function(exports2) {
  var utils2 = exports2;
  function toArray2(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i2 = 0; i2 < msg.length; i2++)
        res[i2] = msg[i2] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i2 = 0; i2 < msg.length; i2 += 2)
        res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
    } else {
      for (var i2 = 0; i2 < msg.length; i2++) {
        var c2 = msg.charCodeAt(i2);
        var hi = c2 >> 8;
        var lo = c2 & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils2.toArray = toArray2;
  function zero22(word2) {
    if (word2.length === 1)
      return "0" + word2;
    else
      return word2;
  }
  utils2.zero2 = zero22;
  function toHex3(msg) {
    var res = "";
    for (var i2 = 0; i2 < msg.length; i2++)
      res += zero22(msg[i2].toString(16));
    return res;
  }
  utils2.toHex = toHex3;
  utils2.encode = function encode5(arr2, enc) {
    if (enc === "hex")
      return toHex3(arr2);
    else
      return arr2;
  };
})(utils$f);
(function(exports2) {
  var utils2 = exports2;
  var BN2 = bn$2.exports;
  var minAssert = minimalisticAssert$1;
  var minUtils = utils$f;
  utils2.assert = minAssert;
  utils2.toArray = minUtils.toArray;
  utils2.zero2 = minUtils.zero2;
  utils2.toHex = minUtils.toHex;
  utils2.encode = minUtils.encode;
  function getNAF2(num, w2, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w2 + 1;
    var k2 = num.clone();
    for (var i2 = 0; i2 < naf.length; i2++) {
      var z2;
      var mod = k2.andln(ws - 1);
      if (k2.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z2 = (ws >> 1) - mod;
        else
          z2 = mod;
        k2.isubn(z2);
      } else {
        z2 = 0;
      }
      naf[i2] = z2;
      k2.iushrn(1);
    }
    return naf;
  }
  utils2.getNAF = getNAF2;
  function getJSF2(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils2.getJSF = getJSF2;
  function cachedProperty2(obj, name2, computer) {
    var key2 = "_" + name2;
    obj.prototype[name2] = function cachedProperty3() {
      return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
    };
  }
  utils2.cachedProperty = cachedProperty2;
  function parseBytes2(bytes3) {
    return typeof bytes3 === "string" ? utils2.toArray(bytes3, "hex") : bytes3;
  }
  utils2.parseBytes = parseBytes2;
  function intFromLE(bytes3) {
    return new BN2(bytes3, "hex", "le");
  }
  utils2.intFromLE = intFromLE;
})(utils$g);
var brorand = { exports: {} };
var r$4;
brorand.exports = function rand2(len2) {
  if (!r$4)
    r$4 = new Rand(null);
  return r$4.generate(len2);
};
function Rand(rand3) {
  this.rand = rand3;
}
brorand.exports.Rand = Rand;
Rand.prototype.generate = function generate3(len2) {
  return this._rand(len2);
};
Rand.prototype._rand = function _rand(n2) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n2);
  var res = new Uint8Array(n2);
  for (var i2 = 0; i2 < res.length; i2++)
    res[i2] = this.rand.getByte();
  return res;
};
if (typeof self === "object") {
  if (self.crypto && self.crypto.getRandomValues) {
    Rand.prototype._rand = function _rand2(n2) {
      var arr2 = new Uint8Array(n2);
      self.crypto.getRandomValues(arr2);
      return arr2;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    Rand.prototype._rand = function _rand2(n2) {
      var arr2 = new Uint8Array(n2);
      self.msCrypto.getRandomValues(arr2);
      return arr2;
    };
  } else if (typeof window === "object") {
    Rand.prototype._rand = function() {
      throw new Error("Not implemented yet");
    };
  }
} else {
  try {
    var crypto$3 = require("crypto");
    if (typeof crypto$3.randomBytes !== "function")
      throw new Error("Not supported");
    Rand.prototype._rand = function _rand2(n2) {
      return crypto$3.randomBytes(n2);
    };
  } catch (e2) {
  }
}
var curve = {};
var BN$g = bn$2.exports;
var utils$e = utils$g;
var getNAF = utils$e.getNAF;
var getJSF = utils$e.getJSF;
var assert$b = utils$e.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN$g(conf.p, 16);
  this.red = conf.prime ? BN$g.red(conf.prime) : BN$g.mont(this.p);
  this.zero = new BN$g(0).toRed(this.red);
  this.one = new BN$g(1).toRed(this.red);
  this.two = new BN$g(2).toRed(this.red);
  this.n = conf.n && new BN$g(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function point3() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function validate5() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul2(p2, k2) {
  assert$b(p2.precomputed);
  var doubles = p2._getDoubles();
  var naf = getNAF(k2, 1, this._bitLength);
  var I2 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I2 /= 3;
  var repr = [];
  var j2;
  var nafW;
  for (j2 = 0; j2 < naf.length; j2 += doubles.step) {
    nafW = 0;
    for (var l2 = j2 + doubles.step - 1; l2 >= j2; l2--)
      nafW = (nafW << 1) + naf[l2];
    repr.push(nafW);
  }
  var a2 = this.jpoint(null, null, null);
  var b2 = this.jpoint(null, null, null);
  for (var i2 = I2; i2 > 0; i2--) {
    for (j2 = 0; j2 < repr.length; j2++) {
      nafW = repr[j2];
      if (nafW === i2)
        b2 = b2.mixedAdd(doubles.points[j2]);
      else if (nafW === -i2)
        b2 = b2.mixedAdd(doubles.points[j2].neg());
    }
    a2 = a2.add(b2);
  }
  return a2.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul2(p2, k2) {
  var w2 = 4;
  var nafPoints = p2._getNAFPoints(w2);
  w2 = nafPoints.wnd;
  var wnd = nafPoints.points;
  var naf = getNAF(k2, w2, this._bitLength);
  var acc = this.jpoint(null, null, null);
  for (var i2 = naf.length - 1; i2 >= 0; i2--) {
    for (var l2 = 0; i2 >= 0 && naf[i2] === 0; i2--)
      l2++;
    if (i2 >= 0)
      l2++;
    acc = acc.dblp(l2);
    if (i2 < 0)
      break;
    var z2 = naf[i2];
    assert$b(z2 !== 0);
    if (p2.type === "affine") {
      if (z2 > 0)
        acc = acc.mixedAdd(wnd[z2 - 1 >> 1]);
      else
        acc = acc.mixedAdd(wnd[-z2 - 1 >> 1].neg());
    } else {
      if (z2 > 0)
        acc = acc.add(wnd[z2 - 1 >> 1]);
      else
        acc = acc.add(wnd[-z2 - 1 >> 1].neg());
    }
  }
  return p2.type === "affine" ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd2(defW, points, coeffs, len2, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;
  var max2 = 0;
  var i2;
  var j2;
  var p2;
  for (i2 = 0; i2 < len2; i2++) {
    p2 = points[i2];
    var nafPoints = p2._getNAFPoints(defW);
    wndWidth[i2] = nafPoints.wnd;
    wnd[i2] = nafPoints.points;
  }
  for (i2 = len2 - 1; i2 >= 1; i2 -= 2) {
    var a2 = i2 - 1;
    var b2 = i2;
    if (wndWidth[a2] !== 1 || wndWidth[b2] !== 1) {
      naf[a2] = getNAF(coeffs[a2], wndWidth[a2], this._bitLength);
      naf[b2] = getNAF(coeffs[b2], wndWidth[b2], this._bitLength);
      max2 = Math.max(naf[a2].length, max2);
      max2 = Math.max(naf[b2].length, max2);
      continue;
    }
    var comb = [
      points[a2],
      null,
      null,
      points[b2]
    ];
    if (points[a2].y.cmp(points[b2].y) === 0) {
      comb[1] = points[a2].add(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    } else if (points[a2].y.cmp(points[b2].y.redNeg()) === 0) {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].add(points[b2].neg());
    } else {
      comb[1] = points[a2].toJ().mixedAdd(points[b2]);
      comb[2] = points[a2].toJ().mixedAdd(points[b2].neg());
    }
    var index2 = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ];
    var jsf = getJSF(coeffs[a2], coeffs[b2]);
    max2 = Math.max(jsf[0].length, max2);
    naf[a2] = new Array(max2);
    naf[b2] = new Array(max2);
    for (j2 = 0; j2 < max2; j2++) {
      var ja = jsf[0][j2] | 0;
      var jb = jsf[1][j2] | 0;
      naf[a2][j2] = index2[(ja + 1) * 3 + (jb + 1)];
      naf[b2][j2] = 0;
      wnd[a2] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i2 = max2; i2 >= 0; i2--) {
    var k2 = 0;
    while (i2 >= 0) {
      var zero = true;
      for (j2 = 0; j2 < len2; j2++) {
        tmp[j2] = naf[j2][i2] | 0;
        if (tmp[j2] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k2++;
      i2--;
    }
    if (i2 >= 0)
      k2++;
    acc = acc.dblp(k2);
    if (i2 < 0)
      break;
    for (j2 = 0; j2 < len2; j2++) {
      var z2 = tmp[j2];
      if (z2 === 0)
        continue;
      else if (z2 > 0)
        p2 = wnd[j2][z2 - 1 >> 1];
      else if (z2 < 0)
        p2 = wnd[j2][-z2 - 1 >> 1].neg();
      if (p2.type === "affine")
        acc = acc.mixedAdd(p2);
      else
        acc = acc.add(p2);
    }
  }
  for (i2 = 0; i2 < len2; i2++)
    wnd[i2] = null;
  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};
function BasePoint(curve2, type) {
  this.curve = curve2;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq4() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function validate6() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint2(bytes3, enc) {
  bytes3 = utils$e.toArray(bytes3, enc);
  var len2 = this.p.byteLength();
  if ((bytes3[0] === 4 || bytes3[0] === 6 || bytes3[0] === 7) && bytes3.length - 1 === 2 * len2) {
    if (bytes3[0] === 6)
      assert$b(bytes3[bytes3.length - 1] % 2 === 0);
    else if (bytes3[0] === 7)
      assert$b(bytes3[bytes3.length - 1] % 2 === 1);
    var res = this.point(bytes3.slice(1, 1 + len2), bytes3.slice(1 + len2, 1 + 2 * len2));
    return res;
  } else if ((bytes3[0] === 2 || bytes3[0] === 3) && bytes3.length - 1 === len2) {
    return this.pointFromX(bytes3.slice(1, 1 + len2), bytes3[0] === 3);
  }
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function encodeCompressed2(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode3(compact) {
  var len2 = this.curve.p.byteLength();
  var x2 = this.getX().toArray("be", len2);
  if (compact)
    return [this.getY().isEven() ? 2 : 3].concat(x2);
  return [4].concat(x2, this.getY().toArray("be", len2));
};
BasePoint.prototype.encode = function encode3(enc, compact) {
  return utils$e.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute2(power) {
  if (this.precomputed)
    return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles2(k2) {
  if (!this.precomputed)
    return false;
  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;
  return doubles.points.length >= Math.ceil((k2.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles2(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i2 = 0; i2 < power; i2 += step) {
    for (var j2 = 0; j2 < step; j2++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints2(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  var res = [this];
  var max2 = (1 << wnd) - 1;
  var dbl7 = max2 === 1 ? null : this.dbl();
  for (var i2 = 1; i2 < max2; i2++)
    res[i2] = res[i2 - 1].add(dbl7);
  return {
    wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta3() {
  return null;
};
BasePoint.prototype.dblp = function dblp3(k2) {
  var r2 = this;
  for (var i2 = 0; i2 < k2; i2++)
    r2 = r2.dbl();
  return r2;
};
var utils$d = utils$g;
var BN$f = bn$2.exports;
var inherits$i = inherits_browser$1.exports;
var Base$3 = base$1;
var assert$a = utils$d.assert;
function ShortCurve(conf) {
  Base$3.call(this, "short", conf);
  this.a = new BN$f(conf.a, 16).toRed(this.red);
  this.b = new BN$f(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits$i(ShortCurve, Base$3);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism2(conf) {
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN$f(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN$f(conf.lambda, 16);
  } else {
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$a(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN$f(vec.a, 16),
        b: new BN$f(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta,
    lambda,
    basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots2(num) {
  var red = num === this.p ? this.red : BN$f.mont(num);
  var tinv = new BN$f(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s2 = new BN$f(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s2).fromRed();
  var l2 = ntinv.redSub(s2).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis2(lambda) {
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
  var u2 = lambda;
  var v2 = this.n.clone();
  var x1 = new BN$f(1);
  var y1 = new BN$f(0);
  var x2 = new BN$f(0);
  var y2 = new BN$f(1);
  var a0;
  var b0;
  var a1;
  var b1;
  var a2;
  var b2;
  var prevR;
  var i2 = 0;
  var r2;
  var x3;
  while (u2.cmpn(0) !== 0) {
    var q2 = v2.div(u2);
    r2 = v2.sub(q2.mul(u2));
    x3 = x2.sub(q2.mul(x1));
    var y3 = y2.sub(q2.mul(y1));
    if (!a1 && r2.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r2.neg();
      b1 = x3;
    } else if (a1 && ++i2 === 2) {
      break;
    }
    prevR = r2;
    v2 = u2;
    u2 = r2;
    x2 = x1;
    x1 = x3;
    y2 = y1;
    y1 = y3;
  }
  a2 = r2.neg();
  b2 = x3;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};
ShortCurve.prototype._endoSplit = function _endoSplit2(k2) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k2).divRound(this.n);
  var c2 = v1.b.neg().mul(k2).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);
  var k1 = k2.sub(p1).sub(p2);
  var k22 = q1.add(q2).neg();
  return { k1, k2: k22 };
};
ShortCurve.prototype.pointFromX = function pointFromX2(x2, odd) {
  x2 = new BN$f(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var y2 = x2.redSqr().redMul(x2).redIAdd(x2.redMul(this.a)).redIAdd(this.b);
  var y3 = y2.redSqrt();
  if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x2, y3);
};
ShortCurve.prototype.validate = function validate7(point7) {
  if (point7.inf)
    return true;
  var x2 = point7.x;
  var y2 = point7.y;
  var ax = this.a.redMul(x2);
  var rhs = x2.redSqr().redMul(x2).redIAdd(ax).redIAdd(this.b);
  return y2.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd2(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i2 = 0; i2 < points.length; i2++) {
    var split = this._endoSplit(coeffs[i2]);
    var p2 = points[i2];
    var beta = p2._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p2 = p2.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i2 * 2] = p2;
    npoints[i2 * 2 + 1] = beta;
    ncoeffs[i2 * 2] = split.k1;
    ncoeffs[i2 * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
  for (var j2 = 0; j2 < i2 * 2; j2++) {
    npoints[j2] = null;
    ncoeffs[j2] = null;
  }
  return res;
};
function Point$2(curve2, x2, y2, isRed) {
  Base$3.BasePoint.call(this, curve2, "affine");
  if (x2 === null && y2 === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN$f(x2, 16);
    this.y = new BN$f(y2, 16);
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits$i(Point$2, Base$3.BasePoint);
ShortCurve.prototype.point = function point4(x2, y2, isRed) {
  return new Point$2(this, x2, y2, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON2(obj, red) {
  return Point$2.fromJSON(this, obj, red);
};
Point$2.prototype._getBeta = function _getBeta4() {
  if (!this.curve.endo)
    return;
  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve2 = this.curve;
    var endoMul = function(p2) {
      return curve2.point(p2.x.redMul(curve2.endo.beta), p2.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point$2.prototype.toJSON = function toJSON2() {
  if (!this.precomputed)
    return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point$2.fromJSON = function fromJSON2(curve2, obj, red) {
  if (typeof obj === "string")
    obj = JSON.parse(obj);
  var res = curve2.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;
  function obj2point(obj2) {
    return curve2.point(obj2[0], obj2[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point$2.prototype.inspect = function inspect5() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function isInfinity3() {
  return this.inf;
};
Point$2.prototype.add = function add4(p2) {
  if (this.inf)
    return p2;
  if (p2.inf)
    return this;
  if (this.eq(p2))
    return this.dbl();
  if (this.neg().eq(p2))
    return this.curve.point(null, null);
  if (this.x.cmp(p2.x) === 0)
    return this.curve.point(null, null);
  var c2 = this.y.redSub(p2.y);
  if (c2.cmpn(0) !== 0)
    c2 = c2.redMul(this.x.redSub(p2.x).redInvm());
  var nx = c2.redSqr().redISub(this.x).redISub(p2.x);
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$2.prototype.dbl = function dbl3() {
  if (this.inf)
    return this;
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);
  var a2 = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c2 = x2.redAdd(x2).redIAdd(x2).redIAdd(a2).redMul(dyinv);
  var nx = c2.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c2.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point$2.prototype.getX = function getX2() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function getY2() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function mul3(k2) {
  k2 = new BN$f(k2, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([this], [k2]);
  else
    return this.curve._wnafMul(this, k2);
};
Point$2.prototype.mulAdd = function mulAdd2(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point$2.prototype.jmulAdd = function jmulAdd2(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point$2.prototype.eq = function eq5(p2) {
  return this === p2 || this.inf === p2.inf && (this.inf || this.x.cmp(p2.x) === 0 && this.y.cmp(p2.y) === 0);
};
Point$2.prototype.neg = function neg3(_precompute) {
  if (this.inf)
    return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p2) {
      return p2.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point$2.prototype.toJ = function toJ2() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve2, x2, y2, z2) {
  Base$3.BasePoint.call(this, curve2, "jacobian");
  if (x2 === null && y2 === null && z2 === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN$f(0);
  } else {
    this.x = new BN$f(x2, 16);
    this.y = new BN$f(y2, 16);
    this.z = new BN$f(z2, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits$i(JPoint, Base$3.BasePoint);
ShortCurve.prototype.jpoint = function jpoint2(x2, y2, z2) {
  return new JPoint(this, x2, y2, z2);
};
JPoint.prototype.toP = function toP2() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg4() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add5(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  var pz2 = p2.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p2.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p2.z));
  var s2 = p2.y.redMul(z2.redMul(this.z));
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p2.z).redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd2(p2) {
  if (this.isInfinity())
    return p2.toJ();
  if (p2.isInfinity())
    return this;
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p2.x.redMul(z2);
  var s1 = this.y;
  var s2 = p2.y.redMul(z2).redMul(this.z);
  var h2 = u1.redSub(u2);
  var r2 = s1.redSub(s2);
  if (h2.cmpn(0) === 0) {
    if (r2.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }
  var h22 = h2.redSqr();
  var h3 = h22.redMul(h2);
  var v2 = u1.redMul(h22);
  var nx = r2.redSqr().redIAdd(h3).redISub(v2).redISub(v2);
  var ny = r2.redMul(v2.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h2);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp4(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();
  var i2;
  if (this.curve.zeroA || this.curve.threeA) {
    var r2 = this;
    for (i2 = 0; i2 < pow; i2++)
      r2 = r2.dbl();
    return r2;
  }
  var a2 = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jyd = jy.redAdd(jy);
  for (i2 = 0; i2 < pow; i2++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c2.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c2.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i2 + 1 < pow)
      jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl4() {
  if (this.isInfinity())
    return this;
  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl2() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    nx = t2;
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var a2 = this.x.redSqr();
    var b2 = this.y.redSqr();
    var c2 = b2.redSqr();
    var d2 = this.x.redAdd(b2).redSqr().redISub(a2).redISub(c2);
    d2 = d2.redIAdd(d2);
    var e2 = a2.redAdd(a2).redIAdd(a2);
    var f2 = e2.redSqr();
    var c8 = c2.redIAdd(c2);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);
    nx = f2.redISub(d2).redISub(d2);
    ny = e2.redMul(d2.redISub(nx)).redISub(c8);
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl2() {
  var nx;
  var ny;
  var nz;
  if (this.zOne) {
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var yyyy = yy.redSqr();
    var s2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s2 = s2.redIAdd(s2);
    var m2 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    var t2 = m2.redSqr().redISub(s2).redISub(s2);
    nx = t2;
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m2.redMul(s2.redISub(t2)).redISub(yyyy8);
    nz = this.y.redAdd(this.y);
  } else {
    var delta = this.z.redSqr();
    var gamma = this.y.redSqr();
    var beta = this.x.redMul(gamma);
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl2() {
  var a2 = this.curve.a;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c2 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a2.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c2.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c2.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl2() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var xx = this.x.redSqr();
  var yy = this.y.redSqr();
  var zz = this.z.redSqr();
  var yyyy = yy.redSqr();
  var m2 = xx.redAdd(xx).redIAdd(xx);
  var mm = m2.redSqr();
  var e2 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e2 = e2.redIAdd(e2);
  e2 = e2.redAdd(e2).redIAdd(e2);
  e2 = e2.redISub(mm);
  var ee = e2.redSqr();
  var t2 = yyyy.redIAdd(yyyy);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  t2 = t2.redIAdd(t2);
  var u2 = m2.redIAdd(e2).redSqr().redISub(mm).redISub(ee).redISub(t2);
  var yyu4 = yy.redMul(u2);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  var ny = this.y.redMul(u2.redMul(t2.redISub(u2)).redISub(e2.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  var nz = this.z.redAdd(e2).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul4(k2, kbase) {
  k2 = new BN$f(k2, kbase);
  return this.curve._wnafMul(this, k2);
};
JPoint.prototype.eq = function eq6(p2) {
  if (p2.type === "affine")
    return this.eq(p2.toJ());
  if (this === p2)
    return true;
  var z2 = this.z.redSqr();
  var pz2 = p2.z.redSqr();
  if (this.x.redMul(pz2).redISub(p2.x.redMul(z2)).cmpn(0) !== 0)
    return false;
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p2.z);
  return this.y.redMul(pz3).redISub(p2.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP2(x2) {
  var zs = this.z.redSqr();
  var rx = x2.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t2 = this.curve.redN.redMul(zs);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
JPoint.prototype.inspect = function inspect6() {
  if (this.isInfinity())
    return "<EC JPoint Infinity>";
  return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function isInfinity4() {
  return this.z.cmpn(0) === 0;
};
var BN$e = bn$2.exports;
var inherits$h = inherits_browser$1.exports;
var Base$2 = base$1;
var utils$c = utils$g;
function MontCurve(conf) {
  Base$2.call(this, "mont", conf);
  this.a = new BN$e(conf.a, 16).toRed(this.red);
  this.b = new BN$e(conf.b, 16).toRed(this.red);
  this.i4 = new BN$e(4).toRed(this.red).redInvm();
  this.two = new BN$e(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$h(MontCurve, Base$2);
var mont = MontCurve;
MontCurve.prototype.validate = function validate8(point7) {
  var x2 = point7.normalize().x;
  var x22 = x2.redSqr();
  var rhs = x22.redMul(x2).redAdd(x22.redMul(this.a)).redAdd(x2);
  var y2 = rhs.redSqrt();
  return y2.redSqr().cmp(rhs) === 0;
};
function Point$1(curve2, x2, z2) {
  Base$2.BasePoint.call(this, curve2, "projective");
  if (x2 === null && z2 === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN$e(x2, 16);
    this.z = new BN$e(z2, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits$h(Point$1, Base$2.BasePoint);
MontCurve.prototype.decodePoint = function decodePoint3(bytes3, enc) {
  return this.point(utils$c.toArray(bytes3, enc), 1);
};
MontCurve.prototype.point = function point5(x2, z2) {
  return new Point$1(this, x2, z2);
};
MontCurve.prototype.pointFromJSON = function pointFromJSON3(obj) {
  return Point$1.fromJSON(this, obj);
};
Point$1.prototype.precompute = function precompute3() {
};
Point$1.prototype._encode = function _encode4() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function fromJSON3(curve2, obj) {
  return new Point$1(curve2, obj[0], obj[1] || curve2.one);
};
Point$1.prototype.inspect = function inspect7() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function isInfinity5() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function dbl5() {
  var a2 = this.x.redAdd(this.z);
  var aa = a2.redSqr();
  var b2 = this.x.redSub(this.z);
  var bb = b2.redSqr();
  var c2 = aa.redSub(bb);
  var nx = aa.redMul(bb);
  var nz = c2.redMul(bb.redAdd(this.curve.a24.redMul(c2)));
  return this.curve.point(nx, nz);
};
Point$1.prototype.add = function add6() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function diffAdd(p2, diff) {
  var a2 = this.x.redAdd(this.z);
  var b2 = this.x.redSub(this.z);
  var c2 = p2.x.redAdd(p2.z);
  var d2 = p2.x.redSub(p2.z);
  var da = d2.redMul(a2);
  var cb = c2.redMul(b2);
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};
Point$1.prototype.mul = function mul5(k2) {
  var t2 = k2.clone();
  var a2 = this;
  var b2 = this.curve.point(null, null);
  var c2 = this;
  for (var bits = []; t2.cmpn(0) !== 0; t2.iushrn(1))
    bits.push(t2.andln(1));
  for (var i2 = bits.length - 1; i2 >= 0; i2--) {
    if (bits[i2] === 0) {
      a2 = a2.diffAdd(b2, c2);
      b2 = b2.dbl();
    } else {
      b2 = a2.diffAdd(b2, c2);
      a2 = a2.dbl();
    }
  }
  return b2;
};
Point$1.prototype.mulAdd = function mulAdd3() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function jumlAdd() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function eq7(other) {
  return this.getX().cmp(other.getX()) === 0;
};
Point$1.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};
Point$1.prototype.getX = function getX3() {
  this.normalize();
  return this.x.fromRed();
};
var utils$b = utils$g;
var BN$d = bn$2.exports;
var inherits$g = inherits_browser$1.exports;
var Base$1 = base$1;
var assert$9 = utils$b.assert;
function EdwardsCurve(conf) {
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;
  Base$1.call(this, "edwards", conf);
  this.a = new BN$d(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN$d(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN$d(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);
  assert$9(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits$g(EdwardsCurve, Base$1);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};
EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};
EdwardsCurve.prototype.jpoint = function jpoint3(x2, y2, z2, t2) {
  return this.point(x2, y2, z2, t2);
};
EdwardsCurve.prototype.pointFromX = function pointFromX3(x2, odd) {
  x2 = new BN$d(x2, 16);
  if (!x2.red)
    x2 = x2.toRed(this.red);
  var x22 = x2.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x22));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x22));
  var y2 = rhs.redMul(lhs.redInvm());
  var y3 = y2.redSqrt();
  if (y3.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var isOdd = y3.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y3 = y3.redNeg();
  return this.point(x2, y3);
};
EdwardsCurve.prototype.pointFromY = function pointFromY(y2, odd) {
  y2 = new BN$d(y2, 16);
  if (!y2.red)
    y2 = y2.toRed(this.red);
  var y22 = y2.redSqr();
  var lhs = y22.redSub(this.c2);
  var rhs = y22.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());
  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error("invalid point");
    else
      return this.point(this.zero, y2);
  }
  var x3 = x2.redSqrt();
  if (x3.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  if (x3.fromRed().isOdd() !== odd)
    x3 = x3.redNeg();
  return this.point(x3, y2);
};
EdwardsCurve.prototype.validate = function validate9(point7) {
  if (point7.isInfinity())
    return true;
  point7.normalize();
  var x2 = point7.x.redSqr();
  var y2 = point7.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
  return lhs.cmp(rhs) === 0;
};
function Point(curve2, x2, y2, z2, t2) {
  Base$1.BasePoint.call(this, curve2, "projective");
  if (x2 === null && y2 === null && z2 === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN$d(x2, 16);
    this.y = new BN$d(y2, 16);
    this.z = z2 ? new BN$d(z2, 16) : this.curve.one;
    this.t = t2 && new BN$d(t2, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits$g(Point, Base$1.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function pointFromJSON4(obj) {
  return Point.fromJSON(this, obj);
};
EdwardsCurve.prototype.point = function point6(x2, y2, z2, t2) {
  return new Point(this, x2, y2, z2, t2);
};
Point.fromJSON = function fromJSON4(curve2, obj) {
  return new Point(curve2, obj[0], obj[1], obj[2]);
};
Point.prototype.inspect = function inspect8() {
  if (this.isInfinity())
    return "<EC Point Infinity>";
  return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function isInfinity6() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function _extDbl() {
  var a2 = this.x.redSqr();
  var b2 = this.y.redSqr();
  var c2 = this.z.redSqr();
  c2 = c2.redIAdd(c2);
  var d2 = this.curve._mulA(a2);
  var e2 = this.x.redAdd(this.y).redSqr().redISub(a2).redISub(b2);
  var g2 = d2.redAdd(b2);
  var f2 = g2.redSub(c2);
  var h2 = d2.redSub(b2);
  var nx = e2.redMul(f2);
  var ny = g2.redMul(h2);
  var nt = e2.redMul(h2);
  var nz = f2.redMul(g2);
  return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projDbl = function _projDbl() {
  var b2 = this.x.redAdd(this.y).redSqr();
  var c2 = this.x.redSqr();
  var d2 = this.y.redSqr();
  var nx;
  var ny;
  var nz;
  var e2;
  var h2;
  var j2;
  if (this.curve.twisted) {
    e2 = this.curve._mulA(c2);
    var f2 = e2.redAdd(d2);
    if (this.zOne) {
      nx = b2.redSub(c2).redSub(d2).redMul(f2.redSub(this.curve.two));
      ny = f2.redMul(e2.redSub(d2));
      nz = f2.redSqr().redSub(f2).redSub(f2);
    } else {
      h2 = this.z.redSqr();
      j2 = f2.redSub(h2).redISub(h2);
      nx = b2.redSub(c2).redISub(d2).redMul(j2);
      ny = f2.redMul(e2.redSub(d2));
      nz = f2.redMul(j2);
    }
  } else {
    e2 = c2.redAdd(d2);
    h2 = this.curve._mulC(this.z).redSqr();
    j2 = e2.redSub(h2).redSub(h2);
    nx = this.curve._mulC(b2.redISub(e2)).redMul(j2);
    ny = this.curve._mulC(e2).redMul(c2.redISub(d2));
    nz = e2.redMul(j2);
  }
  return this.curve.point(nx, ny, nz);
};
Point.prototype.dbl = function dbl6() {
  if (this.isInfinity())
    return this;
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};
Point.prototype._extAdd = function _extAdd(p2) {
  var a2 = this.y.redSub(this.x).redMul(p2.y.redSub(p2.x));
  var b2 = this.y.redAdd(this.x).redMul(p2.y.redAdd(p2.x));
  var c2 = this.t.redMul(this.curve.dd).redMul(p2.t);
  var d2 = this.z.redMul(p2.z.redAdd(p2.z));
  var e2 = b2.redSub(a2);
  var f2 = d2.redSub(c2);
  var g2 = d2.redAdd(c2);
  var h2 = b2.redAdd(a2);
  var nx = e2.redMul(f2);
  var ny = g2.redMul(h2);
  var nt = e2.redMul(h2);
  var nz = f2.redMul(g2);
  return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projAdd = function _projAdd(p2) {
  var a2 = this.z.redMul(p2.z);
  var b2 = a2.redSqr();
  var c2 = this.x.redMul(p2.x);
  var d2 = this.y.redMul(p2.y);
  var e2 = this.curve.d.redMul(c2).redMul(d2);
  var f2 = b2.redSub(e2);
  var g2 = b2.redAdd(e2);
  var tmp = this.x.redAdd(this.y).redMul(p2.x.redAdd(p2.y)).redISub(c2).redISub(d2);
  var nx = a2.redMul(f2).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    ny = a2.redMul(g2).redMul(d2.redSub(this.curve._mulA(c2)));
    nz = f2.redMul(g2);
  } else {
    ny = a2.redMul(g2).redMul(d2.redSub(c2));
    nz = this.curve._mulC(f2).redMul(g2);
  }
  return this.curve.point(nx, ny, nz);
};
Point.prototype.add = function add7(p2) {
  if (this.isInfinity())
    return p2;
  if (p2.isInfinity())
    return this;
  if (this.curve.extended)
    return this._extAdd(p2);
  else
    return this._projAdd(p2);
};
Point.prototype.mul = function mul6(k2) {
  if (this._hasDoubles(k2))
    return this.curve._fixedNafMul(this, k2);
  else
    return this.curve._wnafMul(this, k2);
};
Point.prototype.mulAdd = function mulAdd4(k1, p2, k2) {
  return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, false);
};
Point.prototype.jmulAdd = function jmulAdd3(k1, p2, k2) {
  return this.curve._wnafMulAdd(1, [this, p2], [k1, k2], 2, true);
};
Point.prototype.normalize = function normalize2() {
  if (this.zOne)
    return this;
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};
Point.prototype.neg = function neg5() {
  return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
};
Point.prototype.getX = function getX4() {
  this.normalize();
  return this.x.fromRed();
};
Point.prototype.getY = function getY3() {
  this.normalize();
  return this.y.fromRed();
};
Point.prototype.eq = function eq8(other) {
  return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};
Point.prototype.eqXToP = function eqXToP3(x2) {
  var rx = x2.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;
  var xc = x2.clone();
  var t2 = this.curve.redN.redMul(this.z);
  for (; ; ) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;
    rx.redIAdd(t2);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(exports2) {
  var curve2 = exports2;
  curve2.base = base$1;
  curve2.short = short;
  curve2.mont = mont;
  curve2.edwards = edwards;
})(curve);
var curves$2 = {};
(function(exports2) {
  var curves2 = exports2;
  var hash3 = hash$4;
  var curve$1 = curve;
  var utils2 = utils$g;
  var assert2 = utils2.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve$1.short(options);
    else if (options.type === "edwards")
      this.curve = new curve$1.edwards(options);
    else
      this.curve = new curve$1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert2(this.g.validate(), "Invalid curve");
    assert2(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves2.PresetCurve = PresetCurve;
  function defineCurve(name2, options) {
    Object.defineProperty(curves2, name2, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve2 = new PresetCurve(options);
        Object.defineProperty(curves2, name2, {
          configurable: true,
          enumerable: true,
          value: curve2
        });
        return curve2;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash3.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash3.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash3.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = require("./precomputed/secp256k1");
  } catch (e2) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash3.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
})(curves$2);
var hash$3 = hash$4;
var utils$a = utils$f;
var assert$8 = minimalisticAssert$1;
function HmacDRBG$1(options) {
  if (!(this instanceof HmacDRBG$1))
    return new HmacDRBG$1(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils$a.toArray(options.entropy, options.entropyEnc || "hex");
  var nonce = utils$a.toArray(options.nonce, options.nonceEnc || "hex");
  var pers = utils$a.toArray(options.pers, options.persEnc || "hex");
  assert$8(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG$1;
HmacDRBG$1.prototype._init = function init4(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i2 = 0; i2 < this.V.length; i2++) {
    this.K[i2] = 0;
    this.V[i2] = 1;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 281474976710656;
};
HmacDRBG$1.prototype._hmac = function hmac3() {
  return new hash$3.hmac(this.hash, this.K);
};
HmacDRBG$1.prototype._update = function update5(seed) {
  var kmac = this._hmac().update(this.V).update([0]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;
  this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG$1.prototype.reseed = function reseed2(entropy, entropyEnc, add8, addEnc) {
  if (typeof entropyEnc !== "string") {
    addEnc = add8;
    add8 = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils$a.toArray(entropy, entropyEnc);
  add8 = utils$a.toArray(add8, addEnc);
  assert$8(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
  this._update(entropy.concat(add8 || []));
  this._reseed = 1;
};
HmacDRBG$1.prototype.generate = function generate4(len2, enc, add8, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  if (typeof enc !== "string") {
    addEnc = add8;
    add8 = enc;
    enc = null;
  }
  if (add8) {
    add8 = utils$a.toArray(add8, addEnc || "hex");
    this._update(add8);
  }
  var temp = [];
  while (temp.length < len2) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len2);
  this._update(add8);
  this._reseed++;
  return utils$a.encode(res, enc);
};
var BN$c = bn$2.exports;
var utils$9 = utils$g;
var assert$7 = utils$9.assert;
function KeyPair$3(ec2, options) {
  this.ec = ec2;
  this.priv = null;
  this.pub = null;
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key$1 = KeyPair$3;
KeyPair$3.fromPublic = function fromPublic2(ec2, pub2, enc) {
  if (pub2 instanceof KeyPair$3)
    return pub2;
  return new KeyPair$3(ec2, {
    pub: pub2,
    pubEnc: enc
  });
};
KeyPair$3.fromPrivate = function fromPrivate2(ec2, priv2, enc) {
  if (priv2 instanceof KeyPair$3)
    return priv2;
  return new KeyPair$3(ec2, {
    priv: priv2,
    privEnc: enc
  });
};
KeyPair$3.prototype.validate = function validate10() {
  var pub2 = this.getPublic();
  if (pub2.isInfinity())
    return { result: false, reason: "Invalid public key" };
  if (!pub2.validate())
    return { result: false, reason: "Public key is not a point" };
  if (!pub2.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: "Public key * N != O" };
  return { result: true, reason: null };
};
KeyPair$3.prototype.getPublic = function getPublic2(compact, enc) {
  if (typeof compact === "string") {
    enc = compact;
    compact = null;
  }
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);
  if (!enc)
    return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair$3.prototype.getPrivate = function getPrivate2(enc) {
  if (enc === "hex")
    return this.priv.toString(16, 2);
  else
    return this.priv;
};
KeyPair$3.prototype._importPrivate = function _importPrivate2(key2, enc) {
  this.priv = new BN$c(key2, enc || 16);
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$3.prototype._importPublic = function _importPublic2(key2, enc) {
  if (key2.x || key2.y) {
    if (this.ec.curve.type === "mont") {
      assert$7(key2.x, "Need x coordinate");
    } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
      assert$7(key2.x && key2.y, "Need both x and y coordinate");
    }
    this.pub = this.ec.curve.point(key2.x, key2.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key2, enc);
};
KeyPair$3.prototype.derive = function derive2(pub2) {
  if (!pub2.validate()) {
    assert$7(pub2.validate(), "public point not validated");
  }
  return pub2.mul(this.priv).getX();
};
KeyPair$3.prototype.sign = function sign4(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair$3.prototype.verify = function verify4(msg, signature2) {
  return this.ec.verify(msg, signature2, this);
};
KeyPair$3.prototype.inspect = function inspect9() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$b = bn$2.exports;
var utils$8 = utils$g;
var assert$6 = utils$8.assert;
function Signature$3(options, enc) {
  if (options instanceof Signature$3)
    return options;
  if (this._importDER(options, enc))
    return;
  assert$6(options.r && options.s, "Signature without r or s");
  this.r = new BN$b(options.r, 16);
  this.s = new BN$b(options.s, 16);
  if (options.recoveryParam === void 0)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature$2 = Signature$3;
function Position() {
  this.place = 0;
}
function getLength$1(buf, p2) {
  var initial = buf[p2.place++];
  if (!(initial & 128)) {
    return initial;
  }
  var octetLen = initial & 15;
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i2 = 0, off = p2.place; i2 < octetLen; i2++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }
  if (val <= 127) {
    return false;
  }
  p2.place = off;
  return val;
}
function rmPadding(buf) {
  var i2 = 0;
  var len2 = buf.length - 1;
  while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len2) {
    i2++;
  }
  if (i2 === 0) {
    return buf;
  }
  return buf.slice(i2);
}
Signature$3.prototype._importDER = function _importDER2(data, enc) {
  data = utils$8.toArray(data, enc);
  var p2 = new Position();
  if (data[p2.place++] !== 48) {
    return false;
  }
  var len2 = getLength$1(data, p2);
  if (len2 === false) {
    return false;
  }
  if (len2 + p2.place !== data.length) {
    return false;
  }
  if (data[p2.place++] !== 2) {
    return false;
  }
  var rlen = getLength$1(data, p2);
  if (rlen === false) {
    return false;
  }
  var r2 = data.slice(p2.place, rlen + p2.place);
  p2.place += rlen;
  if (data[p2.place++] !== 2) {
    return false;
  }
  var slen = getLength$1(data, p2);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p2.place) {
    return false;
  }
  var s2 = data.slice(p2.place, slen + p2.place);
  if (r2[0] === 0) {
    if (r2[1] & 128) {
      r2 = r2.slice(1);
    } else {
      return false;
    }
  }
  if (s2[0] === 0) {
    if (s2[1] & 128) {
      s2 = s2.slice(1);
    } else {
      return false;
    }
  }
  this.r = new BN$b(r2);
  this.s = new BN$b(s2);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr2, len2) {
  if (len2 < 128) {
    arr2.push(len2);
    return;
  }
  var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
  arr2.push(octets | 128);
  while (--octets) {
    arr2.push(len2 >>> (octets << 3) & 255);
  }
  arr2.push(len2);
}
Signature$3.prototype.toDER = function toDER2(enc) {
  var r2 = this.r.toArray();
  var s2 = this.s.toArray();
  if (r2[0] & 128)
    r2 = [0].concat(r2);
  if (s2[0] & 128)
    s2 = [0].concat(s2);
  r2 = rmPadding(r2);
  s2 = rmPadding(s2);
  while (!s2[0] && !(s2[1] & 128)) {
    s2 = s2.slice(1);
  }
  var arr2 = [2];
  constructLength(arr2, r2.length);
  arr2 = arr2.concat(r2);
  arr2.push(2);
  constructLength(arr2, s2.length);
  var backHalf = arr2.concat(s2);
  var res = [48];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils$8.encode(res, enc);
};
var BN$a = bn$2.exports;
var HmacDRBG = hmacDrbg;
var utils$7 = utils$g;
var curves$1 = curves$2;
var rand = brorand.exports;
var assert$5 = utils$7.assert;
var KeyPair$2 = key$1;
var Signature$2 = signature$2;
function EC$3(options) {
  if (!(this instanceof EC$3))
    return new EC$3(options);
  if (typeof options === "string") {
    assert$5(Object.prototype.hasOwnProperty.call(curves$1, options), "Unknown curve " + options);
    options = curves$1[options];
  }
  if (options instanceof curves$1.PresetCurve)
    options = { curve: options };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);
  this.hash = options.hash || options.curve.hash;
}
var ec$3 = EC$3;
EC$3.prototype.keyPair = function keyPair2(options) {
  return new KeyPair$2(this, options);
};
EC$3.prototype.keyFromPrivate = function keyFromPrivate2(priv2, enc) {
  return KeyPair$2.fromPrivate(this, priv2, enc);
};
EC$3.prototype.keyFromPublic = function keyFromPublic2(pub2, enc) {
  return KeyPair$2.fromPublic(this, pub2, enc);
};
EC$3.prototype.genKeyPair = function genKeyPair2(options) {
  if (!options)
    options = {};
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || "utf8",
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || "utf8",
    nonce: this.n.toArray()
  });
  var bytes3 = this.n.byteLength();
  var ns2 = this.n.sub(new BN$a(2));
  for (; ; ) {
    var priv2 = new BN$a(drbg.generate(bytes3));
    if (priv2.cmp(ns2) > 0)
      continue;
    priv2.iaddn(1);
    return this.keyFromPrivate(priv2);
  }
};
EC$3.prototype._truncateToN = function _truncateToN2(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};
EC$3.prototype.sign = function sign5(msg, key2, enc, options) {
  if (typeof enc === "object") {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};
  key2 = this.keyFromPrivate(key2, enc);
  msg = this._truncateToN(new BN$a(msg, 16));
  var bytes3 = this.n.byteLength();
  var bkey = key2.getPrivate().toArray("be", bytes3);
  var nonce = msg.toArray("be", bytes3);
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce,
    pers: options.pers,
    persEnc: options.persEnc || "utf8"
  });
  var ns1 = this.n.sub(new BN$a(1));
  for (var iter = 0; ; iter++) {
    var k2 = options.k ? options.k(iter) : new BN$a(drbg.generate(this.n.byteLength()));
    k2 = this._truncateToN(k2, true);
    if (k2.cmpn(1) <= 0 || k2.cmp(ns1) >= 0)
      continue;
    var kp = this.g.mul(k2);
    if (kp.isInfinity())
      continue;
    var kpX = kp.getX();
    var r2 = kpX.umod(this.n);
    if (r2.cmpn(0) === 0)
      continue;
    var s2 = k2.invm(this.n).mul(r2.mul(key2.getPrivate()).iadd(msg));
    s2 = s2.umod(this.n);
    if (s2.cmpn(0) === 0)
      continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r2) !== 0 ? 2 : 0);
    if (options.canonical && s2.cmp(this.nh) > 0) {
      s2 = this.n.sub(s2);
      recoveryParam ^= 1;
    }
    return new Signature$2({ r: r2, s: s2, recoveryParam });
  }
};
EC$3.prototype.verify = function verify5(msg, signature2, key2, enc) {
  msg = this._truncateToN(new BN$a(msg, 16));
  key2 = this.keyFromPublic(key2, enc);
  signature2 = new Signature$2(signature2, "hex");
  var r2 = signature2.r;
  var s2 = signature2.s;
  if (r2.cmpn(1) < 0 || r2.cmp(this.n) >= 0)
    return false;
  if (s2.cmpn(1) < 0 || s2.cmp(this.n) >= 0)
    return false;
  var sinv = s2.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r2).umod(this.n);
  var p2;
  if (!this.curve._maxwellTrick) {
    p2 = this.g.mulAdd(u1, key2.getPublic(), u2);
    if (p2.isInfinity())
      return false;
    return p2.getX().umod(this.n).cmp(r2) === 0;
  }
  p2 = this.g.jmulAdd(u1, key2.getPublic(), u2);
  if (p2.isInfinity())
    return false;
  return p2.eqXToP(r2);
};
EC$3.prototype.recoverPubKey = function(msg, signature2, j2, enc) {
  assert$5((3 & j2) === j2, "The recovery param is more than two bits");
  signature2 = new Signature$2(signature2, enc);
  var n2 = this.n;
  var e2 = new BN$a(msg);
  var r2 = signature2.r;
  var s2 = signature2.s;
  var isYOdd = j2 & 1;
  var isSecondKey = j2 >> 1;
  if (r2.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error("Unable to find sencond key candinate");
  if (isSecondKey)
    r2 = this.curve.pointFromX(r2.add(this.curve.n), isYOdd);
  else
    r2 = this.curve.pointFromX(r2, isYOdd);
  var rInv = signature2.r.invm(n2);
  var s1 = n2.sub(e2).mul(rInv).umod(n2);
  var s22 = s2.mul(rInv).umod(n2);
  return this.g.mulAdd(s1, r2, s22);
};
EC$3.prototype.getKeyRecoveryParam = function(e2, signature2, Q2, enc) {
  signature2 = new Signature$2(signature2, enc);
  if (signature2.recoveryParam !== null)
    return signature2.recoveryParam;
  for (var i2 = 0; i2 < 4; i2++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e2, signature2, i2);
    } catch (e3) {
      continue;
    }
    if (Qprime.eq(Q2))
      return i2;
  }
  throw new Error("Unable to find valid recovery factor");
};
var utils$6 = utils$g;
var assert$4 = utils$6.assert;
var parseBytes$2 = utils$6.parseBytes;
var cachedProperty$1 = utils$6.cachedProperty;
function KeyPair$1(eddsa2, params) {
  this.eddsa = eddsa2;
  this._secret = parseBytes$2(params.secret);
  if (eddsa2.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes$2(params.pub);
}
KeyPair$1.fromPublic = function fromPublic3(eddsa2, pub2) {
  if (pub2 instanceof KeyPair$1)
    return pub2;
  return new KeyPair$1(eddsa2, { pub: pub2 });
};
KeyPair$1.fromSecret = function fromSecret(eddsa2, secret2) {
  if (secret2 instanceof KeyPair$1)
    return secret2;
  return new KeyPair$1(eddsa2, { secret: secret2 });
};
KeyPair$1.prototype.secret = function secret() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function privBytes() {
  var eddsa2 = this.eddsa;
  var hash3 = this.hash();
  var lastIx = eddsa2.encodingLength - 1;
  var a2 = hash3.slice(0, eddsa2.encodingLength);
  a2[0] &= 248;
  a2[lastIx] &= 127;
  a2[lastIx] |= 64;
  return a2;
});
cachedProperty$1(KeyPair$1, "priv", function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function hash2() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function messagePrefix2() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function sign6(message) {
  assert$4(this._secret, "KeyPair can only verify");
  return this.eddsa.sign(message, this);
};
KeyPair$1.prototype.verify = function verify6(message, sig) {
  return this.eddsa.verify(message, sig, this);
};
KeyPair$1.prototype.getSecret = function getSecret(enc) {
  assert$4(this._secret, "KeyPair is public only");
  return utils$6.encode(this.secret(), enc);
};
KeyPair$1.prototype.getPublic = function getPublic3(enc) {
  return utils$6.encode(this.pubBytes(), enc);
};
var key = KeyPair$1;
var BN$9 = bn$2.exports;
var utils$5 = utils$g;
var assert$3 = utils$5.assert;
var cachedProperty = utils$5.cachedProperty;
var parseBytes$1 = utils$5.parseBytes;
function Signature$1(eddsa2, sig) {
  this.eddsa = eddsa2;
  if (typeof sig !== "object")
    sig = parseBytes$1(sig);
  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa2.encodingLength),
      S: sig.slice(eddsa2.encodingLength)
    };
  }
  assert$3(sig.R && sig.S, "Signature without R or S");
  if (eddsa2.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN$9)
    this._S = sig.S;
  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}
cachedProperty(Signature$1, "S", function S2() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function R2() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function toHex2() {
  return utils$5.encode(this.toBytes(), "hex").toUpperCase();
};
var signature$1 = Signature$1;
var hash$2 = hash$4;
var curves = curves$2;
var utils$4 = utils$g;
var assert$2 = utils$4.assert;
var parseBytes = utils$4.parseBytes;
var KeyPair = key;
var Signature = signature$1;
function EDDSA(curve2) {
  assert$2(curve2 === "ed25519", "only tested with ed25519 so far");
  if (!(this instanceof EDDSA))
    return new EDDSA(curve2);
  curve2 = curves[curve2].curve;
  this.curve = curve2;
  this.g = curve2.g;
  this.g.precompute(curve2.n.bitLength() + 1);
  this.pointClass = curve2.point().constructor;
  this.encodingLength = Math.ceil(curve2.n.bitLength() / 8);
  this.hash = hash$2.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function sign7(message, secret2) {
  message = parseBytes(message);
  var key2 = this.keyFromSecret(secret2);
  var r2 = this.hashInt(key2.messagePrefix(), message);
  var R3 = this.g.mul(r2);
  var Rencoded2 = this.encodePoint(R3);
  var s_ = this.hashInt(Rencoded2, key2.pubBytes(), message).mul(key2.priv());
  var S3 = r2.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R3, S: S3, Rencoded: Rencoded2 });
};
EDDSA.prototype.verify = function verify7(message, sig, pub2) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key2 = this.keyFromPublic(pub2);
  var h2 = this.hashInt(sig.Rencoded(), key2.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key2.pub().mul(h2));
  return RplusAh.eq(SG);
};
EDDSA.prototype.hashInt = function hashInt() {
  var hash3 = this.hash();
  for (var i2 = 0; i2 < arguments.length; i2++)
    hash3.update(arguments[i2]);
  return utils$4.intFromLE(hash3.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function keyFromPublic3(pub2) {
  return KeyPair.fromPublic(this, pub2);
};
EDDSA.prototype.keyFromSecret = function keyFromSecret(secret2) {
  return KeyPair.fromSecret(this, secret2);
};
EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};
EDDSA.prototype.encodePoint = function encodePoint(point7) {
  var enc = point7.getY().toArray("le", this.encodingLength);
  enc[this.encodingLength - 1] |= point7.getX().isOdd() ? 128 : 0;
  return enc;
};
EDDSA.prototype.decodePoint = function decodePoint4(bytes3) {
  bytes3 = utils$4.parseBytes(bytes3);
  var lastIx = bytes3.length - 1;
  var normed = bytes3.slice(0, lastIx).concat(bytes3[lastIx] & ~128);
  var xIsOdd = (bytes3[lastIx] & 128) !== 0;
  var y2 = utils$4.intFromLE(normed);
  return this.curve.pointFromY(y2, xIsOdd);
};
EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function decodeInt(bytes3) {
  return utils$4.intFromLE(bytes3);
};
EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};
(function(exports2) {
  var elliptic2 = exports2;
  elliptic2.version = require$$0$2.version;
  elliptic2.utils = utils$g;
  elliptic2.rand = brorand.exports;
  elliptic2.curve = curve;
  elliptic2.curves = curves$2;
  elliptic2.ec = ec$3;
  elliptic2.eddsa = eddsa;
})(elliptic$2);
const EC$2 = elliptic$2.ec;
const ec$2 = new EC$2("secp256k1");
const ecparams$2 = ec$2.curve;
const BN$8 = ecparams$2.n.constructor;
function loadCompressedPublicKey(first2, xbuf) {
  let x2 = new BN$8(xbuf);
  if (x2.cmp(ecparams$2.p) >= 0)
    return null;
  x2 = x2.toRed(ecparams$2.red);
  let y2 = x2.redSqr().redIMul(x2).redIAdd(ecparams$2.b).redSqrt();
  if (first2 === 3 !== y2.isOdd())
    y2 = y2.redNeg();
  return ec$2.keyPair({ pub: { x: x2, y: y2 } });
}
function loadUncompressedPublicKey(first2, xbuf, ybuf) {
  let x2 = new BN$8(xbuf);
  let y2 = new BN$8(ybuf);
  if (x2.cmp(ecparams$2.p) >= 0 || y2.cmp(ecparams$2.p) >= 0)
    return null;
  x2 = x2.toRed(ecparams$2.red);
  y2 = y2.toRed(ecparams$2.red);
  if ((first2 === 6 || first2 === 7) && y2.isOdd() !== (first2 === 7))
    return null;
  const x3 = x2.redSqr().redIMul(x2);
  if (!y2.redSqr().redISub(x3.redIAdd(ecparams$2.b)).isZero())
    return null;
  return ec$2.keyPair({ pub: { x: x2, y: y2 } });
}
function loadPublicKey(pubkey) {
  const first2 = pubkey[0];
  switch (first2) {
    case 2:
    case 3:
      if (pubkey.length !== 33)
        return null;
      return loadCompressedPublicKey(first2, pubkey.subarray(1, 33));
    case 4:
    case 6:
    case 7:
      if (pubkey.length !== 65)
        return null;
      return loadUncompressedPublicKey(first2, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
    default:
      return null;
  }
}
function savePublicKey(output, point7) {
  const pubkey = point7.encode(null, output.length === 33);
  for (let i2 = 0; i2 < output.length; ++i2)
    output[i2] = pubkey[i2];
}
var elliptic$1 = {
  contextRandomize() {
    return 0;
  },
  privateKeyVerify(seckey) {
    const bn2 = new BN$8(seckey);
    return bn2.cmp(ecparams$2.n) < 0 && !bn2.isZero() ? 0 : 1;
  },
  privateKeyNegate(seckey) {
    const bn2 = new BN$8(seckey);
    const negate = ecparams$2.n.sub(bn2).umod(ecparams$2.n).toArrayLike(Uint8Array, "be", 32);
    seckey.set(negate);
    return 0;
  },
  privateKeyTweakAdd(seckey, tweak) {
    const bn2 = new BN$8(tweak);
    if (bn2.cmp(ecparams$2.n) >= 0)
      return 1;
    bn2.iadd(new BN$8(seckey));
    if (bn2.cmp(ecparams$2.n) >= 0)
      bn2.isub(ecparams$2.n);
    if (bn2.isZero())
      return 1;
    const tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
    seckey.set(tweaked);
    return 0;
  },
  privateKeyTweakMul(seckey, tweak) {
    let bn2 = new BN$8(tweak);
    if (bn2.cmp(ecparams$2.n) >= 0 || bn2.isZero())
      return 1;
    bn2.imul(new BN$8(seckey));
    if (bn2.cmp(ecparams$2.n) >= 0)
      bn2 = bn2.umod(ecparams$2.n);
    const tweaked = bn2.toArrayLike(Uint8Array, "be", 32);
    seckey.set(tweaked);
    return 0;
  },
  publicKeyVerify(pubkey) {
    const pair = loadPublicKey(pubkey);
    return pair === null ? 1 : 0;
  },
  publicKeyCreate(output, seckey) {
    const bn2 = new BN$8(seckey);
    if (bn2.cmp(ecparams$2.n) >= 0 || bn2.isZero())
      return 1;
    const point7 = ec$2.keyFromPrivate(seckey).getPublic();
    savePublicKey(output, point7);
    return 0;
  },
  publicKeyConvert(output, pubkey) {
    const pair = loadPublicKey(pubkey);
    if (pair === null)
      return 1;
    const point7 = pair.getPublic();
    savePublicKey(output, point7);
    return 0;
  },
  publicKeyNegate(output, pubkey) {
    const pair = loadPublicKey(pubkey);
    if (pair === null)
      return 1;
    const point7 = pair.getPublic();
    point7.y = point7.y.redNeg();
    savePublicKey(output, point7);
    return 0;
  },
  publicKeyCombine(output, pubkeys) {
    const pairs2 = new Array(pubkeys.length);
    for (let i2 = 0; i2 < pubkeys.length; ++i2) {
      pairs2[i2] = loadPublicKey(pubkeys[i2]);
      if (pairs2[i2] === null)
        return 1;
    }
    let point7 = pairs2[0].getPublic();
    for (let i2 = 1; i2 < pairs2.length; ++i2)
      point7 = point7.add(pairs2[i2].pub);
    if (point7.isInfinity())
      return 2;
    savePublicKey(output, point7);
    return 0;
  },
  publicKeyTweakAdd(output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey);
    if (pair === null)
      return 1;
    tweak = new BN$8(tweak);
    if (tweak.cmp(ecparams$2.n) >= 0)
      return 2;
    const point7 = pair.getPublic().add(ecparams$2.g.mul(tweak));
    if (point7.isInfinity())
      return 2;
    savePublicKey(output, point7);
    return 0;
  },
  publicKeyTweakMul(output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey);
    if (pair === null)
      return 1;
    tweak = new BN$8(tweak);
    if (tweak.cmp(ecparams$2.n) >= 0 || tweak.isZero())
      return 2;
    const point7 = pair.getPublic().mul(tweak);
    savePublicKey(output, point7);
    return 0;
  },
  signatureNormalize(sig) {
    const r2 = new BN$8(sig.subarray(0, 32));
    const s2 = new BN$8(sig.subarray(32, 64));
    if (r2.cmp(ecparams$2.n) >= 0 || s2.cmp(ecparams$2.n) >= 0)
      return 1;
    if (s2.cmp(ec$2.nh) === 1) {
      sig.set(ecparams$2.n.sub(s2).toArrayLike(Uint8Array, "be", 32), 32);
    }
    return 0;
  },
  signatureExport(obj, sig) {
    const sigR = sig.subarray(0, 32);
    const sigS = sig.subarray(32, 64);
    if (new BN$8(sigR).cmp(ecparams$2.n) >= 0)
      return 1;
    if (new BN$8(sigS).cmp(ecparams$2.n) >= 0)
      return 1;
    const { output } = obj;
    let r2 = output.subarray(4, 4 + 33);
    r2[0] = 0;
    r2.set(sigR, 1);
    let lenR = 33;
    let posR = 0;
    for (; lenR > 1 && r2[posR] === 0 && !(r2[posR + 1] & 128); --lenR, ++posR)
      ;
    r2 = r2.subarray(posR);
    if (r2[0] & 128)
      return 1;
    if (lenR > 1 && r2[0] === 0 && !(r2[1] & 128))
      return 1;
    let s2 = output.subarray(6 + 33, 6 + 33 + 33);
    s2[0] = 0;
    s2.set(sigS, 1);
    let lenS = 33;
    let posS = 0;
    for (; lenS > 1 && s2[posS] === 0 && !(s2[posS + 1] & 128); --lenS, ++posS)
      ;
    s2 = s2.subarray(posS);
    if (s2[0] & 128)
      return 1;
    if (lenS > 1 && s2[0] === 0 && !(s2[1] & 128))
      return 1;
    obj.outputlen = 6 + lenR + lenS;
    output[0] = 48;
    output[1] = obj.outputlen - 2;
    output[2] = 2;
    output[3] = r2.length;
    output.set(r2, 4);
    output[4 + lenR] = 2;
    output[5 + lenR] = s2.length;
    output.set(s2, 6 + lenR);
    return 0;
  },
  signatureImport(output, sig) {
    if (sig.length < 8)
      return 1;
    if (sig.length > 72)
      return 1;
    if (sig[0] !== 48)
      return 1;
    if (sig[1] !== sig.length - 2)
      return 1;
    if (sig[2] !== 2)
      return 1;
    const lenR = sig[3];
    if (lenR === 0)
      return 1;
    if (5 + lenR >= sig.length)
      return 1;
    if (sig[4 + lenR] !== 2)
      return 1;
    const lenS = sig[5 + lenR];
    if (lenS === 0)
      return 1;
    if (6 + lenR + lenS !== sig.length)
      return 1;
    if (sig[4] & 128)
      return 1;
    if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128))
      return 1;
    if (sig[lenR + 6] & 128)
      return 1;
    if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128))
      return 1;
    let sigR = sig.subarray(4, 4 + lenR);
    if (sigR.length === 33 && sigR[0] === 0)
      sigR = sigR.subarray(1);
    if (sigR.length > 32)
      return 1;
    let sigS = sig.subarray(6 + lenR);
    if (sigS.length === 33 && sigS[0] === 0)
      sigS = sigS.slice(1);
    if (sigS.length > 32)
      throw new Error("S length is too long");
    let r2 = new BN$8(sigR);
    if (r2.cmp(ecparams$2.n) >= 0)
      r2 = new BN$8(0);
    let s2 = new BN$8(sig.subarray(6 + lenR));
    if (s2.cmp(ecparams$2.n) >= 0)
      s2 = new BN$8(0);
    output.set(r2.toArrayLike(Uint8Array, "be", 32), 0);
    output.set(s2.toArrayLike(Uint8Array, "be", 32), 32);
    return 0;
  },
  ecdsaSign(obj, message, seckey, data, noncefn) {
    if (noncefn) {
      const _noncefn = noncefn;
      noncefn = (counter) => {
        const nonce = _noncefn(message, seckey, null, data, counter);
        const isValid2 = nonce instanceof Uint8Array && nonce.length === 32;
        if (!isValid2)
          throw new Error("This is the way");
        return new BN$8(nonce);
      };
    }
    const d2 = new BN$8(seckey);
    if (d2.cmp(ecparams$2.n) >= 0 || d2.isZero())
      return 1;
    let sig;
    try {
      sig = ec$2.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
    } catch (err) {
      return 1;
    }
    obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
    obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
    obj.recid = sig.recoveryParam;
    return 0;
  },
  ecdsaVerify(sig, msg32, pubkey) {
    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
    const sigr = new BN$8(sigObj.r);
    const sigs = new BN$8(sigObj.s);
    if (sigr.cmp(ecparams$2.n) >= 0 || sigs.cmp(ecparams$2.n) >= 0)
      return 1;
    if (sigs.cmp(ec$2.nh) === 1 || sigr.isZero() || sigs.isZero())
      return 3;
    const pair = loadPublicKey(pubkey);
    if (pair === null)
      return 2;
    const point7 = pair.getPublic();
    const isValid2 = ec$2.verify(msg32, sigObj, point7);
    return isValid2 ? 0 : 3;
  },
  ecdsaRecover(output, sig, recid, msg32) {
    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
    const sigr = new BN$8(sigObj.r);
    const sigs = new BN$8(sigObj.s);
    if (sigr.cmp(ecparams$2.n) >= 0 || sigs.cmp(ecparams$2.n) >= 0)
      return 1;
    if (sigr.isZero() || sigs.isZero())
      return 2;
    let point7;
    try {
      point7 = ec$2.recoverPubKey(msg32, sigObj, recid);
    } catch (err) {
      return 2;
    }
    savePublicKey(output, point7);
    return 0;
  },
  ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
    const pair = loadPublicKey(pubkey);
    if (pair === null)
      return 1;
    const scalar = new BN$8(seckey);
    if (scalar.cmp(ecparams$2.n) >= 0 || scalar.isZero())
      return 2;
    const point7 = pair.getPublic().mul(scalar);
    if (hashfn === void 0) {
      const data2 = point7.encode(null, true);
      const sha2562 = ec$2.hash().update(data2).digest();
      for (let i2 = 0; i2 < 32; ++i2)
        output[i2] = sha2562[i2];
    } else {
      if (!xbuf)
        xbuf = new Uint8Array(32);
      const x2 = point7.getX().toArray("be", 32);
      for (let i2 = 0; i2 < 32; ++i2)
        xbuf[i2] = x2[i2];
      if (!ybuf)
        ybuf = new Uint8Array(32);
      const y2 = point7.getY().toArray("be", 32);
      for (let i2 = 0; i2 < 32; ++i2)
        ybuf[i2] = y2[i2];
      const hash3 = hashfn(xbuf, ybuf, data);
      const isValid2 = hash3 instanceof Uint8Array && hash3.length === output.length;
      if (!isValid2)
        return 2;
      output.set(hash3);
    }
    return 0;
  }
};
var elliptic = lib$3(elliptic$1);
var random = {};
var browser$4 = { exports: {} };
var MAX_BYTES = 65536;
var MAX_UINT32 = 4294967295;
function oldBrowser() {
  throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
}
var Buffer$d = safeBuffer.exports.Buffer;
var crypto$2 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
if (crypto$2 && crypto$2.getRandomValues) {
  browser$4.exports = randomBytes$1;
} else {
  browser$4.exports = oldBrowser;
}
function randomBytes$1(size2, cb) {
  if (size2 > MAX_UINT32)
    throw new RangeError("requested too many random bytes");
  var bytes3 = Buffer$d.allocUnsafe(size2);
  if (size2 > 0) {
    if (size2 > MAX_BYTES) {
      for (var generated = 0; generated < size2; generated += MAX_BYTES) {
        crypto$2.getRandomValues(bytes3.slice(generated, generated + MAX_BYTES));
      }
    } else {
      crypto$2.getRandomValues(bytes3);
    }
  }
  if (typeof cb === "function") {
    return process.nextTick(function() {
      cb(null, bytes3);
    });
  }
  return bytes3;
}
Object.defineProperty(random, "__esModule", { value: true });
var randombytes = browser$4.exports;
function getRandomBytes(bytes3) {
  return new Promise(function(resolve2, reject) {
    randombytes(bytes3, function(err, resp) {
      if (err) {
        reject(err);
        return;
      }
      resolve2(resp);
    });
  });
}
random.getRandomBytes = getRandomBytes;
function getRandomBytesSync(bytes3) {
  return randombytes(bytes3);
}
random.getRandomBytesSync = getRandomBytesSync;
(function(exports2) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
    function adopt(value2) {
      return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
        resolve2(value2);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve2, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y2, t2, g2;
    return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n2) {
      return function(v2) {
        return step([n2, v2]);
      };
    }
    function step(op) {
      if (f2)
        throw new TypeError("Generator is already executing.");
      while (_2)
        try {
          if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
            return t2;
          if (y2 = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y2 = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e2) {
          op = [6, e2];
          y2 = 0;
        } finally {
          f2 = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  };
  function __export(m2) {
    for (var p2 in m2)
      if (!exports2.hasOwnProperty(p2))
        exports2[p2] = m2[p2];
  }
  Object.defineProperty(exports2, "__esModule", { value: true });
  var secp256k1_1 = elliptic;
  var random_1 = random;
  var SECP256K1_PRIVATE_KEY_SIZE = 32;
  function createPrivateKey() {
    return __awaiter2(this, void 0, void 0, function() {
      var pk;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
          case 1:
            pk = _a2.sent();
            if (secp256k1_1.privateKeyVerify(pk)) {
              return [2, pk];
            }
            return [3, 0];
          case 2:
            return [2];
        }
      });
    });
  }
  exports2.createPrivateKey = createPrivateKey;
  function createPrivateKeySync() {
    while (true) {
      var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
      if (secp256k1_1.privateKeyVerify(pk)) {
        return pk;
      }
    }
  }
  exports2.createPrivateKeySync = createPrivateKeySync;
  __export(elliptic);
})(secp256k1$2);
var secp256k1Lib = {};
var BN$7 = bn$2.exports;
var EC$1 = elliptic$2.ec;
var ec$1 = new EC$1("secp256k1");
var ecparams$1 = ec$1.curve;
secp256k1Lib.privateKeyExport = function(privateKey, compressed) {
  var d2 = new BN$7(privateKey);
  if (d2.ucmp(ecparams$1.n) >= 0) {
    throw new Error("couldn't export to DER format");
  }
  var point7 = ec$1.g.mul(d2);
  return toPublicKey$1(point7.getX(), point7.getY(), compressed);
};
secp256k1Lib.privateKeyModInverse = function(privateKey) {
  var bn2 = new BN$7(privateKey);
  if (bn2.ucmp(ecparams$1.n) >= 0 || bn2.isZero()) {
    throw new Error("private key range is invalid");
  }
  return bn2.invm(ecparams$1.n).toArrayLike(buffer$2.Buffer, "be", 32);
};
secp256k1Lib.signatureImport = function(sigObj) {
  var r2 = new BN$7(sigObj.r);
  if (r2.ucmp(ecparams$1.n) >= 0) {
    r2 = new BN$7(0);
  }
  var s2 = new BN$7(sigObj.s);
  if (s2.ucmp(ecparams$1.n) >= 0) {
    s2 = new BN$7(0);
  }
  return buffer$2.Buffer.concat([r2.toArrayLike(buffer$2.Buffer, "be", 32), s2.toArrayLike(buffer$2.Buffer, "be", 32)]);
};
secp256k1Lib.ecdhUnsafe = function(publicKey, privateKey, compressed) {
  var point7 = ec$1.keyFromPublic(publicKey);
  var scalar = new BN$7(privateKey);
  if (scalar.ucmp(ecparams$1.n) >= 0 || scalar.isZero()) {
    throw new Error("scalar was invalid (zero or overflow)");
  }
  var shared = point7.pub.mul(scalar);
  return toPublicKey$1(shared.getX(), shared.getY(), compressed);
};
var toPublicKey$1 = function toPublicKey2(x2, y2, compressed) {
  var publicKey = void 0;
  if (compressed) {
    publicKey = buffer$2.Buffer.alloc(33);
    publicKey[0] = y2.isOdd() ? 3 : 2;
    x2.toArrayLike(buffer$2.Buffer, "be", 32).copy(publicKey, 1);
  } else {
    publicKey = buffer$2.Buffer.alloc(65);
    publicKey[0] = 4;
    x2.toArrayLike(buffer$2.Buffer, "be", 32).copy(publicKey, 1);
    y2.toArrayLike(buffer$2.Buffer, "be", 32).copy(publicKey, 33);
  }
  return publicKey;
};
var der$2 = {};
var EC_PRIVKEY_EXPORT_DER_COMPRESSED$1 = buffer$2.Buffer.from([
  48,
  129,
  211,
  2,
  1,
  1,
  4,
  32,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  160,
  129,
  133,
  48,
  129,
  130,
  2,
  1,
  1,
  48,
  44,
  6,
  7,
  42,
  134,
  72,
  206,
  61,
  1,
  1,
  2,
  33,
  0,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  255,
  255,
  252,
  47,
  48,
  6,
  4,
  1,
  0,
  4,
  1,
  7,
  4,
  33,
  2,
  121,
  190,
  102,
  126,
  249,
  220,
  187,
  172,
  85,
  160,
  98,
  149,
  206,
  135,
  11,
  7,
  2,
  155,
  252,
  219,
  45,
  206,
  40,
  217,
  89,
  242,
  129,
  91,
  22,
  248,
  23,
  152,
  2,
  33,
  0,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  186,
  174,
  220,
  230,
  175,
  72,
  160,
  59,
  191,
  210,
  94,
  140,
  208,
  54,
  65,
  65,
  2,
  1,
  1,
  161,
  36,
  3,
  34,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED$1 = buffer$2.Buffer.from([
  48,
  130,
  1,
  19,
  2,
  1,
  1,
  4,
  32,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  160,
  129,
  165,
  48,
  129,
  162,
  2,
  1,
  1,
  48,
  44,
  6,
  7,
  42,
  134,
  72,
  206,
  61,
  1,
  1,
  2,
  33,
  0,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  255,
  255,
  252,
  47,
  48,
  6,
  4,
  1,
  0,
  4,
  1,
  7,
  4,
  65,
  4,
  121,
  190,
  102,
  126,
  249,
  220,
  187,
  172,
  85,
  160,
  98,
  149,
  206,
  135,
  11,
  7,
  2,
  155,
  252,
  219,
  45,
  206,
  40,
  217,
  89,
  242,
  129,
  91,
  22,
  248,
  23,
  152,
  72,
  58,
  218,
  119,
  38,
  163,
  196,
  101,
  93,
  164,
  251,
  252,
  14,
  17,
  8,
  168,
  253,
  23,
  180,
  72,
  166,
  133,
  84,
  25,
  156,
  71,
  208,
  143,
  251,
  16,
  212,
  184,
  2,
  33,
  0,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  186,
  174,
  220,
  230,
  175,
  72,
  160,
  59,
  191,
  210,
  94,
  140,
  208,
  54,
  65,
  65,
  2,
  1,
  1,
  161,
  68,
  3,
  66,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
der$2.privateKeyExport = function(privateKey, publicKey, compressed) {
  var result = buffer$2.Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED$1 : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED$1);
  privateKey.copy(result, compressed ? 8 : 9);
  publicKey.copy(result, compressed ? 181 : 214);
  return result;
};
der$2.privateKeyImport = function(privateKey) {
  var length = privateKey.length;
  var index2 = 0;
  if (length < index2 + 1 || privateKey[index2] !== 48)
    return null;
  index2 += 1;
  if (length < index2 + 1 || !(privateKey[index2] & 128))
    return null;
  var lenb = privateKey[index2] & 127;
  index2 += 1;
  if (lenb < 1 || lenb > 2)
    return null;
  if (length < index2 + lenb)
    return null;
  var len2 = privateKey[index2 + lenb - 1] | (lenb > 1 ? privateKey[index2 + lenb - 2] << 8 : 0);
  index2 += lenb;
  if (length < index2 + len2)
    return null;
  if (length < index2 + 3 || privateKey[index2] !== 2 || privateKey[index2 + 1] !== 1 || privateKey[index2 + 2] !== 1) {
    return null;
  }
  index2 += 3;
  if (length < index2 + 2 || privateKey[index2] !== 4 || privateKey[index2 + 1] > 32 || length < index2 + 2 + privateKey[index2 + 1]) {
    return null;
  }
  return privateKey.slice(index2 + 2, index2 + 2 + privateKey[index2 + 1]);
};
der$2.signatureImportLax = function(signature2) {
  var r2 = buffer$2.Buffer.alloc(32, 0);
  var s2 = buffer$2.Buffer.alloc(32, 0);
  var length = signature2.length;
  var index2 = 0;
  if (signature2[index2++] !== 48) {
    return null;
  }
  var lenbyte = signature2[index2++];
  if (lenbyte & 128) {
    index2 += lenbyte - 128;
    if (index2 > length) {
      return null;
    }
  }
  if (signature2[index2++] !== 2) {
    return null;
  }
  var rlen = signature2[index2++];
  if (rlen & 128) {
    lenbyte = rlen - 128;
    if (index2 + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature2[index2] === 0; index2 += 1, lenbyte -= 1) {
    }
    for (rlen = 0; lenbyte > 0; index2 += 1, lenbyte -= 1) {
      rlen = (rlen << 8) + signature2[index2];
    }
  }
  if (rlen > length - index2) {
    return null;
  }
  var rindex = index2;
  index2 += rlen;
  if (signature2[index2++] !== 2) {
    return null;
  }
  var slen = signature2[index2++];
  if (slen & 128) {
    lenbyte = slen - 128;
    if (index2 + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature2[index2] === 0; index2 += 1, lenbyte -= 1) {
    }
    for (slen = 0; lenbyte > 0; index2 += 1, lenbyte -= 1) {
      slen = (slen << 8) + signature2[index2];
    }
  }
  if (slen > length - index2) {
    return null;
  }
  var sindex = index2;
  index2 += slen;
  for (; rlen > 0 && signature2[rindex] === 0; rlen -= 1, rindex += 1) {
  }
  if (rlen > 32) {
    return null;
  }
  var rvalue = signature2.slice(rindex, rindex + rlen);
  rvalue.copy(r2, 32 - rvalue.length);
  for (; slen > 0 && signature2[sindex] === 0; slen -= 1, sindex += 1) {
  }
  if (slen > 32) {
    return null;
  }
  var svalue = signature2.slice(sindex, sindex + slen);
  svalue.copy(s2, 32 - svalue.length);
  return { r: r2, s: s2 };
};
var secp256k1$1 = secp256k1$2;
var secp256k1v3 = secp256k1Lib;
var der$1 = der$2;
var privateKeyVerify = function privateKeyVerify2(privateKey) {
  if (privateKey.length !== 32) {
    return false;
  }
  return secp256k1$1.privateKeyVerify(Uint8Array.from(privateKey));
};
var privateKeyExport = function privateKeyExport2(privateKey, compressed) {
  if (privateKey.length !== 32) {
    throw new RangeError("private key length is invalid");
  }
  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);
  return der$1.privateKeyExport(privateKey, publicKey, compressed);
};
var privateKeyImport = function privateKeyImport2(privateKey) {
  privateKey = der$1.privateKeyImport(privateKey);
  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
    return privateKey;
  }
  throw new Error("couldn't import from DER format");
};
var privateKeyNegate = function privateKeyNegate2(privateKey) {
  return buffer$2.Buffer.from(secp256k1$1.privateKeyNegate(Uint8Array.from(privateKey)));
};
var privateKeyModInverse = function privateKeyModInverse2(privateKey) {
  if (privateKey.length !== 32) {
    throw new Error("private key length is invalid");
  }
  return buffer$2.Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};
var privateKeyTweakAdd = function privateKeyTweakAdd2(privateKey, tweak) {
  return buffer$2.Buffer.from(secp256k1$1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};
var privateKeyTweakMul = function privateKeyTweakMul2(privateKey, tweak) {
  return buffer$2.Buffer.from(secp256k1$1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};
var publicKeyCreate = function publicKeyCreate2(privateKey, compressed) {
  return buffer$2.Buffer.from(secp256k1$1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};
var publicKeyConvert = function publicKeyConvert2(publicKey, compressed) {
  return buffer$2.Buffer.from(secp256k1$1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};
var publicKeyVerify = function publicKeyVerify2(publicKey) {
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    return false;
  }
  return secp256k1$1.publicKeyVerify(Uint8Array.from(publicKey));
};
var publicKeyTweakAdd = function publicKeyTweakAdd2(publicKey, tweak, compressed) {
  return buffer$2.Buffer.from(secp256k1$1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
var publicKeyTweakMul = function publicKeyTweakMul2(publicKey, tweak, compressed) {
  return buffer$2.Buffer.from(secp256k1$1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};
var publicKeyCombine = function publicKeyCombine2(publicKeys, compressed) {
  var keys2 = [];
  publicKeys.forEach(function(publicKey) {
    keys2.push(Uint8Array.from(publicKey));
  });
  return buffer$2.Buffer.from(secp256k1$1.publicKeyCombine(keys2, compressed));
};
var signatureNormalize = function signatureNormalize2(signature2) {
  return buffer$2.Buffer.from(secp256k1$1.signatureNormalize(Uint8Array.from(signature2)));
};
var signatureExport = function signatureExport2(signature2) {
  return buffer$2.Buffer.from(secp256k1$1.signatureExport(Uint8Array.from(signature2)));
};
var signatureImport = function signatureImport2(signature2) {
  return buffer$2.Buffer.from(secp256k1$1.signatureImport(Uint8Array.from(signature2)));
};
var signatureImportLax = function signatureImportLax2(signature2) {
  if (signature2.length === 0) {
    throw new RangeError("signature length is invalid");
  }
  var sigObj = der$1.signatureImportLax(signature2);
  if (sigObj === null) {
    throw new Error("couldn't parse DER signature");
  }
  return secp256k1v3.signatureImport(sigObj);
};
var sign = function sign8(message, privateKey, options) {
  if (options === null) {
    throw new TypeError("options should be an Object");
  }
  var signOptions = void 0;
  if (options) {
    signOptions = {};
    if (options.data === null) {
      throw new TypeError("options.data should be a Buffer");
    }
    if (options.data) {
      if (options.data.length !== 32) {
        throw new RangeError("options.data length is invalid");
      }
      signOptions.data = new Uint8Array(options.data);
    }
    if (options.noncefn === null) {
      throw new TypeError("options.noncefn should be a Function");
    }
    if (options.noncefn) {
      signOptions.noncefn = function(message2, privateKey2, algo, data, attempt) {
        var bufferAlgo = algo != null ? buffer$2.Buffer.from(algo) : null;
        var bufferData = data != null ? buffer$2.Buffer.from(data) : null;
        var buffer2 = buffer$2.Buffer.from("");
        if (options.noncefn) {
          buffer2 = options.noncefn(buffer$2.Buffer.from(message2), buffer$2.Buffer.from(privateKey2), bufferAlgo, bufferData, attempt);
        }
        return Uint8Array.from(buffer2);
      };
    }
  }
  var sig = secp256k1$1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
  return {
    signature: buffer$2.Buffer.from(sig.signature),
    recovery: sig.recid
  };
};
var verify = function verify8(message, signature2, publicKey) {
  return secp256k1$1.ecdsaVerify(Uint8Array.from(signature2), Uint8Array.from(message), publicKey);
};
var recover = function recover2(message, signature2, recid, compressed) {
  return buffer$2.Buffer.from(secp256k1$1.ecdsaRecover(Uint8Array.from(signature2), recid, Uint8Array.from(message), compressed));
};
var ecdh = function ecdh2(publicKey, privateKey) {
  return buffer$2.Buffer.from(secp256k1$1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};
var ecdhUnsafe = function ecdhUnsafe2(publicKey, privateKey, compressed) {
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    throw new RangeError("public key length is invalid");
  }
  if (privateKey.length !== 32) {
    throw new RangeError("private key length is invalid");
  }
  return buffer$2.Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};
var secp256k1Adapter = {
  privateKeyVerify,
  privateKeyExport,
  privateKeyImport,
  privateKeyNegate,
  privateKeyModInverse,
  privateKeyTweakAdd,
  privateKeyTweakMul,
  publicKeyCreate,
  publicKeyConvert,
  publicKeyVerify,
  publicKeyTweakAdd,
  publicKeyTweakMul,
  publicKeyCombine,
  signatureNormalize,
  signatureExport,
  signatureImport,
  signatureImportLax,
  sign,
  verify,
  recover,
  ecdh,
  ecdhUnsafe
};
var dist_browser = {};
var bn$1 = { exports: {} };
(function(module2) {
  (function(module3, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base2, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number2 || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module3 === "object") {
      module3.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer2 = window.Buffer;
      } else {
        Buffer2 = require("buffer").Buffer;
      }
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max2(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min2(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init5(number2, base2, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base2, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
        this.negative = 1;
      }
      if (start < number2.length) {
        if (base2 === 16) {
          this._parseHex(number2, start, endian);
        } else {
          this._parseBase(number2, base2, start);
          if (endian === "le") {
            this._initArray(this.toArray(), base2, endian);
          }
        }
      }
    };
    BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base2, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j2, w2;
      var off = 0;
      if (endian === "be") {
        for (i2 = number2.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
          w2 = number2[i2] | number2[i2 - 1] << 8 | number2[i2 - 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i2 = 0, j2 = 0; i2 < number2.length; i2 += 3) {
          w2 = number2[i2] | number2[i2 + 1] << 8 | number2[i2 + 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      }
      return this._strip();
    };
    function parseHex4Bits(string2, index2) {
      var c2 = string2.charCodeAt(index2);
      if (c2 >= 48 && c2 <= 57) {
        return c2 - 48;
      } else if (c2 >= 65 && c2 <= 70) {
        return c2 - 55;
      } else if (c2 >= 97 && c2 <= 102) {
        return c2 - 87;
      } else {
        assert2(false, "Invalid character in " + string2);
      }
    }
    function parseHexByte(string2, lowerBound, index2) {
      var r2 = parseHex4Bits(string2, index2);
      if (index2 - 1 >= lowerBound) {
        r2 |= parseHex4Bits(string2, index2 - 1) << 4;
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start, endian) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var off = 0;
      var j2 = 0;
      var w2;
      if (endian === "be") {
        for (i2 = number2.length - 1; i2 >= start; i2 -= 2) {
          w2 = parseHexByte(number2, start, i2) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number2.length - start;
        for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number2.length; i2 += 2) {
          w2 = parseHexByte(number2, start, i2) << off;
          this.words[j2] |= w2 & 67108863;
          if (off >= 18) {
            off -= 18;
            j2 += 1;
            this.words[j2] |= w2 >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this._strip();
    };
    function parseBase(str2, start, end, mul8) {
      var r2 = 0;
      var b2 = 0;
      var len2 = Math.min(str2.length, end);
      for (var i2 = start; i2 < len2; i2++) {
        var c2 = str2.charCodeAt(i2) - 48;
        r2 *= mul8;
        if (c2 >= 49) {
          b2 = c2 - 49 + 10;
        } else if (c2 >= 17) {
          b2 = c2 - 17 + 10;
        } else {
          b2 = c2;
        }
        assert2(c2 >= 0 && b2 < mul8, "Invalid character");
        r2 += b2;
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number2.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word2 = 0;
      for (var i2 = start; i2 < end; i2 += limbLen) {
        word2 = parseBase(number2, i2, i2 + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word2 < 67108864) {
          this.words[0] += word2;
        } else {
          this._iaddn(word2);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word2 = parseBase(number2, i2, number2.length, base2);
        for (i2 = 0; i2 < mod; i2++) {
          pow *= base2;
        }
        this.imuln(pow);
        if (this.words[0] + word2 < 67108864) {
          this.words[0] += word2;
        } else {
          this._iaddn(word2);
        }
      }
      this._strip();
    };
    BN2.prototype.copy = function copy3(dest) {
      dest.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        dest.words[i2] = this.words[i2];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    function move(dest, src2) {
      dest.words = src2.words;
      dest.length = src2.length;
      dest.negative = src2.negative;
      dest.red = src2.red;
    }
    BN2.prototype._move = function _move(dest) {
      move(dest, this);
    };
    BN2.prototype.clone = function clone() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size2) {
      while (this.length < size2) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype._strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
      try {
        BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect10;
      } catch (e2) {
        BN2.prototype.inspect = inspect10;
      }
    } else {
      BN2.prototype.inspect = inspect10;
    }
    function inspect10() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base2, padding2) {
      base2 = base2 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = this.words[i2];
          var word2 = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          if (carry !== 0 || i2 !== this.length - 1) {
            out = zeros2[6 - word2.length] + word2 + out;
          } else {
            out = word2 + out;
          }
          off += 2;
          if (off >= 26) {
            off -= 26;
            i2--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modrn(groupBase).toString(base2);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber2() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON3() {
      return this.toString(16, 2);
    };
    if (Buffer2) {
      BN2.prototype.toBuffer = function toBuffer2(endian, length) {
        return this.toArrayLike(Buffer2, endian, length);
      };
    }
    BN2.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate2(ArrayType, size2) {
      if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size2);
      }
      return new ArrayType(size2);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      this._strip();
      var byteLength2 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      var res = allocate(ArrayType, reqLength);
      var postfix = endian === "le" ? "LE" : "BE";
      this["_toArrayLike" + postfix](res, byteLength2);
      return res;
    };
    BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
      var position = 0;
      var carry = 0;
      for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
        var word2 = this.words[i2] << shift | carry;
        res[position++] = word2 & 255;
        if (position < res.length) {
          res[position++] = word2 >> 8 & 255;
        }
        if (position < res.length) {
          res[position++] = word2 >> 16 & 255;
        }
        if (shift === 6) {
          if (position < res.length) {
            res[position++] = word2 >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word2 >>> 24;
          shift += 2;
        }
      }
      if (position < res.length) {
        res[position++] = carry;
        while (position < res.length) {
          res[position++] = 0;
        }
      }
    };
    BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
      var position = res.length - 1;
      var carry = 0;
      for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
        var word2 = this.words[i2] << shift | carry;
        res[position--] = word2 & 255;
        if (position >= 0) {
          res[position--] = word2 >> 8 & 255;
        }
        if (position >= 0) {
          res[position--] = word2 >> 16 & 255;
        }
        if (shift === 6) {
          if (position >= 0) {
            res[position--] = word2 >> 24 & 255;
          }
          carry = 0;
          shift = 0;
        } else {
          carry = word2 >>> 24;
          shift += 2;
        }
      }
      if (position >= 0) {
        res[position--] = carry;
        while (position >= 0) {
          res[position--] = 0;
        }
      }
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi = this._countBits(w2);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = num.words[off] >>> wbit & 1;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var b2 = this._zeroBits(this.words[i2]);
        r2 += b2;
        if (b2 !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg6() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i2 = 0; i2 < num.length; i2++) {
        this.words[i2] = this.words[i2] | num.words[i2];
      }
      return this._strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = this.words[i2] & num.words[i2];
      }
      this.length = b2.length;
      return this._strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = a2.words[i2] ^ b2.words[i2];
      }
      if (this !== a2) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = a2.length;
      return this._strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i2 = 0; i2 < bytesNeeded; i2++) {
        this.words[i2] = ~this.words[i2] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
      }
      return this._strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this._strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      return this;
    };
    BN2.prototype.add = function add8(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b2;
      if (cmp > 0) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      if (carry === 0 && i2 < a2.length && a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = Math.max(this.length, i2);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this._strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len2 = self2.length + num.length | 0;
      out.length = len2;
      len2 = len2 - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r2 = a2 * b2;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k2 = 1; k2 < len2; k2++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k2 - j2 | 0;
          a2 = self2.words[i2] | 0;
          b2 = num.words[j2] | 0;
          r2 = a2 * b2 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k2] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k2] = carry | 0;
      } else {
        out.length--;
      }
      return out._strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b2 = num.words;
      var o2 = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o2[0] = w0;
      o2[1] = w1;
      o2[2] = w2;
      o2[3] = w3;
      o2[4] = w4;
      o2[5] = w5;
      o2[6] = w6;
      o2[7] = w7;
      o2[8] = w8;
      o2[9] = w9;
      o2[10] = w10;
      o2[11] = w11;
      o2[12] = w12;
      o2[13] = w13;
      o2[14] = w14;
      o2[15] = w15;
      o2[16] = w16;
      o2[17] = w17;
      o2[18] = w18;
      if (c2 !== 0) {
        o2[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k2 = 0; k2 < out.length - 1; k2++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k2 - j2;
          var a2 = self2.words[i2] | 0;
          var b2 = num.words[j2] | 0;
          var r2 = a2 * b2;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k2] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k2] = carry;
      } else {
        out.length--;
      }
      return out._strip();
    }
    function jumboMulTo(self2, num, out) {
      return bigMulTo(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len2 = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len2 < 63) {
        res = smallMulTo(this, num, out);
      } else if (len2 < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    BN2.prototype.mul = function mul8(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var w2 = (this.words[i2] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i2] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
        if (w2[i2] !== 0)
          break;
      }
      if (++i2 < w2.length) {
        for (var q2 = res.sqr(); i2 < w2.length; i2++, q2 = q2.sqr()) {
          if (w2[i2] === 0)
            continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i2;
      if (r2 !== 0) {
        var carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          var newCarry = this.words[i2] & carryMask;
          var c2 = (this.words[i2] | 0) - newCarry << r2;
          this.words[i2] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i2] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i2 = this.length - 1; i2 >= 0; i2--) {
          this.words[i2 + s2] = this.words[i2];
        }
        for (i2 = 0; i2 < s2; i2++) {
          this.words[i2] = 0;
        }
        this.length += s2;
      }
      return this._strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i2 = 0; i2 < s2; i2++) {
          maskedWords.words[i2] = this.words[i2];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = this.words[i2 + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
        var word2 = this.words[i2] | 0;
        this.words[i2] = carry << 26 - r2 | word2 >>> r2;
        carry = word2 & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this._strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2)
        return false;
      var w2 = this.words[s2];
      return !!(w2 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this._strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
        this.words[i2] -= 67108864;
        if (i2 === this.length - 1) {
          this.words[i2 + 1] = 1;
        } else {
          this.words[i2 + 1]++;
        }
      }
      this.length = Math.max(this.length, i2 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
          this.words[i2] += 67108864;
          this.words[i2 + 1] -= 1;
        }
      }
      return this._strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul8, shift) {
      var len2 = num.length + shift;
      var i2;
      this._expand(len2);
      var w2;
      var carry = 0;
      for (i2 = 0; i2 < num.length; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        var right = (num.words[i2] | 0) * mul8;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i2 + shift] = w2 & 67108863;
      }
      for (; i2 < this.length - shift; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2 + shift] = w2 & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert2(carry === -1);
      carry = 0;
      for (i2 = 0; i2 < this.length; i2++) {
        w2 = -(this.words[i2] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2] = w2 & 67108863;
      }
      this.negative = 1;
      return this._strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
      var shift = this.length - num.length;
      var a2 = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a2.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m2 = a2.length - b2.length;
      var q2;
      if (mode2 !== "mod") {
        q2 = new BN2(null);
        q2.length = m2 + 1;
        q2.words = new Array(q2.length);
        for (var i2 = 0; i2 < q2.length; i2++) {
          q2.words[i2] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
      if (diff.negative === 0) {
        a2 = diff;
        if (q2) {
          q2.words[m2] = 1;
        }
      }
      for (var j2 = m2 - 1; j2 >= 0; j2--) {
        var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a2._ishlnsubmul(b2, qj, j2);
        while (a2.negative !== 0) {
          qj--;
          a2.negative = 0;
          a2._ishlnsubmul(b2, 1, j2);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j2] = qj;
        }
      }
      if (q2) {
        q2._strip();
      }
      a2._strip();
      if (mode2 !== "div" && shift !== 0) {
        a2.iushrn(shift);
      }
      return {
        div: q2 || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode2, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode2);
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode2 === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode2 === "mod") {
          return {
            div: null,
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modrn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode2);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modrn = function modrn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        acc = (p2 * acc + (this.words[i2] | 0)) % num;
      }
      return isNegNum ? -acc : acc;
    };
    BN2.prototype.modn = function modn(num) {
      return this.modrn(num);
    };
    BN2.prototype.idivn = function idivn(num) {
      var isNegNum = num < 0;
      if (isNegNum)
        num = -num;
      assert2(num <= 67108863);
      var carry = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var w2 = (this.words[i2] | 0) + carry * 67108864;
        this.words[i2] = w2 / num | 0;
        carry = w2 % num;
      }
      this._strip();
      return isNegNum ? this.ineg() : this;
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y2 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B2 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g2 = 0;
      while (x2.isEven() && y2.isEven()) {
        x2.iushrn(1);
        y2.iushrn(1);
        ++g2;
      }
      var yp = y2.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          x2.iushrn(i2);
          while (i2-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          y2.iushrn(j2);
          while (j2-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x2.cmp(y2) >= 0) {
          x2.isub(y2);
          A2.isub(C2);
          B2.isub(D2);
        } else {
          y2.isub(x2);
          C2.isub(A2);
          D2.isub(B2);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y2.iushln(g2)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b2 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          a2.iushrn(i2);
          while (i2-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          b2.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b2) >= 0) {
          a2.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a2 = this.clone();
      var b2 = num.clone();
      a2.negative = 0;
      b2.negative = 0;
      for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
        a2.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r2 = a2.cmp(b2);
        if (r2 < 0) {
          var t2 = a2;
          a2 = b2;
          b2 = t2;
        } else if (r2 === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a2.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q2;
        return this;
      }
      var carry = q2;
      for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
        var w2 = this.words[i2] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i2] = w2;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this._strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var a2 = this.words[i2] | 0;
        var b2 = num.words[i2] | 0;
        if (a2 === b2)
          continue;
        if (a2 < b2) {
          res = -1;
        } else if (a2 > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq9(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p2) {
      this.name = name2;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        if (r2.strip !== void 0) {
          r2.strip();
        } else {
          r2._strip();
        }
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i2 = 0; i2 < outLen; i2++) {
        output.words[i2] = input.words[i2];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i2 = 10; i2 < input.length; i2++) {
        var next3 = input.words[i2] | 0;
        input.words[i2 - 10] = (next3 & mask) << 4 | prev >>> 22;
        prev = next3;
      }
      prev >>>= 22;
      input.words[i2 - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var w2 = num.words[i2] | 0;
        lo += w2 * 977;
        num.words[i2] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var hi = (num.words[i2] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i2] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b2) {
      assert2((a2.negative | b2.negative) === 0, "red works only with positives");
      assert2(a2.red && a2.red === b2.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime)
        return this.prime.ireduce(a2)._forceRed(this);
      move(a2, a2.umod(this.m)._forceRed(this));
      return a2;
    };
    Red.prototype.neg = function neg6(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add8(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.imul(b2));
    };
    Red.prototype.mul = function mul8(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.mul(b2));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero())
        return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow);
      }
      var q2 = this.m.subn(1);
      var s2 = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s2++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c2 = this.pow(z2, q2);
      var r2 = this.pow(a2, q2.addn(1).iushrn(1));
      var t2 = this.pow(a2, q2);
      var m2 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
          tmp = tmp.redSqr();
        }
        assert2(i2 < m2);
        var b2 = this.pow(c2, new BN2(1).iushln(m2 - i2 - 1));
        r2 = r2.redMul(b2);
        c2 = b2.redSqr();
        t2 = t2.redMul(c2);
        m2 = i2;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a2, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i2 = 2; i2 < wnd.length; i2++) {
        wnd[i2] = this.mul(wnd[i2 - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i2 = num.length - 1; i2 >= 0; i2--) {
        var word2 = num.words[i2];
        for (var j2 = start - 1; j2 >= 0; j2--) {
          var bit = word2 >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b2) {
      if (a2.isZero() || b2.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t2 = a2.imul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul8(a2, b2) {
      if (a2.isZero() || b2.isZero())
        return new BN2(0)._forceRed(this);
      var t2 = a2.mul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module2, commonjsGlobal);
})(bn$1);
var __importDefault$b = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist_browser, "__esModule", { value: true });
dist_browser.getLength = dist_browser.decode = dist_browser.encode = void 0;
var bn_js_1$2 = __importDefault$b(bn$1.exports);
function encode$2(input) {
  if (Array.isArray(input)) {
    var output = [];
    for (var i2 = 0; i2 < input.length; i2++) {
      output.push(encode$2(input[i2]));
    }
    var buf = buffer$2.Buffer.concat(output);
    return buffer$2.Buffer.concat([encodeLength(buf.length, 192), buf]);
  } else {
    var inputBuf = toBuffer$1(input);
    return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : buffer$2.Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
  }
}
dist_browser.encode = encode$2;
function safeParseInt(v2, base2) {
  if (v2[0] === "0" && v2[1] === "0") {
    throw new Error("invalid RLP: extra zeros");
  }
  return parseInt(v2, base2);
}
function encodeLength(len2, offset) {
  if (len2 < 56) {
    return buffer$2.Buffer.from([len2 + offset]);
  } else {
    var hexLength = intToHex$4(len2);
    var lLength = hexLength.length / 2;
    var firstByte = intToHex$4(offset + 55 + lLength);
    return buffer$2.Buffer.from(firstByte + hexLength, "hex");
  }
}
function decode$3(input, stream) {
  if (stream === void 0) {
    stream = false;
  }
  if (!input || input.length === 0) {
    return buffer$2.Buffer.from([]);
  }
  var inputBuffer = toBuffer$1(input);
  var decoded = _decode(inputBuffer);
  if (stream) {
    return decoded;
  }
  if (decoded.remainder.length !== 0) {
    throw new Error("invalid remainder");
  }
  return decoded.data;
}
dist_browser.decode = decode$3;
function getLength(input) {
  if (!input || input.length === 0) {
    return buffer$2.Buffer.from([]);
  }
  var inputBuffer = toBuffer$1(input);
  var firstByte = inputBuffer[0];
  if (firstByte <= 127) {
    return inputBuffer.length;
  } else if (firstByte <= 183) {
    return firstByte - 127;
  } else if (firstByte <= 191) {
    return firstByte - 182;
  } else if (firstByte <= 247) {
    return firstByte - 191;
  } else {
    var llength = firstByte - 246;
    var length_1 = safeParseInt(inputBuffer.slice(1, llength).toString("hex"), 16);
    return llength + length_1;
  }
}
dist_browser.getLength = getLength;
function _decode(input) {
  var length, llength, data, innerRemainder, d2;
  var decoded = [];
  var firstByte = input[0];
  if (firstByte <= 127) {
    return {
      data: input.slice(0, 1),
      remainder: input.slice(1)
    };
  } else if (firstByte <= 183) {
    length = firstByte - 127;
    if (firstByte === 128) {
      data = buffer$2.Buffer.from([]);
    } else {
      data = input.slice(1, length);
    }
    if (length === 2 && data[0] < 128) {
      throw new Error("invalid rlp encoding: byte must be less 0x80");
    }
    return {
      data,
      remainder: input.slice(length)
    };
  } else if (firstByte <= 191) {
    llength = firstByte - 182;
    if (input.length - 1 < llength) {
      throw new Error("invalid RLP: not enough bytes for string length");
    }
    length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
    if (length <= 55) {
      throw new Error("invalid RLP: expected string length to be greater than 55");
    }
    data = input.slice(llength, length + llength);
    if (data.length < length) {
      throw new Error("invalid RLP: not enough bytes for string");
    }
    return {
      data,
      remainder: input.slice(length + llength)
    };
  } else if (firstByte <= 247) {
    length = firstByte - 191;
    innerRemainder = input.slice(1, length);
    while (innerRemainder.length) {
      d2 = _decode(innerRemainder);
      decoded.push(d2.data);
      innerRemainder = d2.remainder;
    }
    return {
      data: decoded,
      remainder: input.slice(length)
    };
  } else {
    llength = firstByte - 246;
    length = safeParseInt(input.slice(1, llength).toString("hex"), 16);
    var totalLength = llength + length;
    if (totalLength > input.length) {
      throw new Error("invalid rlp: total length is larger than the data");
    }
    innerRemainder = input.slice(llength, totalLength);
    if (innerRemainder.length === 0) {
      throw new Error("invalid rlp, List has a invalid length");
    }
    while (innerRemainder.length) {
      d2 = _decode(innerRemainder);
      decoded.push(d2.data);
      innerRemainder = d2.remainder;
    }
    return {
      data: decoded,
      remainder: input.slice(totalLength)
    };
  }
}
function isHexPrefixed$2(str2) {
  return str2.slice(0, 2) === "0x";
}
function stripHexPrefix$2(str2) {
  if (typeof str2 !== "string") {
    return str2;
  }
  return isHexPrefixed$2(str2) ? str2.slice(2) : str2;
}
function intToHex$4(integer) {
  if (integer < 0) {
    throw new Error("Invalid integer as argument, must be unsigned!");
  }
  var hex = integer.toString(16);
  return hex.length % 2 ? "0" + hex : hex;
}
function padToEven$2(a2) {
  return a2.length % 2 ? "0" + a2 : a2;
}
function intToBuffer$2(integer) {
  var hex = intToHex$4(integer);
  return buffer$2.Buffer.from(hex, "hex");
}
function toBuffer$1(v2) {
  if (!buffer$2.Buffer.isBuffer(v2)) {
    if (typeof v2 === "string") {
      if (isHexPrefixed$2(v2)) {
        return buffer$2.Buffer.from(padToEven$2(stripHexPrefix$2(v2)), "hex");
      } else {
        return buffer$2.Buffer.from(v2);
      }
    } else if (typeof v2 === "number" || typeof v2 === "bigint") {
      if (!v2) {
        return buffer$2.Buffer.from([]);
      } else {
        return intToBuffer$2(v2);
      }
    } else if (v2 === null || v2 === void 0) {
      return buffer$2.Buffer.from([]);
    } else if (v2 instanceof Uint8Array) {
      return buffer$2.Buffer.from(v2);
    } else if (bn_js_1$2.default.isBN(v2)) {
      return buffer$2.Buffer.from(v2.toArray());
    } else {
      throw new Error("invalid type");
    }
  }
  return v2;
}
var Buffer$c = safeBuffer.exports.Buffer;
var Transform$1 = readableBrowser.exports.Transform;
var inherits$f = inherits_browser$1.exports;
function throwIfNotStringOrBuffer(val, prefix) {
  if (!Buffer$c.isBuffer(val) && typeof val !== "string") {
    throw new TypeError(prefix + " must be a string or a buffer");
  }
}
function HashBase$2(blockSize) {
  Transform$1.call(this);
  this._block = Buffer$c.allocUnsafe(blockSize);
  this._blockSize = blockSize;
  this._blockOffset = 0;
  this._length = [0, 0, 0, 0];
  this._finalized = false;
}
inherits$f(HashBase$2, Transform$1);
HashBase$2.prototype._transform = function(chunk, encoding, callback) {
  var error2 = null;
  try {
    this.update(chunk, encoding);
  } catch (err) {
    error2 = err;
  }
  callback(error2);
};
HashBase$2.prototype._flush = function(callback) {
  var error2 = null;
  try {
    this.push(this.digest());
  } catch (err) {
    error2 = err;
  }
  callback(error2);
};
HashBase$2.prototype.update = function(data, encoding) {
  throwIfNotStringOrBuffer(data, "Data");
  if (this._finalized)
    throw new Error("Digest already called");
  if (!Buffer$c.isBuffer(data))
    data = Buffer$c.from(data, encoding);
  var block = this._block;
  var offset = 0;
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i2 = this._blockOffset; i2 < this._blockSize; )
      block[i2++] = data[offset++];
    this._update();
    this._blockOffset = 0;
  }
  while (offset < data.length)
    block[this._blockOffset++] = data[offset++];
  for (var j2 = 0, carry = data.length * 8; carry > 0; ++j2) {
    this._length[j2] += carry;
    carry = this._length[j2] / 4294967296 | 0;
    if (carry > 0)
      this._length[j2] -= 4294967296 * carry;
  }
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(encoding) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = true;
  var digest9 = this._digest();
  if (encoding !== void 0)
    digest9 = digest9.toString(encoding);
  this._block.fill(0);
  this._blockOffset = 0;
  for (var i2 = 0; i2 < 4; ++i2)
    this._length[i2] = 0;
  return digest9;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2;
var inherits$e = inherits_browser$1.exports;
var HashBase$1 = hashBase;
var Buffer$b = safeBuffer.exports.Buffer;
var ARRAY16$1 = new Array(16);
function MD5$1() {
  HashBase$1.call(this, 64);
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
}
inherits$e(MD5$1, HashBase$1);
MD5$1.prototype._update = function() {
  var M2 = ARRAY16$1;
  for (var i2 = 0; i2 < 16; ++i2)
    M2[i2] = this._block.readInt32LE(i2 * 4);
  var a2 = this._a;
  var b2 = this._b;
  var c2 = this._c;
  var d2 = this._d;
  a2 = fnF(a2, b2, c2, d2, M2[0], 3614090360, 7);
  d2 = fnF(d2, a2, b2, c2, M2[1], 3905402710, 12);
  c2 = fnF(c2, d2, a2, b2, M2[2], 606105819, 17);
  b2 = fnF(b2, c2, d2, a2, M2[3], 3250441966, 22);
  a2 = fnF(a2, b2, c2, d2, M2[4], 4118548399, 7);
  d2 = fnF(d2, a2, b2, c2, M2[5], 1200080426, 12);
  c2 = fnF(c2, d2, a2, b2, M2[6], 2821735955, 17);
  b2 = fnF(b2, c2, d2, a2, M2[7], 4249261313, 22);
  a2 = fnF(a2, b2, c2, d2, M2[8], 1770035416, 7);
  d2 = fnF(d2, a2, b2, c2, M2[9], 2336552879, 12);
  c2 = fnF(c2, d2, a2, b2, M2[10], 4294925233, 17);
  b2 = fnF(b2, c2, d2, a2, M2[11], 2304563134, 22);
  a2 = fnF(a2, b2, c2, d2, M2[12], 1804603682, 7);
  d2 = fnF(d2, a2, b2, c2, M2[13], 4254626195, 12);
  c2 = fnF(c2, d2, a2, b2, M2[14], 2792965006, 17);
  b2 = fnF(b2, c2, d2, a2, M2[15], 1236535329, 22);
  a2 = fnG(a2, b2, c2, d2, M2[1], 4129170786, 5);
  d2 = fnG(d2, a2, b2, c2, M2[6], 3225465664, 9);
  c2 = fnG(c2, d2, a2, b2, M2[11], 643717713, 14);
  b2 = fnG(b2, c2, d2, a2, M2[0], 3921069994, 20);
  a2 = fnG(a2, b2, c2, d2, M2[5], 3593408605, 5);
  d2 = fnG(d2, a2, b2, c2, M2[10], 38016083, 9);
  c2 = fnG(c2, d2, a2, b2, M2[15], 3634488961, 14);
  b2 = fnG(b2, c2, d2, a2, M2[4], 3889429448, 20);
  a2 = fnG(a2, b2, c2, d2, M2[9], 568446438, 5);
  d2 = fnG(d2, a2, b2, c2, M2[14], 3275163606, 9);
  c2 = fnG(c2, d2, a2, b2, M2[3], 4107603335, 14);
  b2 = fnG(b2, c2, d2, a2, M2[8], 1163531501, 20);
  a2 = fnG(a2, b2, c2, d2, M2[13], 2850285829, 5);
  d2 = fnG(d2, a2, b2, c2, M2[2], 4243563512, 9);
  c2 = fnG(c2, d2, a2, b2, M2[7], 1735328473, 14);
  b2 = fnG(b2, c2, d2, a2, M2[12], 2368359562, 20);
  a2 = fnH(a2, b2, c2, d2, M2[5], 4294588738, 4);
  d2 = fnH(d2, a2, b2, c2, M2[8], 2272392833, 11);
  c2 = fnH(c2, d2, a2, b2, M2[11], 1839030562, 16);
  b2 = fnH(b2, c2, d2, a2, M2[14], 4259657740, 23);
  a2 = fnH(a2, b2, c2, d2, M2[1], 2763975236, 4);
  d2 = fnH(d2, a2, b2, c2, M2[4], 1272893353, 11);
  c2 = fnH(c2, d2, a2, b2, M2[7], 4139469664, 16);
  b2 = fnH(b2, c2, d2, a2, M2[10], 3200236656, 23);
  a2 = fnH(a2, b2, c2, d2, M2[13], 681279174, 4);
  d2 = fnH(d2, a2, b2, c2, M2[0], 3936430074, 11);
  c2 = fnH(c2, d2, a2, b2, M2[3], 3572445317, 16);
  b2 = fnH(b2, c2, d2, a2, M2[6], 76029189, 23);
  a2 = fnH(a2, b2, c2, d2, M2[9], 3654602809, 4);
  d2 = fnH(d2, a2, b2, c2, M2[12], 3873151461, 11);
  c2 = fnH(c2, d2, a2, b2, M2[15], 530742520, 16);
  b2 = fnH(b2, c2, d2, a2, M2[2], 3299628645, 23);
  a2 = fnI(a2, b2, c2, d2, M2[0], 4096336452, 6);
  d2 = fnI(d2, a2, b2, c2, M2[7], 1126891415, 10);
  c2 = fnI(c2, d2, a2, b2, M2[14], 2878612391, 15);
  b2 = fnI(b2, c2, d2, a2, M2[5], 4237533241, 21);
  a2 = fnI(a2, b2, c2, d2, M2[12], 1700485571, 6);
  d2 = fnI(d2, a2, b2, c2, M2[3], 2399980690, 10);
  c2 = fnI(c2, d2, a2, b2, M2[10], 4293915773, 15);
  b2 = fnI(b2, c2, d2, a2, M2[1], 2240044497, 21);
  a2 = fnI(a2, b2, c2, d2, M2[8], 1873313359, 6);
  d2 = fnI(d2, a2, b2, c2, M2[15], 4264355552, 10);
  c2 = fnI(c2, d2, a2, b2, M2[6], 2734768916, 15);
  b2 = fnI(b2, c2, d2, a2, M2[13], 1309151649, 21);
  a2 = fnI(a2, b2, c2, d2, M2[4], 4149444226, 6);
  d2 = fnI(d2, a2, b2, c2, M2[11], 3174756917, 10);
  c2 = fnI(c2, d2, a2, b2, M2[2], 718787259, 15);
  b2 = fnI(b2, c2, d2, a2, M2[9], 3951481745, 21);
  this._a = this._a + a2 | 0;
  this._b = this._b + b2 | 0;
  this._c = this._c + c2 | 0;
  this._d = this._d + d2 | 0;
};
MD5$1.prototype._digest = function() {
  this._block[this._blockOffset++] = 128;
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);
    this._update();
    this._blockOffset = 0;
  }
  this._block.fill(0, this._blockOffset, 56);
  this._block.writeUInt32LE(this._length[0], 56);
  this._block.writeUInt32LE(this._length[1], 60);
  this._update();
  var buffer2 = Buffer$b.allocUnsafe(16);
  buffer2.writeInt32LE(this._a, 0);
  buffer2.writeInt32LE(this._b, 4);
  buffer2.writeInt32LE(this._c, 8);
  buffer2.writeInt32LE(this._d, 12);
  return buffer2;
};
function rotl$1(x2, n2) {
  return x2 << n2 | x2 >>> 32 - n2;
}
function fnF(a2, b2, c2, d2, m2, k2, s2) {
  return rotl$1(a2 + (b2 & c2 | ~b2 & d2) + m2 + k2 | 0, s2) + b2 | 0;
}
function fnG(a2, b2, c2, d2, m2, k2, s2) {
  return rotl$1(a2 + (b2 & d2 | c2 & ~d2) + m2 + k2 | 0, s2) + b2 | 0;
}
function fnH(a2, b2, c2, d2, m2, k2, s2) {
  return rotl$1(a2 + (b2 ^ c2 ^ d2) + m2 + k2 | 0, s2) + b2 | 0;
}
function fnI(a2, b2, c2, d2, m2, k2, s2) {
  return rotl$1(a2 + (c2 ^ (b2 | ~d2)) + m2 + k2 | 0, s2) + b2 | 0;
}
var md5_js = MD5$1;
var Buffer$a = buffer$2.Buffer;
var inherits$d = inherits_browser$1.exports;
var HashBase = hashBase;
var ARRAY16 = new Array(16);
var zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$1() {
  HashBase.call(this, 64);
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
}
inherits$d(RIPEMD160$1, HashBase);
RIPEMD160$1.prototype._update = function() {
  var words2 = ARRAY16;
  for (var j2 = 0; j2 < 16; ++j2)
    words2[j2] = this._block.readInt32LE(j2 * 4);
  var al = this._a | 0;
  var bl = this._b | 0;
  var cl = this._c | 0;
  var dl = this._d | 0;
  var el = this._e | 0;
  var ar = this._a | 0;
  var br = this._b | 0;
  var cr = this._c | 0;
  var dr = this._d | 0;
  var er = this._e | 0;
  for (var i2 = 0; i2 < 80; i2 += 1) {
    var tl;
    var tr;
    if (i2 < 16) {
      tl = fn1(al, bl, cl, dl, el, words2[zl[i2]], hl[0], sl[i2]);
      tr = fn5(ar, br, cr, dr, er, words2[zr[i2]], hr[0], sr[i2]);
    } else if (i2 < 32) {
      tl = fn2(al, bl, cl, dl, el, words2[zl[i2]], hl[1], sl[i2]);
      tr = fn4(ar, br, cr, dr, er, words2[zr[i2]], hr[1], sr[i2]);
    } else if (i2 < 48) {
      tl = fn3(al, bl, cl, dl, el, words2[zl[i2]], hl[2], sl[i2]);
      tr = fn3(ar, br, cr, dr, er, words2[zr[i2]], hr[2], sr[i2]);
    } else if (i2 < 64) {
      tl = fn4(al, bl, cl, dl, el, words2[zl[i2]], hl[3], sl[i2]);
      tr = fn2(ar, br, cr, dr, er, words2[zr[i2]], hr[3], sr[i2]);
    } else {
      tl = fn5(al, bl, cl, dl, el, words2[zl[i2]], hl[4], sl[i2]);
      tr = fn1(ar, br, cr, dr, er, words2[zr[i2]], hr[4], sr[i2]);
    }
    al = el;
    el = dl;
    dl = rotl(cl, 10);
    cl = bl;
    bl = tl;
    ar = er;
    er = dr;
    dr = rotl(cr, 10);
    cr = br;
    br = tr;
  }
  var t2 = this._b + cl + dr | 0;
  this._b = this._c + dl + er | 0;
  this._c = this._d + el + ar | 0;
  this._d = this._e + al + br | 0;
  this._e = this._a + bl + cr | 0;
  this._a = t2;
};
RIPEMD160$1.prototype._digest = function() {
  this._block[this._blockOffset++] = 128;
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);
    this._update();
    this._blockOffset = 0;
  }
  this._block.fill(0, this._blockOffset, 56);
  this._block.writeUInt32LE(this._length[0], 56);
  this._block.writeUInt32LE(this._length[1], 60);
  this._update();
  var buffer2 = Buffer$a.alloc ? Buffer$a.alloc(20) : new Buffer$a(20);
  buffer2.writeInt32LE(this._a, 0);
  buffer2.writeInt32LE(this._b, 4);
  buffer2.writeInt32LE(this._c, 8);
  buffer2.writeInt32LE(this._d, 12);
  buffer2.writeInt32LE(this._e, 16);
  return buffer2;
};
function rotl(x2, n2) {
  return x2 << n2 | x2 >>> 32 - n2;
}
function fn1(a2, b2, c2, d2, e2, m2, k2, s2) {
  return rotl(a2 + (b2 ^ c2 ^ d2) + m2 + k2 | 0, s2) + e2 | 0;
}
function fn2(a2, b2, c2, d2, e2, m2, k2, s2) {
  return rotl(a2 + (b2 & c2 | ~b2 & d2) + m2 + k2 | 0, s2) + e2 | 0;
}
function fn3(a2, b2, c2, d2, e2, m2, k2, s2) {
  return rotl(a2 + ((b2 | ~c2) ^ d2) + m2 + k2 | 0, s2) + e2 | 0;
}
function fn4(a2, b2, c2, d2, e2, m2, k2, s2) {
  return rotl(a2 + (b2 & d2 | c2 & ~d2) + m2 + k2 | 0, s2) + e2 | 0;
}
function fn5(a2, b2, c2, d2, e2, m2, k2, s2) {
  return rotl(a2 + (b2 ^ (c2 | ~d2)) + m2 + k2 | 0, s2) + e2 | 0;
}
var ripemd160 = RIPEMD160$1;
var sha_js = { exports: {} };
var Buffer$9 = safeBuffer.exports.Buffer;
function Hash$7(blockSize, finalSize) {
  this._block = Buffer$9.alloc(blockSize);
  this._finalSize = finalSize;
  this._blockSize = blockSize;
  this._len = 0;
}
Hash$7.prototype.update = function(data, enc) {
  if (typeof data === "string") {
    enc = enc || "utf8";
    data = Buffer$9.from(data, enc);
  }
  var block = this._block;
  var blockSize = this._blockSize;
  var length = data.length;
  var accum = this._len;
  for (var offset = 0; offset < length; ) {
    var assigned = accum % blockSize;
    var remainder = Math.min(length - offset, blockSize - assigned);
    for (var i2 = 0; i2 < remainder; i2++) {
      block[assigned + i2] = data[offset + i2];
    }
    accum += remainder;
    offset += remainder;
    if (accum % blockSize === 0) {
      this._update(block);
    }
  }
  this._len += length;
  return this;
};
Hash$7.prototype.digest = function(enc) {
  var rem = this._len % this._blockSize;
  this._block[rem] = 128;
  this._block.fill(0, rem + 1);
  if (rem >= this._finalSize) {
    this._update(this._block);
    this._block.fill(0);
  }
  var bits = this._len * 8;
  if (bits <= 4294967295) {
    this._block.writeUInt32BE(bits, this._blockSize - 4);
  } else {
    var lowBits = (bits & 4294967295) >>> 0;
    var highBits = (bits - lowBits) / 4294967296;
    this._block.writeUInt32BE(highBits, this._blockSize - 8);
    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
  }
  this._update(this._block);
  var hash3 = this._hash();
  return enc ? hash3.toString(enc) : hash3;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$1 = Hash$7;
var inherits$c = inherits_browser$1.exports;
var Hash$6 = hash$1;
var Buffer$8 = safeBuffer.exports.Buffer;
var K$4 = [
  1518500249,
  1859775393,
  2400959708 | 0,
  3395469782 | 0
];
var W$6 = new Array(80);
function Sha() {
  this.init();
  this._w = W$6;
  Hash$6.call(this, 64, 56);
}
inherits$c(Sha, Hash$6);
Sha.prototype.init = function() {
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
  return this;
};
function rotl5$1(num) {
  return num << 5 | num >>> 27;
}
function rotl30$1(num) {
  return num << 30 | num >>> 2;
}
function ft$1(s2, b2, c2, d2) {
  if (s2 === 0)
    return b2 & c2 | ~b2 & d2;
  if (s2 === 2)
    return b2 & c2 | b2 & d2 | c2 & d2;
  return b2 ^ c2 ^ d2;
}
Sha.prototype._update = function(M2) {
  var W2 = this._w;
  var a2 = this._a | 0;
  var b2 = this._b | 0;
  var c2 = this._c | 0;
  var d2 = this._d | 0;
  var e2 = this._e | 0;
  for (var i2 = 0; i2 < 16; ++i2)
    W2[i2] = M2.readInt32BE(i2 * 4);
  for (; i2 < 80; ++i2)
    W2[i2] = W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16];
  for (var j2 = 0; j2 < 80; ++j2) {
    var s2 = ~~(j2 / 20);
    var t2 = rotl5$1(a2) + ft$1(s2, b2, c2, d2) + e2 + W2[j2] + K$4[s2] | 0;
    e2 = d2;
    d2 = c2;
    c2 = rotl30$1(b2);
    b2 = a2;
    a2 = t2;
  }
  this._a = a2 + this._a | 0;
  this._b = b2 + this._b | 0;
  this._c = c2 + this._c | 0;
  this._d = d2 + this._d | 0;
  this._e = e2 + this._e | 0;
};
Sha.prototype._hash = function() {
  var H2 = Buffer$8.allocUnsafe(20);
  H2.writeInt32BE(this._a | 0, 0);
  H2.writeInt32BE(this._b | 0, 4);
  H2.writeInt32BE(this._c | 0, 8);
  H2.writeInt32BE(this._d | 0, 12);
  H2.writeInt32BE(this._e | 0, 16);
  return H2;
};
var sha$1 = Sha;
var inherits$b = inherits_browser$1.exports;
var Hash$5 = hash$1;
var Buffer$7 = safeBuffer.exports.Buffer;
var K$3 = [
  1518500249,
  1859775393,
  2400959708 | 0,
  3395469782 | 0
];
var W$5 = new Array(80);
function Sha1() {
  this.init();
  this._w = W$5;
  Hash$5.call(this, 64, 56);
}
inherits$b(Sha1, Hash$5);
Sha1.prototype.init = function() {
  this._a = 1732584193;
  this._b = 4023233417;
  this._c = 2562383102;
  this._d = 271733878;
  this._e = 3285377520;
  return this;
};
function rotl1(num) {
  return num << 1 | num >>> 31;
}
function rotl5(num) {
  return num << 5 | num >>> 27;
}
function rotl30(num) {
  return num << 30 | num >>> 2;
}
function ft(s2, b2, c2, d2) {
  if (s2 === 0)
    return b2 & c2 | ~b2 & d2;
  if (s2 === 2)
    return b2 & c2 | b2 & d2 | c2 & d2;
  return b2 ^ c2 ^ d2;
}
Sha1.prototype._update = function(M2) {
  var W2 = this._w;
  var a2 = this._a | 0;
  var b2 = this._b | 0;
  var c2 = this._c | 0;
  var d2 = this._d | 0;
  var e2 = this._e | 0;
  for (var i2 = 0; i2 < 16; ++i2)
    W2[i2] = M2.readInt32BE(i2 * 4);
  for (; i2 < 80; ++i2)
    W2[i2] = rotl1(W2[i2 - 3] ^ W2[i2 - 8] ^ W2[i2 - 14] ^ W2[i2 - 16]);
  for (var j2 = 0; j2 < 80; ++j2) {
    var s2 = ~~(j2 / 20);
    var t2 = rotl5(a2) + ft(s2, b2, c2, d2) + e2 + W2[j2] + K$3[s2] | 0;
    e2 = d2;
    d2 = c2;
    c2 = rotl30(b2);
    b2 = a2;
    a2 = t2;
  }
  this._a = a2 + this._a | 0;
  this._b = b2 + this._b | 0;
  this._c = c2 + this._c | 0;
  this._d = d2 + this._d | 0;
  this._e = e2 + this._e | 0;
};
Sha1.prototype._hash = function() {
  var H2 = Buffer$7.allocUnsafe(20);
  H2.writeInt32BE(this._a | 0, 0);
  H2.writeInt32BE(this._b | 0, 4);
  H2.writeInt32BE(this._c | 0, 8);
  H2.writeInt32BE(this._d | 0, 12);
  H2.writeInt32BE(this._e | 0, 16);
  return H2;
};
var sha1 = Sha1;
var inherits$a = inherits_browser$1.exports;
var Hash$4 = hash$1;
var Buffer$6 = safeBuffer.exports.Buffer;
var K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
var W$4 = new Array(64);
function Sha256$1() {
  this.init();
  this._w = W$4;
  Hash$4.call(this, 64, 56);
}
inherits$a(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  this._a = 1779033703;
  this._b = 3144134277;
  this._c = 1013904242;
  this._d = 2773480762;
  this._e = 1359893119;
  this._f = 2600822924;
  this._g = 528734635;
  this._h = 1541459225;
  return this;
};
function ch$1(x2, y2, z2) {
  return z2 ^ x2 & (y2 ^ z2);
}
function maj$1(x2, y2, z2) {
  return x2 & y2 | z2 & (x2 | y2);
}
function sigma0$1(x2) {
  return (x2 >>> 2 | x2 << 30) ^ (x2 >>> 13 | x2 << 19) ^ (x2 >>> 22 | x2 << 10);
}
function sigma1$1(x2) {
  return (x2 >>> 6 | x2 << 26) ^ (x2 >>> 11 | x2 << 21) ^ (x2 >>> 25 | x2 << 7);
}
function gamma0(x2) {
  return (x2 >>> 7 | x2 << 25) ^ (x2 >>> 18 | x2 << 14) ^ x2 >>> 3;
}
function gamma1(x2) {
  return (x2 >>> 17 | x2 << 15) ^ (x2 >>> 19 | x2 << 13) ^ x2 >>> 10;
}
Sha256$1.prototype._update = function(M2) {
  var W2 = this._w;
  var a2 = this._a | 0;
  var b2 = this._b | 0;
  var c2 = this._c | 0;
  var d2 = this._d | 0;
  var e2 = this._e | 0;
  var f2 = this._f | 0;
  var g2 = this._g | 0;
  var h2 = this._h | 0;
  for (var i2 = 0; i2 < 16; ++i2)
    W2[i2] = M2.readInt32BE(i2 * 4);
  for (; i2 < 64; ++i2)
    W2[i2] = gamma1(W2[i2 - 2]) + W2[i2 - 7] + gamma0(W2[i2 - 15]) + W2[i2 - 16] | 0;
  for (var j2 = 0; j2 < 64; ++j2) {
    var T1 = h2 + sigma1$1(e2) + ch$1(e2, f2, g2) + K$2[j2] + W2[j2] | 0;
    var T2 = sigma0$1(a2) + maj$1(a2, b2, c2) | 0;
    h2 = g2;
    g2 = f2;
    f2 = e2;
    e2 = d2 + T1 | 0;
    d2 = c2;
    c2 = b2;
    b2 = a2;
    a2 = T1 + T2 | 0;
  }
  this._a = a2 + this._a | 0;
  this._b = b2 + this._b | 0;
  this._c = c2 + this._c | 0;
  this._d = d2 + this._d | 0;
  this._e = e2 + this._e | 0;
  this._f = f2 + this._f | 0;
  this._g = g2 + this._g | 0;
  this._h = h2 + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var H2 = Buffer$6.allocUnsafe(32);
  H2.writeInt32BE(this._a, 0);
  H2.writeInt32BE(this._b, 4);
  H2.writeInt32BE(this._c, 8);
  H2.writeInt32BE(this._d, 12);
  H2.writeInt32BE(this._e, 16);
  H2.writeInt32BE(this._f, 20);
  H2.writeInt32BE(this._g, 24);
  H2.writeInt32BE(this._h, 28);
  return H2;
};
var sha256$1 = Sha256$1;
var inherits$9 = inherits_browser$1.exports;
var Sha256 = sha256$1;
var Hash$3 = hash$1;
var Buffer$5 = safeBuffer.exports.Buffer;
var W$3 = new Array(64);
function Sha224() {
  this.init();
  this._w = W$3;
  Hash$3.call(this, 64, 56);
}
inherits$9(Sha224, Sha256);
Sha224.prototype.init = function() {
  this._a = 3238371032;
  this._b = 914150663;
  this._c = 812702999;
  this._d = 4144912697;
  this._e = 4290775857;
  this._f = 1750603025;
  this._g = 1694076839;
  this._h = 3204075428;
  return this;
};
Sha224.prototype._hash = function() {
  var H2 = Buffer$5.allocUnsafe(28);
  H2.writeInt32BE(this._a, 0);
  H2.writeInt32BE(this._b, 4);
  H2.writeInt32BE(this._c, 8);
  H2.writeInt32BE(this._d, 12);
  H2.writeInt32BE(this._e, 16);
  H2.writeInt32BE(this._f, 20);
  H2.writeInt32BE(this._g, 24);
  return H2;
};
var sha224 = Sha224;
var inherits$8 = inherits_browser$1.exports;
var Hash$2 = hash$1;
var Buffer$4 = safeBuffer.exports.Buffer;
var K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
var W$2 = new Array(160);
function Sha512() {
  this.init();
  this._w = W$2;
  Hash$2.call(this, 128, 112);
}
inherits$8(Sha512, Hash$2);
Sha512.prototype.init = function() {
  this._ah = 1779033703;
  this._bh = 3144134277;
  this._ch = 1013904242;
  this._dh = 2773480762;
  this._eh = 1359893119;
  this._fh = 2600822924;
  this._gh = 528734635;
  this._hh = 1541459225;
  this._al = 4089235720;
  this._bl = 2227873595;
  this._cl = 4271175723;
  this._dl = 1595750129;
  this._el = 2917565137;
  this._fl = 725511199;
  this._gl = 4215389547;
  this._hl = 327033209;
  return this;
};
function Ch(x2, y2, z2) {
  return z2 ^ x2 & (y2 ^ z2);
}
function maj(x2, y2, z2) {
  return x2 & y2 | z2 & (x2 | y2);
}
function sigma0(x2, xl) {
  return (x2 >>> 28 | xl << 4) ^ (xl >>> 2 | x2 << 30) ^ (xl >>> 7 | x2 << 25);
}
function sigma1(x2, xl) {
  return (x2 >>> 14 | xl << 18) ^ (x2 >>> 18 | xl << 14) ^ (xl >>> 9 | x2 << 23);
}
function Gamma0(x2, xl) {
  return (x2 >>> 1 | xl << 31) ^ (x2 >>> 8 | xl << 24) ^ x2 >>> 7;
}
function Gamma0l(x2, xl) {
  return (x2 >>> 1 | xl << 31) ^ (x2 >>> 8 | xl << 24) ^ (x2 >>> 7 | xl << 25);
}
function Gamma1(x2, xl) {
  return (x2 >>> 19 | xl << 13) ^ (xl >>> 29 | x2 << 3) ^ x2 >>> 6;
}
function Gamma1l(x2, xl) {
  return (x2 >>> 19 | xl << 13) ^ (xl >>> 29 | x2 << 3) ^ (x2 >>> 6 | xl << 26);
}
function getCarry(a2, b2) {
  return a2 >>> 0 < b2 >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(M2) {
  var W2 = this._w;
  var ah = this._ah | 0;
  var bh = this._bh | 0;
  var ch2 = this._ch | 0;
  var dh = this._dh | 0;
  var eh = this._eh | 0;
  var fh = this._fh | 0;
  var gh = this._gh | 0;
  var hh = this._hh | 0;
  var al = this._al | 0;
  var bl = this._bl | 0;
  var cl = this._cl | 0;
  var dl = this._dl | 0;
  var el = this._el | 0;
  var fl = this._fl | 0;
  var gl = this._gl | 0;
  var hl2 = this._hl | 0;
  for (var i2 = 0; i2 < 32; i2 += 2) {
    W2[i2] = M2.readInt32BE(i2 * 4);
    W2[i2 + 1] = M2.readInt32BE(i2 * 4 + 4);
  }
  for (; i2 < 160; i2 += 2) {
    var xh = W2[i2 - 15 * 2];
    var xl = W2[i2 - 15 * 2 + 1];
    var gamma02 = Gamma0(xh, xl);
    var gamma0l = Gamma0l(xl, xh);
    xh = W2[i2 - 2 * 2];
    xl = W2[i2 - 2 * 2 + 1];
    var gamma12 = Gamma1(xh, xl);
    var gamma1l = Gamma1l(xl, xh);
    var Wi7h = W2[i2 - 7 * 2];
    var Wi7l = W2[i2 - 7 * 2 + 1];
    var Wi16h = W2[i2 - 16 * 2];
    var Wi16l = W2[i2 - 16 * 2 + 1];
    var Wil = gamma0l + Wi7l | 0;
    var Wih = gamma02 + Wi7h + getCarry(Wil, gamma0l) | 0;
    Wil = Wil + gamma1l | 0;
    Wih = Wih + gamma12 + getCarry(Wil, gamma1l) | 0;
    Wil = Wil + Wi16l | 0;
    Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
    W2[i2] = Wih;
    W2[i2 + 1] = Wil;
  }
  for (var j2 = 0; j2 < 160; j2 += 2) {
    Wih = W2[j2];
    Wil = W2[j2 + 1];
    var majh = maj(ah, bh, ch2);
    var majl = maj(al, bl, cl);
    var sigma0h = sigma0(ah, al);
    var sigma0l = sigma0(al, ah);
    var sigma1h = sigma1(eh, el);
    var sigma1l = sigma1(el, eh);
    var Kih = K$1[j2];
    var Kil = K$1[j2 + 1];
    var chh = Ch(eh, fh, gh);
    var chl = Ch(el, fl, gl);
    var t1l = hl2 + sigma1l | 0;
    var t1h = hh + sigma1h + getCarry(t1l, hl2) | 0;
    t1l = t1l + chl | 0;
    t1h = t1h + chh + getCarry(t1l, chl) | 0;
    t1l = t1l + Kil | 0;
    t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
    t1l = t1l + Wil | 0;
    t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
    var t2l = sigma0l + majl | 0;
    var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
    hh = gh;
    hl2 = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    el = dl + t1l | 0;
    eh = dh + t1h + getCarry(el, dl) | 0;
    dh = ch2;
    dl = cl;
    ch2 = bh;
    cl = bl;
    bh = ah;
    bl = al;
    al = t1l + t2l | 0;
    ah = t1h + t2h + getCarry(al, t1l) | 0;
  }
  this._al = this._al + al | 0;
  this._bl = this._bl + bl | 0;
  this._cl = this._cl + cl | 0;
  this._dl = this._dl + dl | 0;
  this._el = this._el + el | 0;
  this._fl = this._fl + fl | 0;
  this._gl = this._gl + gl | 0;
  this._hl = this._hl + hl2 | 0;
  this._ah = this._ah + ah + getCarry(this._al, al) | 0;
  this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
  this._ch = this._ch + ch2 + getCarry(this._cl, cl) | 0;
  this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
  this._eh = this._eh + eh + getCarry(this._el, el) | 0;
  this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
  this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
  this._hh = this._hh + hh + getCarry(this._hl, hl2) | 0;
};
Sha512.prototype._hash = function() {
  var H2 = Buffer$4.allocUnsafe(64);
  function writeInt64BE(h2, l2, offset) {
    H2.writeInt32BE(h2, offset);
    H2.writeInt32BE(l2, offset + 4);
  }
  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  writeInt64BE(this._gh, this._gl, 48);
  writeInt64BE(this._hh, this._hl, 56);
  return H2;
};
var sha512 = Sha512;
var inherits$7 = inherits_browser$1.exports;
var SHA512 = sha512;
var Hash$1 = hash$1;
var Buffer$3 = safeBuffer.exports.Buffer;
var W$1 = new Array(160);
function Sha384() {
  this.init();
  this._w = W$1;
  Hash$1.call(this, 128, 112);
}
inherits$7(Sha384, SHA512);
Sha384.prototype.init = function() {
  this._ah = 3418070365;
  this._bh = 1654270250;
  this._ch = 2438529370;
  this._dh = 355462360;
  this._eh = 1731405415;
  this._fh = 2394180231;
  this._gh = 3675008525;
  this._hh = 1203062813;
  this._al = 3238371032;
  this._bl = 914150663;
  this._cl = 812702999;
  this._dl = 4144912697;
  this._el = 4290775857;
  this._fl = 1750603025;
  this._gl = 1694076839;
  this._hl = 3204075428;
  return this;
};
Sha384.prototype._hash = function() {
  var H2 = Buffer$3.allocUnsafe(48);
  function writeInt64BE(h2, l2, offset) {
    H2.writeInt32BE(h2, offset);
    H2.writeInt32BE(l2, offset + 4);
  }
  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  return H2;
};
var sha384 = Sha384;
var exports = sha_js.exports = function SHA(algorithm2) {
  algorithm2 = algorithm2.toLowerCase();
  var Algorithm = exports[algorithm2];
  if (!Algorithm)
    throw new Error(algorithm2 + " is not supported (we accept pull requests)");
  return new Algorithm();
};
exports.sha = sha$1;
exports.sha1 = sha1;
exports.sha224 = sha224;
exports.sha256 = sha256$1;
exports.sha384 = sha384;
exports.sha512 = sha512;
var Buffer$2 = safeBuffer.exports.Buffer;
var Transform = require$$2$2.Transform;
var StringDecoder = string_decoder.StringDecoder;
var inherits$6 = inherits_browser$1.exports;
function CipherBase(hashMode) {
  Transform.call(this);
  this.hashMode = typeof hashMode === "string";
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest;
  } else {
    this.final = this._finalOrDigest;
  }
  if (this._final) {
    this.__final = this._final;
    this._final = null;
  }
  this._decoder = null;
  this._encoding = null;
}
inherits$6(CipherBase, Transform);
CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
  if (typeof data === "string") {
    data = Buffer$2.from(data, inputEnc);
  }
  var outData = this._update(data);
  if (this.hashMode)
    return this;
  if (outputEnc) {
    outData = this._toString(outData, outputEnc);
  }
  return outData;
};
CipherBase.prototype.setAutoPadding = function() {
};
CipherBase.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(data, _2, next3) {
  var err;
  try {
    if (this.hashMode) {
      this._update(data);
    } else {
      this.push(this._update(data));
    }
  } catch (e2) {
    err = e2;
  } finally {
    next3(err);
  }
};
CipherBase.prototype._flush = function(done2) {
  var err;
  try {
    this.push(this.__final());
  } catch (e2) {
    err = e2;
  }
  done2(err);
};
CipherBase.prototype._finalOrDigest = function(outputEnc) {
  var outData = this.__final() || Buffer$2.alloc(0);
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true);
  }
  return outData;
};
CipherBase.prototype._toString = function(value2, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc);
    this._encoding = enc;
  }
  if (this._encoding !== enc)
    throw new Error("can't switch encodings");
  var out = this._decoder.write(value2);
  if (fin) {
    out += this._decoder.end();
  }
  return out;
};
var cipherBase = CipherBase;
var inherits$5 = inherits_browser$1.exports;
var MD5 = md5_js;
var RIPEMD160 = ripemd160;
var sha = sha_js.exports;
var Base = cipherBase;
function Hash(hash3) {
  Base.call(this, "digest");
  this._hash = hash3;
}
inherits$5(Hash, Base);
Hash.prototype._update = function(data) {
  this._hash.update(data);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser$3 = function createHash(alg) {
  alg = alg.toLowerCase();
  if (alg === "md5")
    return new MD5();
  if (alg === "rmd160" || alg === "ripemd160")
    return new RIPEMD160();
  return new Hash(sha(alg));
};
var src$1 = function isHexPrefixed2(str2) {
  if (typeof str2 !== "string") {
    throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + typeof str2 + ", while checking isHexPrefixed.");
  }
  return str2.slice(0, 2) === "0x";
};
var isHexPrefixed$1 = src$1;
var src = function stripHexPrefix2(str2) {
  if (typeof str2 !== "string") {
    return str2;
  }
  return isHexPrefixed$1(str2) ? str2.slice(2) : str2;
};
var isHexPrefixed = src$1;
var stripHexPrefix$1 = src;
function padToEven$1(value2) {
  var a2 = value2;
  if (typeof a2 !== "string") {
    throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + typeof a2 + ", while padToEven.");
  }
  if (a2.length % 2) {
    a2 = "0" + a2;
  }
  return a2;
}
function intToHex$3(i2) {
  var hex = i2.toString(16);
  return "0x" + hex;
}
function intToBuffer$1(i2) {
  var hex = intToHex$3(i2);
  return new buffer$2.Buffer(padToEven$1(hex.slice(2)), "hex");
}
function getBinarySize(str2) {
  if (typeof str2 !== "string") {
    throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + typeof str2 + "'.");
  }
  return buffer$2.Buffer.byteLength(str2, "utf8");
}
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + typeof superset + "'");
  }
  if (Array.isArray(subset) !== true) {
    throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + typeof subset + "'");
  }
  return subset[Boolean(some) && "some" || "every"](function(value2) {
    return superset.indexOf(value2) >= 0;
  });
}
function toUtf8(hex) {
  var bufferValue = new buffer$2.Buffer(padToEven$1(stripHexPrefix$1(hex).replace(/^0+|0+$/g, "")), "hex");
  return bufferValue.toString("utf8");
}
function toAscii(hex) {
  var str2 = "";
  var i2 = 0, l2 = hex.length;
  if (hex.substring(0, 2) === "0x") {
    i2 = 2;
  }
  for (; i2 < l2; i2 += 2) {
    var code2 = parseInt(hex.substr(i2, 2), 16);
    str2 += String.fromCharCode(code2);
  }
  return str2;
}
function fromUtf8(stringValue) {
  var str2 = new buffer$2.Buffer(stringValue, "utf8");
  return "0x" + padToEven$1(str2.toString("hex")).replace(/^0+|0+$/g, "");
}
function fromAscii(stringValue) {
  var hex = "";
  for (var i2 = 0; i2 < stringValue.length; i2++) {
    var code2 = stringValue.charCodeAt(i2);
    var n2 = code2.toString(16);
    hex += n2.length < 2 ? "0" + n2 : n2;
  }
  return "0x" + hex;
}
function getKeys(params, key2, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + typeof params + "'");
  }
  if (typeof key2 !== "string") {
    throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + typeof key2 + "'.");
  }
  var result = [];
  for (var i2 = 0; i2 < params.length; i2++) {
    var value2 = params[i2][key2];
    if (allowEmpty && !value2) {
      value2 = "";
    } else if (typeof value2 !== "string") {
      throw new Error("invalid abi");
    }
    result.push(value2);
  }
  return result;
}
function isHexString$4(value2, length) {
  if (typeof value2 !== "string" || !value2.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value2.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var lib$2 = {
  arrayContainsArray,
  intToBuffer: intToBuffer$1,
  getBinarySize,
  isHexPrefixed,
  stripHexPrefix: stripHexPrefix$1,
  padToEven: padToEven$1,
  intToHex: intToHex$3,
  fromAscii,
  fromUtf8,
  toAscii,
  toUtf8,
  getKeys,
  isHexString: isHexString$4
};
(function(exports2) {
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var _require3 = keccak$3, keccak224 = _require3.keccak224, keccak384 = _require3.keccak384, k256 = _require3.keccak256, keccak512 = _require3.keccak512;
  var secp256k12 = secp256k1Adapter;
  var assert2 = require$$2$2;
  var rlp2 = dist_browser;
  var BN2 = bn$2.exports;
  var createHash2 = browser$3;
  var Buffer2 = safeBuffer.exports.Buffer;
  Object.assign(exports2, lib$2);
  exports2.MAX_INTEGER = new BN2("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
  exports2.TWO_POW256 = new BN2("10000000000000000000000000000000000000000000000000000000000000000", 16);
  exports2.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
  exports2.SHA3_NULL_S = exports2.KECCAK256_NULL_S;
  exports2.KECCAK256_NULL = Buffer2.from(exports2.KECCAK256_NULL_S, "hex");
  exports2.SHA3_NULL = exports2.KECCAK256_NULL;
  exports2.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
  exports2.SHA3_RLP_ARRAY_S = exports2.KECCAK256_RLP_ARRAY_S;
  exports2.KECCAK256_RLP_ARRAY = Buffer2.from(exports2.KECCAK256_RLP_ARRAY_S, "hex");
  exports2.SHA3_RLP_ARRAY = exports2.KECCAK256_RLP_ARRAY;
  exports2.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
  exports2.SHA3_RLP_S = exports2.KECCAK256_RLP_S;
  exports2.KECCAK256_RLP = Buffer2.from(exports2.KECCAK256_RLP_S, "hex");
  exports2.SHA3_RLP = exports2.KECCAK256_RLP;
  exports2.BN = BN2;
  exports2.rlp = rlp2;
  exports2.secp256k1 = secp256k12;
  exports2.zeros = function(bytes3) {
    return Buffer2.allocUnsafe(bytes3).fill(0);
  };
  exports2.zeroAddress = function() {
    var addressLength = 20;
    var zeroAddress = exports2.zeros(addressLength);
    return exports2.bufferToHex(zeroAddress);
  };
  exports2.setLengthLeft = exports2.setLength = function(msg, length, right) {
    var buf = exports2.zeros(length);
    msg = exports2.toBuffer(msg);
    if (right) {
      if (msg.length < length) {
        msg.copy(buf);
        return buf;
      }
      return msg.slice(0, length);
    } else {
      if (msg.length < length) {
        msg.copy(buf, length - msg.length);
        return buf;
      }
      return msg.slice(-length);
    }
  };
  exports2.setLengthRight = function(msg, length) {
    return exports2.setLength(msg, length, true);
  };
  exports2.unpad = exports2.stripZeros = function(a2) {
    a2 = exports2.stripHexPrefix(a2);
    var first2 = a2[0];
    while (a2.length > 0 && first2.toString() === "0") {
      a2 = a2.slice(1);
      first2 = a2[0];
    }
    return a2;
  };
  exports2.toBuffer = function(v2) {
    if (!Buffer2.isBuffer(v2)) {
      if (Array.isArray(v2)) {
        v2 = Buffer2.from(v2);
      } else if (typeof v2 === "string") {
        if (exports2.isHexString(v2)) {
          v2 = Buffer2.from(exports2.padToEven(exports2.stripHexPrefix(v2)), "hex");
        } else {
          v2 = Buffer2.from(v2);
        }
      } else if (typeof v2 === "number") {
        v2 = exports2.intToBuffer(v2);
      } else if (v2 === null || v2 === void 0) {
        v2 = Buffer2.allocUnsafe(0);
      } else if (BN2.isBN(v2)) {
        v2 = v2.toArrayLike(Buffer2);
      } else if (v2.toArray) {
        v2 = Buffer2.from(v2.toArray());
      } else {
        throw new Error("invalid type");
      }
    }
    return v2;
  };
  exports2.bufferToInt = function(buf) {
    return new BN2(exports2.toBuffer(buf)).toNumber();
  };
  exports2.bufferToHex = function(buf) {
    buf = exports2.toBuffer(buf);
    return "0x" + buf.toString("hex");
  };
  exports2.fromSigned = function(num) {
    return new BN2(num).fromTwos(256);
  };
  exports2.toUnsigned = function(num) {
    return Buffer2.from(num.toTwos(256).toArray());
  };
  exports2.keccak = function(a2, bits) {
    a2 = exports2.toBuffer(a2);
    if (!bits)
      bits = 256;
    switch (bits) {
      case 224: {
        return keccak224(a2);
      }
      case 256: {
        return k256(a2);
      }
      case 384: {
        return keccak384(a2);
      }
      case 512: {
        return keccak512(a2);
      }
      default: {
        throw new Error("Invald algorithm: keccak" + bits);
      }
    }
  };
  exports2.keccak256 = function(a2) {
    return exports2.keccak(a2);
  };
  exports2.sha3 = exports2.keccak;
  exports2.sha256 = function(a2) {
    a2 = exports2.toBuffer(a2);
    return createHash2("sha256").update(a2).digest();
  };
  exports2.ripemd160 = function(a2, padded) {
    a2 = exports2.toBuffer(a2);
    var hash3 = createHash2("rmd160").update(a2).digest();
    if (padded === true) {
      return exports2.setLength(hash3, 32);
    } else {
      return hash3;
    }
  };
  exports2.rlphash = function(a2) {
    return exports2.keccak(rlp2.encode(a2));
  };
  exports2.isValidPrivate = function(privateKey) {
    return secp256k12.privateKeyVerify(privateKey);
  };
  exports2.isValidPublic = function(publicKey, sanitize) {
    if (publicKey.length === 64) {
      return secp256k12.publicKeyVerify(Buffer2.concat([Buffer2.from([4]), publicKey]));
    }
    if (!sanitize) {
      return false;
    }
    return secp256k12.publicKeyVerify(publicKey);
  };
  exports2.pubToAddress = exports2.publicToAddress = function(pubKey, sanitize) {
    pubKey = exports2.toBuffer(pubKey);
    if (sanitize && pubKey.length !== 64) {
      pubKey = secp256k12.publicKeyConvert(pubKey, false).slice(1);
    }
    assert2(pubKey.length === 64);
    return exports2.keccak(pubKey).slice(-20);
  };
  var privateToPublic = exports2.privateToPublic = function(privateKey) {
    privateKey = exports2.toBuffer(privateKey);
    return secp256k12.publicKeyCreate(privateKey, false).slice(1);
  };
  exports2.importPublic = function(publicKey) {
    publicKey = exports2.toBuffer(publicKey);
    if (publicKey.length !== 64) {
      publicKey = secp256k12.publicKeyConvert(publicKey, false).slice(1);
    }
    return publicKey;
  };
  exports2.ecsign = function(msgHash, privateKey) {
    var sig = secp256k12.sign(msgHash, privateKey);
    var ret = {};
    ret.r = sig.signature.slice(0, 32);
    ret.s = sig.signature.slice(32, 64);
    ret.v = sig.recovery + 27;
    return ret;
  };
  exports2.hashPersonalMessage = function(message) {
    var prefix = exports2.toBuffer("Ethereum Signed Message:\n" + message.length.toString());
    return exports2.keccak(Buffer2.concat([prefix, message]));
  };
  exports2.ecrecover = function(msgHash, v2, r2, s2) {
    var signature2 = Buffer2.concat([exports2.setLength(r2, 32), exports2.setLength(s2, 32)], 64);
    var recovery = v2 - 27;
    if (recovery !== 0 && recovery !== 1) {
      throw new Error("Invalid signature v value");
    }
    var senderPubKey = secp256k12.recover(msgHash, signature2, recovery);
    return secp256k12.publicKeyConvert(senderPubKey, false).slice(1);
  };
  exports2.toRpcSig = function(v2, r2, s2) {
    if (v2 !== 27 && v2 !== 28) {
      throw new Error("Invalid recovery id");
    }
    return exports2.bufferToHex(Buffer2.concat([exports2.setLengthLeft(r2, 32), exports2.setLengthLeft(s2, 32), exports2.toBuffer(v2 - 27)]));
  };
  exports2.fromRpcSig = function(sig) {
    sig = exports2.toBuffer(sig);
    if (sig.length !== 65) {
      throw new Error("Invalid signature length");
    }
    var v2 = sig[64];
    if (v2 < 27) {
      v2 += 27;
    }
    return {
      v: v2,
      r: sig.slice(0, 32),
      s: sig.slice(32, 64)
    };
  };
  exports2.privateToAddress = function(privateKey) {
    return exports2.publicToAddress(privateToPublic(privateKey));
  };
  exports2.isValidAddress = function(address) {
    return /^0x[0-9a-fA-F]{40}$/.test(address);
  };
  exports2.isZeroAddress = function(address) {
    var zeroAddress = exports2.zeroAddress();
    return zeroAddress === exports2.addHexPrefix(address);
  };
  exports2.toChecksumAddress = function(address) {
    address = exports2.stripHexPrefix(address).toLowerCase();
    var hash3 = exports2.keccak(address).toString("hex");
    var ret = "0x";
    for (var i2 = 0; i2 < address.length; i2++) {
      if (parseInt(hash3[i2], 16) >= 8) {
        ret += address[i2].toUpperCase();
      } else {
        ret += address[i2];
      }
    }
    return ret;
  };
  exports2.isValidChecksumAddress = function(address) {
    return exports2.isValidAddress(address) && exports2.toChecksumAddress(address) === address;
  };
  exports2.generateAddress = function(from2, nonce) {
    from2 = exports2.toBuffer(from2);
    nonce = new BN2(nonce);
    if (nonce.isZero()) {
      nonce = null;
    } else {
      nonce = Buffer2.from(nonce.toArray());
    }
    return exports2.rlphash([from2, nonce]).slice(-20);
  };
  exports2.isPrecompiled = function(address) {
    var a2 = exports2.unpad(address);
    return a2.length === 1 && a2[0] >= 1 && a2[0] <= 8;
  };
  exports2.addHexPrefix = function(str2) {
    if (typeof str2 !== "string") {
      return str2;
    }
    return exports2.isHexPrefixed(str2) ? str2 : "0x" + str2;
  };
  exports2.isValidSignature = function(v2, r2, s2, homestead2) {
    var SECP256K1_N_DIV_2 = new BN2("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
    var SECP256K1_N = new BN2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
    if (r2.length !== 32 || s2.length !== 32) {
      return false;
    }
    if (v2 !== 27 && v2 !== 28) {
      return false;
    }
    r2 = new BN2(r2);
    s2 = new BN2(s2);
    if (r2.isZero() || r2.gt(SECP256K1_N) || s2.isZero() || s2.gt(SECP256K1_N)) {
      return false;
    }
    if (homestead2 === false && new BN2(s2).cmp(SECP256K1_N_DIV_2) === 1) {
      return false;
    }
    return true;
  };
  exports2.baToJSON = function(ba) {
    if (Buffer2.isBuffer(ba)) {
      return "0x" + ba.toString("hex");
    } else if (ba instanceof Array) {
      var array2 = [];
      for (var i2 = 0; i2 < ba.length; i2++) {
        array2.push(exports2.baToJSON(ba[i2]));
      }
      return array2;
    }
  };
  exports2.defineProperties = function(self2, fields, data) {
    self2.raw = [];
    self2._fields = [];
    self2.toJSON = function(label) {
      if (label) {
        var obj = {};
        self2._fields.forEach(function(field) {
          obj[field] = "0x" + self2[field].toString("hex");
        });
        return obj;
      }
      return exports2.baToJSON(this.raw);
    };
    self2.serialize = function serialize2() {
      return rlp2.encode(self2.raw);
    };
    fields.forEach(function(field, i2) {
      self2._fields.push(field.name);
      function getter() {
        return self2.raw[i2];
      }
      function setter(v2) {
        v2 = exports2.toBuffer(v2);
        if (v2.toString("hex") === "00" && !field.allowZero) {
          v2 = Buffer2.allocUnsafe(0);
        }
        if (field.allowLess && field.length) {
          v2 = exports2.stripZeros(v2);
          assert2(field.length >= v2.length, "The field " + field.name + " must not have more " + field.length + " bytes");
        } else if (!(field.allowZero && v2.length === 0) && field.length) {
          assert2(field.length === v2.length, "The field " + field.name + " must have byte length of " + field.length);
        }
        self2.raw[i2] = v2;
      }
      Object.defineProperty(self2, field.name, {
        enumerable: true,
        configurable: true,
        get: getter,
        set: setter
      });
      if (field.default) {
        self2[field.name] = field.default;
      }
      if (field.alias) {
        Object.defineProperty(self2, field.alias, {
          enumerable: false,
          configurable: true,
          set: setter,
          get: getter
        });
      }
    });
    if (data) {
      if (typeof data === "string") {
        data = Buffer2.from(exports2.stripHexPrefix(data), "hex");
      }
      if (Buffer2.isBuffer(data)) {
        data = rlp2.decode(data);
      }
      if (Array.isArray(data)) {
        if (data.length > self2._fields.length) {
          throw new Error("wrong number of fields in data");
        }
        data.forEach(function(d2, i2) {
          self2[self2._fields[i2]] = exports2.toBuffer(d2);
        });
      } else if ((typeof data === "undefined" ? "undefined" : _typeof(data)) === "object") {
        var keys2 = Object.keys(data);
        fields.forEach(function(field) {
          if (keys2.indexOf(field.name) !== -1)
            self2[field.name] = data[field.name];
          if (keys2.indexOf(field.alias) !== -1)
            self2[field.alias] = data[field.alias];
        });
      } else {
        throw new Error("invalid data");
      }
    }
  };
})(dist$5);
const processFn$1 = (fn, opts) => function() {
  const P2 = opts.promiseModule;
  const args = new Array(arguments.length);
  for (let i2 = 0; i2 < arguments.length; i2++) {
    args[i2] = arguments[i2];
  }
  return new P2((resolve2, reject) => {
    if (opts.errorFirst) {
      args.push(function(err, result) {
        if (opts.multiArgs) {
          const results2 = new Array(arguments.length - 1);
          for (let i2 = 1; i2 < arguments.length; i2++) {
            results2[i2 - 1] = arguments[i2];
          }
          if (err) {
            results2.unshift(err);
            reject(results2);
          } else {
            resolve2(results2);
          }
        } else if (err) {
          reject(err);
        } else {
          resolve2(result);
        }
      });
    } else {
      args.push(function(result) {
        if (opts.multiArgs) {
          const results2 = new Array(arguments.length - 1);
          for (let i2 = 0; i2 < arguments.length; i2++) {
            results2[i2] = arguments[i2];
          }
          resolve2(results2);
        } else {
          resolve2(result);
        }
      });
    }
    fn.apply(this, args);
  });
};
var pify$3 = (obj, opts) => {
  opts = Object.assign({
    exclude: [/.+(Sync|Stream)$/],
    errorFirst: true,
    promiseModule: Promise
  }, opts);
  const filter2 = (key2) => {
    const match = (pattern) => typeof pattern === "string" ? key2 === pattern : pattern.test(key2);
    return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
  };
  let ret;
  if (typeof obj === "function") {
    ret = function() {
      if (opts.excludeMain) {
        return obj.apply(this, arguments);
      }
      return processFn$1(obj, opts).apply(this, arguments);
    };
  } else {
    ret = Object.create(Object.getPrototypeOf(obj));
  }
  for (const key2 in obj) {
    const x2 = obj[key2];
    ret[key2] = typeof x2 === "function" && filter2(key2) ? processFn$1(x2, opts) : x2;
  }
  return ret;
};
var immutable = extend$3;
var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
function extend$3() {
  var target = {};
  for (var i2 = 0; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key2 in source) {
      if (hasOwnProperty$5.call(source, key2)) {
        target[key2] = source[key2];
      }
    }
  }
  return target;
}
var jsonRpcRandomId = IdIterator;
function IdIterator(opts) {
  opts = opts || {};
  var max2 = opts.max || Number.MAX_SAFE_INTEGER;
  var idCounter2 = typeof opts.start !== "undefined" ? opts.start : Math.floor(Math.random() * max2);
  return function createRandomId2() {
    idCounter2 = idCounter2 % max2;
    return idCounter2++;
  };
}
const extend$2 = immutable;
const createRandomId$1 = jsonRpcRandomId();
var ethQuery = EthQuery$1;
function EthQuery$1(provider) {
  const self2 = this;
  self2.currentProvider = provider;
}
EthQuery$1.prototype.getBalance = generateFnWithDefaultBlockFor(2, "eth_getBalance");
EthQuery$1.prototype.getCode = generateFnWithDefaultBlockFor(2, "eth_getCode");
EthQuery$1.prototype.getTransactionCount = generateFnWithDefaultBlockFor(2, "eth_getTransactionCount");
EthQuery$1.prototype.getStorageAt = generateFnWithDefaultBlockFor(3, "eth_getStorageAt");
EthQuery$1.prototype.call = generateFnWithDefaultBlockFor(2, "eth_call");
EthQuery$1.prototype.protocolVersion = generateFnFor("eth_protocolVersion");
EthQuery$1.prototype.syncing = generateFnFor("eth_syncing");
EthQuery$1.prototype.coinbase = generateFnFor("eth_coinbase");
EthQuery$1.prototype.mining = generateFnFor("eth_mining");
EthQuery$1.prototype.hashrate = generateFnFor("eth_hashrate");
EthQuery$1.prototype.gasPrice = generateFnFor("eth_gasPrice");
EthQuery$1.prototype.accounts = generateFnFor("eth_accounts");
EthQuery$1.prototype.blockNumber = generateFnFor("eth_blockNumber");
EthQuery$1.prototype.getBlockTransactionCountByHash = generateFnFor("eth_getBlockTransactionCountByHash");
EthQuery$1.prototype.getBlockTransactionCountByNumber = generateFnFor("eth_getBlockTransactionCountByNumber");
EthQuery$1.prototype.getUncleCountByBlockHash = generateFnFor("eth_getUncleCountByBlockHash");
EthQuery$1.prototype.getUncleCountByBlockNumber = generateFnFor("eth_getUncleCountByBlockNumber");
EthQuery$1.prototype.sign = generateFnFor("eth_sign");
EthQuery$1.prototype.sendTransaction = generateFnFor("eth_sendTransaction");
EthQuery$1.prototype.sendRawTransaction = generateFnFor("eth_sendRawTransaction");
EthQuery$1.prototype.estimateGas = generateFnFor("eth_estimateGas");
EthQuery$1.prototype.getBlockByHash = generateFnFor("eth_getBlockByHash");
EthQuery$1.prototype.getBlockByNumber = generateFnFor("eth_getBlockByNumber");
EthQuery$1.prototype.getTransactionByHash = generateFnFor("eth_getTransactionByHash");
EthQuery$1.prototype.getTransactionByBlockHashAndIndex = generateFnFor("eth_getTransactionByBlockHashAndIndex");
EthQuery$1.prototype.getTransactionByBlockNumberAndIndex = generateFnFor("eth_getTransactionByBlockNumberAndIndex");
EthQuery$1.prototype.getTransactionReceipt = generateFnFor("eth_getTransactionReceipt");
EthQuery$1.prototype.getUncleByBlockHashAndIndex = generateFnFor("eth_getUncleByBlockHashAndIndex");
EthQuery$1.prototype.getUncleByBlockNumberAndIndex = generateFnFor("eth_getUncleByBlockNumberAndIndex");
EthQuery$1.prototype.getCompilers = generateFnFor("eth_getCompilers");
EthQuery$1.prototype.compileLLL = generateFnFor("eth_compileLLL");
EthQuery$1.prototype.compileSolidity = generateFnFor("eth_compileSolidity");
EthQuery$1.prototype.compileSerpent = generateFnFor("eth_compileSerpent");
EthQuery$1.prototype.newFilter = generateFnFor("eth_newFilter");
EthQuery$1.prototype.newBlockFilter = generateFnFor("eth_newBlockFilter");
EthQuery$1.prototype.newPendingTransactionFilter = generateFnFor("eth_newPendingTransactionFilter");
EthQuery$1.prototype.uninstallFilter = generateFnFor("eth_uninstallFilter");
EthQuery$1.prototype.getFilterChanges = generateFnFor("eth_getFilterChanges");
EthQuery$1.prototype.getFilterLogs = generateFnFor("eth_getFilterLogs");
EthQuery$1.prototype.getLogs = generateFnFor("eth_getLogs");
EthQuery$1.prototype.getWork = generateFnFor("eth_getWork");
EthQuery$1.prototype.submitWork = generateFnFor("eth_submitWork");
EthQuery$1.prototype.submitHashrate = generateFnFor("eth_submitHashrate");
EthQuery$1.prototype.sendAsync = function(opts, cb) {
  const self2 = this;
  self2.currentProvider.sendAsync(createPayload$4(opts), function(err, response) {
    if (!err && response.error)
      err = new Error("EthQuery - RPC Error - " + response.error.message);
    if (err)
      return cb(err);
    cb(null, response.result);
  });
};
function generateFnFor(methodName) {
  return function() {
    const self2 = this;
    var args = [].slice.call(arguments);
    var cb = args.pop();
    self2.sendAsync({
      method: methodName,
      params: args
    }, cb);
  };
}
function generateFnWithDefaultBlockFor(argCount, methodName) {
  return function() {
    const self2 = this;
    var args = [].slice.call(arguments);
    var cb = args.pop();
    if (args.length < argCount)
      args.push("latest");
    self2.sendAsync({
      method: methodName,
      params: args
    }, cb);
  };
}
function createPayload$4(data) {
  return extend$2({
    id: createRandomId$1(),
    jsonrpc: "2.0",
    params: []
  }, data);
}
const util$6 = util$7;
const EventEmitter$3 = events$1.exports;
var R$1 = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R$1 && typeof R$1.apply === "function" ? R$1.apply : function ReflectApply3(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var safeEventEmitter$1 = SafeEventEmitter$4;
function SafeEventEmitter$4() {
  EventEmitter$3.call(this);
}
util$6.inherits(SafeEventEmitter$4, EventEmitter$3);
SafeEventEmitter$4.prototype.emit = function(type) {
  var args = [];
  for (var i2 = 1; i2 < arguments.length; i2++)
    args.push(arguments[i2]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    safeApply$1(handler, this, args);
  } else {
    var len2 = handler.length;
    var listeners2 = arrayClone$1(handler, len2);
    for (var i2 = 0; i2 < len2; ++i2)
      safeApply$1(listeners2[i2], this, args);
  }
  return true;
};
function safeApply$1(handler, context, args) {
  try {
    ReflectApply(handler, context, args);
  } catch (err) {
    setTimeout(() => {
      throw err;
    });
  }
}
function arrayClone$1(arr2, n2) {
  var copy3 = new Array(n2);
  for (var i2 = 0; i2 < n2; ++i2)
    copy3[i2] = arr2[i2];
  return copy3;
}
const SafeEventEmitter$3 = safeEventEmitter$1;
const sec$1 = 1e3;
const calculateSum = (accumulator, currentValue) => accumulator + currentValue;
const blockTrackerEvents = ["sync", "latest"];
class BaseBlockTracker$1 extends SafeEventEmitter$3 {
  constructor(opts = {}) {
    super();
    this._blockResetDuration = opts.blockResetDuration || 20 * sec$1;
    this._blockResetTimeout;
    this._currentBlock = null;
    this._isRunning = false;
    this._onNewListener = this._onNewListener.bind(this);
    this._onRemoveListener = this._onRemoveListener.bind(this);
    this._resetCurrentBlock = this._resetCurrentBlock.bind(this);
    this._setupInternalEvents();
  }
  isRunning() {
    return this._isRunning;
  }
  getCurrentBlock() {
    return this._currentBlock;
  }
  async getLatestBlock() {
    if (this._currentBlock)
      return this._currentBlock;
    const latestBlock = await new Promise((resolve2) => this.once("latest", resolve2));
    return latestBlock;
  }
  removeAllListeners(eventName) {
    if (eventName) {
      super.removeAllListeners(eventName);
    } else {
      super.removeAllListeners();
    }
    this._setupInternalEvents();
    this._onRemoveListener();
  }
  _start() {
  }
  _end() {
  }
  _setupInternalEvents() {
    this.removeListener("newListener", this._onNewListener);
    this.removeListener("removeListener", this._onRemoveListener);
    this.on("newListener", this._onNewListener);
    this.on("removeListener", this._onRemoveListener);
  }
  _onNewListener(eventName, handler) {
    if (!blockTrackerEvents.includes(eventName))
      return;
    this._maybeStart();
  }
  _onRemoveListener(eventName, handler) {
    if (this._getBlockTrackerEventCount() > 0)
      return;
    this._maybeEnd();
  }
  _maybeStart() {
    if (this._isRunning)
      return;
    this._isRunning = true;
    this._cancelBlockResetTimeout();
    this._start();
  }
  _maybeEnd() {
    if (!this._isRunning)
      return;
    this._isRunning = false;
    this._setupBlockResetTimeout();
    this._end();
  }
  _getBlockTrackerEventCount() {
    return blockTrackerEvents.map((eventName) => this.listenerCount(eventName)).reduce(calculateSum);
  }
  _newPotentialLatest(newBlock) {
    const currentBlock2 = this._currentBlock;
    if (currentBlock2 && hexToInt$4(newBlock) <= hexToInt$4(currentBlock2))
      return;
    this._setCurrentBlock(newBlock);
  }
  _setCurrentBlock(newBlock) {
    const oldBlock = this._currentBlock;
    this._currentBlock = newBlock;
    this.emit("latest", newBlock);
    this.emit("sync", { oldBlock, newBlock });
  }
  _setupBlockResetTimeout() {
    this._cancelBlockResetTimeout();
    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration);
    if (this._blockResetTimeout.unref) {
      this._blockResetTimeout.unref();
    }
  }
  _cancelBlockResetTimeout() {
    clearTimeout(this._blockResetTimeout);
  }
  _resetCurrentBlock() {
    this._currentBlock = null;
  }
}
var base = BaseBlockTracker$1;
function hexToInt$4(hexInt) {
  return Number.parseInt(hexInt, 16);
}
const pify$2 = pify$3;
const BaseBlockTracker = base;
const sec = 1e3;
class PollingBlockTracker$1 extends BaseBlockTracker {
  constructor(opts = {}) {
    if (!opts.provider)
      throw new Error("PollingBlockTracker - no provider specified.");
    const pollingInterval = opts.pollingInterval || 20 * sec;
    const retryTimeout = opts.retryTimeout || pollingInterval / 10;
    const keepEventLoopActive = opts.keepEventLoopActive !== void 0 ? opts.keepEventLoopActive : true;
    const setSkipCacheFlag = opts.setSkipCacheFlag || false;
    super(Object.assign({
      blockResetDuration: pollingInterval
    }, opts));
    this._provider = opts.provider;
    this._pollingInterval = pollingInterval;
    this._retryTimeout = retryTimeout;
    this._keepEventLoopActive = keepEventLoopActive;
    this._setSkipCacheFlag = setSkipCacheFlag;
  }
  async checkForLatestBlock() {
    await this._updateLatestBlock();
    return await this.getLatestBlock();
  }
  _start() {
    this._performSync().catch((err) => this.emit("error", err));
  }
  async _performSync() {
    while (this._isRunning) {
      try {
        await this._updateLatestBlock();
        await timeout$1(this._pollingInterval, !this._keepEventLoopActive);
      } catch (err) {
        const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${err.stack}`);
        try {
          this.emit("error", newErr);
        } catch (emitErr) {
          console.error(newErr);
        }
        await timeout$1(this._retryTimeout, !this._keepEventLoopActive);
      }
    }
  }
  async _updateLatestBlock() {
    const latestBlock = await this._fetchLatestBlock();
    this._newPotentialLatest(latestBlock);
  }
  async _fetchLatestBlock() {
    const req = { jsonrpc: "2.0", id: 1, method: "eth_blockNumber", params: [] };
    if (this._setSkipCacheFlag)
      req.skipCache = true;
    const res = await pify$2((cb) => this._provider.sendAsync(req, cb))();
    if (res.error)
      throw new Error(`PollingBlockTracker - encountered error fetching block:
${res.error}`);
    return res.result;
  }
}
var polling = PollingBlockTracker$1;
function timeout$1(duration, unref2) {
  return new Promise((resolve2) => {
    const timoutRef = setTimeout(resolve2, duration);
    if (timoutRef.unref && unref2) {
      timoutRef.unref();
    }
  });
}
var map$3 = { exports: {} };
var doParallel = { exports: {} };
var eachOf = { exports: {} };
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$1 = freeGlobal || freeSelf || Function("return this")();
var _root = root$1;
var root = _root;
var Symbol$3 = root.Symbol;
var _Symbol = Symbol$3;
var Symbol$2 = _Symbol;
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
var nativeObjectToString$1 = objectProto$5.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag$1(value2) {
  var isOwn = hasOwnProperty$4.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$4 = Object.prototype;
var nativeObjectToString = objectProto$4.toString;
function objectToString$1(value2) {
  return nativeObjectToString.call(value2);
}
var _objectToString = objectToString$1;
var Symbol$1 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag$3(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
var _baseGetTag = baseGetTag$3;
function isObject$2(value2) {
  var type = typeof value2;
  return value2 != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$2;
var baseGetTag$2 = _baseGetTag, isObject$1 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(value2) {
  if (!isObject$1(value2)) {
    return false;
  }
  var tag = baseGetTag$2(value2);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$2;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$2(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$2;
var isFunction$1 = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$2(value2) {
  return value2 != null && isLength$1(value2.length) && !isFunction$1(value2);
}
var isArrayLike_1 = isArrayLike$2;
var breakLoop = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = {};
  module2.exports = exports2["default"];
})(breakLoop, breakLoop.exports);
var eachOfLimit$1 = { exports: {} };
var eachOfLimit = { exports: {} };
function noop$4() {
}
var noop_1 = noop$4;
var once = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = once3;
  function once3(fn) {
    return function() {
      if (fn === null)
        return;
      var callFn = fn;
      fn = null;
      callFn.apply(this, arguments);
    };
  }
  module2.exports = exports2["default"];
})(once, once.exports);
var iterator$1 = { exports: {} };
var getIterator = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = function(coll) {
    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
  };
  var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
  module2.exports = exports2["default"];
})(getIterator, getIterator.exports);
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$3(value2) {
  return value2 != null && typeof value2 == "object";
}
var isObjectLike_1 = isObjectLike$3;
var baseGetTag$1 = _baseGetTag, isObjectLike$2 = isObjectLike_1;
var argsTag$1 = "[object Arguments]";
function baseIsArguments$1(value2) {
  return isObjectLike$2(value2) && baseGetTag$1(value2) == argsTag$1;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$1 = isObjectLike_1;
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
var isArguments$1 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value2) {
  return isObjectLike$1(value2) && hasOwnProperty$3.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
};
var isArguments_1 = isArguments$1;
var isArray$7 = Array.isArray;
var isArray_1 = isArray$7;
var isBuffer$2 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module2, exports2) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer4 = nativeIsBuffer || stubFalse2;
  module2.exports = isBuffer4;
})(isBuffer$2, isBuffer$2.exports);
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value2, length) {
  var type = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
var _isIndex = isIndex$1;
var baseGetTag = _baseGetTag, isLength = isLength_1, isObjectLike = isObjectLike_1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray$1(value2) {
  return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value2) {
    return func(value2);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
(function(module2, exports2) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module2.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$4 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$4;
var baseTimes = _baseTimes, isArguments = isArguments_1, isArray$6 = isArray_1, isBuffer$1 = isBuffer$2.exports, isIndex = _isIndex, isTypedArray$3 = isTypedArray_1;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function arrayLikeKeys$1(value2, inherited) {
  var isArr = isArray$6(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer$1(value2), isType = !isArr && !isArg && !isBuff && isTypedArray$3(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
  for (var key2 in value2) {
    if ((inherited || hasOwnProperty$2.call(value2, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length)))) {
      result.push(key2);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$1 = Object.prototype;
function isPrototype$1(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$1;
  return value2 === proto;
}
var _isPrototype = isPrototype$1;
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype, nativeKeys = _nativeKeys;
var objectProto = Object.prototype;
var hasOwnProperty$1 = objectProto.hasOwnProperty;
function baseKeys$1(object2) {
  if (!isPrototype(object2)) {
    return nativeKeys(object2);
  }
  var result = [];
  for (var key2 in Object(object2)) {
    if (hasOwnProperty$1.call(object2, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$1 = isArrayLike_1;
function keys(object2) {
  return isArrayLike$1(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
}
var keys_1 = keys;
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = iterator2;
  var _isArrayLike = isArrayLike_1;
  var _isArrayLike2 = _interopRequireDefault2(_isArrayLike);
  var _getIterator = getIterator.exports;
  var _getIterator2 = _interopRequireDefault2(_getIterator);
  var _keys = keys_1;
  var _keys2 = _interopRequireDefault2(_keys);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function createArrayIterator(coll) {
    var i2 = -1;
    var len2 = coll.length;
    return function next3() {
      return ++i2 < len2 ? { value: coll[i2], key: i2 } : null;
    };
  }
  function createES2015Iterator(iterator3) {
    var i2 = -1;
    return function next3() {
      var item = iterator3.next();
      if (item.done)
        return null;
      i2++;
      return { value: item.value, key: i2 };
    };
  }
  function createObjectIterator(obj) {
    var okeys = (0, _keys2.default)(obj);
    var i2 = -1;
    var len2 = okeys.length;
    return function next3() {
      var key2 = okeys[++i2];
      return i2 < len2 ? { value: obj[key2], key: key2 } : null;
    };
  }
  function iterator2(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
      return createArrayIterator(coll);
    }
    var iterator3 = (0, _getIterator2.default)(coll);
    return iterator3 ? createES2015Iterator(iterator3) : createObjectIterator(coll);
  }
  module2.exports = exports2["default"];
})(iterator$1, iterator$1.exports);
var onlyOnce = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = onlyOnce2;
  function onlyOnce2(fn) {
    return function() {
      if (fn === null)
        throw new Error("Callback was already called.");
      var callFn = fn;
      fn = null;
      callFn.apply(this, arguments);
    };
  }
  module2.exports = exports2["default"];
})(onlyOnce, onlyOnce.exports);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = _eachOfLimit;
  var _noop = noop_1;
  var _noop2 = _interopRequireDefault2(_noop);
  var _once = once.exports;
  var _once2 = _interopRequireDefault2(_once);
  var _iterator = iterator$1.exports;
  var _iterator2 = _interopRequireDefault2(_iterator);
  var _onlyOnce = onlyOnce.exports;
  var _onlyOnce2 = _interopRequireDefault2(_onlyOnce);
  var _breakLoop = breakLoop.exports;
  var _breakLoop2 = _interopRequireDefault2(_breakLoop);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _eachOfLimit(limit) {
    return function(obj, iteratee, callback) {
      callback = (0, _once2.default)(callback || _noop2.default);
      if (limit <= 0 || !obj) {
        return callback(null);
      }
      var nextElem = (0, _iterator2.default)(obj);
      var done2 = false;
      var running = 0;
      var looping = false;
      function iterateeCallback(err, value2) {
        running -= 1;
        if (err) {
          done2 = true;
          callback(err);
        } else if (value2 === _breakLoop2.default || done2 && running <= 0) {
          done2 = true;
          return callback(null);
        } else if (!looping) {
          replenish();
        }
      }
      function replenish() {
        looping = true;
        while (running < limit && !done2) {
          var elem = nextElem();
          if (elem === null) {
            done2 = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running += 1;
          iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
        }
        looping = false;
      }
      replenish();
    };
  }
  module2.exports = exports2["default"];
})(eachOfLimit, eachOfLimit.exports);
var wrapAsync$1 = {};
var asyncify = { exports: {} };
var initialParams = { exports: {} };
var slice = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = slice3;
  function slice3(arrayLike, start) {
    start = start | 0;
    var newLen = Math.max(arrayLike.length - start, 0);
    var newArr = Array(newLen);
    for (var idx = 0; idx < newLen; idx++) {
      newArr[idx] = arrayLike[start + idx];
    }
    return newArr;
  }
  module2.exports = exports2["default"];
})(slice, slice.exports);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = function(fn) {
    return function() {
      var args = (0, _slice22.default)(arguments);
      var callback = args.pop();
      fn.call(this, args, callback);
    };
  };
  var _slice3 = slice.exports;
  var _slice22 = _interopRequireDefault2(_slice3);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  module2.exports = exports2["default"];
})(initialParams, initialParams.exports);
var setImmediate$1 = {};
Object.defineProperty(setImmediate$1, "__esModule", {
  value: true
});
setImmediate$1.hasNextTick = setImmediate$1.hasSetImmediate = void 0;
setImmediate$1.fallback = fallback;
setImmediate$1.wrap = wrap;
var _slice = slice.exports;
var _slice2 = _interopRequireDefault$1(_slice);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var hasSetImmediate = setImmediate$1.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
var hasNextTick = setImmediate$1.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
function fallback(fn) {
  setTimeout(fn, 0);
}
function wrap(defer2) {
  return function(fn) {
    var args = (0, _slice2.default)(arguments, 1);
    defer2(function() {
      fn.apply(null, args);
    });
  };
}
var _defer;
if (hasSetImmediate) {
  _defer = setImmediate;
} else if (hasNextTick) {
  _defer = process.nextTick;
} else {
  _defer = fallback;
}
setImmediate$1.default = wrap(_defer);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = asyncify2;
  var _isObject = isObject_1;
  var _isObject2 = _interopRequireDefault2(_isObject);
  var _initialParams = initialParams.exports;
  var _initialParams2 = _interopRequireDefault2(_initialParams);
  var _setImmediate = setImmediate$1;
  var _setImmediate2 = _interopRequireDefault2(_setImmediate);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function asyncify2(func) {
    return (0, _initialParams2.default)(function(args, callback) {
      var result;
      try {
        result = func.apply(this, args);
      } catch (e2) {
        return callback(e2);
      }
      if ((0, _isObject2.default)(result) && typeof result.then === "function") {
        result.then(function(value2) {
          invokeCallback(callback, null, value2);
        }, function(err) {
          invokeCallback(callback, err.message ? err : new Error(err));
        });
      } else {
        callback(null, result);
      }
    });
  }
  function invokeCallback(callback, error2, value2) {
    try {
      callback(error2, value2);
    } catch (e2) {
      (0, _setImmediate2.default)(rethrow, e2);
    }
  }
  function rethrow(error2) {
    throw error2;
  }
  module2.exports = exports2["default"];
})(asyncify, asyncify.exports);
Object.defineProperty(wrapAsync$1, "__esModule", {
  value: true
});
wrapAsync$1.isAsync = void 0;
var _asyncify = asyncify.exports;
var _asyncify2 = _interopRequireDefault(_asyncify);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
var supportsSymbol = typeof Symbol === "function";
function isAsync(fn) {
  return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
}
function wrapAsync(asyncFn) {
  return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
}
wrapAsync$1.default = wrapAsync;
wrapAsync$1.isAsync = isAsync;
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = eachOfLimit$12;
  var _eachOfLimit2 = eachOfLimit.exports;
  var _eachOfLimit3 = _interopRequireDefault2(_eachOfLimit2);
  var _wrapAsync = wrapAsync$1;
  var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function eachOfLimit$12(coll, limit, iteratee, callback) {
    (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
  }
  module2.exports = exports2["default"];
})(eachOfLimit$1, eachOfLimit$1.exports);
var doLimit = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = doLimit2;
  function doLimit2(fn, limit) {
    return function(iterable, iteratee, callback) {
      return fn(iterable, limit, iteratee, callback);
    };
  }
  module2.exports = exports2["default"];
})(doLimit, doLimit.exports);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = function(coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
  };
  var _isArrayLike = isArrayLike_1;
  var _isArrayLike2 = _interopRequireDefault2(_isArrayLike);
  var _breakLoop = breakLoop.exports;
  var _breakLoop2 = _interopRequireDefault2(_breakLoop);
  var _eachOfLimit = eachOfLimit$1.exports;
  var _eachOfLimit2 = _interopRequireDefault2(_eachOfLimit);
  var _doLimit = doLimit.exports;
  var _doLimit2 = _interopRequireDefault2(_doLimit);
  var _noop = noop_1;
  var _noop2 = _interopRequireDefault2(_noop);
  var _once = once.exports;
  var _once2 = _interopRequireDefault2(_once);
  var _onlyOnce = onlyOnce.exports;
  var _onlyOnce2 = _interopRequireDefault2(_onlyOnce);
  var _wrapAsync = wrapAsync$1;
  var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function eachOfArrayLike(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback || _noop2.default);
    var index2 = 0, completed = 0, length = coll.length;
    if (length === 0) {
      callback(null);
    }
    function iteratorCallback(err, value2) {
      if (err) {
        callback(err);
      } else if (++completed === length || value2 === _breakLoop2.default) {
        callback(null);
      }
    }
    for (; index2 < length; index2++) {
      iteratee(coll[index2], index2, (0, _onlyOnce2.default)(iteratorCallback));
    }
  }
  var eachOfGeneric = (0, _doLimit2.default)(_eachOfLimit2.default, Infinity);
  module2.exports = exports2["default"];
})(eachOf, eachOf.exports);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = doParallel2;
  var _eachOf = eachOf.exports;
  var _eachOf2 = _interopRequireDefault2(_eachOf);
  var _wrapAsync = wrapAsync$1;
  var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function doParallel2(fn) {
    return function(obj, iteratee, callback) {
      return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
    };
  }
  module2.exports = exports2["default"];
})(doParallel, doParallel.exports);
var map$2 = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = _asyncMap;
  var _noop = noop_1;
  var _noop2 = _interopRequireDefault2(_noop);
  var _wrapAsync = wrapAsync$1;
  var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _asyncMap(eachfn, arr2, iteratee, callback) {
    callback = callback || _noop2.default;
    arr2 = arr2 || [];
    var results2 = [];
    var counter = 0;
    var _iteratee = (0, _wrapAsync2.default)(iteratee);
    eachfn(arr2, function(value2, _2, callback2) {
      var index2 = counter++;
      _iteratee(value2, function(err, v2) {
        results2[index2] = v2;
        callback2(err);
      });
    }, function(err) {
      callback(err, results2);
    });
  }
  module2.exports = exports2["default"];
})(map$2, map$2.exports);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _doParallel = doParallel.exports;
  var _doParallel2 = _interopRequireDefault2(_doParallel);
  var _map = map$2.exports;
  var _map2 = _interopRequireDefault2(_map);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  exports2.default = (0, _doParallel2.default)(_map2.default);
  module2.exports = exports2["default"];
})(map$3, map$3.exports);
var eachSeries$1 = { exports: {} };
var eachLimit = { exports: {} };
var withoutIndex = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = _withoutIndex;
  function _withoutIndex(iteratee) {
    return function(value2, index2, callback) {
      return iteratee(value2, callback);
    };
  }
  module2.exports = exports2["default"];
})(withoutIndex, withoutIndex.exports);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = eachLimit2;
  var _eachOfLimit = eachOfLimit.exports;
  var _eachOfLimit2 = _interopRequireDefault2(_eachOfLimit);
  var _withoutIndex = withoutIndex.exports;
  var _withoutIndex2 = _interopRequireDefault2(_withoutIndex);
  var _wrapAsync = wrapAsync$1;
  var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function eachLimit2(coll, limit, iteratee, callback) {
    (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
  }
  module2.exports = exports2["default"];
})(eachLimit, eachLimit.exports);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _eachLimit = eachLimit.exports;
  var _eachLimit2 = _interopRequireDefault2(_eachLimit);
  var _doLimit = doLimit.exports;
  var _doLimit2 = _interopRequireDefault2(_doLimit);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  exports2.default = (0, _doLimit2.default)(_eachLimit2.default, 1);
  module2.exports = exports2["default"];
})(eachSeries$1, eachSeries$1.exports);
const EventEmitter$2 = events$1.exports.EventEmitter;
const inherits$4 = util$7.inherits;
var stoplight = Stoplight$1;
inherits$4(Stoplight$1, EventEmitter$2);
function Stoplight$1() {
  const self2 = this;
  EventEmitter$2.call(self2);
  self2.isLocked = true;
}
Stoplight$1.prototype.go = function() {
  const self2 = this;
  self2.isLocked = false;
  self2.emit("unlock");
};
Stoplight$1.prototype.stop = function() {
  const self2 = this;
  self2.isLocked = true;
  self2.emit("lock");
};
Stoplight$1.prototype.await = function(fn) {
  const self2 = this;
  if (self2.isLocked) {
    self2.once("unlock", fn);
  } else {
    setTimeout(fn);
  }
};
var jsonify$1 = {};
var at, ch, escapee = {
  '"': '"',
  "\\": "\\",
  "/": "/",
  b: "\b",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	"
}, text, error$1 = function(m2) {
  throw {
    name: "SyntaxError",
    message: m2,
    at,
    text
  };
}, next = function(c2) {
  if (c2 && c2 !== ch) {
    error$1("Expected '" + c2 + "' instead of '" + ch + "'");
  }
  ch = text.charAt(at);
  at += 1;
  return ch;
}, number = function() {
  var number2, string2 = "";
  if (ch === "-") {
    string2 = "-";
    next("-");
  }
  while (ch >= "0" && ch <= "9") {
    string2 += ch;
    next();
  }
  if (ch === ".") {
    string2 += ".";
    while (next() && ch >= "0" && ch <= "9") {
      string2 += ch;
    }
  }
  if (ch === "e" || ch === "E") {
    string2 += ch;
    next();
    if (ch === "-" || ch === "+") {
      string2 += ch;
      next();
    }
    while (ch >= "0" && ch <= "9") {
      string2 += ch;
      next();
    }
  }
  number2 = +string2;
  if (!isFinite(number2)) {
    error$1("Bad number");
  } else {
    return number2;
  }
}, string = function() {
  var hex, i2, string2 = "", uffff;
  if (ch === '"') {
    while (next()) {
      if (ch === '"') {
        next();
        return string2;
      } else if (ch === "\\") {
        next();
        if (ch === "u") {
          uffff = 0;
          for (i2 = 0; i2 < 4; i2 += 1) {
            hex = parseInt(next(), 16);
            if (!isFinite(hex)) {
              break;
            }
            uffff = uffff * 16 + hex;
          }
          string2 += String.fromCharCode(uffff);
        } else if (typeof escapee[ch] === "string") {
          string2 += escapee[ch];
        } else {
          break;
        }
      } else {
        string2 += ch;
      }
    }
  }
  error$1("Bad string");
}, white = function() {
  while (ch && ch <= " ") {
    next();
  }
}, word = function() {
  switch (ch) {
    case "t":
      next("t");
      next("r");
      next("u");
      next("e");
      return true;
    case "f":
      next("f");
      next("a");
      next("l");
      next("s");
      next("e");
      return false;
    case "n":
      next("n");
      next("u");
      next("l");
      next("l");
      return null;
  }
  error$1("Unexpected '" + ch + "'");
}, value, array = function() {
  var array2 = [];
  if (ch === "[") {
    next("[");
    white();
    if (ch === "]") {
      next("]");
      return array2;
    }
    while (ch) {
      array2.push(value());
      white();
      if (ch === "]") {
        next("]");
        return array2;
      }
      next(",");
      white();
    }
  }
  error$1("Bad array");
}, object$1 = function() {
  var key2, object2 = {};
  if (ch === "{") {
    next("{");
    white();
    if (ch === "}") {
      next("}");
      return object2;
    }
    while (ch) {
      key2 = string();
      white();
      next(":");
      if (Object.hasOwnProperty.call(object2, key2)) {
        error$1('Duplicate key "' + key2 + '"');
      }
      object2[key2] = value();
      white();
      if (ch === "}") {
        next("}");
        return object2;
      }
      next(",");
      white();
    }
  }
  error$1("Bad object");
};
value = function() {
  white();
  switch (ch) {
    case "{":
      return object$1();
    case "[":
      return array();
    case '"':
      return string();
    case "-":
      return number();
    default:
      return ch >= "0" && ch <= "9" ? number() : word();
  }
};
var parse = function(source, reviver) {
  var result;
  text = source;
  at = 0;
  ch = " ";
  result = value();
  white();
  if (ch) {
    error$1("Syntax error");
  }
  return typeof reviver === "function" ? function walk(holder, key2) {
    var k2, v2, value2 = holder[key2];
    if (value2 && typeof value2 === "object") {
      for (k2 in value2) {
        if (Object.prototype.hasOwnProperty.call(value2, k2)) {
          v2 = walk(value2, k2);
          if (v2 !== void 0) {
            value2[k2] = v2;
          } else {
            delete value2[k2];
          }
        }
      }
    }
    return reviver.call(holder, key2, value2);
  }({ "": result }, "") : result;
};
var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  '"': '\\"',
  "\\": "\\\\"
}, rep;
function quote(string2) {
  escapable.lastIndex = 0;
  return escapable.test(string2) ? '"' + string2.replace(escapable, function(a2) {
    var c2 = meta[a2];
    return typeof c2 === "string" ? c2 : "\\u" + ("0000" + a2.charCodeAt(0).toString(16)).slice(-4);
  }) + '"' : '"' + string2 + '"';
}
function str(key2, holder) {
  var i2, k2, v2, length, mind = gap, partial, value2 = holder[key2];
  if (value2 && typeof value2 === "object" && typeof value2.toJSON === "function") {
    value2 = value2.toJSON(key2);
  }
  if (typeof rep === "function") {
    value2 = rep.call(holder, key2, value2);
  }
  switch (typeof value2) {
    case "string":
      return quote(value2);
    case "number":
      return isFinite(value2) ? String(value2) : "null";
    case "boolean":
    case "null":
      return String(value2);
    case "object":
      if (!value2)
        return "null";
      gap += indent;
      partial = [];
      if (Object.prototype.toString.apply(value2) === "[object Array]") {
        length = value2.length;
        for (i2 = 0; i2 < length; i2 += 1) {
          partial[i2] = str(i2, value2) || "null";
        }
        v2 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
        gap = mind;
        return v2;
      }
      if (rep && typeof rep === "object") {
        length = rep.length;
        for (i2 = 0; i2 < length; i2 += 1) {
          k2 = rep[i2];
          if (typeof k2 === "string") {
            v2 = str(k2, value2);
            if (v2) {
              partial.push(quote(k2) + (gap ? ": " : ":") + v2);
            }
          }
        }
      } else {
        for (k2 in value2) {
          if (Object.prototype.hasOwnProperty.call(value2, k2)) {
            v2 = str(k2, value2);
            if (v2) {
              partial.push(quote(k2) + (gap ? ": " : ":") + v2);
            }
          }
        }
      }
      v2 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
      gap = mind;
      return v2;
  }
}
var stringify$4 = function(value2, replacer2, space) {
  var i2;
  gap = "";
  indent = "";
  if (typeof space === "number") {
    for (i2 = 0; i2 < space; i2 += 1) {
      indent += " ";
    }
  } else if (typeof space === "string") {
    indent = space;
  }
  rep = replacer2;
  if (replacer2 && typeof replacer2 !== "function" && (typeof replacer2 !== "object" || typeof replacer2.length !== "number")) {
    throw new Error("JSON.stringify");
  }
  return str("", { "": value2 });
};
jsonify$1.parse = parse;
jsonify$1.stringify = stringify$4;
var json = typeof JSON !== "undefined" ? JSON : jsonify$1;
var jsonStableStringify = function(obj, opts) {
  if (!opts)
    opts = {};
  if (typeof opts === "function")
    opts = { cmp: opts };
  var space = opts.space || "";
  if (typeof space === "number")
    space = Array(space + 1).join(" ");
  var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
  var replacer2 = opts.replacer || function(key2, value2) {
    return value2;
  };
  var cmp = opts.cmp && function(f2) {
    return function(node) {
      return function(a2, b2) {
        var aobj = { key: a2, value: node[a2] };
        var bobj = { key: b2, value: node[b2] };
        return f2(aobj, bobj);
      };
    };
  }(opts.cmp);
  var seen = [];
  return function stringify2(parent, key2, node, level) {
    var indent2 = space ? "\n" + new Array(level + 1).join(space) : "";
    var colonSeparator = space ? ": " : ":";
    if (node && node.toJSON && typeof node.toJSON === "function") {
      node = node.toJSON();
    }
    node = replacer2.call(parent, key2, node);
    if (node === void 0) {
      return;
    }
    if (typeof node !== "object" || node === null) {
      return json.stringify(node);
    }
    if (isArray$5(node)) {
      var out = [];
      for (var i2 = 0; i2 < node.length; i2++) {
        var item = stringify2(node, i2, node[i2], level + 1) || json.stringify(null);
        out.push(indent2 + space + item);
      }
      return "[" + out.join(",") + indent2 + "]";
    } else {
      if (seen.indexOf(node) !== -1) {
        if (cycles)
          return json.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      } else
        seen.push(node);
      var keys2 = objectKeys(node).sort(cmp && cmp(node));
      var out = [];
      for (var i2 = 0; i2 < keys2.length; i2++) {
        var key2 = keys2[i2];
        var value2 = stringify2(node, key2, node[key2], level + 1);
        if (!value2)
          continue;
        var keyValue = json.stringify(key2) + colonSeparator + value2;
        out.push(indent2 + space + keyValue);
      }
      seen.splice(seen.indexOf(node), 1);
      return "{" + out.join(",") + indent2 + "}";
    }
  }({ "": obj }, "", obj, 0);
};
var isArray$5 = Array.isArray || function(x2) {
  return {}.toString.call(x2) === "[object Array]";
};
var objectKeys = Object.keys || function(obj) {
  var has2 = Object.prototype.hasOwnProperty || function() {
    return true;
  };
  var keys2 = [];
  for (var key2 in obj) {
    if (has2.call(obj, key2))
      keys2.push(key2);
  }
  return keys2;
};
const stringify$3 = jsonStableStringify;
var rpcCacheUtils = {
  cacheIdentifierForPayload: cacheIdentifierForPayload$1,
  canCache: canCache$1,
  blockTagForPayload: blockTagForPayload$2,
  paramsWithoutBlockTag: paramsWithoutBlockTag$1,
  blockTagParamIndex: blockTagParamIndex$1,
  cacheTypeForPayload: cacheTypeForPayload$1
};
function cacheIdentifierForPayload$1(payload, opts = {}) {
  if (!canCache$1(payload))
    return null;
  const { includeBlockRef } = opts;
  const params = includeBlockRef ? payload.params : paramsWithoutBlockTag$1(payload);
  return payload.method + ":" + stringify$3(params);
}
function canCache$1(payload) {
  return cacheTypeForPayload$1(payload) !== "never";
}
function blockTagForPayload$2(payload) {
  var index2 = blockTagParamIndex$1(payload);
  if (index2 >= payload.params.length) {
    return null;
  }
  return payload.params[index2];
}
function paramsWithoutBlockTag$1(payload) {
  var index2 = blockTagParamIndex$1(payload);
  if (index2 >= payload.params.length) {
    return payload.params;
  }
  if (payload.method === "eth_getBlockByNumber") {
    return payload.params.slice(1);
  }
  return payload.params.slice(0, index2);
}
function blockTagParamIndex$1(payload) {
  switch (payload.method) {
    case "eth_getStorageAt":
      return 2;
    case "eth_getBalance":
    case "eth_getCode":
    case "eth_getTransactionCount":
    case "eth_call":
    case "eth_estimateGas":
      return 1;
    case "eth_getBlockByNumber":
      return 0;
    default:
      return void 0;
  }
}
function cacheTypeForPayload$1(payload) {
  switch (payload.method) {
    case "web3_clientVersion":
    case "web3_sha3":
    case "eth_protocolVersion":
    case "eth_getBlockTransactionCountByHash":
    case "eth_getUncleCountByBlockHash":
    case "eth_getCode":
    case "eth_getBlockByHash":
    case "eth_getTransactionByHash":
    case "eth_getTransactionByBlockHashAndIndex":
    case "eth_getTransactionReceipt":
    case "eth_getUncleByBlockHashAndIndex":
    case "eth_getCompilers":
    case "eth_compileLLL":
    case "eth_compileSolidity":
    case "eth_compileSerpent":
    case "shh_version":
      return "perma";
    case "eth_getBlockByNumber":
    case "eth_getBlockTransactionCountByNumber":
    case "eth_getUncleCountByBlockNumber":
    case "eth_getTransactionByBlockNumberAndIndex":
    case "eth_getUncleByBlockNumberAndIndex":
      return "fork";
    case "eth_gasPrice":
    case "eth_getBalance":
    case "eth_getStorageAt":
    case "eth_getTransactionCount":
    case "eth_call":
    case "eth_estimateGas":
    case "eth_getFilterLogs":
    case "eth_getLogs":
    case "eth_blockNumber":
      return "block";
    case "net_version":
    case "net_peerCount":
    case "net_listening":
    case "eth_syncing":
    case "eth_sign":
    case "eth_coinbase":
    case "eth_mining":
    case "eth_hashrate":
    case "eth_accounts":
    case "eth_sendTransaction":
    case "eth_sendRawTransaction":
    case "eth_newFilter":
    case "eth_newBlockFilter":
    case "eth_newPendingTransactionFilter":
    case "eth_uninstallFilter":
    case "eth_getFilterChanges":
    case "eth_getWork":
    case "eth_submitWork":
    case "eth_submitHashrate":
    case "db_putString":
    case "db_getString":
    case "db_putHex":
    case "db_getHex":
    case "shh_post":
    case "shh_newIdentity":
    case "shh_hasIdentity":
    case "shh_newGroup":
    case "shh_addToGroup":
    case "shh_newFilter":
    case "shh_uninstallFilter":
    case "shh_getFilterChanges":
    case "shh_getMessages":
      return "never";
  }
}
var randomId = createRandomId;
function createRandomId() {
  return Math.floor(Number.MAX_SAFE_INTEGER * Math.random());
}
const getRandomId = randomId;
const extend$1 = immutable;
var createPayload_1 = createPayload$3;
function createPayload$3(data) {
  return extend$1({
    id: getRandomId(),
    jsonrpc: "2.0",
    params: []
  }, data);
}
const EventEmitter$1 = events$1.exports.EventEmitter;
const inherits$3 = util$7.inherits;
const ethUtil$4 = dist$5;
const EthBlockTracker = polling;
const map$1 = map$3.exports;
const eachSeries = eachSeries$1.exports;
const Stoplight = stoplight;
const createPayload$2 = createPayload_1;
const noop$3 = function() {
};
var web3ProviderEngine = Web3ProviderEngine;
inherits$3(Web3ProviderEngine, EventEmitter$1);
function Web3ProviderEngine(opts) {
  const self2 = this;
  EventEmitter$1.call(self2);
  self2.setMaxListeners(30);
  opts = opts || {};
  const directProvider = { sendAsync: self2._handleAsync.bind(self2) };
  const blockTrackerProvider = opts.blockTrackerProvider || directProvider;
  self2._blockTracker = opts.blockTracker || new EthBlockTracker({
    provider: blockTrackerProvider,
    pollingInterval: opts.pollingInterval || 4e3,
    setSkipCacheFlag: true
  });
  self2._ready = new Stoplight();
  self2.currentBlock = null;
  self2._providers = [];
}
Web3ProviderEngine.prototype.start = function(cb = noop$3) {
  const self2 = this;
  self2._ready.go();
  self2._blockTracker.on("latest", (blockNumber) => {
    self2._getBlockByNumberWithRetry(blockNumber, (err, block) => {
      if (err) {
        this.emit("error", err);
        return;
      }
      if (!block) {
        console.log(block);
        this.emit("error", new Error("Could not find block"));
        return;
      }
      const bufferBlock = toBufferBlock(block);
      self2._setCurrentBlock(bufferBlock);
      self2.emit("rawBlock", block);
      self2.emit("latest", block);
    });
  });
  self2._blockTracker.on("sync", self2.emit.bind(self2, "sync"));
  self2._blockTracker.on("error", self2.emit.bind(self2, "error"));
  self2._running = true;
  self2.emit("start");
};
Web3ProviderEngine.prototype.stop = function() {
  const self2 = this;
  self2._blockTracker.removeAllListeners();
  self2._running = false;
  self2.emit("stop");
};
Web3ProviderEngine.prototype.isRunning = function() {
  const self2 = this;
  return self2._running;
};
Web3ProviderEngine.prototype.addProvider = function(source, index2) {
  const self2 = this;
  if (typeof index2 === "number") {
    self2._providers.splice(index2, 0, source);
  } else {
    self2._providers.push(source);
  }
  source.setEngine(this);
};
Web3ProviderEngine.prototype.removeProvider = function(source) {
  const self2 = this;
  const index2 = self2._providers.indexOf(source);
  if (index2 < 0)
    throw new Error("Provider not found.");
  self2._providers.splice(index2, 1);
};
Web3ProviderEngine.prototype.send = function(payload) {
  throw new Error("Web3ProviderEngine does not support synchronous requests.");
};
Web3ProviderEngine.prototype.sendAsync = function(payload, cb) {
  const self2 = this;
  self2._ready.await(function() {
    if (Array.isArray(payload)) {
      map$1(payload, self2._handleAsync.bind(self2), cb);
    } else {
      self2._handleAsync(payload, cb);
    }
  });
};
Web3ProviderEngine.prototype._getBlockByNumberWithRetry = function(blockNumber, cb) {
  const self2 = this;
  let retriesRemaining = 5;
  attemptRequest();
  return;
  function attemptRequest() {
    self2._getBlockByNumber(blockNumber, afterRequest);
  }
  function afterRequest(err, block) {
    if (err)
      return cb(err);
    if (!block) {
      if (retriesRemaining > 0) {
        retriesRemaining--;
        setTimeout(function() {
          attemptRequest();
        }, 1e3);
        return;
      } else {
        cb(null, null);
        return;
      }
    }
    cb(null, block);
    return;
  }
};
Web3ProviderEngine.prototype._getBlockByNumber = function(blockNumber, cb) {
  const req = createPayload$2({ method: "eth_getBlockByNumber", params: [blockNumber, false], skipCache: true });
  this._handleAsync(req, (err, res) => {
    if (err)
      return cb(err);
    return cb(null, res.result);
  });
};
Web3ProviderEngine.prototype._handleAsync = function(payload, finished2) {
  var self2 = this;
  var currentProvider = -1;
  var result = null;
  var error2 = null;
  var stack = [];
  next3();
  function next3(after) {
    currentProvider += 1;
    stack.unshift(after);
    if (currentProvider >= self2._providers.length) {
      end(new Error('Request for method "' + payload.method + '" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'));
    } else {
      try {
        var provider = self2._providers[currentProvider];
        provider.handleRequest(payload, next3, end);
      } catch (e2) {
        end(e2);
      }
    }
  }
  function end(_error, _result) {
    error2 = _error;
    result = _result;
    eachSeries(stack, function(fn, callback) {
      if (fn) {
        fn(error2, result, callback);
      } else {
        callback();
      }
    }, function() {
      var resultObj = {
        id: payload.id,
        jsonrpc: payload.jsonrpc,
        result
      };
      if (error2 != null) {
        resultObj.error = {
          message: error2.stack || error2.message || error2,
          code: -32e3
        };
        finished2(error2, resultObj);
      } else {
        finished2(null, resultObj);
      }
    });
  }
};
Web3ProviderEngine.prototype._setCurrentBlock = function(block) {
  const self2 = this;
  self2.currentBlock = block;
  self2.emit("block", block);
};
function toBufferBlock(jsonBlock) {
  return {
    number: ethUtil$4.toBuffer(jsonBlock.number),
    hash: ethUtil$4.toBuffer(jsonBlock.hash),
    parentHash: ethUtil$4.toBuffer(jsonBlock.parentHash),
    nonce: ethUtil$4.toBuffer(jsonBlock.nonce),
    mixHash: ethUtil$4.toBuffer(jsonBlock.mixHash),
    sha3Uncles: ethUtil$4.toBuffer(jsonBlock.sha3Uncles),
    logsBloom: ethUtil$4.toBuffer(jsonBlock.logsBloom),
    transactionsRoot: ethUtil$4.toBuffer(jsonBlock.transactionsRoot),
    stateRoot: ethUtil$4.toBuffer(jsonBlock.stateRoot),
    receiptsRoot: ethUtil$4.toBuffer(jsonBlock.receiptRoot || jsonBlock.receiptsRoot),
    miner: ethUtil$4.toBuffer(jsonBlock.miner),
    difficulty: ethUtil$4.toBuffer(jsonBlock.difficulty),
    totalDifficulty: ethUtil$4.toBuffer(jsonBlock.totalDifficulty),
    size: ethUtil$4.toBuffer(jsonBlock.size),
    extraData: ethUtil$4.toBuffer(jsonBlock.extraData),
    gasLimit: ethUtil$4.toBuffer(jsonBlock.gasLimit),
    gasUsed: ethUtil$4.toBuffer(jsonBlock.gasUsed),
    timestamp: ethUtil$4.toBuffer(jsonBlock.timestamp),
    transactions: jsonBlock.transactions
  };
}
const createPayload$1 = createPayload_1;
var subprovider = SubProvider;
function SubProvider() {
}
SubProvider.prototype.setEngine = function(engine) {
  const self2 = this;
  if (self2.engine)
    return;
  self2.engine = engine;
  engine.on("block", function(block) {
    self2.currentBlock = block;
  });
  engine.on("start", function() {
    self2.start();
  });
  engine.on("stop", function() {
    self2.stop();
  });
};
SubProvider.prototype.handleRequest = function(payload, next3, end) {
  throw new Error("Subproviders should override `handleRequest`.");
};
SubProvider.prototype.emitPayload = function(payload, cb) {
  const self2 = this;
  self2.engine.sendAsync(createPayload$1(payload), cb);
};
SubProvider.prototype.stop = function() {
};
SubProvider.prototype.start = function() {
};
const Subprovider$3 = subprovider;
class JsonRpcEngineMiddlewareSubprovider extends Subprovider$3 {
  constructor(constructorFn) {
    super();
    if (!constructorFn)
      throw new Error("JsonRpcEngineMiddlewareSubprovider - no constructorFn specified");
    this._constructorFn = constructorFn;
  }
  setEngine(engine) {
    if (this.middleware)
      throw new Error("JsonRpcEngineMiddlewareSubprovider - subprovider added to engine twice");
    const blockTracker = engine._blockTracker;
    const middleware = this._constructorFn({ engine, provider: engine, blockTracker });
    if (!middleware)
      throw new Error("JsonRpcEngineMiddlewareSubprovider - _constructorFn did not return middleware");
    if (typeof middleware !== "function")
      throw new Error("JsonRpcEngineMiddlewareSubprovider - specified middleware is not a function");
    this.middleware = middleware;
  }
  handleRequest(req, provEngNext, provEngEnd) {
    const res = { id: req.id };
    this.middleware(req, res, middlewareNext, middlewareEnd);
    function middlewareNext(handler) {
      provEngNext((err, result, cb) => {
        if (err) {
          delete res.result;
          res.error = { message: err.message || err };
        } else {
          res.result = result;
        }
        if (handler) {
          handler(cb);
        } else {
          cb();
        }
      });
    }
    function middlewareEnd(err) {
      if (err)
        return provEngEnd(err);
      provEngEnd(null, res.result);
    }
  }
}
var jsonRpcEngineMiddleware = JsonRpcEngineMiddlewareSubprovider;
const stringify$2 = jsonStableStringify;
var cacheUtils$1 = {
  cacheIdentifierForPayload,
  canCache,
  blockTagForPayload: blockTagForPayload$1,
  paramsWithoutBlockTag,
  blockTagParamIndex,
  cacheTypeForPayload
};
function cacheIdentifierForPayload(payload, skipBlockRef) {
  const simpleParams = skipBlockRef ? paramsWithoutBlockTag(payload) : payload.params;
  if (canCache(payload)) {
    return payload.method + ":" + stringify$2(simpleParams);
  } else {
    return null;
  }
}
function canCache(payload) {
  return cacheTypeForPayload(payload) !== "never";
}
function blockTagForPayload$1(payload) {
  let index2 = blockTagParamIndex(payload);
  if (index2 >= payload.params.length) {
    return null;
  }
  return payload.params[index2];
}
function paramsWithoutBlockTag(payload) {
  const index2 = blockTagParamIndex(payload);
  if (index2 >= payload.params.length) {
    return payload.params;
  }
  if (payload.method === "eth_getBlockByNumber") {
    return payload.params.slice(1);
  }
  return payload.params.slice(0, index2);
}
function blockTagParamIndex(payload) {
  switch (payload.method) {
    case "eth_getStorageAt":
      return 2;
    case "eth_getBalance":
    case "eth_getCode":
    case "eth_getTransactionCount":
    case "eth_call":
      return 1;
    case "eth_getBlockByNumber":
      return 0;
    default:
      return void 0;
  }
}
function cacheTypeForPayload(payload) {
  switch (payload.method) {
    case "web3_clientVersion":
    case "web3_sha3":
    case "eth_protocolVersion":
    case "eth_getBlockTransactionCountByHash":
    case "eth_getUncleCountByBlockHash":
    case "eth_getCode":
    case "eth_getBlockByHash":
    case "eth_getTransactionByHash":
    case "eth_getTransactionByBlockHashAndIndex":
    case "eth_getTransactionReceipt":
    case "eth_getUncleByBlockHashAndIndex":
    case "eth_getCompilers":
    case "eth_compileLLL":
    case "eth_compileSolidity":
    case "eth_compileSerpent":
    case "shh_version":
    case "test_permaCache":
      return "perma";
    case "eth_getBlockByNumber":
    case "eth_getBlockTransactionCountByNumber":
    case "eth_getUncleCountByBlockNumber":
    case "eth_getTransactionByBlockNumberAndIndex":
    case "eth_getUncleByBlockNumberAndIndex":
    case "test_forkCache":
      return "fork";
    case "eth_gasPrice":
    case "eth_blockNumber":
    case "eth_getBalance":
    case "eth_getStorageAt":
    case "eth_getTransactionCount":
    case "eth_call":
    case "eth_estimateGas":
    case "eth_getFilterLogs":
    case "eth_getLogs":
    case "test_blockCache":
      return "block";
    case "net_version":
    case "net_peerCount":
    case "net_listening":
    case "eth_syncing":
    case "eth_sign":
    case "eth_coinbase":
    case "eth_mining":
    case "eth_hashrate":
    case "eth_accounts":
    case "eth_sendTransaction":
    case "eth_sendRawTransaction":
    case "eth_newFilter":
    case "eth_newBlockFilter":
    case "eth_newPendingTransactionFilter":
    case "eth_uninstallFilter":
    case "eth_getFilterChanges":
    case "eth_getWork":
    case "eth_submitWork":
    case "eth_submitHashrate":
    case "db_putString":
    case "db_getString":
    case "db_putHex":
    case "db_getHex":
    case "shh_post":
    case "shh_newIdentity":
    case "shh_hasIdentity":
    case "shh_newGroup":
    case "shh_addToGroup":
    case "shh_newFilter":
    case "shh_uninstallFilter":
    case "shh_getFilterChanges":
    case "shh_getMessages":
    case "test_neverCache":
      return "never";
  }
}
var createAsyncMiddleware$5 = function createAsyncMiddleware2(asyncMiddleware) {
  return (req, res, next3, end) => {
    let resolveNextPromise;
    const nextPromise = new Promise((resolve2) => {
      resolveNextPromise = resolve2;
    });
    let returnHandlerCallback, nextWasCalled;
    const asyncNext = async () => {
      nextWasCalled = true;
      next3((callback) => {
        returnHandlerCallback = callback;
        resolveNextPromise();
      });
      await nextPromise;
    };
    asyncMiddleware(req, res, asyncNext).then(async () => {
      if (nextWasCalled) {
        await nextPromise;
        returnHandlerCallback(null);
      } else {
        end(null);
      }
    }).catch((error2) => {
      if (returnHandlerCallback) {
        returnHandlerCallback(error2);
      } else {
        end(error2);
      }
    });
  };
};
const cacheUtils = cacheUtils$1;
const createAsyncMiddleware$4 = createAsyncMiddleware$5;
const emptyValues = [void 0, null, "<nil>"];
var blockCache = createBlockCacheMiddleware$1;
function createBlockCacheMiddleware$1(opts = {}) {
  const { blockTracker } = opts;
  if (!blockTracker)
    throw new Error("createBlockCacheMiddleware - No BlockTracker specified");
  const blockCache2 = new BlockCacheStrategy();
  const strategies = {
    perma: blockCache2,
    block: blockCache2,
    fork: blockCache2
  };
  return createAsyncMiddleware$4(async (req, res, next3) => {
    if (req.skipCache) {
      return next3();
    }
    const type = cacheUtils.cacheTypeForPayload(req);
    const strategy = strategies[type];
    if (!strategy) {
      return next3();
    }
    if (!strategy.canCacheRequest(req)) {
      return next3();
    }
    let blockTag = cacheUtils.blockTagForPayload(req);
    if (!blockTag)
      blockTag = "latest";
    let requestedBlockNumber;
    if (blockTag === "earliest") {
      requestedBlockNumber = "0x00";
    } else if (blockTag === "latest") {
      const latestBlockNumber = await blockTracker.getLatestBlock();
      blockCache2.clearBefore(latestBlockNumber);
      requestedBlockNumber = latestBlockNumber;
    } else {
      requestedBlockNumber = blockTag;
    }
    const cacheResult = await strategy.get(req, requestedBlockNumber);
    if (cacheResult === void 0) {
      await next3();
      await strategy.set(req, requestedBlockNumber, res.result);
    } else {
      res.result = cacheResult;
    }
  });
}
class BlockCacheStrategy {
  constructor() {
    this.cache = {};
  }
  getBlockCacheForPayload(payload, blockNumberHex) {
    const blockNumber = Number.parseInt(blockNumberHex, 16);
    let blockCache2 = this.cache[blockNumber];
    if (!blockCache2) {
      const newCache = {};
      this.cache[blockNumber] = newCache;
      blockCache2 = newCache;
    }
    return blockCache2;
  }
  async get(payload, requestedBlockNumber) {
    const blockCache2 = this.getBlockCacheForPayload(payload, requestedBlockNumber);
    if (!blockCache2)
      return;
    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
    const cached = blockCache2[identifier];
    return cached;
  }
  async set(payload, requestedBlockNumber, result) {
    const canCache2 = this.canCacheResult(payload, result);
    if (!canCache2)
      return;
    const blockCache2 = this.getBlockCacheForPayload(payload, requestedBlockNumber);
    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
    blockCache2[identifier] = result;
  }
  canCacheRequest(payload) {
    if (!cacheUtils.canCache(payload)) {
      return false;
    }
    const blockTag = cacheUtils.blockTagForPayload(payload);
    if (blockTag === "pending") {
      return false;
    }
    return true;
  }
  canCacheResult(payload, result) {
    if (emptyValues.includes(result))
      return;
    if (["eth_getTransactionByHash", "eth_getTransactionReceipt"].includes(payload.method)) {
      if (!result || !result.blockHash || result.blockHash === "0x0000000000000000000000000000000000000000000000000000000000000000") {
        return false;
      }
    }
    return true;
  }
  clearBefore(oldBlockHex) {
    const self2 = this;
    const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
    Object.keys(self2.cache).map(Number).filter((num) => num < oldBlockNumber).forEach((num) => delete self2.cache[num]);
  }
}
const ProviderSubprovider$2 = jsonRpcEngineMiddleware;
const createBlockCacheMiddleware = blockCache;
class BlockCacheSubprovider extends ProviderSubprovider$2 {
  constructor(opts) {
    super(({ blockTracker }) => createBlockCacheMiddleware(Object.assign({ blockTracker }, opts)));
  }
}
var cache = BlockCacheSubprovider;
const inherits$2 = util$7.inherits;
const Subprovider$2 = subprovider;
var fixture = FixtureProvider;
inherits$2(FixtureProvider, Subprovider$2);
function FixtureProvider(staticResponses) {
  const self2 = this;
  staticResponses = staticResponses || {};
  self2.staticResponses = staticResponses;
}
FixtureProvider.prototype.handleRequest = function(payload, next3, end) {
  const self2 = this;
  var staticResponse = self2.staticResponses[payload.method];
  if (typeof staticResponse === "function") {
    staticResponse(payload, next3, end);
  } else if (staticResponse !== void 0) {
    setTimeout(() => end(null, staticResponse));
  } else {
    next3();
  }
};
var lib$1 = {};
var Mutex$2 = {};
var tslib = { exports: {} };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
(function(module2) {
  var __extends2;
  var __assign2;
  var __rest;
  var __decorate2;
  var __param;
  var __metadata;
  var __awaiter2;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays2;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar2;
  var __importDefault2;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __createBinding2;
  (function(factory) {
    var root2 = typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : {};
    {
      factory(createExporter(root2, createExporter(module2.exports)));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root2) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id2, v2) {
        return exports2[id2] = previous ? previous(id2, v2) : v2;
      };
    }
  })(function(exporter) {
    var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    __extends2 = function(d2, b2) {
      if (typeof b2 !== "function" && b2 !== null)
        throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
      extendStatics2(d2, b2);
      function __() {
        this.constructor = d2;
      }
      d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    };
    __assign2 = Object.assign || function(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2))
            t2[p2] = s2[p2];
      }
      return t2;
    };
    __rest = function(s2, e2) {
      var t2 = {};
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
          t2[p2] = s2[p2];
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
          if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
            t2[p2[i2]] = s2[p2[i2]];
        }
      return t2;
    };
    __decorate2 = function(decorators, target, key2, desc) {
      var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r2 = Reflect.decorate(decorators, target, key2, desc);
      else
        for (var i2 = decorators.length - 1; i2 >= 0; i2--)
          if (d2 = decorators[i2])
            r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
      return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key2) {
        decorator(target, key2, paramIndex);
      };
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter2 = function(thisArg, _arguments, P2, generator) {
      function adopt(value2) {
        return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
          resolve2(value2);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve2, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f2, y2, t2, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
              return t2;
            if (y2 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t2[1]) {
                  _2.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _2.label < t2[2]) {
                  _2.label = t2[2];
                  _2.ops.push(op);
                  break;
                }
                if (t2[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f2 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    __exportStar = function(m2, o2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
          __createBinding2(o2, m2, p2);
    };
    __createBinding2 = Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      Object.defineProperty(o2, k22, { enumerable: true, get: function() {
        return m2[k2];
      } });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    };
    __values = function(o2) {
      var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
      if (m2)
        return m2.call(o2);
      if (o2 && typeof o2.length === "number")
        return {
          next: function() {
            if (o2 && i2 >= o2.length)
              o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
      throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o2, n2) {
      var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m2)
        return o2;
      var i2 = m2.call(o2), r2, ar = [], e2;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
          ar.push(r2.value);
      } catch (error2) {
        e2 = { error: error2 };
      } finally {
        try {
          if (r2 && !r2.done && (m2 = i2["return"]))
            m2.call(i2);
        } finally {
          if (e2)
            throw e2.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
        ar = ar.concat(__read(arguments[i2]));
      return ar;
    };
    __spreadArrays2 = function() {
      for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s2 += arguments[i2].length;
      for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
        for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
          r2[k2] = a2[j2];
      return r2;
    };
    __spreadArray = function(to, from2, pack2) {
      if (pack2 || arguments.length === 2)
        for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from2)) {
            if (!ar)
              ar = Array.prototype.slice.call(from2, 0, i2);
            ar[i2] = from2[i2];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from2));
    };
    __await = function(v2) {
      return this instanceof __await ? (this.v = v2, this) : new __await(v2);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
      return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function verb(n2) {
        if (g2[n2])
          i2[n2] = function(v2) {
            return new Promise(function(a2, b2) {
              q2.push([n2, v2, a2, b2]) > 1 || resume2(n2, v2);
            });
          };
      }
      function resume2(n2, v2) {
        try {
          step(g2[n2](v2));
        } catch (e2) {
          settle(q2[0][3], e2);
        }
      }
      function step(r2) {
        r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
      }
      function fulfill(value2) {
        resume2("next", value2);
      }
      function reject(value2) {
        resume2("throw", value2);
      }
      function settle(f2, v2) {
        if (f2(v2), q2.shift(), q2.length)
          resume2(q2[0][0], q2[0][1]);
      }
    };
    __asyncDelegator = function(o2) {
      var i2, p2;
      return i2 = {}, verb("next"), verb("throw", function(e2) {
        throw e2;
      }), verb("return"), i2[Symbol.iterator] = function() {
        return this;
      }, i2;
      function verb(n2, f2) {
        i2[n2] = o2[n2] ? function(v2) {
          return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
        } : f2;
      }
    };
    __asyncValues = function(o2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m2 = o2[Symbol.asyncIterator], i2;
      return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n2) {
        i2[n2] = o2[n2] && function(v2) {
          return new Promise(function(resolve2, reject) {
            v2 = o2[n2](v2), settle(resolve2, reject, v2.done, v2.value);
          });
        };
      }
      function settle(resolve2, reject, d2, v2) {
        Promise.resolve(v2).then(function(v3) {
          resolve2({ value: v3, done: d2 });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    var __setModuleDefault2 = Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    };
    __importStar2 = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
            __createBinding2(result, mod, k2);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    __importDefault2 = function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    __classPrivateFieldGet = function(receiver, state2, kind, f2) {
      if (kind === "a" && !f2)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state2 === "function" ? receiver !== state2 || !f2 : !state2.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state2.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state2, value2, kind, f2) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f2)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state2 === "function" ? receiver !== state2 || !f2 : !state2.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f2.call(receiver, value2) : f2 ? f2.value = value2 : state2.set(receiver, value2), value2;
    };
    exporter("__extends", __extends2);
    exporter("__assign", __assign2);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate2);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter2);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding2);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays2);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar2);
    exporter("__importDefault", __importDefault2);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
  });
})(tslib);
var Semaphore$2 = {};
Object.defineProperty(Semaphore$2, "__esModule", { value: true });
var tslib_1$2 = tslib.exports;
var Semaphore$1 = function() {
  function Semaphore2(_maxConcurrency) {
    this._maxConcurrency = _maxConcurrency;
    this._queue = [];
    if (_maxConcurrency <= 0) {
      throw new Error("semaphore must be initialized to a positive value");
    }
    this._value = _maxConcurrency;
  }
  Semaphore2.prototype.acquire = function() {
    var _this = this;
    var locked = this.isLocked();
    var ticket = new Promise(function(r2) {
      return _this._queue.push(r2);
    });
    if (!locked)
      this._dispatch();
    return ticket;
  };
  Semaphore2.prototype.runExclusive = function(callback) {
    return tslib_1$2.__awaiter(this, void 0, void 0, function() {
      var _a2, value2, release;
      return tslib_1$2.__generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            return [4, this.acquire()];
          case 1:
            _a2 = _b2.sent(), value2 = _a2[0], release = _a2[1];
            _b2.label = 2;
          case 2:
            _b2.trys.push([2, , 4, 5]);
            return [4, callback(value2)];
          case 3:
            return [2, _b2.sent()];
          case 4:
            release();
            return [7];
          case 5:
            return [2];
        }
      });
    });
  };
  Semaphore2.prototype.isLocked = function() {
    return this._value <= 0;
  };
  Semaphore2.prototype.release = function() {
    if (this._maxConcurrency > 1) {
      throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
    }
    if (this._currentReleaser) {
      var releaser = this._currentReleaser;
      this._currentReleaser = void 0;
      releaser();
    }
  };
  Semaphore2.prototype._dispatch = function() {
    var _this = this;
    var nextConsumer = this._queue.shift();
    if (!nextConsumer)
      return;
    var released = false;
    this._currentReleaser = function() {
      if (released)
        return;
      released = true;
      _this._value++;
      _this._dispatch();
    };
    nextConsumer([this._value--, this._currentReleaser]);
  };
  return Semaphore2;
}();
Semaphore$2.default = Semaphore$1;
Object.defineProperty(Mutex$2, "__esModule", { value: true });
var tslib_1$1 = tslib.exports;
var Semaphore_1 = Semaphore$2;
var Mutex$1 = function() {
  function Mutex2() {
    this._semaphore = new Semaphore_1.default(1);
  }
  Mutex2.prototype.acquire = function() {
    return tslib_1$1.__awaiter(this, void 0, void 0, function() {
      var _a2, releaser;
      return tslib_1$1.__generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            return [4, this._semaphore.acquire()];
          case 1:
            _a2 = _b2.sent(), releaser = _a2[1];
            return [2, releaser];
        }
      });
    });
  };
  Mutex2.prototype.runExclusive = function(callback) {
    return this._semaphore.runExclusive(function() {
      return callback();
    });
  };
  Mutex2.prototype.isLocked = function() {
    return this._semaphore.isLocked();
  };
  Mutex2.prototype.release = function() {
    this._semaphore.release();
  };
  return Mutex2;
}();
Mutex$2.default = Mutex$1;
var withTimeout$1 = {};
Object.defineProperty(withTimeout$1, "__esModule", { value: true });
withTimeout$1.withTimeout = void 0;
var tslib_1 = tslib.exports;
function withTimeout(sync, timeout2, timeoutError) {
  var _this = this;
  if (timeoutError === void 0) {
    timeoutError = new Error("timeout");
  }
  return {
    acquire: function() {
      return new Promise(function(resolve2, reject) {
        return tslib_1.__awaiter(_this, void 0, void 0, function() {
          var isTimeout, ticket, release;
          return tslib_1.__generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                isTimeout = false;
                setTimeout(function() {
                  isTimeout = true;
                  reject(timeoutError);
                }, timeout2);
                return [4, sync.acquire()];
              case 1:
                ticket = _a2.sent();
                if (isTimeout) {
                  release = Array.isArray(ticket) ? ticket[1] : ticket;
                  release();
                } else {
                  resolve2(ticket);
                }
                return [2];
            }
          });
        });
      });
    },
    runExclusive: function(callback) {
      return tslib_1.__awaiter(this, void 0, void 0, function() {
        var release, ticket;
        return tslib_1.__generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              release = function() {
                return void 0;
              };
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, , 7, 8]);
              return [4, this.acquire()];
            case 2:
              ticket = _a2.sent();
              if (!Array.isArray(ticket))
                return [3, 4];
              release = ticket[1];
              return [4, callback(ticket[0])];
            case 3:
              return [2, _a2.sent()];
            case 4:
              release = ticket;
              return [4, callback()];
            case 5:
              return [2, _a2.sent()];
            case 6:
              return [3, 8];
            case 7:
              release();
              return [7];
            case 8:
              return [2];
          }
        });
      });
    },
    release: function() {
      sync.release();
    },
    isLocked: function() {
      return sync.isLocked();
    }
  };
}
withTimeout$1.withTimeout = withTimeout;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.withTimeout = exports2.Semaphore = exports2.Mutex = void 0;
  var Mutex_1 = Mutex$2;
  Object.defineProperty(exports2, "Mutex", { enumerable: true, get: function() {
    return Mutex_1.default;
  } });
  var Semaphore_12 = Semaphore$2;
  Object.defineProperty(exports2, "Semaphore", { enumerable: true, get: function() {
    return Semaphore_12.default;
  } });
  var withTimeout_1 = withTimeout$1;
  Object.defineProperty(exports2, "withTimeout", { enumerable: true, get: function() {
    return withTimeout_1.withTimeout;
  } });
})(lib$1);
var dist$4 = {};
var idRemapMiddleware = {};
var getUniqueId$1 = {};
Object.defineProperty(getUniqueId$1, "__esModule", { value: true });
getUniqueId$1.getUniqueId = void 0;
const MAX = 4294967295;
let idCounter = Math.floor(Math.random() * MAX);
function getUniqueId() {
  idCounter = (idCounter + 1) % MAX;
  return idCounter;
}
getUniqueId$1.getUniqueId = getUniqueId;
Object.defineProperty(idRemapMiddleware, "__esModule", { value: true });
idRemapMiddleware.createIdRemapMiddleware = void 0;
const getUniqueId_1 = getUniqueId$1;
function createIdRemapMiddleware() {
  return (req, res, next3, _end) => {
    const originalId = req.id;
    const newId = getUniqueId_1.getUniqueId();
    req.id = newId;
    res.id = newId;
    next3((done2) => {
      req.id = originalId;
      res.id = originalId;
      done2();
    });
  };
}
idRemapMiddleware.createIdRemapMiddleware = createIdRemapMiddleware;
var createAsyncMiddleware$3 = {};
Object.defineProperty(createAsyncMiddleware$3, "__esModule", { value: true });
createAsyncMiddleware$3.createAsyncMiddleware = void 0;
function createAsyncMiddleware$2(asyncMiddleware) {
  return async (req, res, next3, end) => {
    let resolveNextPromise;
    const nextPromise = new Promise((resolve2) => {
      resolveNextPromise = resolve2;
    });
    let returnHandlerCallback = null;
    let nextWasCalled = false;
    const asyncNext = async () => {
      nextWasCalled = true;
      next3((runReturnHandlersCallback) => {
        returnHandlerCallback = runReturnHandlersCallback;
        resolveNextPromise();
      });
      await nextPromise;
    };
    try {
      await asyncMiddleware(req, res, asyncNext);
      if (nextWasCalled) {
        await nextPromise;
        returnHandlerCallback(null);
      } else {
        end(null);
      }
    } catch (error2) {
      if (returnHandlerCallback) {
        returnHandlerCallback(error2);
      } else {
        end(error2);
      }
    }
  };
}
createAsyncMiddleware$3.createAsyncMiddleware = createAsyncMiddleware$2;
var createScaffoldMiddleware$3 = {};
Object.defineProperty(createScaffoldMiddleware$3, "__esModule", { value: true });
createScaffoldMiddleware$3.createScaffoldMiddleware = void 0;
function createScaffoldMiddleware$2(handlers2) {
  return (req, res, next3, end) => {
    const handler = handlers2[req.method];
    if (handler === void 0) {
      return next3();
    }
    if (typeof handler === "function") {
      return handler(req, res, next3, end);
    }
    res.result = handler;
    return end();
  };
}
createScaffoldMiddleware$3.createScaffoldMiddleware = createScaffoldMiddleware$2;
var JsonRpcEngine$1 = {};
var safeEventEmitter = {};
Object.defineProperty(safeEventEmitter, "__esModule", { value: true });
const events_1 = events$1.exports;
function safeApply(handler, context, args) {
  try {
    Reflect.apply(handler, context, args);
  } catch (err) {
    setTimeout(() => {
      throw err;
    });
  }
}
function arrayClone(arr2) {
  const n2 = arr2.length;
  const copy3 = new Array(n2);
  for (let i2 = 0; i2 < n2; i2 += 1) {
    copy3[i2] = arr2[i2];
  }
  return copy3;
}
class SafeEventEmitter$2 extends events_1.EventEmitter {
  emit(type, ...args) {
    let doError = type === "error";
    const events2 = this._events;
    if (events2 !== void 0) {
      doError = doError && events2.error === void 0;
    } else if (!doError) {
      return false;
    }
    if (doError) {
      let er;
      if (args.length > 0) {
        [er] = args;
      }
      if (er instanceof Error) {
        throw er;
      }
      const err = new Error(`Unhandled error.${er ? ` (${er.message})` : ""}`);
      err.context = er;
      throw err;
    }
    const handler = events2[type];
    if (handler === void 0) {
      return false;
    }
    if (typeof handler === "function") {
      safeApply(handler, this, args);
    } else {
      const len2 = handler.length;
      const listeners2 = arrayClone(handler);
      for (let i2 = 0; i2 < len2; i2 += 1) {
        safeApply(listeners2[i2], this, args);
      }
    }
    return true;
  }
}
safeEventEmitter.default = SafeEventEmitter$2;
var dist$3 = {};
var classes = {};
var fastSafeStringify = stringify$1;
stringify$1.default = stringify$1;
stringify$1.stable = deterministicStringify;
stringify$1.stableStringify = deterministicStringify;
var LIMIT_REPLACE_NODE = "[...]";
var CIRCULAR_REPLACE_NODE = "[Circular]";
var arr = [];
var replacerStack = [];
function defaultOptions() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function stringify$1(obj, replacer2, spacer, options) {
  if (typeof options === "undefined") {
    options = defaultOptions();
  }
  decirc(obj, "", 0, [], void 0, 0, options);
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(obj, replacer2, spacer);
    } else {
      res = JSON.stringify(obj, replaceGetterValues(replacer2), spacer);
    }
  } catch (_2) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function setReplace(replace, val, k2, parent) {
  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k2);
  if (propertyDescriptor.get !== void 0) {
    if (propertyDescriptor.configurable) {
      Object.defineProperty(parent, k2, { value: replace });
      arr.push([parent, k2, val, propertyDescriptor]);
    } else {
      replacerStack.push([val, k2, replace]);
    }
  } else {
    parent[k2] = replace;
    arr.push([parent, k2, val]);
  }
}
function decirc(val, k2, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i2;
  if (typeof val === "object" && val !== null) {
    for (i2 = 0; i2 < stack.length; i2++) {
      if (stack[i2] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k2, parent);
        return;
      }
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i2 = 0; i2 < val.length; i2++) {
        decirc(val[i2], i2, i2, stack, val, depth, options);
      }
    } else {
      var keys2 = Object.keys(val);
      for (i2 = 0; i2 < keys2.length; i2++) {
        var key2 = keys2[i2];
        decirc(val[key2], key2, i2, stack, val, depth, options);
      }
    }
    stack.pop();
  }
}
function compareFunction(a2, b2) {
  if (a2 < b2) {
    return -1;
  }
  if (a2 > b2) {
    return 1;
  }
  return 0;
}
function deterministicStringify(obj, replacer2, spacer, options) {
  if (typeof options === "undefined") {
    options = defaultOptions();
  }
  var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
  var res;
  try {
    if (replacerStack.length === 0) {
      res = JSON.stringify(tmp, replacer2, spacer);
    } else {
      res = JSON.stringify(tmp, replaceGetterValues(replacer2), spacer);
    }
  } catch (_2) {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    while (arr.length !== 0) {
      var part = arr.pop();
      if (part.length === 4) {
        Object.defineProperty(part[0], part[1], part[3]);
      } else {
        part[0][part[1]] = part[2];
      }
    }
  }
  return res;
}
function deterministicDecirc(val, k2, edgeIndex, stack, parent, depth, options) {
  depth += 1;
  var i2;
  if (typeof val === "object" && val !== null) {
    for (i2 = 0; i2 < stack.length; i2++) {
      if (stack[i2] === val) {
        setReplace(CIRCULAR_REPLACE_NODE, val, k2, parent);
        return;
      }
    }
    try {
      if (typeof val.toJSON === "function") {
        return;
      }
    } catch (_2) {
      return;
    }
    if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
      return;
    }
    if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
      setReplace(LIMIT_REPLACE_NODE, val, k2, parent);
      return;
    }
    stack.push(val);
    if (Array.isArray(val)) {
      for (i2 = 0; i2 < val.length; i2++) {
        deterministicDecirc(val[i2], i2, i2, stack, val, depth, options);
      }
    } else {
      var tmp = {};
      var keys2 = Object.keys(val).sort(compareFunction);
      for (i2 = 0; i2 < keys2.length; i2++) {
        var key2 = keys2[i2];
        deterministicDecirc(val[key2], key2, i2, stack, val, depth, options);
        tmp[key2] = val[key2];
      }
      if (typeof parent !== "undefined") {
        arr.push([parent, k2, val]);
        parent[k2] = tmp;
      } else {
        return tmp;
      }
    }
    stack.pop();
  }
}
function replaceGetterValues(replacer2) {
  replacer2 = typeof replacer2 !== "undefined" ? replacer2 : function(k2, v2) {
    return v2;
  };
  return function(key2, val) {
    if (replacerStack.length > 0) {
      for (var i2 = 0; i2 < replacerStack.length; i2++) {
        var part = replacerStack[i2];
        if (part[1] === key2 && part[0] === val) {
          val = part[2];
          replacerStack.splice(i2, 1);
          break;
        }
      }
    }
    return replacer2.call(this, key2, val);
  };
}
Object.defineProperty(classes, "__esModule", { value: true });
classes.EthereumProviderError = classes.EthereumRpcError = void 0;
const fast_safe_stringify_1 = fastSafeStringify;
class EthereumRpcError extends Error {
  constructor(code2, message, data) {
    if (!Number.isInteger(code2)) {
      throw new Error('"code" must be an integer.');
    }
    if (!message || typeof message !== "string") {
      throw new Error('"message" must be a nonempty string.');
    }
    super(message);
    this.code = code2;
    if (data !== void 0) {
      this.data = data;
    }
  }
  serialize() {
    const serialized = {
      code: this.code,
      message: this.message
    };
    if (this.data !== void 0) {
      serialized.data = this.data;
    }
    if (this.stack) {
      serialized.stack = this.stack;
    }
    return serialized;
  }
  toString() {
    return fast_safe_stringify_1.default(this.serialize(), stringifyReplacer, 2);
  }
}
classes.EthereumRpcError = EthereumRpcError;
class EthereumProviderError extends EthereumRpcError {
  constructor(code2, message, data) {
    if (!isValidEthProviderCode(code2)) {
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    }
    super(code2, message, data);
  }
}
classes.EthereumProviderError = EthereumProviderError;
function isValidEthProviderCode(code2) {
  return Number.isInteger(code2) && code2 >= 1e3 && code2 <= 4999;
}
function stringifyReplacer(_2, value2) {
  if (value2 === "[Circular]") {
    return void 0;
  }
  return value2;
}
var utils$3 = {};
var errorConstants = {};
Object.defineProperty(errorConstants, "__esModule", { value: true });
errorConstants.errorValues = errorConstants.errorCodes = void 0;
errorConstants.errorCodes = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901
  }
};
errorConstants.errorValues = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  "4001": {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  "4100": {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  "4200": {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  "4900": {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  "4901": {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  }
};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.serializeError = exports2.isValidCode = exports2.getMessageFromCode = exports2.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
  const error_constants_12 = errorConstants;
  const classes_12 = classes;
  const FALLBACK_ERROR_CODE = error_constants_12.errorCodes.rpc.internal;
  const FALLBACK_MESSAGE = "Unspecified error message. This is a bug, please report it.";
  const FALLBACK_ERROR = {
    code: FALLBACK_ERROR_CODE,
    message: getMessageFromCode(FALLBACK_ERROR_CODE)
  };
  exports2.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
  function getMessageFromCode(code2, fallbackMessage = FALLBACK_MESSAGE) {
    if (Number.isInteger(code2)) {
      const codeString = code2.toString();
      if (hasKey(error_constants_12.errorValues, codeString)) {
        return error_constants_12.errorValues[codeString].message;
      }
      if (isJsonRpcServerError(code2)) {
        return exports2.JSON_RPC_SERVER_ERROR_MESSAGE;
      }
    }
    return fallbackMessage;
  }
  exports2.getMessageFromCode = getMessageFromCode;
  function isValidCode(code2) {
    if (!Number.isInteger(code2)) {
      return false;
    }
    const codeString = code2.toString();
    if (error_constants_12.errorValues[codeString]) {
      return true;
    }
    if (isJsonRpcServerError(code2)) {
      return true;
    }
    return false;
  }
  exports2.isValidCode = isValidCode;
  function serializeError(error2, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {}) {
    var _a2, _b2;
    if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== "string") {
      throw new Error("Must provide fallback error with integer number code and string message.");
    }
    if (error2 instanceof classes_12.EthereumRpcError) {
      return error2.serialize();
    }
    const serialized = {};
    if (error2 && typeof error2 === "object" && !Array.isArray(error2) && hasKey(error2, "code") && isValidCode(error2.code)) {
      const _error = error2;
      serialized.code = _error.code;
      if (_error.message && typeof _error.message === "string") {
        serialized.message = _error.message;
        if (hasKey(_error, "data")) {
          serialized.data = _error.data;
        }
      } else {
        serialized.message = getMessageFromCode(serialized.code);
        serialized.data = { originalError: assignOriginalError(error2) };
      }
    } else {
      serialized.code = fallbackError.code;
      const message = (_a2 = error2) === null || _a2 === void 0 ? void 0 : _a2.message;
      serialized.message = message && typeof message === "string" ? message : fallbackError.message;
      serialized.data = { originalError: assignOriginalError(error2) };
    }
    const stack = (_b2 = error2) === null || _b2 === void 0 ? void 0 : _b2.stack;
    if (shouldIncludeStack && error2 && stack && typeof stack === "string") {
      serialized.stack = stack;
    }
    return serialized;
  }
  exports2.serializeError = serializeError;
  function isJsonRpcServerError(code2) {
    return code2 >= -32099 && code2 <= -32e3;
  }
  function assignOriginalError(error2) {
    if (error2 && typeof error2 === "object" && !Array.isArray(error2)) {
      return Object.assign({}, error2);
    }
    return error2;
  }
  function hasKey(obj, key2) {
    return Object.prototype.hasOwnProperty.call(obj, key2);
  }
})(utils$3);
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: true });
errors$1.ethErrors = void 0;
const classes_1 = classes;
const utils_1 = utils$3;
const error_constants_1 = errorConstants;
errors$1.ethErrors = {
  rpc: {
    parse: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg),
    invalidRequest: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg),
    invalidParams: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg),
    methodNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg),
    internal: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg),
    server: (opts) => {
      if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      }
      const { code: code2 } = opts;
      if (!Number.isInteger(code2) || code2 > -32005 || code2 < -32099) {
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      }
      return getEthJsonRpcError(code2, opts);
    },
    invalidInput: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg),
    resourceNotFound: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg),
    resourceUnavailable: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg),
    transactionRejected: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg),
    methodNotSupported: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg),
    limitExceeded: (arg) => getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg)
  },
  provider: {
    userRejectedRequest: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
    },
    unauthorized: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
    },
    unsupportedMethod: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
    },
    disconnected: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
    },
    chainDisconnected: (arg) => {
      return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
    },
    custom: (opts) => {
      if (!opts || typeof opts !== "object" || Array.isArray(opts)) {
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      }
      const { code: code2, message, data } = opts;
      if (!message || typeof message !== "string") {
        throw new Error('"message" must be a nonempty string');
      }
      return new classes_1.EthereumProviderError(code2, message, data);
    }
  }
};
function getEthJsonRpcError(code2, arg) {
  const [message, data] = parseOpts(arg);
  return new classes_1.EthereumRpcError(code2, message || utils_1.getMessageFromCode(code2), data);
}
function getEthProviderError(code2, arg) {
  const [message, data] = parseOpts(arg);
  return new classes_1.EthereumProviderError(code2, message || utils_1.getMessageFromCode(code2), data);
}
function parseOpts(arg) {
  if (arg) {
    if (typeof arg === "string") {
      return [arg];
    } else if (typeof arg === "object" && !Array.isArray(arg)) {
      const { message, data } = arg;
      if (message && typeof message !== "string") {
        throw new Error("Must specify string message.");
      }
      return [message || void 0, data];
    }
  }
  return [];
}
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.getMessageFromCode = exports2.serializeError = exports2.EthereumProviderError = exports2.EthereumRpcError = exports2.ethErrors = exports2.errorCodes = void 0;
  const classes_12 = classes;
  Object.defineProperty(exports2, "EthereumRpcError", { enumerable: true, get: function() {
    return classes_12.EthereumRpcError;
  } });
  Object.defineProperty(exports2, "EthereumProviderError", { enumerable: true, get: function() {
    return classes_12.EthereumProviderError;
  } });
  const utils_12 = utils$3;
  Object.defineProperty(exports2, "serializeError", { enumerable: true, get: function() {
    return utils_12.serializeError;
  } });
  Object.defineProperty(exports2, "getMessageFromCode", { enumerable: true, get: function() {
    return utils_12.getMessageFromCode;
  } });
  const errors_12 = errors$1;
  Object.defineProperty(exports2, "ethErrors", { enumerable: true, get: function() {
    return errors_12.ethErrors;
  } });
  const error_constants_12 = errorConstants;
  Object.defineProperty(exports2, "errorCodes", { enumerable: true, get: function() {
    return error_constants_12.errorCodes;
  } });
})(dist$3);
var __importDefault$a = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(JsonRpcEngine$1, "__esModule", { value: true });
JsonRpcEngine$1.JsonRpcEngine = void 0;
const safe_event_emitter_1$1 = __importDefault$a(safeEventEmitter);
const eth_rpc_errors_1$3 = dist$3;
class JsonRpcEngine extends safe_event_emitter_1$1.default {
  constructor() {
    super();
    this._middleware = [];
  }
  push(middleware) {
    this._middleware.push(middleware);
  }
  handle(req, cb) {
    if (cb && typeof cb !== "function") {
      throw new Error('"callback" must be a function if provided.');
    }
    if (Array.isArray(req)) {
      if (cb) {
        return this._handleBatch(req, cb);
      }
      return this._handleBatch(req);
    }
    if (cb) {
      return this._handle(req, cb);
    }
    return this._promiseHandle(req);
  }
  asMiddleware() {
    return async (req, res, next3, end) => {
      try {
        const [middlewareError, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
        if (isComplete) {
          await JsonRpcEngine._runReturnHandlers(returnHandlers);
          return end(middlewareError);
        }
        return next3(async (handlerCallback) => {
          try {
            await JsonRpcEngine._runReturnHandlers(returnHandlers);
          } catch (error2) {
            return handlerCallback(error2);
          }
          return handlerCallback();
        });
      } catch (error2) {
        return end(error2);
      }
    };
  }
  async _handleBatch(reqs, cb) {
    try {
      const responses = await Promise.all(reqs.map(this._promiseHandle.bind(this)));
      if (cb) {
        return cb(null, responses);
      }
      return responses;
    } catch (error2) {
      if (cb) {
        return cb(error2);
      }
      throw error2;
    }
  }
  _promiseHandle(req) {
    return new Promise((resolve2) => {
      this._handle(req, (_err, res) => {
        resolve2(res);
      });
    });
  }
  async _handle(callerReq, cb) {
    if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== "object") {
      const error3 = new eth_rpc_errors_1$3.EthereumRpcError(eth_rpc_errors_1$3.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });
      return cb(error3, { id: void 0, jsonrpc: "2.0", error: error3 });
    }
    if (typeof callerReq.method !== "string") {
      const error3 = new eth_rpc_errors_1$3.EthereumRpcError(eth_rpc_errors_1$3.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });
      return cb(error3, { id: callerReq.id, jsonrpc: "2.0", error: error3 });
    }
    const req = Object.assign({}, callerReq);
    const res = {
      id: req.id,
      jsonrpc: req.jsonrpc
    };
    let error2 = null;
    try {
      await this._processRequest(req, res);
    } catch (_error) {
      error2 = _error;
    }
    if (error2) {
      delete res.result;
      if (!res.error) {
        res.error = eth_rpc_errors_1$3.serializeError(error2);
      }
    }
    return cb(error2, res);
  }
  async _processRequest(req, res) {
    const [error2, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);
    JsonRpcEngine._checkForCompletion(req, res, isComplete);
    await JsonRpcEngine._runReturnHandlers(returnHandlers);
    if (error2) {
      throw error2;
    }
  }
  static async _runAllMiddleware(req, res, middlewareStack) {
    const returnHandlers = [];
    let error2 = null;
    let isComplete = false;
    for (const middleware of middlewareStack) {
      [error2, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);
      if (isComplete) {
        break;
      }
    }
    return [error2, isComplete, returnHandlers.reverse()];
  }
  static _runMiddleware(req, res, middleware, returnHandlers) {
    return new Promise((resolve2) => {
      const end = (err) => {
        const error2 = err || res.error;
        if (error2) {
          res.error = eth_rpc_errors_1$3.serializeError(error2);
        }
        resolve2([error2, true]);
      };
      const next3 = (returnHandler) => {
        if (res.error) {
          end(res.error);
        } else {
          if (returnHandler) {
            if (typeof returnHandler !== "function") {
              end(new eth_rpc_errors_1$3.EthereumRpcError(eth_rpc_errors_1$3.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof returnHandler}" for request:
${jsonify(req)}`, { request: req }));
            }
            returnHandlers.push(returnHandler);
          }
          resolve2([null, false]);
        }
      };
      try {
        middleware(req, res, next3, end);
      } catch (error2) {
        end(error2);
      }
    });
  }
  static async _runReturnHandlers(handlers2) {
    for (const handler of handlers2) {
      await new Promise((resolve2, reject) => {
        handler((err) => err ? reject(err) : resolve2());
      });
    }
  }
  static _checkForCompletion(req, res, isComplete) {
    if (!("result" in res) && !("error" in res)) {
      throw new eth_rpc_errors_1$3.EthereumRpcError(eth_rpc_errors_1$3.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${jsonify(req)}`, { request: req });
    }
    if (!isComplete) {
      throw new eth_rpc_errors_1$3.EthereumRpcError(eth_rpc_errors_1$3.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${jsonify(req)}`, { request: req });
    }
  }
}
JsonRpcEngine$1.JsonRpcEngine = JsonRpcEngine;
function jsonify(request) {
  return JSON.stringify(request, null, 2);
}
var mergeMiddleware$1 = {};
Object.defineProperty(mergeMiddleware$1, "__esModule", { value: true });
mergeMiddleware$1.mergeMiddleware = void 0;
const JsonRpcEngine_1 = JsonRpcEngine$1;
function mergeMiddleware(middlewareStack) {
  const engine = new JsonRpcEngine_1.JsonRpcEngine();
  middlewareStack.forEach((middleware) => engine.push(middleware));
  return engine.asMiddleware();
}
mergeMiddleware$1.mergeMiddleware = mergeMiddleware;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(idRemapMiddleware, exports2);
  __exportStar(createAsyncMiddleware$3, exports2);
  __exportStar(createScaffoldMiddleware$3, exports2);
  __exportStar(getUniqueId$1, exports2);
  __exportStar(JsonRpcEngine$1, exports2);
  __exportStar(mergeMiddleware$1, exports2);
})(dist$4);
var createScaffoldMiddleware$1 = function createScaffoldMiddleware2(handlers2) {
  return (req, res, next3, end) => {
    const handler = handlers2[req.method];
    if (handler === void 0) {
      return next3();
    }
    if (typeof handler === "function") {
      return handler(req, res, next3, end);
    }
    res.result = handler;
    return end();
  };
};
var scaffold = createScaffoldMiddleware$1;
const processFn = (fn, options, proxy, unwrapped) => function(...arguments_) {
  const P2 = options.promiseModule;
  return new P2((resolve2, reject) => {
    if (options.multiArgs) {
      arguments_.push((...result) => {
        if (options.errorFirst) {
          if (result[0]) {
            reject(result);
          } else {
            result.shift();
            resolve2(result);
          }
        } else {
          resolve2(result);
        }
      });
    } else if (options.errorFirst) {
      arguments_.push((error2, result) => {
        if (error2) {
          reject(error2);
        } else {
          resolve2(result);
        }
      });
    } else {
      arguments_.push(resolve2);
    }
    const self2 = this === proxy ? unwrapped : this;
    Reflect.apply(fn, self2, arguments_);
  });
};
const filterCache = new WeakMap();
var pify$1 = (input, options) => {
  options = __spreadValues2({
    exclude: [/.+(?:Sync|Stream)$/],
    errorFirst: true,
    promiseModule: Promise
  }, options);
  const objectType = typeof input;
  if (!(input !== null && (objectType === "object" || objectType === "function"))) {
    throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
  }
  const filter2 = (target, key2) => {
    let cached = filterCache.get(target);
    if (!cached) {
      cached = {};
      filterCache.set(target, cached);
    }
    if (key2 in cached) {
      return cached[key2];
    }
    const match = (pattern) => typeof pattern === "string" || typeof key2 === "symbol" ? key2 === pattern : pattern.test(key2);
    const desc = Reflect.getOwnPropertyDescriptor(target, key2);
    const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
    const included = options.include ? options.include.some(match) : !options.exclude.some(match);
    const shouldFilter = included && writableOrConfigurableOwn;
    cached[key2] = shouldFilter;
    return shouldFilter;
  };
  const cache2 = new WeakMap();
  const proxy = new Proxy(input, {
    apply(target, thisArg, args) {
      const cached = cache2.get(target);
      if (cached) {
        return Reflect.apply(cached, thisArg, args);
      }
      const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
      cache2.set(target, pified);
      return Reflect.apply(pified, thisArg, args);
    },
    get(target, key2) {
      const property = target[key2];
      if (!filter2(target, key2) || property === Function.prototype[key2]) {
        return property;
      }
      const cached = cache2.get(property);
      if (cached) {
        return cached;
      }
      if (typeof property === "function") {
        const pified = processFn(property, options, proxy, target);
        cache2.set(property, pified);
        return pified;
      }
      return property;
    }
  });
  return proxy;
};
const SafeEventEmitter$1 = safeEventEmitter.default;
class BaseFilter$3 extends SafeEventEmitter$1 {
  constructor() {
    super();
    this.updates = [];
  }
  async initialize() {
  }
  async update() {
    throw new Error("BaseFilter - no update method specified");
  }
  addResults(newResults) {
    this.updates = this.updates.concat(newResults);
    newResults.forEach((result) => this.emit("update", result));
  }
  addInitialResults(newResults) {
  }
  getChangesAndClear() {
    const updates = this.updates;
    this.updates = [];
    return updates;
  }
}
var baseFilter = BaseFilter$3;
const BaseFilter$2 = baseFilter;
class BaseFilterWithHistory$1 extends BaseFilter$2 {
  constructor() {
    super();
    this.allResults = [];
  }
  async update() {
    throw new Error("BaseFilterWithHistory - no update method specified");
  }
  addResults(newResults) {
    this.allResults = this.allResults.concat(newResults);
    super.addResults(newResults);
  }
  addInitialResults(newResults) {
    this.allResults = this.allResults.concat(newResults);
    super.addInitialResults(newResults);
  }
  getAllResults() {
    return this.allResults;
  }
}
var baseFilterHistory = BaseFilterWithHistory$1;
var hexUtils = {
  minBlockRef: minBlockRef$1,
  maxBlockRef,
  sortBlockRefs,
  bnToHex: bnToHex$1,
  blockRefIsNumber: blockRefIsNumber$1,
  hexToInt: hexToInt$3,
  incrementHexInt: incrementHexInt$4,
  intToHex: intToHex$2,
  unsafeRandomBytes: unsafeRandomBytes$1
};
function minBlockRef$1(...refs) {
  const sortedRefs = sortBlockRefs(refs);
  return sortedRefs[0];
}
function maxBlockRef(...refs) {
  const sortedRefs = sortBlockRefs(refs);
  return sortedRefs[sortedRefs.length - 1];
}
function sortBlockRefs(refs) {
  return refs.sort((refA, refB) => {
    if (refA === "latest" || refB === "earliest")
      return 1;
    if (refB === "latest" || refA === "earliest")
      return -1;
    return hexToInt$3(refA) - hexToInt$3(refB);
  });
}
function bnToHex$1(bn2) {
  return "0x" + bn2.toString(16);
}
function blockRefIsNumber$1(blockRef) {
  return blockRef && !["earliest", "latest", "pending"].includes(blockRef);
}
function hexToInt$3(hexString) {
  if (hexString === void 0 || hexString === null)
    return hexString;
  return Number.parseInt(hexString, 16);
}
function incrementHexInt$4(hexString) {
  if (hexString === void 0 || hexString === null)
    return hexString;
  const value2 = hexToInt$3(hexString);
  return intToHex$2(value2 + 1);
}
function intToHex$2(int) {
  if (int === void 0 || int === null)
    return int;
  let hexString = int.toString(16);
  const needsLeftPad = hexString.length % 2;
  if (needsLeftPad)
    hexString = "0" + hexString;
  return "0x" + hexString;
}
function unsafeRandomBytes$1(byteCount) {
  let result = "0x";
  for (let i2 = 0; i2 < byteCount; i2++) {
    result += unsafeRandomNibble();
    result += unsafeRandomNibble();
  }
  return result;
}
function unsafeRandomNibble() {
  return Math.floor(Math.random() * 16).toString(16);
}
const EthQuery = ethQuery;
const pify = pify$1;
const BaseFilterWithHistory = baseFilterHistory;
const { bnToHex, hexToInt: hexToInt$2, incrementHexInt: incrementHexInt$3, minBlockRef, blockRefIsNumber } = hexUtils;
class LogFilter$1 extends BaseFilterWithHistory {
  constructor({ provider, params }) {
    super();
    this.type = "log";
    this.ethQuery = new EthQuery(provider);
    this.params = Object.assign({
      fromBlock: "latest",
      toBlock: "latest",
      address: void 0,
      topics: []
    }, params);
    if (this.params.address) {
      if (!Array.isArray(this.params.address)) {
        this.params.address = [this.params.address];
      }
      this.params.address = this.params.address.map((address) => address.toLowerCase());
    }
  }
  async initialize({ currentBlock: currentBlock2 }) {
    let fromBlock = this.params.fromBlock;
    if (["latest", "pending"].includes(fromBlock))
      fromBlock = currentBlock2;
    if (fromBlock === "earliest")
      fromBlock = "0x0";
    this.params.fromBlock = fromBlock;
    const toBlock = minBlockRef(this.params.toBlock, currentBlock2);
    const params = Object.assign({}, this.params, { toBlock });
    const newLogs = await this._fetchLogs(params);
    this.addInitialResults(newLogs);
  }
  async update({ oldBlock, newBlock }) {
    const toBlock = newBlock;
    let fromBlock;
    if (oldBlock) {
      fromBlock = incrementHexInt$3(oldBlock);
    } else {
      fromBlock = newBlock;
    }
    const params = Object.assign({}, this.params, { fromBlock, toBlock });
    const newLogs = await this._fetchLogs(params);
    const matchingLogs = newLogs.filter((log2) => this.matchLog(log2));
    this.addResults(matchingLogs);
  }
  async _fetchLogs(params) {
    const newLogs = await pify((cb) => this.ethQuery.getLogs(params, cb))();
    return newLogs;
  }
  matchLog(log2) {
    if (hexToInt$2(this.params.fromBlock) >= hexToInt$2(log2.blockNumber))
      return false;
    if (blockRefIsNumber(this.params.toBlock) && hexToInt$2(this.params.toBlock) <= hexToInt$2(log2.blockNumber))
      return false;
    const normalizedLogAddress = log2.address && log2.address.toLowerCase();
    if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress))
      return false;
    const topicsMatch = this.params.topics.every((topicPattern, index2) => {
      let logTopic = log2.topics[index2];
      if (!logTopic)
        return false;
      logTopic = logTopic.toLowerCase();
      let subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
      const subtopicsIncludeWildcard = subtopicsToMatch.includes(null);
      if (subtopicsIncludeWildcard)
        return true;
      subtopicsToMatch = subtopicsToMatch.map((topic) => topic.toLowerCase());
      const topicDoesMatch = subtopicsToMatch.includes(logTopic);
      return topicDoesMatch;
    });
    return topicsMatch;
  }
}
var logFilter = LogFilter$1;
var getBlocksForRange_1 = getBlocksForRange$3;
async function getBlocksForRange$3({ provider, fromBlock, toBlock }) {
  if (!fromBlock)
    fromBlock = toBlock;
  const fromBlockNumber = hexToInt$1(fromBlock);
  const toBlockNumber = hexToInt$1(toBlock);
  const blockCountToQuery = toBlockNumber - fromBlockNumber + 1;
  const missingBlockNumbers = Array(blockCountToQuery).fill().map((_2, index2) => fromBlockNumber + index2).map(intToHex$1);
  const blockBodies = await Promise.all(missingBlockNumbers.map((blockNum) => query(provider, "eth_getBlockByNumber", [blockNum, false])));
  return blockBodies;
}
function hexToInt$1(hexString) {
  if (hexString === void 0 || hexString === null)
    return hexString;
  return Number.parseInt(hexString, 16);
}
function intToHex$1(int) {
  if (int === void 0 || int === null)
    return int;
  const hexString = int.toString(16);
  return "0x" + hexString;
}
function query(provider, method2, params) {
  return new Promise((resolve2, reject) => {
    provider.sendAsync({ id: 1, jsonrpc: "2.0", method: method2, params }, (err, res) => {
      if (err)
        return reject(err);
      resolve2(res.result);
    });
  });
}
const BaseFilter$1 = baseFilter;
const getBlocksForRange$2 = getBlocksForRange_1;
const { incrementHexInt: incrementHexInt$2 } = hexUtils;
class BlockFilter$1 extends BaseFilter$1 {
  constructor({ provider, params }) {
    super();
    this.type = "block";
    this.provider = provider;
  }
  async update({ oldBlock, newBlock }) {
    const toBlock = newBlock;
    const fromBlock = incrementHexInt$2(oldBlock);
    const blockBodies = await getBlocksForRange$2({ provider: this.provider, fromBlock, toBlock });
    const blockHashes = blockBodies.map((block) => block.hash);
    this.addResults(blockHashes);
  }
}
var blockFilter = BlockFilter$1;
const BaseFilter = baseFilter;
const getBlocksForRange$1 = getBlocksForRange_1;
const { incrementHexInt: incrementHexInt$1 } = hexUtils;
class TxFilter$1 extends BaseFilter {
  constructor({ provider }) {
    super();
    this.type = "tx";
    this.provider = provider;
  }
  async update({ oldBlock }) {
    const toBlock = oldBlock;
    const fromBlock = incrementHexInt$1(oldBlock);
    const blocks2 = await getBlocksForRange$1({ provider: this.provider, fromBlock, toBlock });
    const blockTxHashes = [];
    for (const block of blocks2) {
      blockTxHashes.push(...block.transactions);
    }
    this.addResults(blockTxHashes);
  }
}
var txFilter = TxFilter$1;
const Mutex = lib$1.Mutex;
const { createAsyncMiddleware: createAsyncMiddleware$1 } = dist$4;
const createJsonRpcMiddleware = scaffold;
const LogFilter = logFilter;
const BlockFilter = blockFilter;
const TxFilter = txFilter;
const { intToHex, hexToInt } = hexUtils;
var ethJsonRpcFilters = createEthFilterMiddleware;
function createEthFilterMiddleware({ blockTracker, provider }) {
  let filterIndex = 0;
  let filters2 = {};
  const mutex = new Mutex();
  const waitForFree = mutexMiddlewareWrapper({ mutex });
  const middleware = createJsonRpcMiddleware({
    eth_newFilter: waitForFree(toFilterCreationMiddleware(newLogFilter)),
    eth_newBlockFilter: waitForFree(toFilterCreationMiddleware(newBlockFilter)),
    eth_newPendingTransactionFilter: waitForFree(toFilterCreationMiddleware(newPendingTransactionFilter)),
    eth_uninstallFilter: waitForFree(toAsyncRpcMiddleware(uninstallFilterHandler)),
    eth_getFilterChanges: waitForFree(toAsyncRpcMiddleware(getFilterChanges)),
    eth_getFilterLogs: waitForFree(toAsyncRpcMiddleware(getFilterLogs))
  });
  const filterUpdater = async ({ oldBlock, newBlock }) => {
    if (filters2.length === 0)
      return;
    const releaseLock = await mutex.acquire();
    try {
      await Promise.all(objValues(filters2).map(async (filter2) => {
        try {
          await filter2.update({ oldBlock, newBlock });
        } catch (err) {
          console.error(err);
        }
      }));
    } catch (err) {
      console.error(err);
    }
    releaseLock();
  };
  middleware.newLogFilter = newLogFilter;
  middleware.newBlockFilter = newBlockFilter;
  middleware.newPendingTransactionFilter = newPendingTransactionFilter;
  middleware.uninstallFilter = uninstallFilterHandler;
  middleware.getFilterChanges = getFilterChanges;
  middleware.getFilterLogs = getFilterLogs;
  middleware.destroy = () => {
    uninstallAllFilters();
  };
  return middleware;
  async function newLogFilter(params) {
    const filter2 = new LogFilter({ provider, params });
    await installFilter(filter2);
    return filter2;
  }
  async function newBlockFilter() {
    const filter2 = new BlockFilter({ provider });
    await installFilter(filter2);
    return filter2;
  }
  async function newPendingTransactionFilter() {
    const filter2 = new TxFilter({ provider });
    await installFilter(filter2);
    return filter2;
  }
  async function getFilterChanges(filterIndexHex) {
    const filterIndex2 = hexToInt(filterIndexHex);
    const filter2 = filters2[filterIndex2];
    if (!filter2) {
      throw new Error(`No filter for index "${filterIndex2}"`);
    }
    const results2 = filter2.getChangesAndClear();
    return results2;
  }
  async function getFilterLogs(filterIndexHex) {
    const filterIndex2 = hexToInt(filterIndexHex);
    const filter2 = filters2[filterIndex2];
    if (!filter2) {
      throw new Error(`No filter for index "${filterIndex2}"`);
    }
    if (filter2.type === "log") {
      results = filter2.getAllResults();
    } else {
      results = [];
    }
    return results;
  }
  async function uninstallFilterHandler(filterIndexHex) {
    const filterIndex2 = hexToInt(filterIndexHex);
    const filter2 = filters2[filterIndex2];
    const result = Boolean(filter2);
    if (result) {
      await uninstallFilter(filterIndex2);
    }
    return result;
  }
  async function installFilter(filter2) {
    const prevFilterCount = objValues(filters2).length;
    const currentBlock2 = await blockTracker.getLatestBlock();
    await filter2.initialize({ currentBlock: currentBlock2 });
    filterIndex++;
    filters2[filterIndex] = filter2;
    filter2.id = filterIndex;
    filter2.idHex = intToHex(filterIndex);
    const newFilterCount = objValues(filters2).length;
    updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
    return filterIndex;
  }
  async function uninstallFilter(filterIndex2) {
    const prevFilterCount = objValues(filters2).length;
    delete filters2[filterIndex2];
    const newFilterCount = objValues(filters2).length;
    updateBlockTrackerSubs({ prevFilterCount, newFilterCount });
  }
  async function uninstallAllFilters() {
    const prevFilterCount = objValues(filters2).length;
    filters2 = {};
    updateBlockTrackerSubs({ prevFilterCount, newFilterCount: 0 });
  }
  function updateBlockTrackerSubs({ prevFilterCount, newFilterCount }) {
    if (prevFilterCount === 0 && newFilterCount > 0) {
      blockTracker.on("sync", filterUpdater);
      return;
    }
    if (prevFilterCount > 0 && newFilterCount === 0) {
      blockTracker.removeListener("sync", filterUpdater);
      return;
    }
  }
}
function toFilterCreationMiddleware(createFilterFn) {
  return toAsyncRpcMiddleware(async (...args) => {
    const filter2 = await createFilterFn(...args);
    const result = intToHex(filter2.id);
    return result;
  });
}
function toAsyncRpcMiddleware(asyncFn) {
  return createAsyncMiddleware$1(async (req, res) => {
    const result = await asyncFn.apply(null, req.params);
    res.result = result;
  });
}
function mutexMiddlewareWrapper({ mutex }) {
  return (middleware) => {
    return async (req, res, next3, end) => {
      const releaseLock = await mutex.acquire();
      releaseLock();
      middleware(req, res, next3, end);
    };
  };
}
function objValues(obj, fn) {
  const values = [];
  for (let key2 in obj) {
    values.push(obj[key2]);
  }
  return values;
}
const ProviderSubprovider$1 = jsonRpcEngineMiddleware;
const createFilterMiddleware$1 = ethJsonRpcFilters;
class SubscriptionsSubprovider$2 extends ProviderSubprovider$1 {
  constructor() {
    super(({ blockTracker, provider, engine }) => {
      return createFilterMiddleware$1({ blockTracker, provider });
    });
  }
}
var filters = SubscriptionsSubprovider$2;
var waterfall$1 = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = function(tasks, callback) {
    callback = (0, _once2.default)(callback || _noop2.default);
    if (!(0, _isArray2.default)(tasks))
      return callback(new Error("First argument to waterfall must be an array of functions"));
    if (!tasks.length)
      return callback();
    var taskIndex = 0;
    function nextTask(args) {
      var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);
      args.push((0, _onlyOnce2.default)(next3));
      task.apply(null, args);
    }
    function next3(err) {
      if (err || taskIndex === tasks.length) {
        return callback.apply(null, arguments);
      }
      nextTask((0, _slice22.default)(arguments, 1));
    }
    nextTask([]);
  };
  var _isArray = isArray_1;
  var _isArray2 = _interopRequireDefault2(_isArray);
  var _noop = noop_1;
  var _noop2 = _interopRequireDefault2(_noop);
  var _once = once.exports;
  var _once2 = _interopRequireDefault2(_once);
  var _slice3 = slice.exports;
  var _slice22 = _interopRequireDefault2(_slice3);
  var _onlyOnce = onlyOnce.exports;
  var _onlyOnce2 = _interopRequireDefault2(_onlyOnce);
  var _wrapAsync = wrapAsync$1;
  var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  module2.exports = exports2["default"];
})(waterfall$1, waterfall$1.exports);
var parallel$2 = { exports: {} };
var parallel$1 = { exports: {} };
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = _parallel;
  var _noop = noop_1;
  var _noop2 = _interopRequireDefault2(_noop);
  var _isArrayLike = isArrayLike_1;
  var _isArrayLike2 = _interopRequireDefault2(_isArrayLike);
  var _slice3 = slice.exports;
  var _slice22 = _interopRequireDefault2(_slice3);
  var _wrapAsync = wrapAsync$1;
  var _wrapAsync2 = _interopRequireDefault2(_wrapAsync);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _parallel(eachfn, tasks, callback) {
    callback = callback || _noop2.default;
    var results2 = (0, _isArrayLike2.default)(tasks) ? [] : {};
    eachfn(tasks, function(task, key2, callback2) {
      (0, _wrapAsync2.default)(task)(function(err, result) {
        if (arguments.length > 2) {
          result = (0, _slice22.default)(arguments, 1);
        }
        results2[key2] = result;
        callback2(err);
      });
    }, function(err) {
      callback(err, results2);
    });
  }
  module2.exports = exports2["default"];
})(parallel$1, parallel$1.exports);
(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = parallelLimit;
  var _eachOf = eachOf.exports;
  var _eachOf2 = _interopRequireDefault2(_eachOf);
  var _parallel = parallel$1.exports;
  var _parallel2 = _interopRequireDefault2(_parallel);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function parallelLimit(tasks, callback) {
    (0, _parallel2.default)(_eachOf2.default, tasks, callback);
  }
  module2.exports = exports2["default"];
})(parallel$2, parallel$2.exports);
var dist$2 = {};
var secp256k1v3Adapter = {};
var secp256k1v3Lib = {};
Object.defineProperty(secp256k1v3Lib, "__esModule", { value: true });
var BN$6 = bn$2.exports;
var EC = elliptic$2.ec;
var ec = new EC("secp256k1");
var ecparams = ec.curve;
secp256k1v3Lib.privateKeyExport = function(privateKey, compressed) {
  if (compressed === void 0) {
    compressed = true;
  }
  var d2 = new BN$6(privateKey);
  if (d2.ucmp(ecparams.n) >= 0) {
    throw new Error("couldn't export to DER format");
  }
  var point7 = ec.g.mul(d2);
  return toPublicKey(point7.getX(), point7.getY(), compressed);
};
secp256k1v3Lib.privateKeyModInverse = function(privateKey) {
  var bn2 = new BN$6(privateKey);
  if (bn2.ucmp(ecparams.n) >= 0 || bn2.isZero()) {
    throw new Error("private key range is invalid");
  }
  return bn2.invm(ecparams.n).toArrayLike(buffer$2.Buffer, "be", 32);
};
secp256k1v3Lib.signatureImport = function(sigObj) {
  var r2 = new BN$6(sigObj.r);
  if (r2.ucmp(ecparams.n) >= 0) {
    r2 = new BN$6(0);
  }
  var s2 = new BN$6(sigObj.s);
  if (s2.ucmp(ecparams.n) >= 0) {
    s2 = new BN$6(0);
  }
  return buffer$2.Buffer.concat([r2.toArrayLike(buffer$2.Buffer, "be", 32), s2.toArrayLike(buffer$2.Buffer, "be", 32)]);
};
secp256k1v3Lib.ecdhUnsafe = function(publicKey, privateKey, compressed) {
  if (compressed === void 0) {
    compressed = true;
  }
  var point7 = ec.keyFromPublic(publicKey);
  var scalar = new BN$6(privateKey);
  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
    throw new Error("scalar was invalid (zero or overflow)");
  }
  var shared = point7.pub.mul(scalar);
  return toPublicKey(shared.getX(), shared.getY(), compressed);
};
var toPublicKey = function(x2, y2, compressed) {
  var publicKey;
  if (compressed) {
    publicKey = buffer$2.Buffer.alloc(33);
    publicKey[0] = y2.isOdd() ? 3 : 2;
    x2.toArrayLike(buffer$2.Buffer, "be", 32).copy(publicKey, 1);
  } else {
    publicKey = buffer$2.Buffer.alloc(65);
    publicKey[0] = 4;
    x2.toArrayLike(buffer$2.Buffer, "be", 32).copy(publicKey, 1);
    y2.toArrayLike(buffer$2.Buffer, "be", 32).copy(publicKey, 33);
  }
  return publicKey;
};
var der = {};
Object.defineProperty(der, "__esModule", { value: true });
var EC_PRIVKEY_EXPORT_DER_COMPRESSED = buffer$2.Buffer.from([
  48,
  129,
  211,
  2,
  1,
  1,
  4,
  32,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  160,
  129,
  133,
  48,
  129,
  130,
  2,
  1,
  1,
  48,
  44,
  6,
  7,
  42,
  134,
  72,
  206,
  61,
  1,
  1,
  2,
  33,
  0,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  255,
  255,
  252,
  47,
  48,
  6,
  4,
  1,
  0,
  4,
  1,
  7,
  4,
  33,
  2,
  121,
  190,
  102,
  126,
  249,
  220,
  187,
  172,
  85,
  160,
  98,
  149,
  206,
  135,
  11,
  7,
  2,
  155,
  252,
  219,
  45,
  206,
  40,
  217,
  89,
  242,
  129,
  91,
  22,
  248,
  23,
  152,
  2,
  33,
  0,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  186,
  174,
  220,
  230,
  175,
  72,
  160,
  59,
  191,
  210,
  94,
  140,
  208,
  54,
  65,
  65,
  2,
  1,
  1,
  161,
  36,
  3,
  34,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = buffer$2.Buffer.from([
  48,
  130,
  1,
  19,
  2,
  1,
  1,
  4,
  32,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  160,
  129,
  165,
  48,
  129,
  162,
  2,
  1,
  1,
  48,
  44,
  6,
  7,
  42,
  134,
  72,
  206,
  61,
  1,
  1,
  2,
  33,
  0,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  255,
  255,
  252,
  47,
  48,
  6,
  4,
  1,
  0,
  4,
  1,
  7,
  4,
  65,
  4,
  121,
  190,
  102,
  126,
  249,
  220,
  187,
  172,
  85,
  160,
  98,
  149,
  206,
  135,
  11,
  7,
  2,
  155,
  252,
  219,
  45,
  206,
  40,
  217,
  89,
  242,
  129,
  91,
  22,
  248,
  23,
  152,
  72,
  58,
  218,
  119,
  38,
  163,
  196,
  101,
  93,
  164,
  251,
  252,
  14,
  17,
  8,
  168,
  253,
  23,
  180,
  72,
  166,
  133,
  84,
  25,
  156,
  71,
  208,
  143,
  251,
  16,
  212,
  184,
  2,
  33,
  0,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  255,
  254,
  186,
  174,
  220,
  230,
  175,
  72,
  160,
  59,
  191,
  210,
  94,
  140,
  208,
  54,
  65,
  65,
  2,
  1,
  1,
  161,
  68,
  3,
  66,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
]);
der.privateKeyExport = function(privateKey, publicKey, compressed) {
  if (compressed === void 0) {
    compressed = true;
  }
  var result = buffer$2.Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
  privateKey.copy(result, compressed ? 8 : 9);
  publicKey.copy(result, compressed ? 181 : 214);
  return result;
};
der.privateKeyImport = function(privateKey) {
  var length = privateKey.length;
  var index2 = 0;
  if (length < index2 + 1 || privateKey[index2] !== 48)
    return null;
  index2 += 1;
  if (length < index2 + 1 || !(privateKey[index2] & 128))
    return null;
  var lenb = privateKey[index2] & 127;
  index2 += 1;
  if (lenb < 1 || lenb > 2)
    return null;
  if (length < index2 + lenb)
    return null;
  var len2 = privateKey[index2 + lenb - 1] | (lenb > 1 ? privateKey[index2 + lenb - 2] << 8 : 0);
  index2 += lenb;
  if (length < index2 + len2)
    return null;
  if (length < index2 + 3 || privateKey[index2] !== 2 || privateKey[index2 + 1] !== 1 || privateKey[index2 + 2] !== 1) {
    return null;
  }
  index2 += 3;
  if (length < index2 + 2 || privateKey[index2] !== 4 || privateKey[index2 + 1] > 32 || length < index2 + 2 + privateKey[index2 + 1]) {
    return null;
  }
  return privateKey.slice(index2 + 2, index2 + 2 + privateKey[index2 + 1]);
};
der.signatureImportLax = function(signature2) {
  var r2 = buffer$2.Buffer.alloc(32, 0);
  var s2 = buffer$2.Buffer.alloc(32, 0);
  var length = signature2.length;
  var index2 = 0;
  if (signature2[index2++] !== 48) {
    return null;
  }
  var lenbyte = signature2[index2++];
  if (lenbyte & 128) {
    index2 += lenbyte - 128;
    if (index2 > length) {
      return null;
    }
  }
  if (signature2[index2++] !== 2) {
    return null;
  }
  var rlen = signature2[index2++];
  if (rlen & 128) {
    lenbyte = rlen - 128;
    if (index2 + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature2[index2] === 0; index2 += 1, lenbyte -= 1)
      ;
    for (rlen = 0; lenbyte > 0; index2 += 1, lenbyte -= 1)
      rlen = (rlen << 8) + signature2[index2];
  }
  if (rlen > length - index2) {
    return null;
  }
  var rindex = index2;
  index2 += rlen;
  if (signature2[index2++] !== 2) {
    return null;
  }
  var slen = signature2[index2++];
  if (slen & 128) {
    lenbyte = slen - 128;
    if (index2 + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature2[index2] === 0; index2 += 1, lenbyte -= 1)
      ;
    for (slen = 0; lenbyte > 0; index2 += 1, lenbyte -= 1)
      slen = (slen << 8) + signature2[index2];
  }
  if (slen > length - index2) {
    return null;
  }
  var sindex = index2;
  index2 += slen;
  for (; rlen > 0 && signature2[rindex] === 0; rlen -= 1, rindex += 1)
    ;
  if (rlen > 32) {
    return null;
  }
  var rvalue = signature2.slice(rindex, rindex + rlen);
  rvalue.copy(r2, 32 - rvalue.length);
  for (; slen > 0 && signature2[sindex] === 0; slen -= 1, sindex += 1)
    ;
  if (slen > 32) {
    return null;
  }
  var svalue = signature2.slice(sindex, sindex + slen);
  svalue.copy(s2, 32 - svalue.length);
  return { r: r2, s: s2 };
};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ecdhUnsafe = exports2.ecdh = exports2.recover = exports2.verify = exports2.sign = exports2.signatureImportLax = exports2.signatureImport = exports2.signatureExport = exports2.signatureNormalize = exports2.publicKeyCombine = exports2.publicKeyTweakMul = exports2.publicKeyTweakAdd = exports2.publicKeyVerify = exports2.publicKeyConvert = exports2.publicKeyCreate = exports2.privateKeyTweakMul = exports2.privateKeyTweakAdd = exports2.privateKeyModInverse = exports2.privateKeyNegate = exports2.privateKeyImport = exports2.privateKeyExport = exports2.privateKeyVerify = void 0;
  var secp256k12 = secp256k1$2;
  var secp256k1v32 = secp256k1v3Lib;
  var der$12 = der;
  exports2.privateKeyVerify = function(privateKey) {
    if (privateKey.length !== 32) {
      return false;
    }
    return secp256k12.privateKeyVerify(Uint8Array.from(privateKey));
  };
  exports2.privateKeyExport = function(privateKey, compressed) {
    if (privateKey.length !== 32) {
      throw new RangeError("private key length is invalid");
    }
    var publicKey = secp256k1v32.privateKeyExport(privateKey, compressed);
    return der$12.privateKeyExport(privateKey, publicKey, compressed);
  };
  exports2.privateKeyImport = function(privateKey) {
    privateKey = der$12.privateKeyImport(privateKey);
    if (privateKey !== null && privateKey.length === 32 && exports2.privateKeyVerify(privateKey)) {
      return privateKey;
    }
    throw new Error("couldn't import from DER format");
  };
  exports2.privateKeyNegate = function(privateKey) {
    return buffer$2.Buffer.from(secp256k12.privateKeyNegate(Uint8Array.from(privateKey)));
  };
  exports2.privateKeyModInverse = function(privateKey) {
    if (privateKey.length !== 32) {
      throw new Error("private key length is invalid");
    }
    return buffer$2.Buffer.from(secp256k1v32.privateKeyModInverse(Uint8Array.from(privateKey)));
  };
  exports2.privateKeyTweakAdd = function(privateKey, tweak) {
    return buffer$2.Buffer.from(secp256k12.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
  };
  exports2.privateKeyTweakMul = function(privateKey, tweak) {
    return buffer$2.Buffer.from(secp256k12.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
  };
  exports2.publicKeyCreate = function(privateKey, compressed) {
    return buffer$2.Buffer.from(secp256k12.publicKeyCreate(Uint8Array.from(privateKey), compressed));
  };
  exports2.publicKeyConvert = function(publicKey, compressed) {
    return buffer$2.Buffer.from(secp256k12.publicKeyConvert(Uint8Array.from(publicKey), compressed));
  };
  exports2.publicKeyVerify = function(publicKey) {
    if (publicKey.length !== 33 && publicKey.length !== 65) {
      return false;
    }
    return secp256k12.publicKeyVerify(Uint8Array.from(publicKey));
  };
  exports2.publicKeyTweakAdd = function(publicKey, tweak, compressed) {
    return buffer$2.Buffer.from(secp256k12.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
  };
  exports2.publicKeyTweakMul = function(publicKey, tweak, compressed) {
    return buffer$2.Buffer.from(secp256k12.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
  };
  exports2.publicKeyCombine = function(publicKeys, compressed) {
    var keys2 = [];
    publicKeys.forEach(function(publicKey) {
      keys2.push(Uint8Array.from(publicKey));
    });
    return buffer$2.Buffer.from(secp256k12.publicKeyCombine(keys2, compressed));
  };
  exports2.signatureNormalize = function(signature2) {
    return buffer$2.Buffer.from(secp256k12.signatureNormalize(Uint8Array.from(signature2)));
  };
  exports2.signatureExport = function(signature2) {
    return buffer$2.Buffer.from(secp256k12.signatureExport(Uint8Array.from(signature2)));
  };
  exports2.signatureImport = function(signature2) {
    return buffer$2.Buffer.from(secp256k12.signatureImport(Uint8Array.from(signature2)));
  };
  exports2.signatureImportLax = function(signature2) {
    if (signature2.length === 0) {
      throw new RangeError("signature length is invalid");
    }
    var sigObj = der$12.signatureImportLax(signature2);
    if (sigObj === null) {
      throw new Error("couldn't parse DER signature");
    }
    return secp256k1v32.signatureImport(sigObj);
  };
  exports2.sign = function(message, privateKey, options) {
    if (options === null) {
      throw new TypeError("options should be an Object");
    }
    var signOptions = void 0;
    if (options) {
      signOptions = {};
      if (options.data === null) {
        throw new TypeError("options.data should be a Buffer");
      }
      if (options.data) {
        if (options.data.length != 32) {
          throw new RangeError("options.data length is invalid");
        }
        signOptions.data = new Uint8Array(options.data);
      }
      if (options.noncefn === null) {
        throw new TypeError("options.noncefn should be a Function");
      }
      if (options.noncefn) {
        signOptions.noncefn = function(message2, privateKey2, algo, data, attempt) {
          var bufferAlgo = algo != null ? buffer$2.Buffer.from(algo) : null;
          var bufferData = data != null ? buffer$2.Buffer.from(data) : null;
          var buffer2 = buffer$2.Buffer.from("");
          if (options.noncefn) {
            buffer2 = options.noncefn(buffer$2.Buffer.from(message2), buffer$2.Buffer.from(privateKey2), bufferAlgo, bufferData, attempt);
          }
          return new Uint8Array(buffer2);
        };
      }
    }
    var sig = secp256k12.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);
    return {
      signature: buffer$2.Buffer.from(sig.signature),
      recovery: sig.recid
    };
  };
  exports2.verify = function(message, signature2, publicKey) {
    return secp256k12.ecdsaVerify(Uint8Array.from(signature2), Uint8Array.from(message), publicKey);
  };
  exports2.recover = function(message, signature2, recid, compressed) {
    return buffer$2.Buffer.from(secp256k12.ecdsaRecover(Uint8Array.from(signature2), recid, Uint8Array.from(message), compressed));
  };
  exports2.ecdh = function(publicKey, privateKey) {
    return buffer$2.Buffer.from(secp256k12.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
  };
  exports2.ecdhUnsafe = function(publicKey, privateKey, compressed) {
    if (publicKey.length !== 33 && publicKey.length !== 65) {
      throw new RangeError("public key length is invalid");
    }
    if (privateKey.length !== 32) {
      throw new RangeError("private key length is invalid");
    }
    return buffer$2.Buffer.from(secp256k1v32.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
  };
})(secp256k1v3Adapter);
var constants$1 = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.KECCAK256_RLP = exports2.KECCAK256_RLP_S = exports2.KECCAK256_RLP_ARRAY = exports2.KECCAK256_RLP_ARRAY_S = exports2.KECCAK256_NULL = exports2.KECCAK256_NULL_S = exports2.TWO_POW256 = exports2.MAX_INTEGER = void 0;
  var BN2 = bn$2.exports;
  exports2.MAX_INTEGER = new BN2("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
  exports2.TWO_POW256 = new BN2("10000000000000000000000000000000000000000000000000000000000000000", 16);
  exports2.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
  exports2.KECCAK256_NULL = buffer$2.Buffer.from(exports2.KECCAK256_NULL_S, "hex");
  exports2.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
  exports2.KECCAK256_RLP_ARRAY = buffer$2.Buffer.from(exports2.KECCAK256_RLP_ARRAY_S, "hex");
  exports2.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
  exports2.KECCAK256_RLP = buffer$2.Buffer.from(exports2.KECCAK256_RLP_S, "hex");
})(constants$1);
var account = {};
var bytes = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.baToJSON = exports2.addHexPrefix = exports2.toUnsigned = exports2.fromSigned = exports2.bufferToHex = exports2.bufferToInt = exports2.toBuffer = exports2.stripZeros = exports2.unpad = exports2.setLengthRight = exports2.setLength = exports2.setLengthLeft = exports2.zeros = void 0;
  var ethjsUtil2 = lib$2;
  var BN2 = bn$2.exports;
  exports2.zeros = function(bytes3) {
    return buffer$2.Buffer.allocUnsafe(bytes3).fill(0);
  };
  exports2.setLengthLeft = function(msg, length, right) {
    if (right === void 0) {
      right = false;
    }
    var buf = exports2.zeros(length);
    msg = exports2.toBuffer(msg);
    if (right) {
      if (msg.length < length) {
        msg.copy(buf);
        return buf;
      }
      return msg.slice(0, length);
    } else {
      if (msg.length < length) {
        msg.copy(buf, length - msg.length);
        return buf;
      }
      return msg.slice(-length);
    }
  };
  exports2.setLength = exports2.setLengthLeft;
  exports2.setLengthRight = function(msg, length) {
    return exports2.setLength(msg, length, true);
  };
  exports2.unpad = function(a2) {
    a2 = ethjsUtil2.stripHexPrefix(a2);
    var first2 = a2[0];
    while (a2.length > 0 && first2.toString() === "0") {
      a2 = a2.slice(1);
      first2 = a2[0];
    }
    return a2;
  };
  exports2.stripZeros = exports2.unpad;
  exports2.toBuffer = function(v2) {
    if (!buffer$2.Buffer.isBuffer(v2)) {
      if (Array.isArray(v2)) {
        v2 = buffer$2.Buffer.from(v2);
      } else if (typeof v2 === "string") {
        if (ethjsUtil2.isHexString(v2)) {
          v2 = buffer$2.Buffer.from(ethjsUtil2.padToEven(ethjsUtil2.stripHexPrefix(v2)), "hex");
        } else {
          throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v2);
        }
      } else if (typeof v2 === "number") {
        v2 = ethjsUtil2.intToBuffer(v2);
      } else if (v2 === null || v2 === void 0) {
        v2 = buffer$2.Buffer.allocUnsafe(0);
      } else if (BN2.isBN(v2)) {
        v2 = v2.toArrayLike(buffer$2.Buffer);
      } else if (v2.toArray) {
        v2 = buffer$2.Buffer.from(v2.toArray());
      } else {
        throw new Error("invalid type");
      }
    }
    return v2;
  };
  exports2.bufferToInt = function(buf) {
    return new BN2(exports2.toBuffer(buf)).toNumber();
  };
  exports2.bufferToHex = function(buf) {
    buf = exports2.toBuffer(buf);
    return "0x" + buf.toString("hex");
  };
  exports2.fromSigned = function(num) {
    return new BN2(num).fromTwos(256);
  };
  exports2.toUnsigned = function(num) {
    return buffer$2.Buffer.from(num.toTwos(256).toArray());
  };
  exports2.addHexPrefix = function(str2) {
    if (typeof str2 !== "string") {
      return str2;
    }
    return ethjsUtil2.isHexPrefixed(str2) ? str2 : "0x" + str2;
  };
  exports2.baToJSON = function(ba) {
    if (buffer$2.Buffer.isBuffer(ba)) {
      return "0x" + ba.toString("hex");
    } else if (ba instanceof Array) {
      var array2 = [];
      for (var i2 = 0; i2 < ba.length; i2++) {
        array2.push(exports2.baToJSON(ba[i2]));
      }
      return array2;
    }
  };
})(bytes);
var hash = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.rlphash = exports2.ripemd160 = exports2.sha256 = exports2.keccak256 = exports2.keccak = void 0;
  var _a2 = keccak$3, keccak224 = _a2.keccak224, keccak384 = _a2.keccak384, k256 = _a2.keccak256, keccak512 = _a2.keccak512;
  var createHash2 = browser$3;
  var ethjsUtil2 = lib$2;
  var rlp2 = dist_browser;
  var bytes_12 = bytes;
  exports2.keccak = function(a2, bits) {
    if (bits === void 0) {
      bits = 256;
    }
    if (typeof a2 === "string" && !ethjsUtil2.isHexString(a2)) {
      a2 = buffer$2.Buffer.from(a2, "utf8");
    } else {
      a2 = bytes_12.toBuffer(a2);
    }
    if (!bits)
      bits = 256;
    switch (bits) {
      case 224: {
        return keccak224(a2);
      }
      case 256: {
        return k256(a2);
      }
      case 384: {
        return keccak384(a2);
      }
      case 512: {
        return keccak512(a2);
      }
      default: {
        throw new Error("Invald algorithm: keccak" + bits);
      }
    }
  };
  exports2.keccak256 = function(a2) {
    return exports2.keccak(a2);
  };
  exports2.sha256 = function(a2) {
    a2 = bytes_12.toBuffer(a2);
    return createHash2("sha256").update(a2).digest();
  };
  exports2.ripemd160 = function(a2, padded) {
    a2 = bytes_12.toBuffer(a2);
    var hash3 = createHash2("rmd160").update(a2).digest();
    if (padded === true) {
      return bytes_12.setLength(hash3, 32);
    } else {
      return hash3;
    }
  };
  exports2.rlphash = function(a2) {
    return exports2.keccak(rlp2.encode(a2));
  };
})(hash);
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.importPublic = exports2.privateToPublic = exports2.privateToAddress = exports2.publicToAddress = exports2.pubToAddress = exports2.isValidPublic = exports2.isValidPrivate = exports2.isPrecompiled = exports2.generateAddress2 = exports2.generateAddress = exports2.isValidChecksumAddress = exports2.toChecksumAddress = exports2.isZeroAddress = exports2.isValidAddress = exports2.zeroAddress = void 0;
  var assert2 = require$$2$2;
  var ethjsUtil2 = lib$2;
  var secp256k12 = secp256k1v3Adapter;
  var BN2 = bn$2.exports;
  var bytes_12 = bytes;
  var hash_12 = hash;
  exports2.zeroAddress = function() {
    var addressLength = 20;
    var addr = bytes_12.zeros(addressLength);
    return bytes_12.bufferToHex(addr);
  };
  exports2.isValidAddress = function(address) {
    return /^0x[0-9a-fA-F]{40}$/.test(address);
  };
  exports2.isZeroAddress = function(address) {
    var zeroAddr = exports2.zeroAddress();
    return zeroAddr === bytes_12.addHexPrefix(address);
  };
  exports2.toChecksumAddress = function(address, eip1191ChainId) {
    address = ethjsUtil2.stripHexPrefix(address).toLowerCase();
    var prefix = eip1191ChainId !== void 0 ? eip1191ChainId.toString() + "0x" : "";
    var hash3 = hash_12.keccak(prefix + address).toString("hex");
    var ret = "0x";
    for (var i2 = 0; i2 < address.length; i2++) {
      if (parseInt(hash3[i2], 16) >= 8) {
        ret += address[i2].toUpperCase();
      } else {
        ret += address[i2];
      }
    }
    return ret;
  };
  exports2.isValidChecksumAddress = function(address, eip1191ChainId) {
    return exports2.isValidAddress(address) && exports2.toChecksumAddress(address, eip1191ChainId) === address;
  };
  exports2.generateAddress = function(from2, nonce) {
    from2 = bytes_12.toBuffer(from2);
    var nonceBN = new BN2(nonce);
    if (nonceBN.isZero()) {
      return hash_12.rlphash([from2, null]).slice(-20);
    }
    return hash_12.rlphash([from2, buffer$2.Buffer.from(nonceBN.toArray())]).slice(-20);
  };
  exports2.generateAddress2 = function(from2, salt, initCode) {
    var fromBuf = bytes_12.toBuffer(from2);
    var saltBuf = bytes_12.toBuffer(salt);
    var initCodeBuf = bytes_12.toBuffer(initCode);
    assert2(fromBuf.length === 20);
    assert2(saltBuf.length === 32);
    var address = hash_12.keccak256(buffer$2.Buffer.concat([buffer$2.Buffer.from("ff", "hex"), fromBuf, saltBuf, hash_12.keccak256(initCodeBuf)]));
    return address.slice(-20);
  };
  exports2.isPrecompiled = function(address) {
    var a2 = bytes_12.unpad(address);
    return a2.length === 1 && a2[0] >= 1 && a2[0] <= 8;
  };
  exports2.isValidPrivate = function(privateKey) {
    return secp256k12.privateKeyVerify(privateKey);
  };
  exports2.isValidPublic = function(publicKey, sanitize) {
    if (sanitize === void 0) {
      sanitize = false;
    }
    if (publicKey.length === 64) {
      return secp256k12.publicKeyVerify(buffer$2.Buffer.concat([buffer$2.Buffer.from([4]), publicKey]));
    }
    if (!sanitize) {
      return false;
    }
    return secp256k12.publicKeyVerify(publicKey);
  };
  exports2.pubToAddress = function(pubKey, sanitize) {
    if (sanitize === void 0) {
      sanitize = false;
    }
    pubKey = bytes_12.toBuffer(pubKey);
    if (sanitize && pubKey.length !== 64) {
      pubKey = secp256k12.publicKeyConvert(pubKey, false).slice(1);
    }
    assert2(pubKey.length === 64);
    return hash_12.keccak(pubKey).slice(-20);
  };
  exports2.publicToAddress = exports2.pubToAddress;
  exports2.privateToAddress = function(privateKey) {
    return exports2.publicToAddress(exports2.privateToPublic(privateKey));
  };
  exports2.privateToPublic = function(privateKey) {
    privateKey = bytes_12.toBuffer(privateKey);
    return secp256k12.publicKeyCreate(privateKey, false).slice(1);
  };
  exports2.importPublic = function(publicKey) {
    publicKey = bytes_12.toBuffer(publicKey);
    if (publicKey.length !== 64) {
      publicKey = secp256k12.publicKeyConvert(publicKey, false).slice(1);
    }
    return publicKey;
  };
})(account);
var signature = {};
Object.defineProperty(signature, "__esModule", { value: true });
signature.hashPersonalMessage = signature.isValidSignature = signature.fromRpcSig = signature.toRpcSig = signature.ecrecover = signature.ecsign = void 0;
var secp256k1 = secp256k1v3Adapter;
var BN$5 = bn$2.exports;
var bytes_1$1 = bytes;
var hash_1 = hash;
signature.ecsign = function(msgHash, privateKey, chainId) {
  var sig = secp256k1.sign(msgHash, privateKey);
  var recovery = sig.recovery;
  var ret = {
    r: sig.signature.slice(0, 32),
    s: sig.signature.slice(32, 64),
    v: chainId ? recovery + (chainId * 2 + 35) : recovery + 27
  };
  return ret;
};
signature.ecrecover = function(msgHash, v2, r2, s2, chainId) {
  var signature2 = buffer$2.Buffer.concat([bytes_1$1.setLength(r2, 32), bytes_1$1.setLength(s2, 32)], 64);
  var recovery = calculateSigRecovery(v2, chainId);
  if (!isValidSigRecovery(recovery)) {
    throw new Error("Invalid signature v value");
  }
  var senderPubKey = secp256k1.recover(msgHash, signature2, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};
signature.toRpcSig = function(v2, r2, s2, chainId) {
  var recovery = calculateSigRecovery(v2, chainId);
  if (!isValidSigRecovery(recovery)) {
    throw new Error("Invalid signature v value");
  }
  return bytes_1$1.bufferToHex(buffer$2.Buffer.concat([bytes_1$1.setLengthLeft(r2, 32), bytes_1$1.setLengthLeft(s2, 32), bytes_1$1.toBuffer(v2)]));
};
signature.fromRpcSig = function(sig) {
  var buf = bytes_1$1.toBuffer(sig);
  if (buf.length !== 65) {
    throw new Error("Invalid signature length");
  }
  var v2 = buf[64];
  if (v2 < 27) {
    v2 += 27;
  }
  return {
    v: v2,
    r: buf.slice(0, 32),
    s: buf.slice(32, 64)
  };
};
signature.isValidSignature = function(v2, r2, s2, homesteadOrLater, chainId) {
  if (homesteadOrLater === void 0) {
    homesteadOrLater = true;
  }
  var SECP256K1_N_DIV_2 = new BN$5("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
  var SECP256K1_N = new BN$5("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
  if (r2.length !== 32 || s2.length !== 32) {
    return false;
  }
  if (!isValidSigRecovery(calculateSigRecovery(v2, chainId))) {
    return false;
  }
  var rBN = new BN$5(r2);
  var sBN = new BN$5(s2);
  if (rBN.isZero() || rBN.gt(SECP256K1_N) || sBN.isZero() || sBN.gt(SECP256K1_N)) {
    return false;
  }
  if (homesteadOrLater && sBN.cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }
  return true;
};
signature.hashPersonalMessage = function(message) {
  var prefix = buffer$2.Buffer.from("Ethereum Signed Message:\n" + message.length.toString(), "utf-8");
  return hash_1.keccak(buffer$2.Buffer.concat([prefix, message]));
};
function calculateSigRecovery(v2, chainId) {
  return chainId ? v2 - (2 * chainId + 35) : v2 - 27;
}
function isValidSigRecovery(recovery) {
  return recovery === 0 || recovery === 1;
}
var object = {};
Object.defineProperty(object, "__esModule", { value: true });
object.defineProperties = void 0;
var assert$1 = require$$2$2;
var ethjsUtil = lib$2;
var rlp = dist_browser;
var bytes_1 = bytes;
object.defineProperties = function(self2, fields, data) {
  self2.raw = [];
  self2._fields = [];
  self2.toJSON = function(label) {
    if (label === void 0) {
      label = false;
    }
    if (label) {
      var obj_1 = {};
      self2._fields.forEach(function(field) {
        obj_1[field] = "0x" + self2[field].toString("hex");
      });
      return obj_1;
    }
    return bytes_1.baToJSON(self2.raw);
  };
  self2.serialize = function serialize2() {
    return rlp.encode(self2.raw);
  };
  fields.forEach(function(field, i2) {
    self2._fields.push(field.name);
    function getter() {
      return self2.raw[i2];
    }
    function setter(v2) {
      v2 = bytes_1.toBuffer(v2);
      if (v2.toString("hex") === "00" && !field.allowZero) {
        v2 = buffer$2.Buffer.allocUnsafe(0);
      }
      if (field.allowLess && field.length) {
        v2 = bytes_1.stripZeros(v2);
        assert$1(field.length >= v2.length, "The field " + field.name + " must not have more " + field.length + " bytes");
      } else if (!(field.allowZero && v2.length === 0) && field.length) {
        assert$1(field.length === v2.length, "The field " + field.name + " must have byte length of " + field.length);
      }
      self2.raw[i2] = v2;
    }
    Object.defineProperty(self2, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });
    if (field.default) {
      self2[field.name] = field.default;
    }
    if (field.alias) {
      Object.defineProperty(self2, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });
  if (data) {
    if (typeof data === "string") {
      data = buffer$2.Buffer.from(ethjsUtil.stripHexPrefix(data), "hex");
    }
    if (buffer$2.Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }
    if (Array.isArray(data)) {
      if (data.length > self2._fields.length) {
        throw new Error("wrong number of fields in data");
      }
      data.forEach(function(d2, i2) {
        self2[self2._fields[i2]] = bytes_1.toBuffer(d2);
      });
    } else if (typeof data === "object") {
      var keys_12 = Object.keys(data);
      fields.forEach(function(field) {
        if (keys_12.indexOf(field.name) !== -1)
          self2[field.name] = data[field.name];
        if (keys_12.indexOf(field.alias) !== -1)
          self2[field.alias] = data[field.alias];
      });
    } else {
      throw new Error("invalid data");
    }
  }
};
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !exports3.hasOwnProperty(p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.secp256k1 = exports2.rlp = exports2.BN = void 0;
  var secp256k12 = secp256k1v3Adapter;
  exports2.secp256k1 = secp256k12;
  var ethjsUtil2 = lib$2;
  var BN2 = bn$2.exports;
  exports2.BN = BN2;
  var rlp2 = dist_browser;
  exports2.rlp = rlp2;
  Object.assign(exports2, ethjsUtil2);
  __exportStar(constants$1, exports2);
  __exportStar(account, exports2);
  __exportStar(hash, exports2);
  __exportStar(signature, exports2);
  __exportStar(bytes, exports2);
  __exportStar(object, exports2);
})(dist$2);
const utils$2 = dist$2;
const BN$4 = bn$2.exports;
var ABI = function() {
};
function elementaryName$1(name2) {
  if (name2.startsWith("int[")) {
    return "int256" + name2.slice(3);
  } else if (name2 === "int") {
    return "int256";
  } else if (name2.startsWith("uint[")) {
    return "uint256" + name2.slice(4);
  } else if (name2 === "uint") {
    return "uint256";
  } else if (name2.startsWith("fixed[")) {
    return "fixed128x128" + name2.slice(5);
  } else if (name2 === "fixed") {
    return "fixed128x128";
  } else if (name2.startsWith("ufixed[")) {
    return "ufixed128x128" + name2.slice(6);
  } else if (name2 === "ufixed") {
    return "ufixed128x128";
  }
  return name2;
}
ABI.eventID = function(name2, types2) {
  var sig = name2 + "(" + types2.map(elementaryName$1).join(",") + ")";
  return utils$2.keccak256(buffer$2.Buffer.from(sig));
};
ABI.methodID = function(name2, types2) {
  return ABI.eventID(name2, types2).slice(0, 4);
};
function parseTypeN$1(type) {
  return parseInt(/^\D+(\d+)$/.exec(type)[1], 10);
}
function parseTypeNxM$1(type) {
  var tmp = /^\D+(\d+)x(\d+)$/.exec(type);
  return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
}
function parseTypeArray$1(type) {
  var tmp = type.match(/(.*)\[(.*?)\]$/);
  if (tmp) {
    return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
  }
  return null;
}
function parseNumber$1(arg) {
  var type = typeof arg;
  if (type === "string") {
    if (utils$2.isHexPrefixed(arg)) {
      return new BN$4(utils$2.stripHexPrefix(arg), 16);
    } else {
      return new BN$4(arg, 10);
    }
  } else if (type === "number") {
    return new BN$4(arg);
  } else if (arg.toArray) {
    return arg;
  } else {
    throw new Error("Argument is not a number");
  }
}
function parseSignature(sig) {
  var tmp = /^(\w+)\((.*)\)$/.exec(sig);
  if (tmp.length !== 3) {
    throw new Error("Invalid method signature");
  }
  var args = /^(.+)\):\((.+)$/.exec(tmp[2]);
  if (args !== null && args.length === 3) {
    return {
      method: tmp[1],
      args: args[1].split(","),
      retargs: args[2].split(",")
    };
  } else {
    var params = tmp[2].split(",");
    if (params.length === 1 && params[0] === "") {
      params = [];
    }
    return {
      method: tmp[1],
      args: params
    };
  }
}
function encodeSingle$1(type, arg) {
  var size2, num, ret, i2;
  if (type === "address") {
    return encodeSingle$1("uint160", parseNumber$1(arg));
  } else if (type === "bool") {
    return encodeSingle$1("uint8", arg ? 1 : 0);
  } else if (type === "string") {
    return encodeSingle$1("bytes", buffer$2.Buffer.from(arg, "utf8"));
  } else if (isArray$4(type)) {
    if (typeof arg.length === "undefined") {
      throw new Error("Not an array?");
    }
    size2 = parseTypeArray$1(type);
    if (size2 !== "dynamic" && size2 !== 0 && arg.length > size2) {
      throw new Error("Elements exceed array size: " + size2);
    }
    ret = [];
    type = type.slice(0, type.lastIndexOf("["));
    if (typeof arg === "string") {
      arg = JSON.parse(arg);
    }
    for (i2 in arg) {
      ret.push(encodeSingle$1(type, arg[i2]));
    }
    if (size2 === "dynamic") {
      var length = encodeSingle$1("uint256", arg.length);
      ret.unshift(length);
    }
    return buffer$2.Buffer.concat(ret);
  } else if (type === "bytes") {
    arg = buffer$2.Buffer.from(arg);
    ret = buffer$2.Buffer.concat([encodeSingle$1("uint256", arg.length), arg]);
    if (arg.length % 32 !== 0) {
      ret = buffer$2.Buffer.concat([ret, utils$2.zeros(32 - arg.length % 32)]);
    }
    return ret;
  } else if (type.startsWith("bytes")) {
    size2 = parseTypeN$1(type);
    if (size2 < 1 || size2 > 32) {
      throw new Error("Invalid bytes<N> width: " + size2);
    }
    return utils$2.setLengthRight(arg, 32);
  } else if (type.startsWith("uint")) {
    size2 = parseTypeN$1(type);
    if (size2 % 8 || size2 < 8 || size2 > 256) {
      throw new Error("Invalid uint<N> width: " + size2);
    }
    num = parseNumber$1(arg);
    if (num.bitLength() > size2) {
      throw new Error("Supplied uint exceeds width: " + size2 + " vs " + num.bitLength());
    }
    if (num < 0) {
      throw new Error("Supplied uint is negative");
    }
    return num.toArrayLike(buffer$2.Buffer, "be", 32);
  } else if (type.startsWith("int")) {
    size2 = parseTypeN$1(type);
    if (size2 % 8 || size2 < 8 || size2 > 256) {
      throw new Error("Invalid int<N> width: " + size2);
    }
    num = parseNumber$1(arg);
    if (num.bitLength() > size2) {
      throw new Error("Supplied int exceeds width: " + size2 + " vs " + num.bitLength());
    }
    return num.toTwos(256).toArrayLike(buffer$2.Buffer, "be", 32);
  } else if (type.startsWith("ufixed")) {
    size2 = parseTypeNxM$1(type);
    num = parseNumber$1(arg);
    if (num < 0) {
      throw new Error("Supplied ufixed is negative");
    }
    return encodeSingle$1("uint256", num.mul(new BN$4(2).pow(new BN$4(size2[1]))));
  } else if (type.startsWith("fixed")) {
    size2 = parseTypeNxM$1(type);
    return encodeSingle$1("int256", parseNumber$1(arg).mul(new BN$4(2).pow(new BN$4(size2[1]))));
  }
  throw new Error("Unsupported or invalid type: " + type);
}
function decodeSingle(parsedType, data, offset) {
  if (typeof parsedType === "string") {
    parsedType = parseType(parsedType);
  }
  var size2, num, ret, i2;
  if (parsedType.name === "address") {
    return decodeSingle(parsedType.rawType, data, offset).toArrayLike(buffer$2.Buffer, "be", 20).toString("hex");
  } else if (parsedType.name === "bool") {
    return decodeSingle(parsedType.rawType, data, offset).toString() === new BN$4(1).toString();
  } else if (parsedType.name === "string") {
    var bytes3 = decodeSingle(parsedType.rawType, data, offset);
    return buffer$2.Buffer.from(bytes3, "utf8").toString();
  } else if (parsedType.isArray) {
    ret = [];
    size2 = parsedType.size;
    if (parsedType.size === "dynamic") {
      offset = decodeSingle("uint256", data, offset).toNumber();
      size2 = decodeSingle("uint256", data, offset).toNumber();
      offset = offset + 32;
    }
    for (i2 = 0; i2 < size2; i2++) {
      var decoded = decodeSingle(parsedType.subArray, data, offset);
      ret.push(decoded);
      offset += parsedType.subArray.memoryUsage;
    }
    return ret;
  } else if (parsedType.name === "bytes") {
    offset = decodeSingle("uint256", data, offset).toNumber();
    size2 = decodeSingle("uint256", data, offset).toNumber();
    return data.slice(offset + 32, offset + 32 + size2);
  } else if (parsedType.name.startsWith("bytes")) {
    return data.slice(offset, offset + parsedType.size);
  } else if (parsedType.name.startsWith("uint")) {
    num = new BN$4(data.slice(offset, offset + 32), 16, "be");
    if (num.bitLength() > parsedType.size) {
      throw new Error("Decoded int exceeds width: " + parsedType.size + " vs " + num.bitLength());
    }
    return num;
  } else if (parsedType.name.startsWith("int")) {
    num = new BN$4(data.slice(offset, offset + 32), 16, "be").fromTwos(256);
    if (num.bitLength() > parsedType.size) {
      throw new Error("Decoded uint exceeds width: " + parsedType.size + " vs " + num.bitLength());
    }
    return num;
  } else if (parsedType.name.startsWith("ufixed")) {
    size2 = new BN$4(2).pow(new BN$4(parsedType.size[1]));
    num = decodeSingle("uint256", data, offset);
    if (!num.mod(size2).isZero()) {
      throw new Error("Decimals not supported yet");
    }
    return num.div(size2);
  } else if (parsedType.name.startsWith("fixed")) {
    size2 = new BN$4(2).pow(new BN$4(parsedType.size[1]));
    num = decodeSingle("int256", data, offset);
    if (!num.mod(size2).isZero()) {
      throw new Error("Decimals not supported yet");
    }
    return num.div(size2);
  }
  throw new Error("Unsupported or invalid type: " + parsedType.name);
}
function parseType(type) {
  var size2;
  var ret;
  if (isArray$4(type)) {
    size2 = parseTypeArray$1(type);
    var subArray = type.slice(0, type.lastIndexOf("["));
    subArray = parseType(subArray);
    ret = {
      isArray: true,
      name: type,
      size: size2,
      memoryUsage: size2 === "dynamic" ? 32 : subArray.memoryUsage * size2,
      subArray
    };
    return ret;
  } else {
    var rawType;
    switch (type) {
      case "address":
        rawType = "uint160";
        break;
      case "bool":
        rawType = "uint8";
        break;
      case "string":
        rawType = "bytes";
        break;
    }
    ret = {
      rawType,
      name: type,
      memoryUsage: 32
    };
    if (type.startsWith("bytes") && type !== "bytes" || type.startsWith("uint") || type.startsWith("int")) {
      ret.size = parseTypeN$1(type);
    } else if (type.startsWith("ufixed") || type.startsWith("fixed")) {
      ret.size = parseTypeNxM$1(type);
    }
    if (type.startsWith("bytes") && type !== "bytes" && (ret.size < 1 || ret.size > 32)) {
      throw new Error("Invalid bytes<N> width: " + ret.size);
    }
    if ((type.startsWith("uint") || type.startsWith("int")) && (ret.size % 8 || ret.size < 8 || ret.size > 256)) {
      throw new Error("Invalid int/uint<N> width: " + ret.size);
    }
    return ret;
  }
}
function isDynamic$1(type) {
  return type === "string" || type === "bytes" || parseTypeArray$1(type) === "dynamic";
}
function isArray$4(type) {
  return type.lastIndexOf("]") === type.length - 1;
}
ABI.rawEncode = function(types2, values) {
  var output = [];
  var data = [];
  var headLength = 0;
  types2.forEach(function(type2) {
    if (isArray$4(type2)) {
      var size2 = parseTypeArray$1(type2);
      if (size2 !== "dynamic") {
        headLength += 32 * size2;
      } else {
        headLength += 32;
      }
    } else {
      headLength += 32;
    }
  });
  for (var i2 = 0; i2 < types2.length; i2++) {
    var type = elementaryName$1(types2[i2]);
    var value2 = values[i2];
    var cur = encodeSingle$1(type, value2);
    if (isDynamic$1(type)) {
      output.push(encodeSingle$1("uint256", headLength));
      data.push(cur);
      headLength += cur.length;
    } else {
      output.push(cur);
    }
  }
  return buffer$2.Buffer.concat(output.concat(data));
};
ABI.rawDecode = function(types2, data) {
  var ret = [];
  data = buffer$2.Buffer.from(data);
  var offset = 0;
  for (var i2 = 0; i2 < types2.length; i2++) {
    var type = elementaryName$1(types2[i2]);
    var parsed = parseType(type);
    var decoded = decodeSingle(parsed, data, offset);
    offset += parsed.memoryUsage;
    ret.push(decoded);
  }
  return ret;
};
ABI.simpleEncode = function(method2) {
  var args = Array.prototype.slice.call(arguments).slice(1);
  var sig = parseSignature(method2);
  if (args.length !== sig.args.length) {
    throw new Error("Argument count mismatch");
  }
  return buffer$2.Buffer.concat([ABI.methodID(sig.method, sig.args), ABI.rawEncode(sig.args, args)]);
};
ABI.simpleDecode = function(method2, data) {
  var sig = parseSignature(method2);
  if (!sig.retargs) {
    throw new Error("No return values in method");
  }
  return ABI.rawDecode(sig.retargs, data);
};
function stringify(type, value2) {
  if (type.startsWith("address") || type.startsWith("bytes")) {
    return "0x" + value2.toString("hex");
  } else {
    return value2.toString();
  }
}
ABI.stringify = function(types2, values) {
  var ret = [];
  for (var i2 in types2) {
    var type = types2[i2];
    var value2 = values[i2];
    if (/^[^\[]+\[.*\]$/.test(type)) {
      value2 = value2.map(function(item) {
        return stringify(type, item);
      }).join(", ");
    } else {
      value2 = stringify(type, value2);
    }
    ret.push(value2);
  }
  return ret;
};
ABI.solidityHexValue = function(type, value2, bitsize) {
  var size2, num;
  if (isArray$4(type)) {
    var subType = type.replace(/\[.*?\]/, "");
    if (!isArray$4(subType)) {
      var arraySize = parseTypeArray$1(type);
      if (arraySize !== "dynamic" && arraySize !== 0 && value2.length > arraySize) {
        throw new Error("Elements exceed array size: " + arraySize);
      }
    }
    var arrayValues = value2.map(function(v2) {
      return ABI.solidityHexValue(subType, v2, 256);
    });
    return buffer$2.Buffer.concat(arrayValues);
  } else if (type === "bytes") {
    return value2;
  } else if (type === "string") {
    return buffer$2.Buffer.from(value2, "utf8");
  } else if (type === "bool") {
    bitsize = bitsize || 8;
    var padding2 = Array(bitsize / 4).join("0");
    return buffer$2.Buffer.from(value2 ? padding2 + "1" : padding2 + "0", "hex");
  } else if (type === "address") {
    var bytesize = 20;
    if (bitsize) {
      bytesize = bitsize / 8;
    }
    return utils$2.setLengthLeft(value2, bytesize);
  } else if (type.startsWith("bytes")) {
    size2 = parseTypeN$1(type);
    if (size2 < 1 || size2 > 32) {
      throw new Error("Invalid bytes<N> width: " + size2);
    }
    return utils$2.setLengthRight(value2, size2);
  } else if (type.startsWith("uint")) {
    size2 = parseTypeN$1(type);
    if (size2 % 8 || size2 < 8 || size2 > 256) {
      throw new Error("Invalid uint<N> width: " + size2);
    }
    num = parseNumber$1(value2);
    if (num.bitLength() > size2) {
      throw new Error("Supplied uint exceeds width: " + size2 + " vs " + num.bitLength());
    }
    bitsize = bitsize || size2;
    return num.toArrayLike(buffer$2.Buffer, "be", bitsize / 8);
  } else if (type.startsWith("int")) {
    size2 = parseTypeN$1(type);
    if (size2 % 8 || size2 < 8 || size2 > 256) {
      throw new Error("Invalid int<N> width: " + size2);
    }
    num = parseNumber$1(value2);
    if (num.bitLength() > size2) {
      throw new Error("Supplied int exceeds width: " + size2 + " vs " + num.bitLength());
    }
    bitsize = bitsize || size2;
    return num.toTwos(size2).toArrayLike(buffer$2.Buffer, "be", bitsize / 8);
  } else {
    throw new Error("Unsupported or invalid type: " + type);
  }
};
ABI.solidityPack = function(types2, values) {
  if (types2.length !== values.length) {
    throw new Error("Number of types are not matching the values");
  }
  var ret = [];
  for (var i2 = 0; i2 < types2.length; i2++) {
    var type = elementaryName$1(types2[i2]);
    var value2 = values[i2];
    ret.push(ABI.solidityHexValue(type, value2, null));
  }
  return buffer$2.Buffer.concat(ret);
};
ABI.soliditySHA3 = function(types2, values) {
  return utils$2.keccak256(ABI.solidityPack(types2, values));
};
ABI.soliditySHA256 = function(types2, values) {
  return utils$2.sha256(ABI.solidityPack(types2, values));
};
ABI.solidityRIPEMD160 = function(types2, values) {
  return utils$2.ripemd160(ABI.solidityPack(types2, values), true);
};
function isNumeric$1(c2) {
  return c2 >= "0" && c2 <= "9";
}
ABI.fromSerpent = function(sig) {
  var ret = [];
  for (var i2 = 0; i2 < sig.length; i2++) {
    var type = sig[i2];
    if (type === "s") {
      ret.push("bytes");
    } else if (type === "b") {
      var tmp = "bytes";
      var j2 = i2 + 1;
      while (j2 < sig.length && isNumeric$1(sig[j2])) {
        tmp += sig[j2] - "0";
        j2++;
      }
      i2 = j2 - 1;
      ret.push(tmp);
    } else if (type === "i") {
      ret.push("int256");
    } else if (type === "a") {
      ret.push("int256[]");
    } else {
      throw new Error("Unsupported or invalid type: " + type);
    }
  }
  return ret;
};
ABI.toSerpent = function(types2) {
  var ret = [];
  for (var i2 = 0; i2 < types2.length; i2++) {
    var type = types2[i2];
    if (type === "bytes") {
      ret.push("s");
    } else if (type.startsWith("bytes")) {
      ret.push("b" + parseTypeN$1(type));
    } else if (type === "int256") {
      ret.push("i");
    } else if (type === "int256[]") {
      ret.push("a");
    } else {
      throw new Error("Unsupported or invalid type: " + type);
    }
  }
  return ret.join("");
};
var lib = ABI;
var ethereumjsAbi = lib;
const ethUtil$3 = dist$5;
const ethAbi = ethereumjsAbi;
var ethSigUtil = {
  concatSig: function(v2, r2, s2) {
    const rSig = ethUtil$3.fromSigned(r2);
    const sSig = ethUtil$3.fromSigned(s2);
    const vSig = ethUtil$3.bufferToInt(v2);
    const rStr = padWithZeroes(ethUtil$3.toUnsigned(rSig).toString("hex"), 64);
    const sStr = padWithZeroes(ethUtil$3.toUnsigned(sSig).toString("hex"), 64);
    const vStr = ethUtil$3.stripHexPrefix(ethUtil$3.intToHex(vSig));
    return ethUtil$3.addHexPrefix(rStr.concat(sStr, vStr)).toString("hex");
  },
  normalize: function(input) {
    if (!input)
      return;
    if (typeof input === "number") {
      const buffer2 = ethUtil$3.toBuffer(input);
      input = ethUtil$3.bufferToHex(buffer2);
    }
    if (typeof input !== "string") {
      var msg = "eth-sig-util.normalize() requires hex string or integer input.";
      msg += " received " + typeof input + ": " + input;
      throw new Error(msg);
    }
    return ethUtil$3.addHexPrefix(input.toLowerCase());
  },
  personalSign: function(privateKey, msgParams) {
    var message = ethUtil$3.toBuffer(msgParams.data);
    var msgHash = ethUtil$3.hashPersonalMessage(message);
    var sig = ethUtil$3.ecsign(msgHash, privateKey);
    var serialized = ethUtil$3.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
    return serialized;
  },
  recoverPersonalSignature: function(msgParams) {
    const publicKey = getPublicKeyFor(msgParams);
    const sender = ethUtil$3.publicToAddress(publicKey);
    const senderHex = ethUtil$3.bufferToHex(sender);
    return senderHex;
  },
  extractPublicKey: function(msgParams) {
    const publicKey = getPublicKeyFor(msgParams);
    return "0x" + publicKey.toString("hex");
  },
  typedSignatureHash: function(typedData) {
    const hashBuffer = typedSignatureHash(typedData);
    return ethUtil$3.bufferToHex(hashBuffer);
  },
  signTypedData: function(privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data);
    const sig = ethUtil$3.ecsign(msgHash, privateKey);
    return ethUtil$3.bufferToHex(this.concatSig(sig.v, sig.r, sig.s));
  },
  recoverTypedSignature: function(msgParams) {
    const msgHash = typedSignatureHash(msgParams.data);
    const publicKey = recoverPublicKey(msgHash, msgParams.sig);
    const sender = ethUtil$3.publicToAddress(publicKey);
    return ethUtil$3.bufferToHex(sender);
  }
};
function typedSignatureHash(typedData) {
  const error2 = new Error("Expect argument to be non-empty array");
  if (typeof typedData !== "object" || !typedData.length)
    throw error2;
  const data = typedData.map(function(e2) {
    return e2.type === "bytes" ? ethUtil$3.toBuffer(e2.value) : e2.value;
  });
  const types2 = typedData.map(function(e2) {
    return e2.type;
  });
  const schema = typedData.map(function(e2) {
    if (!e2.name)
      throw error2;
    return e2.type + " " + e2.name;
  });
  return ethAbi.soliditySHA3(["bytes32", "bytes32"], [
    ethAbi.soliditySHA3(new Array(typedData.length).fill("string"), schema),
    ethAbi.soliditySHA3(types2, data)
  ]);
}
function recoverPublicKey(hash3, sig) {
  const signature2 = ethUtil$3.toBuffer(sig);
  const sigParams = ethUtil$3.fromRpcSig(signature2);
  return ethUtil$3.ecrecover(hash3, sigParams.v, sigParams.r, sigParams.s);
}
function getPublicKeyFor(msgParams) {
  const message = ethUtil$3.toBuffer(msgParams.data);
  const msgHash = ethUtil$3.hashPersonalMessage(message);
  return recoverPublicKey(msgHash, msgParams.sig);
}
function padWithZeroes(number2, length) {
  var myString = "" + number2;
  while (myString.length < length) {
    myString = "0" + myString;
  }
  return myString;
}
var semaphore = { exports: {} };
(function(module2, exports2) {
  (function(global2) {
    var nextTick2 = function(fn) {
      setTimeout(fn, 0);
    };
    if (typeof process != "undefined" && process && typeof process.nextTick == "function") {
      nextTick2 = process.nextTick;
    }
    function semaphore2(capacity) {
      var semaphore3 = {
        capacity: capacity || 1,
        current: 0,
        queue: [],
        firstHere: false,
        take: function() {
          if (semaphore3.firstHere === false) {
            semaphore3.current++;
            semaphore3.firstHere = true;
            var isFirst = 1;
          } else {
            var isFirst = 0;
          }
          var item = { n: 1 };
          if (typeof arguments[0] == "function") {
            item.task = arguments[0];
          } else {
            item.n = arguments[0];
          }
          if (arguments.length >= 2) {
            if (typeof arguments[1] == "function")
              item.task = arguments[1];
            else
              item.n = arguments[1];
          }
          var task = item.task;
          item.task = function() {
            task(semaphore3.leave);
          };
          if (semaphore3.current + item.n - isFirst > semaphore3.capacity) {
            if (isFirst === 1) {
              semaphore3.current--;
              semaphore3.firstHere = false;
            }
            return semaphore3.queue.push(item);
          }
          semaphore3.current += item.n - isFirst;
          item.task(semaphore3.leave);
          if (isFirst === 1)
            semaphore3.firstHere = false;
        },
        leave: function(n2) {
          n2 = n2 || 1;
          semaphore3.current -= n2;
          if (!semaphore3.queue.length) {
            if (semaphore3.current < 0) {
              throw new Error("leave called too many times.");
            }
            return;
          }
          var item = semaphore3.queue[0];
          if (item.n + semaphore3.current > semaphore3.capacity) {
            return;
          }
          semaphore3.queue.shift();
          semaphore3.current += item.n;
          nextTick2(item.task);
        },
        available: function(n2) {
          n2 = n2 || 1;
          return semaphore3.current + n2 <= semaphore3.capacity;
        }
      };
      return semaphore3;
    }
    {
      module2.exports = semaphore2;
    }
  })();
})(semaphore);
const createPayload = createPayload_1;
var estimateGas_1 = estimateGas$1;
function estimateGas$1(provider, txParams, cb) {
  provider.sendAsync(createPayload({
    method: "eth_estimateGas",
    params: [txParams]
  }), function(err, res) {
    if (err) {
      if (err.message === "no contract code at given address") {
        return cb(null, "0xcf08");
      } else {
        return cb(err);
      }
    }
    cb(null, res.result);
  });
}
const waterfall = waterfall$1.exports;
const parallel = parallel$2.exports;
const inherits$1 = util$7.inherits;
const ethUtil$2 = dist$5;
const sigUtil = ethSigUtil;
const extend = immutable;
const Semaphore = semaphore.exports;
const Subprovider$1 = subprovider;
const estimateGas = estimateGas_1;
const hexRegex = /^[0-9A-Fa-f]+$/g;
var hookedWallet = HookedWalletSubprovider$1;
inherits$1(HookedWalletSubprovider$1, Subprovider$1);
function HookedWalletSubprovider$1(opts) {
  const self2 = this;
  self2.nonceLock = Semaphore(1);
  if (opts.getAccounts)
    self2.getAccounts = opts.getAccounts;
  if (opts.processTransaction)
    self2.processTransaction = opts.processTransaction;
  if (opts.processMessage)
    self2.processMessage = opts.processMessage;
  if (opts.processPersonalMessage)
    self2.processPersonalMessage = opts.processPersonalMessage;
  if (opts.processTypedMessage)
    self2.processTypedMessage = opts.processTypedMessage;
  self2.approveTransaction = opts.approveTransaction || self2.autoApprove;
  self2.approveMessage = opts.approveMessage || self2.autoApprove;
  self2.approvePersonalMessage = opts.approvePersonalMessage || self2.autoApprove;
  self2.approveDecryptMessage = opts.approveDecryptMessage || self2.autoApprove;
  self2.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self2.autoApprove;
  self2.approveTypedMessage = opts.approveTypedMessage || self2.autoApprove;
  if (opts.signTransaction)
    self2.signTransaction = opts.signTransaction || mustProvideInConstructor("signTransaction");
  if (opts.signMessage)
    self2.signMessage = opts.signMessage || mustProvideInConstructor("signMessage");
  if (opts.signPersonalMessage)
    self2.signPersonalMessage = opts.signPersonalMessage || mustProvideInConstructor("signPersonalMessage");
  if (opts.decryptMessage)
    self2.decryptMessage = opts.decryptMessage || mustProvideInConstructor("decryptMessage");
  if (opts.encryptionPublicKey)
    self2.encryptionPublicKey = opts.encryptionPublicKey || mustProvideInConstructor("encryptionPublicKey");
  if (opts.signTypedMessage)
    self2.signTypedMessage = opts.signTypedMessage || mustProvideInConstructor("signTypedMessage");
  if (opts.recoverPersonalSignature)
    self2.recoverPersonalSignature = opts.recoverPersonalSignature;
  if (opts.publishTransaction)
    self2.publishTransaction = opts.publishTransaction;
  self2.estimateGas = opts.estimateGas || self2.estimateGas;
  self2.getGasPrice = opts.getGasPrice || self2.getGasPrice;
}
HookedWalletSubprovider$1.prototype.handleRequest = function(payload, next3, end) {
  const self2 = this;
  self2._parityRequests = {};
  self2._parityRequestCount = 0;
  let txParams, msgParams, extraParams;
  let message, address;
  switch (payload.method) {
    case "eth_coinbase":
      self2.getAccounts(function(err, accounts) {
        if (err)
          return end(err);
        let result = accounts[0] || null;
        end(null, result);
      });
      return;
    case "eth_accounts":
      self2.getAccounts(function(err, accounts) {
        if (err)
          return end(err);
        end(null, accounts);
      });
      return;
    case "eth_sendTransaction":
      txParams = payload.params[0];
      waterfall([
        (cb) => self2.validateTransaction(txParams, cb),
        (cb) => self2.processTransaction(txParams, cb)
      ], end);
      return;
    case "eth_signTransaction":
      txParams = payload.params[0];
      waterfall([
        (cb) => self2.validateTransaction(txParams, cb),
        (cb) => self2.processSignTransaction(txParams, cb)
      ], end);
      return;
    case "eth_sign":
      address = payload.params[0];
      message = payload.params[1];
      extraParams = payload.params[2] || {};
      msgParams = extend(extraParams, {
        from: address,
        data: message
      });
      waterfall([
        (cb) => self2.validateMessage(msgParams, cb),
        (cb) => self2.processMessage(msgParams, cb)
      ], end);
      return;
    case "personal_sign":
      return function() {
        const first2 = payload.params[0];
        const second = payload.params[1];
        if (resemblesData(second) && resemblesAddress(first2)) {
          let warning = `The eth_personalSign method requires params ordered `;
          warning += `[message, address]. This was previously handled incorrectly, `;
          warning += `and has been corrected automatically. `;
          warning += `Please switch this param order for smooth behavior in the future.`;
          console.warn(warning);
          address = payload.params[0];
          message = payload.params[1];
        } else {
          message = payload.params[0];
          address = payload.params[1];
        }
        extraParams = payload.params[2] || {};
        msgParams = extend(extraParams, {
          from: address,
          data: message
        });
        waterfall([
          (cb) => self2.validatePersonalMessage(msgParams, cb),
          (cb) => self2.processPersonalMessage(msgParams, cb)
        ], end);
      }();
    case "eth_decryptMessage":
      return function() {
        const first2 = payload.params[0];
        const second = payload.params[1];
        if (resemblesData(second) && resemblesAddress(first2)) {
          let warning = `The eth_decryptMessage method requires params ordered `;
          warning += `[message, address]. This was previously handled incorrectly, `;
          warning += `and has been corrected automatically. `;
          warning += `Please switch this param order for smooth behavior in the future.`;
          console.warn(warning);
          address = payload.params[0];
          message = payload.params[1];
        } else {
          message = payload.params[0];
          address = payload.params[1];
        }
        extraParams = payload.params[2] || {};
        msgParams = extend(extraParams, {
          from: address,
          data: message
        });
        waterfall([
          (cb) => self2.validateDecryptMessage(msgParams, cb),
          (cb) => self2.processDecryptMessage(msgParams, cb)
        ], end);
      }();
    case "encryption_public_key":
      return function() {
        const address2 = payload.params[0];
        waterfall([
          (cb) => self2.validateEncryptionPublicKey(address2, cb),
          (cb) => self2.processEncryptionPublicKey(address2, cb)
        ], end);
      }();
    case "personal_ecRecover":
      return function() {
        message = payload.params[0];
        let signature2 = payload.params[1];
        extraParams = payload.params[2] || {};
        msgParams = extend(extraParams, {
          sig: signature2,
          data: message
        });
        self2.recoverPersonalSignature(msgParams, end);
      }();
    case "eth_signTypedData":
    case "eth_signTypedData_v3":
    case "eth_signTypedData_v4":
      return function() {
        const first2 = payload.params[0];
        const second = payload.params[1];
        if (resemblesAddress(first2)) {
          address = first2;
          message = second;
        } else {
          message = first2;
          address = second;
        }
        extraParams = payload.params[2] || {};
        msgParams = extend(extraParams, {
          from: address,
          data: message
        });
        waterfall([
          (cb) => self2.validateTypedMessage(msgParams, cb),
          (cb) => self2.processTypedMessage(msgParams, cb)
        ], end);
      }();
    case "parity_postTransaction":
      txParams = payload.params[0];
      self2.parityPostTransaction(txParams, end);
      return;
    case "parity_postSign":
      address = payload.params[0];
      message = payload.params[1];
      self2.parityPostSign(address, message, end);
      return;
    case "parity_checkRequest":
      return function() {
        const requestId = payload.params[0];
        self2.parityCheckRequest(requestId, end);
      }();
    case "parity_defaultAccount":
      self2.getAccounts(function(err, accounts) {
        if (err)
          return end(err);
        const account2 = accounts[0] || null;
        end(null, account2);
      });
      return;
    default:
      next3();
      return;
  }
};
HookedWalletSubprovider$1.prototype.getAccounts = function(cb) {
  cb(null, []);
};
HookedWalletSubprovider$1.prototype.processTransaction = function(txParams, cb) {
  const self2 = this;
  waterfall([
    (cb2) => self2.approveTransaction(txParams, cb2),
    (didApprove, cb2) => self2.checkApproval("transaction", didApprove, cb2),
    (cb2) => self2.finalizeAndSubmitTx(txParams, cb2)
  ], cb);
};
HookedWalletSubprovider$1.prototype.processSignTransaction = function(txParams, cb) {
  const self2 = this;
  waterfall([
    (cb2) => self2.approveTransaction(txParams, cb2),
    (didApprove, cb2) => self2.checkApproval("transaction", didApprove, cb2),
    (cb2) => self2.finalizeTx(txParams, cb2)
  ], cb);
};
HookedWalletSubprovider$1.prototype.processMessage = function(msgParams, cb) {
  const self2 = this;
  waterfall([
    (cb2) => self2.approveMessage(msgParams, cb2),
    (didApprove, cb2) => self2.checkApproval("message", didApprove, cb2),
    (cb2) => self2.signMessage(msgParams, cb2)
  ], cb);
};
HookedWalletSubprovider$1.prototype.processPersonalMessage = function(msgParams, cb) {
  const self2 = this;
  waterfall([
    (cb2) => self2.approvePersonalMessage(msgParams, cb2),
    (didApprove, cb2) => self2.checkApproval("message", didApprove, cb2),
    (cb2) => self2.signPersonalMessage(msgParams, cb2)
  ], cb);
};
HookedWalletSubprovider$1.prototype.processDecryptMessage = function(msgParams, cb) {
  const self2 = this;
  waterfall([
    (cb2) => self2.approveDecryptMessage(msgParams, cb2),
    (didApprove, cb2) => self2.checkApproval("decryptMessage", didApprove, cb2),
    (cb2) => self2.decryptMessage(msgParams, cb2)
  ], cb);
};
HookedWalletSubprovider$1.prototype.processEncryptionPublicKey = function(msgParams, cb) {
  const self2 = this;
  waterfall([
    (cb2) => self2.approveEncryptionPublicKey(msgParams, cb2),
    (didApprove, cb2) => self2.checkApproval("encryptionPublicKey", didApprove, cb2),
    (cb2) => self2.encryptionPublicKey(msgParams, cb2)
  ], cb);
};
HookedWalletSubprovider$1.prototype.processTypedMessage = function(msgParams, cb) {
  const self2 = this;
  waterfall([
    (cb2) => self2.approveTypedMessage(msgParams, cb2),
    (didApprove, cb2) => self2.checkApproval("message", didApprove, cb2),
    (cb2) => self2.signTypedMessage(msgParams, cb2)
  ], cb);
};
HookedWalletSubprovider$1.prototype.autoApprove = function(txParams, cb) {
  cb(null, true);
};
HookedWalletSubprovider$1.prototype.checkApproval = function(type, didApprove, cb) {
  cb(didApprove ? null : new Error("User denied " + type + " signature."));
};
HookedWalletSubprovider$1.prototype.parityPostTransaction = function(txParams, cb) {
  const self2 = this;
  const count2 = self2._parityRequestCount;
  const reqId = `0x${count2.toString(16)}`;
  self2._parityRequestCount++;
  self2.emitPayload({
    method: "eth_sendTransaction",
    params: [txParams]
  }, function(error2, res) {
    if (error2) {
      self2._parityRequests[reqId] = { error: error2 };
      return;
    }
    const txHash = res.result;
    self2._parityRequests[reqId] = txHash;
  });
  cb(null, reqId);
};
HookedWalletSubprovider$1.prototype.parityPostSign = function(address, message, cb) {
  const self2 = this;
  const count2 = self2._parityRequestCount;
  const reqId = `0x${count2.toString(16)}`;
  self2._parityRequestCount++;
  self2.emitPayload({
    method: "eth_sign",
    params: [address, message]
  }, function(error2, res) {
    if (error2) {
      self2._parityRequests[reqId] = { error: error2 };
      return;
    }
    const result = res.result;
    self2._parityRequests[reqId] = result;
  });
  cb(null, reqId);
};
HookedWalletSubprovider$1.prototype.parityCheckRequest = function(reqId, cb) {
  const self2 = this;
  const result = self2._parityRequests[reqId] || null;
  if (!result)
    return cb(null, null);
  if (result.error)
    return cb(result.error);
  cb(null, result);
};
HookedWalletSubprovider$1.prototype.recoverPersonalSignature = function(msgParams, cb) {
  let senderHex;
  try {
    senderHex = sigUtil.recoverPersonalSignature(msgParams);
  } catch (err) {
    return cb(err);
  }
  cb(null, senderHex);
};
HookedWalletSubprovider$1.prototype.validateTransaction = function(txParams, cb) {
  const self2 = this;
  if (txParams.from === void 0)
    return cb(new Error(`Undefined address - from address required to sign transaction.`));
  self2.validateSender(txParams.from, function(err, senderIsValid) {
    if (err)
      return cb(err);
    if (!senderIsValid)
      return cb(new Error(`Unknown address - unable to sign transaction for this address: "${txParams.from}"`));
    cb();
  });
};
HookedWalletSubprovider$1.prototype.validateMessage = function(msgParams, cb) {
  const self2 = this;
  if (msgParams.from === void 0)
    return cb(new Error(`Undefined address - from address required to sign message.`));
  self2.validateSender(msgParams.from, function(err, senderIsValid) {
    if (err)
      return cb(err);
    if (!senderIsValid)
      return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));
    cb();
  });
};
HookedWalletSubprovider$1.prototype.validatePersonalMessage = function(msgParams, cb) {
  const self2 = this;
  if (msgParams.from === void 0)
    return cb(new Error(`Undefined address - from address required to sign personal message.`));
  if (msgParams.data === void 0)
    return cb(new Error(`Undefined message - message required to sign personal message.`));
  if (!isValidHex(msgParams.data))
    return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`));
  self2.validateSender(msgParams.from, function(err, senderIsValid) {
    if (err)
      return cb(err);
    if (!senderIsValid)
      return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));
    cb();
  });
};
HookedWalletSubprovider$1.prototype.validateDecryptMessage = function(msgParams, cb) {
  const self2 = this;
  if (msgParams.from === void 0)
    return cb(new Error(`Undefined address - from address required to decrypt message.`));
  if (msgParams.data === void 0)
    return cb(new Error(`Undefined message - message required to decrypt message.`));
  if (!isValidHex(msgParams.data))
    return cb(new Error(`HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.`));
  self2.validateSender(msgParams.from, function(err, senderIsValid) {
    if (err)
      return cb(err);
    if (!senderIsValid)
      return cb(new Error(`Unknown address - unable to decrypt message for this address: "${msgParams.from}"`));
    cb();
  });
};
HookedWalletSubprovider$1.prototype.validateEncryptionPublicKey = function(address, cb) {
  const self2 = this;
  self2.validateSender(address, function(err, senderIsValid) {
    if (err)
      return cb(err);
    if (!senderIsValid)
      return cb(new Error(`Unknown address - unable to obtain encryption public key for this address: "${address}"`));
    cb();
  });
};
HookedWalletSubprovider$1.prototype.validateTypedMessage = function(msgParams, cb) {
  if (msgParams.from === void 0)
    return cb(new Error(`Undefined address - from address required to sign typed data.`));
  if (msgParams.data === void 0)
    return cb(new Error(`Undefined data - message required to sign typed data.`));
  this.validateSender(msgParams.from, function(err, senderIsValid) {
    if (err)
      return cb(err);
    if (!senderIsValid)
      return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`));
    cb();
  });
};
HookedWalletSubprovider$1.prototype.validateSender = function(senderAddress, cb) {
  const self2 = this;
  if (!senderAddress)
    return cb(null, false);
  self2.getAccounts(function(err, accounts) {
    if (err)
      return cb(err);
    const senderIsValid = accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1;
    cb(null, senderIsValid);
  });
};
HookedWalletSubprovider$1.prototype.finalizeAndSubmitTx = function(txParams, cb) {
  const self2 = this;
  self2.nonceLock.take(function() {
    waterfall([
      self2.fillInTxExtras.bind(self2, txParams),
      self2.signTransaction.bind(self2),
      self2.publishTransaction.bind(self2)
    ], function(err, txHash) {
      self2.nonceLock.leave();
      if (err)
        return cb(err);
      cb(null, txHash);
    });
  });
};
HookedWalletSubprovider$1.prototype.finalizeTx = function(txParams, cb) {
  const self2 = this;
  self2.nonceLock.take(function() {
    waterfall([
      self2.fillInTxExtras.bind(self2, txParams),
      self2.signTransaction.bind(self2)
    ], function(err, signedTx) {
      self2.nonceLock.leave();
      if (err)
        return cb(err);
      cb(null, { raw: signedTx, tx: txParams });
    });
  });
};
HookedWalletSubprovider$1.prototype.publishTransaction = function(rawTx, cb) {
  const self2 = this;
  self2.emitPayload({
    method: "eth_sendRawTransaction",
    params: [rawTx]
  }, function(err, res) {
    if (err)
      return cb(err);
    cb(null, res.result);
  });
};
HookedWalletSubprovider$1.prototype.estimateGas = function(txParams, cb) {
  const self2 = this;
  estimateGas(self2.engine, txParams, cb);
};
HookedWalletSubprovider$1.prototype.getGasPrice = function(cb) {
  const self2 = this;
  self2.emitPayload({ method: "eth_gasPrice", params: [] }, function(err, res) {
    if (err)
      return cb(err);
    cb(null, res.result);
  });
};
HookedWalletSubprovider$1.prototype.fillInTxExtras = function(txParams, cb) {
  const self2 = this;
  const address = txParams.from;
  const tasks = {};
  if (txParams.gasPrice === void 0) {
    tasks.gasPrice = self2.getGasPrice.bind(self2);
  }
  if (txParams.nonce === void 0) {
    tasks.nonce = self2.emitPayload.bind(self2, { method: "eth_getTransactionCount", params: [address, "pending"] });
  }
  if (txParams.gas === void 0) {
    tasks.gas = self2.estimateGas.bind(self2, cloneTxParams(txParams));
  }
  parallel(tasks, function(err, taskResults) {
    if (err)
      return cb(err);
    const result = {};
    if (taskResults.gasPrice)
      result.gasPrice = taskResults.gasPrice;
    if (taskResults.nonce)
      result.nonce = taskResults.nonce.result;
    if (taskResults.gas)
      result.gas = taskResults.gas;
    cb(null, extend(txParams, result));
  });
};
function cloneTxParams(txParams) {
  return {
    from: txParams.from,
    to: txParams.to,
    value: txParams.value,
    data: txParams.data,
    gas: txParams.gas,
    gasPrice: txParams.gasPrice,
    nonce: txParams.nonce
  };
}
function toLowerCase(string2) {
  return string2.toLowerCase();
}
function resemblesAddress(string2) {
  const fixed = ethUtil$2.addHexPrefix(string2);
  const isValid2 = ethUtil$2.isValidAddress(fixed);
  return isValid2;
}
function resemblesData(string2) {
  const fixed = ethUtil$2.addHexPrefix(string2);
  const isValidAddress2 = ethUtil$2.isValidAddress(fixed);
  return !isValidAddress2 && isValidHex(string2);
}
function isValidHex(data) {
  const isString2 = typeof data === "string";
  if (!isString2)
    return false;
  const isHexPrefixed3 = data.slice(0, 2) === "0x";
  if (!isHexPrefixed3)
    return false;
  const nonPrefixed = data.slice(2);
  const isValid2 = nonPrefixed.match(hexRegex);
  return isValid2;
}
function mustProvideInConstructor(methodName) {
  return function(params, cb) {
    cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide "' + methodName + '" fn in constructor options'));
  };
}
const genesisGasLimit = {
  v: 5e3,
  d: "Gas limit of the Genesis block."
};
const genesisDifficulty = {
  v: 17179869184,
  d: "Difficulty of the Genesis block."
};
const genesisNonce = {
  v: "0x0000000000000042",
  d: "the geneis nonce"
};
const genesisExtraData = {
  v: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
  d: "extra data "
};
const genesisHash = {
  v: "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3",
  d: "genesis hash"
};
const genesisStateRoot = {
  v: "0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544",
  d: "the genesis state root"
};
const minGasLimit = {
  v: 5e3,
  d: "Minimum the gas limit may ever be."
};
const gasLimitBoundDivisor = {
  v: 1024,
  d: "The bound divisor of the gas limit, used in update calculations."
};
const minimumDifficulty = {
  v: 131072,
  d: "The minimum that the difficulty may ever be."
};
const difficultyBoundDivisor = {
  v: 2048,
  d: "The bound divisor of the difficulty, used in the update calculations."
};
const durationLimit = {
  v: 13,
  d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not."
};
const maximumExtraDataSize = {
  v: 32,
  d: "Maximum size extra data may be after Genesis."
};
const epochDuration = {
  v: 3e4,
  d: "Duration between proof-of-work epochs."
};
const stackLimit = {
  v: 1024,
  d: "Maximum size of VM stack allowed."
};
const callCreateDepth = {
  v: 1024,
  d: "Maximum depth of call/create stack."
};
const tierStepGas = {
  v: [
    0,
    2,
    3,
    5,
    8,
    10,
    20
  ],
  d: "Once per operation, for a selection of them."
};
const expGas = {
  v: 10,
  d: "Once per EXP instuction."
};
const expByteGas = {
  v: 10,
  d: "Times ceil(log256(exponent)) for the EXP instruction."
};
const sha3Gas = {
  v: 30,
  d: "Once per SHA3 operation."
};
const sha3WordGas = {
  v: 6,
  d: "Once per word of the SHA3 operation's data."
};
const sloadGas = {
  v: 50,
  d: "Once per SLOAD operation."
};
const sstoreSetGas = {
  v: 2e4,
  d: "Once per SSTORE operation if the zeroness changes from zero."
};
const sstoreResetGas = {
  v: 5e3,
  d: "Once per SSTORE operation if the zeroness does not change from zero."
};
const sstoreRefundGas = {
  v: 15e3,
  d: "Once per SSTORE operation if the zeroness changes to zero."
};
const jumpdestGas = {
  v: 1,
  d: "Refunded gas, once per SSTORE operation if the zeroness changes to zero."
};
const logGas = {
  v: 375,
  d: "Per LOG* operation."
};
const logDataGas = {
  v: 8,
  d: "Per byte in a LOG* operation's data."
};
const logTopicGas = {
  v: 375,
  d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas."
};
const createGas = {
  v: 32e3,
  d: "Once per CREATE operation & contract-creation transaction."
};
const callGas = {
  v: 40,
  d: "Once per CALL operation & message call transaction."
};
const callStipend = {
  v: 2300,
  d: "Free gas given at beginning of call."
};
const callValueTransferGas = {
  v: 9e3,
  d: "Paid for CALL when the value transfor is non-zero."
};
const callNewAccountGas = {
  v: 25e3,
  d: "Paid for CALL when the destination address didn't exist prior."
};
const suicideRefundGas = {
  v: 24e3,
  d: "Refunded following a suicide operation."
};
const memoryGas = {
  v: 3,
  d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL."
};
const quadCoeffDiv = {
  v: 512,
  d: "Divisor for the quadratic particle of the memory cost equation."
};
const createDataGas = {
  v: 200,
  d: ""
};
const txGas = {
  v: 21e3,
  d: "Per transaction. NOTE: Not payable on data of calls between transactions."
};
const txCreation = {
  v: 32e3,
  d: "the cost of creating a contract via tx"
};
const txDataZeroGas = {
  v: 4,
  d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions."
};
const txDataNonZeroGas = {
  v: 68,
  d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions."
};
const copyGas = {
  v: 3,
  d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added."
};
const ecrecoverGas = {
  v: 3e3,
  d: ""
};
const sha256Gas = {
  v: 60,
  d: ""
};
const sha256WordGas = {
  v: 12,
  d: ""
};
const ripemd160Gas = {
  v: 600,
  d: ""
};
const ripemd160WordGas = {
  v: 120,
  d: ""
};
const identityGas = {
  v: 15,
  d: ""
};
const identityWordGas = {
  v: 3,
  d: ""
};
const minerReward = {
  v: "5000000000000000000",
  d: "the amount a miner get rewarded for mining a block"
};
const ommerReward = {
  v: "625000000000000000",
  d: "The amount of wei a miner of an uncle block gets for being inculded in the blockchain"
};
const niblingReward = {
  v: "156250000000000000",
  d: "the amount a miner gets for inculding a uncle"
};
const homeSteadForkNumber = {
  v: 115e4,
  d: "the block that the Homestead fork started at"
};
const homesteadRepriceForkNumber = {
  v: 2463e3,
  d: "the block that the Homestead Reprice (EIP150) fork started at"
};
const timebombPeriod = {
  v: 1e5,
  d: "Exponential difficulty timebomb period"
};
const freeBlockPeriod = {
  v: 2
};
var require$$1$2 = {
  genesisGasLimit,
  genesisDifficulty,
  genesisNonce,
  genesisExtraData,
  genesisHash,
  genesisStateRoot,
  minGasLimit,
  gasLimitBoundDivisor,
  minimumDifficulty,
  difficultyBoundDivisor,
  durationLimit,
  maximumExtraDataSize,
  epochDuration,
  stackLimit,
  callCreateDepth,
  tierStepGas,
  expGas,
  expByteGas,
  sha3Gas,
  sha3WordGas,
  sloadGas,
  sstoreSetGas,
  sstoreResetGas,
  sstoreRefundGas,
  jumpdestGas,
  logGas,
  logDataGas,
  logTopicGas,
  createGas,
  callGas,
  callStipend,
  callValueTransferGas,
  callNewAccountGas,
  suicideRefundGas,
  memoryGas,
  quadCoeffDiv,
  createDataGas,
  txGas,
  txCreation,
  txDataZeroGas,
  txDataNonZeroGas,
  copyGas,
  ecrecoverGas,
  sha256Gas,
  sha256WordGas,
  ripemd160Gas,
  ripemd160WordGas,
  identityGas,
  identityWordGas,
  minerReward,
  ommerReward,
  niblingReward,
  homeSteadForkNumber,
  homesteadRepriceForkNumber,
  timebombPeriod,
  freeBlockPeriod
};
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var ethUtil$1 = dist$5;
var fees = require$$1$2;
var BN$3 = ethUtil$1.BN;
var N_DIV_2 = new BN$3("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
var Transaction$1 = function() {
  function Transaction2(data) {
    _classCallCheck(this, Transaction2);
    data = data || {};
    var fields = [{
      name: "nonce",
      length: 32,
      allowLess: true,
      default: new buffer$2.Buffer([])
    }, {
      name: "gasPrice",
      length: 32,
      allowLess: true,
      default: new buffer$2.Buffer([])
    }, {
      name: "gasLimit",
      alias: "gas",
      length: 32,
      allowLess: true,
      default: new buffer$2.Buffer([])
    }, {
      name: "to",
      allowZero: true,
      length: 20,
      default: new buffer$2.Buffer([])
    }, {
      name: "value",
      length: 32,
      allowLess: true,
      default: new buffer$2.Buffer([])
    }, {
      name: "data",
      alias: "input",
      allowZero: true,
      default: new buffer$2.Buffer([])
    }, {
      name: "v",
      allowZero: true,
      default: new buffer$2.Buffer([28])
    }, {
      name: "r",
      length: 32,
      allowZero: true,
      allowLess: true,
      default: new buffer$2.Buffer([])
    }, {
      name: "s",
      length: 32,
      allowZero: true,
      allowLess: true,
      default: new buffer$2.Buffer([])
    }];
    ethUtil$1.defineProperties(this, fields, data);
    Object.defineProperty(this, "from", {
      enumerable: true,
      configurable: true,
      get: this.getSenderAddress.bind(this)
    });
    var sigV = ethUtil$1.bufferToInt(this.v);
    var chainId = Math.floor((sigV - 35) / 2);
    if (chainId < 0)
      chainId = 0;
    this._chainId = chainId || data.chainId || 0;
    this._homestead = true;
  }
  Transaction2.prototype.toCreationAddress = function toCreationAddress() {
    return this.to.toString("hex") === "";
  };
  Transaction2.prototype.hash = function hash3(includeSignature) {
    if (includeSignature === void 0)
      includeSignature = true;
    var items = void 0;
    if (includeSignature) {
      items = this.raw;
    } else {
      if (this._chainId > 0) {
        var raw = this.raw.slice();
        this.v = this._chainId;
        this.r = 0;
        this.s = 0;
        items = this.raw;
        this.raw = raw;
      } else {
        items = this.raw.slice(0, 6);
      }
    }
    return ethUtil$1.rlphash(items);
  };
  Transaction2.prototype.getChainId = function getChainId() {
    return this._chainId;
  };
  Transaction2.prototype.getSenderAddress = function getSenderAddress() {
    if (this._from) {
      return this._from;
    }
    var pubkey = this.getSenderPublicKey();
    this._from = ethUtil$1.publicToAddress(pubkey);
    return this._from;
  };
  Transaction2.prototype.getSenderPublicKey = function getSenderPublicKey() {
    if (!this._senderPubKey || !this._senderPubKey.length) {
      if (!this.verifySignature())
        throw new Error("Invalid Signature");
    }
    return this._senderPubKey;
  };
  Transaction2.prototype.verifySignature = function verifySignature() {
    var msgHash = this.hash(false);
    if (this._homestead && new BN$3(this.s).cmp(N_DIV_2) === 1) {
      return false;
    }
    try {
      var v2 = ethUtil$1.bufferToInt(this.v);
      if (this._chainId > 0) {
        v2 -= this._chainId * 2 + 8;
      }
      this._senderPubKey = ethUtil$1.ecrecover(msgHash, v2, this.r, this.s);
    } catch (e2) {
      return false;
    }
    return !!this._senderPubKey;
  };
  Transaction2.prototype.sign = function sign9(privateKey) {
    var msgHash = this.hash(false);
    var sig = ethUtil$1.ecsign(msgHash, privateKey);
    if (this._chainId > 0) {
      sig.v += this._chainId * 2 + 8;
    }
    Object.assign(this, sig);
  };
  Transaction2.prototype.getDataFee = function getDataFee() {
    var data = this.raw[5];
    var cost = new BN$3(0);
    for (var i2 = 0; i2 < data.length; i2++) {
      data[i2] === 0 ? cost.iaddn(fees.txDataZeroGas.v) : cost.iaddn(fees.txDataNonZeroGas.v);
    }
    return cost;
  };
  Transaction2.prototype.getBaseFee = function getBaseFee() {
    var fee = this.getDataFee().iaddn(fees.txGas.v);
    if (this._homestead && this.toCreationAddress()) {
      fee.iaddn(fees.txCreation.v);
    }
    return fee;
  };
  Transaction2.prototype.getUpfrontCost = function getUpfrontCost() {
    return new BN$3(this.gasLimit).imul(new BN$3(this.gasPrice)).iadd(new BN$3(this.value));
  };
  Transaction2.prototype.validate = function validate11(stringError) {
    var errors2 = [];
    if (!this.verifySignature()) {
      errors2.push("Invalid Signature");
    }
    if (this.getBaseFee().cmp(new BN$3(this.gasLimit)) > 0) {
      errors2.push(["gas limit is too low. Need at least " + this.getBaseFee()]);
    }
    if (stringError === void 0 || stringError === false) {
      return errors2.length === 0;
    } else {
      return errors2.join(" ");
    }
  };
  return Transaction2;
}();
var es5 = Transaction$1;
const inherits = util$7.inherits;
const Transaction = es5;
const ethUtil = dist$5;
const Subprovider = subprovider;
const blockTagForPayload = rpcCacheUtils.blockTagForPayload;
var nonceTracker = NonceTrackerSubprovider;
inherits(NonceTrackerSubprovider, Subprovider);
function NonceTrackerSubprovider(opts) {
  const self2 = this;
  self2.nonceCache = {};
}
NonceTrackerSubprovider.prototype.handleRequest = function(payload, next3, end) {
  const self2 = this;
  switch (payload.method) {
    case "eth_getTransactionCount":
      var blockTag = blockTagForPayload(payload);
      var address = payload.params[0].toLowerCase();
      var cachedResult = self2.nonceCache[address];
      if (blockTag === "pending") {
        if (cachedResult) {
          end(null, cachedResult);
        } else {
          next3(function(err, result, cb) {
            if (err)
              return cb();
            if (self2.nonceCache[address] === void 0) {
              self2.nonceCache[address] = result;
            }
            cb();
          });
        }
      } else {
        next3();
      }
      return;
    case "eth_sendRawTransaction":
      next3(function(err, result, cb) {
        if (err)
          return cb();
        var rawTx = payload.params[0];
        ethUtil.stripHexPrefix(rawTx);
        buffer$2.Buffer.from(ethUtil.stripHexPrefix(rawTx), "hex");
        var tx = new Transaction(buffer$2.Buffer.from(ethUtil.stripHexPrefix(rawTx), "hex"));
        var address2 = "0x" + tx.getSenderAddress().toString("hex").toLowerCase();
        var nonce = ethUtil.bufferToInt(tx.nonce);
        nonce++;
        var hexNonce = nonce.toString(16);
        if (hexNonce.length % 2)
          hexNonce = "0" + hexNonce;
        hexNonce = "0x" + hexNonce;
        self2.nonceCache[address2] = hexNonce;
        cb();
      });
      return;
    case "evm_revert":
      self2.nonceCache = {};
      next3();
      return;
    default:
      next3();
      return;
  }
};
const SafeEventEmitter = safeEventEmitter.default;
const createScaffoldMiddleware = scaffold;
const { createAsyncMiddleware } = dist$4;
const createFilterMiddleware = ethJsonRpcFilters;
const { unsafeRandomBytes, incrementHexInt } = hexUtils;
const getBlocksForRange = getBlocksForRange_1;
var subscriptionManager = createSubscriptionMiddleware;
function createSubscriptionMiddleware({ blockTracker, provider }) {
  const subscriptions2 = {};
  const filterManager = createFilterMiddleware({ blockTracker, provider });
  let isDestroyed = false;
  const events2 = new SafeEventEmitter();
  const middleware = createScaffoldMiddleware({
    eth_subscribe: createAsyncMiddleware(subscribe),
    eth_unsubscribe: createAsyncMiddleware(unsubscribe)
  });
  middleware.destroy = destroy2;
  return { events: events2, middleware };
  async function subscribe(req, res) {
    if (isDestroyed)
      throw new Error("SubscriptionManager - attempting to use after destroying");
    const subscriptionType = req.params[0];
    const subId = unsafeRandomBytes(16);
    let sub;
    switch (subscriptionType) {
      case "newHeads":
        sub = createSubNewHeads({ subId });
        break;
      case "logs":
        const filterParams = req.params[1];
        const filter2 = await filterManager.newLogFilter(filterParams);
        sub = createSubFromFilter({ subId, filter: filter2 });
        break;
      default:
        throw new Error(`SubscriptionManager - unsupported subscription type "${subscriptionType}"`);
    }
    subscriptions2[subId] = sub;
    res.result = subId;
    return;
    function createSubNewHeads({ subId: subId2 }) {
      const sub2 = {
        type: subscriptionType,
        destroy: async () => {
          blockTracker.removeListener("sync", sub2.update);
        },
        update: async ({ oldBlock, newBlock }) => {
          const toBlock = newBlock;
          const fromBlock = incrementHexInt(oldBlock);
          const rawBlocks = await getBlocksForRange({ provider, fromBlock, toBlock });
          const results2 = rawBlocks.map(normalizeBlock);
          results2.forEach((value2) => {
            _emitSubscriptionResult(subId2, value2);
          });
        }
      };
      blockTracker.on("sync", sub2.update);
      return sub2;
    }
    function createSubFromFilter({ subId: subId2, filter: filter2 }) {
      filter2.on("update", (result) => _emitSubscriptionResult(subId2, result));
      const sub2 = {
        type: subscriptionType,
        destroy: async () => {
          return await filterManager.uninstallFilter(filter2.idHex);
        }
      };
      return sub2;
    }
  }
  async function unsubscribe(req, res) {
    if (isDestroyed)
      throw new Error("SubscriptionManager - attempting to use after destroying");
    const id2 = req.params[0];
    const subscription = subscriptions2[id2];
    if (!subscription) {
      res.result = false;
      return;
    }
    delete subscriptions2[id2];
    await subscription.destroy();
    res.result = true;
  }
  function _emitSubscriptionResult(filterIdHex, value2) {
    events2.emit("notification", {
      jsonrpc: "2.0",
      method: "eth_subscription",
      params: {
        subscription: filterIdHex,
        result: value2
      }
    });
  }
  function destroy2() {
    events2.removeAllListeners();
    for (const id2 in subscriptions2) {
      subscriptions2[id2].destroy();
      delete subscriptions2[id2];
    }
    isDestroyed = true;
  }
}
function normalizeBlock(block) {
  return {
    hash: block.hash,
    parentHash: block.parentHash,
    sha3Uncles: block.sha3Uncles,
    miner: block.miner,
    stateRoot: block.stateRoot,
    transactionsRoot: block.transactionsRoot,
    receiptsRoot: block.receiptsRoot,
    logsBloom: block.logsBloom,
    difficulty: block.difficulty,
    number: block.number,
    gasLimit: block.gasLimit,
    gasUsed: block.gasUsed,
    nonce: block.nonce,
    mixHash: block.mixHash,
    timestamp: block.timestamp,
    extraData: block.extraData
  };
}
const ProviderSubprovider = jsonRpcEngineMiddleware;
const createSubscriptionManager$1 = subscriptionManager;
class SubscriptionsSubprovider$1 extends ProviderSubprovider {
  constructor() {
    super(({ blockTracker, provider, engine }) => {
      const { events: events2, middleware } = createSubscriptionManager$1({ blockTracker, provider });
      events2.on("notification", (data) => engine.emit("data", null, data));
      return middleware;
    });
  }
}
var subscriptions = SubscriptionsSubprovider$1;
var cjs$4 = {};
var cjs$3 = {};
Object.defineProperty(cjs$3, "__esModule", { value: true });
var getLocalStorage_1 = cjs$3.getLocalStorage = getLocalStorageOrThrow_1 = cjs$3.getLocalStorageOrThrow = getCrypto_1 = cjs$3.getCrypto = getCryptoOrThrow_1 = cjs$3.getCryptoOrThrow = getLocation_1 = cjs$3.getLocation = getLocationOrThrow_1 = cjs$3.getLocationOrThrow = getNavigator_1 = cjs$3.getNavigator = getNavigatorOrThrow_1 = cjs$3.getNavigatorOrThrow = getDocument_1 = cjs$3.getDocument = getDocumentOrThrow_1 = cjs$3.getDocumentOrThrow = getFromWindowOrThrow_1 = cjs$3.getFromWindowOrThrow = getFromWindow_1 = cjs$3.getFromWindow = void 0;
function getFromWindow$1(name2) {
  let res = void 0;
  if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
    res = window[name2];
  }
  return res;
}
var getFromWindow_1 = cjs$3.getFromWindow = getFromWindow$1;
function getFromWindowOrThrow$1(name2) {
  const res = getFromWindow$1(name2);
  if (!res) {
    throw new Error(`${name2} is not defined in Window`);
  }
  return res;
}
var getFromWindowOrThrow_1 = cjs$3.getFromWindowOrThrow = getFromWindowOrThrow$1;
function getDocumentOrThrow$1() {
  return getFromWindowOrThrow$1("document");
}
var getDocumentOrThrow_1 = cjs$3.getDocumentOrThrow = getDocumentOrThrow$1;
function getDocument$1() {
  return getFromWindow$1("document");
}
var getDocument_1 = cjs$3.getDocument = getDocument$1;
function getNavigatorOrThrow$1() {
  return getFromWindowOrThrow$1("navigator");
}
var getNavigatorOrThrow_1 = cjs$3.getNavigatorOrThrow = getNavigatorOrThrow$1;
function getNavigator$1() {
  return getFromWindow$1("navigator");
}
var getNavigator_1 = cjs$3.getNavigator = getNavigator$1;
function getLocationOrThrow$1() {
  return getFromWindowOrThrow$1("location");
}
var getLocationOrThrow_1 = cjs$3.getLocationOrThrow = getLocationOrThrow$1;
function getLocation$1() {
  return getFromWindow$1("location");
}
var getLocation_1 = cjs$3.getLocation = getLocation$1;
function getCryptoOrThrow$1() {
  return getFromWindowOrThrow$1("crypto");
}
var getCryptoOrThrow_1 = cjs$3.getCryptoOrThrow = getCryptoOrThrow$1;
function getCrypto$1() {
  return getFromWindow$1("crypto");
}
var getCrypto_1 = cjs$3.getCrypto = getCrypto$1;
function getLocalStorageOrThrow$1() {
  return getFromWindowOrThrow$1("localStorage");
}
var getLocalStorageOrThrow_1 = cjs$3.getLocalStorageOrThrow = getLocalStorageOrThrow$1;
function getLocalStorage$1() {
  return getFromWindow$1("localStorage");
}
getLocalStorage_1 = cjs$3.getLocalStorage = getLocalStorage$1;
Object.defineProperty(cjs$4, "__esModule", { value: true });
var getWindowMetadata_1 = cjs$4.getWindowMetadata = void 0;
const window_getters_1 = cjs$3;
function getWindowMetadata() {
  let doc2;
  let loc;
  try {
    doc2 = window_getters_1.getDocumentOrThrow();
    loc = window_getters_1.getLocationOrThrow();
  } catch (e2) {
    return null;
  }
  function getIcons() {
    const links = doc2.getElementsByTagName("link");
    const icons2 = [];
    for (let i2 = 0; i2 < links.length; i2++) {
      const link = links[i2];
      const rel = link.getAttribute("rel");
      if (rel) {
        if (rel.toLowerCase().indexOf("icon") > -1) {
          const href = link.getAttribute("href");
          if (href) {
            if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
              let absoluteHref = loc.protocol + "//" + loc.host;
              if (href.indexOf("/") === 0) {
                absoluteHref += href;
              } else {
                const path = loc.pathname.split("/");
                path.pop();
                const finalPath = path.join("/");
                absoluteHref += finalPath + "/" + href;
              }
              icons2.push(absoluteHref);
            } else if (href.indexOf("//") === 0) {
              const absoluteUrl = loc.protocol + href;
              icons2.push(absoluteUrl);
            } else {
              icons2.push(href);
            }
          }
        }
      }
    }
    return icons2;
  }
  function getWindowMetadataOfAny(...args) {
    const metaTags = doc2.getElementsByTagName("meta");
    for (let i2 = 0; i2 < metaTags.length; i2++) {
      const tag = metaTags[i2];
      const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
        if (attr) {
          return args.includes(attr);
        }
        return false;
      });
      if (attributes.length && attributes) {
        const content = tag.getAttribute("content");
        if (content) {
          return content;
        }
      }
    }
    return "";
  }
  function getName() {
    let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
    if (!name3) {
      name3 = doc2.title;
    }
    return name3;
  }
  function getDescription() {
    const description3 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
    return description3;
  }
  const name2 = getName();
  const description2 = getDescription();
  const url2 = loc.origin;
  const icons = getIcons();
  const meta2 = {
    description: description2,
    url: url2,
    icons,
    name: name2
  };
  return meta2;
}
getWindowMetadata_1 = cjs$4.getWindowMetadata = getWindowMetadata;
var __spreadArrays = globalThis && globalThis.__spreadArrays || function() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
};
var BrowserInfo = function() {
  function BrowserInfo2(name2, version2, os2) {
    this.name = name2;
    this.version = version2;
    this.os = os2;
    this.type = "browser";
  }
  return BrowserInfo2;
}();
var NodeInfo = function() {
  function NodeInfo2(version2) {
    this.version = version2;
    this.type = "node";
    this.name = "node";
    this.os = process.platform;
  }
  return NodeInfo2;
}();
var SearchBotDeviceInfo = function() {
  function SearchBotDeviceInfo2(name2, version2, os2, bot) {
    this.name = name2;
    this.version = version2;
    this.os = os2;
    this.bot = bot;
    this.type = "bot-device";
  }
  return SearchBotDeviceInfo2;
}();
var BotInfo = function() {
  function BotInfo2() {
    this.type = "bot";
    this.bot = true;
    this.name = "bot";
    this.version = null;
    this.os = null;
  }
  return BotInfo2;
}();
var ReactNativeInfo = function() {
  function ReactNativeInfo2() {
    this.type = "react-native";
    this.name = "react-native";
    this.version = null;
    this.os = null;
  }
  return ReactNativeInfo2;
}();
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FBAV\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser2 = _a2[0], regex2 = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex2.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name2 = matchedRule[0], match = matchedRule[1];
  if (name2 === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os2 = detectOS$1(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name2, version2, os2, searchBotMatch[1]);
  }
  return new BrowserInfo(name2, version2, os2);
}
function detectOS$1(ua) {
  for (var ii = 0, count2 = operatingSystemRules.length; ii < count2; ii++) {
    var _a2 = operatingSystemRules[ii], os2 = _a2[0], regex2 = _a2[1];
    var match = regex2.exec(ua);
    if (match) {
      return os2;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count2) {
  var output = [];
  for (var ii = 0; ii < count2; ii++) {
    output.push("0");
  }
  return output;
}
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS() {
  const env2 = detectEnv();
  return env2 && env2.os ? env2.os : void 0;
}
function isAndroid() {
  const os2 = detectOS();
  return os2 ? os2.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os2 = detectOS();
  return os2 ? os2.toLowerCase().includes("ios") || os2.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os2 = detectOS();
  return os2 ? isAndroid() || isIOS() : false;
}
function isNode$2() {
  const env2 = detectEnv();
  const result = env2 && env2.name ? env2.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser$1() {
  const result = !isNode$2() && !!getNavigator();
  return result;
}
const getFromWindow = getFromWindow_1;
const getFromWindowOrThrow = getFromWindowOrThrow_1;
const getDocumentOrThrow = getDocumentOrThrow_1;
const getDocument = getDocument_1;
const getNavigatorOrThrow = getNavigatorOrThrow_1;
const getNavigator = getNavigator_1;
const getLocationOrThrow = getLocationOrThrow_1;
const getLocation = getLocation_1;
const getCryptoOrThrow = getCryptoOrThrow_1;
const getCrypto = getCrypto_1;
const getLocalStorageOrThrow = getLocalStorageOrThrow_1;
const getLocalStorage = getLocalStorage_1;
function getClientMeta() {
  return getWindowMetadata_1();
}
function safeJsonParse$1(value2) {
  if (typeof value2 !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value2}`);
  }
  try {
    return JSON.parse(value2);
  } catch (_a2) {
    return value2;
  }
}
function safeJsonStringify$1(value2) {
  return typeof value2 === "string" ? value2 : JSON.stringify(value2);
}
const safeJsonParse = safeJsonParse$1;
const safeJsonStringify = safeJsonStringify$1;
function setLocal(key2, data) {
  const raw = safeJsonStringify(data);
  const local = getLocalStorage();
  if (local) {
    local.setItem(key2, raw);
  }
}
function getLocal(key2) {
  let data = null;
  let raw = null;
  const local = getLocalStorage();
  if (local) {
    raw = local.getItem(key2);
  }
  data = raw ? safeJsonParse(raw) : raw;
  return data;
}
function removeLocal(key2) {
  const local = getLocalStorage();
  if (local) {
    local.removeItem(key2);
  }
}
const mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
function formatIOSMobile(uri, entry) {
  const encodedUri = encodeURIComponent(uri);
  return entry.universalLink ? `${entry.universalLink}/wc?uri=${encodedUri}` : entry.deepLink ? `${entry.deepLink}${entry.deepLink.endsWith(":") ? "//" : "/"}wc?uri=${encodedUri}` : "";
}
function saveMobileLinkInfo(data) {
  const focusUri = data.href.split("?")[0];
  setLocal(mobileLinkChoiceKey, Object.assign(Object.assign({}, data), { href: focusUri }));
}
function getMobileRegistryEntry(registry, name2) {
  return registry.filter((entry) => entry.name.toLowerCase().includes(name2.toLowerCase()))[0];
}
function getMobileLinkRegistry(registry, whitelist) {
  let links = registry;
  if (whitelist) {
    links = whitelist.map((name2) => getMobileRegistryEntry(registry, name2)).filter(Boolean);
  }
  return links;
}
const API_URL = "https://registry.walletconnect.org";
function getWalletRegistryUrl() {
  return API_URL + "/data/wallets.json";
}
function getDappRegistryUrl() {
  return API_URL + "/data/dapps.json";
}
function getAppLogoUrl(id2) {
  return API_URL + "/logo/sm/" + id2 + ".jpeg";
}
function formatMobileRegistryEntry(entry, platform = "mobile") {
  return {
    name: entry.name || "",
    shortName: entry.metadata.shortName || "",
    color: entry.metadata.colors.primary || "",
    logo: entry.id ? getAppLogoUrl(entry.id) : "",
    universalLink: entry[platform].universal || "",
    deepLink: entry[platform].native || ""
  };
}
function formatMobileRegistry(registry, platform = "mobile") {
  return Object.values(registry).filter((entry) => !!entry[platform].universal || !!entry[platform].native).map((entry) => formatMobileRegistryEntry(entry, platform));
}
var esm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  detectEnv,
  detectOS,
  isAndroid,
  isIOS,
  isMobile,
  isNode: isNode$2,
  isBrowser: isBrowser$1,
  getFromWindow,
  getFromWindowOrThrow,
  getDocumentOrThrow,
  getDocument,
  getNavigatorOrThrow,
  getNavigator,
  getLocationOrThrow,
  getLocation,
  getCryptoOrThrow,
  getCrypto,
  getLocalStorageOrThrow,
  getLocalStorage,
  getClientMeta,
  safeJsonParse,
  safeJsonStringify,
  setLocal,
  getLocal,
  removeLocal,
  mobileLinkChoiceKey,
  formatIOSMobile,
  saveMobileLinkInfo,
  getMobileRegistryEntry,
  getMobileLinkRegistry,
  getWalletRegistryUrl,
  getDappRegistryUrl,
  getAppLogoUrl,
  formatMobileRegistryEntry,
  formatMobileRegistry
});
const reservedEvents = [
  "session_request",
  "session_update",
  "exchange_key",
  "connect",
  "disconnect",
  "display_uri",
  "modal_closed",
  "transport_open",
  "transport_close",
  "transport_error"
];
const signingMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v1",
  "eth_signTypedData_v2",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "personal_sign"
];
const infuraNetworks = {
  1: "mainnet",
  3: "ropsten",
  4: "rinkeby",
  5: "goerli",
  42: "kovan"
};
var bn = { exports: {} };
(function(module2) {
  (function(module3, exports2) {
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits2(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN2(number2, base2, endian) {
      if (BN2.isBN(number2)) {
        return number2;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number2 !== null) {
        if (base2 === "le" || base2 === "be") {
          endian = base2;
          base2 = 10;
        }
        this._init(number2 || 0, base2 || 10, endian || "be");
      }
    }
    if (typeof module3 === "object") {
      module3.exports = BN2;
    } else {
      exports2.BN = BN2;
    }
    BN2.BN = BN2;
    BN2.wordSize = 26;
    var Buffer2;
    try {
      Buffer2 = require("buffer").Buffer;
    } catch (e2) {
    }
    BN2.isBN = function isBN(num) {
      if (num instanceof BN2) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
    };
    BN2.max = function max2(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN2.min = function min2(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN2.prototype._init = function init5(number2, base2, endian) {
      if (typeof number2 === "number") {
        return this._initNumber(number2, base2, endian);
      }
      if (typeof number2 === "object") {
        return this._initArray(number2, base2, endian);
      }
      if (base2 === "hex") {
        base2 = 16;
      }
      assert2(base2 === (base2 | 0) && base2 >= 2 && base2 <= 36);
      number2 = number2.toString().replace(/\s+/g, "");
      var start = 0;
      if (number2[0] === "-") {
        start++;
      }
      if (base2 === 16) {
        this._parseHex(number2, start);
      } else {
        this._parseBase(number2, base2, start);
      }
      if (number2[0] === "-") {
        this.negative = 1;
      }
      this.strip();
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initNumber = function _initNumber(number2, base2, endian) {
      if (number2 < 0) {
        this.negative = 1;
        number2 = -number2;
      }
      if (number2 < 67108864) {
        this.words = [number2 & 67108863];
        this.length = 1;
      } else if (number2 < 4503599627370496) {
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert2(number2 < 9007199254740992);
        this.words = [
          number2 & 67108863,
          number2 / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base2, endian);
    };
    BN2.prototype._initArray = function _initArray(number2, base2, endian) {
      assert2(typeof number2.length === "number");
      if (number2.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number2.length / 3);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j2, w2;
      var off = 0;
      if (endian === "be") {
        for (i2 = number2.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
          w2 = number2[i2] | number2[i2 - 1] << 8 | number2[i2 - 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      } else if (endian === "le") {
        for (i2 = 0, j2 = 0; i2 < number2.length; i2 += 3) {
          w2 = number2[i2] | number2[i2 + 1] << 8 | number2[i2 + 2] << 16;
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
      }
      return this.strip();
    };
    function parseHex(str2, start, end) {
      var r2 = 0;
      var len2 = Math.min(str2.length, end);
      for (var i2 = start; i2 < len2; i2++) {
        var c2 = str2.charCodeAt(i2) - 48;
        r2 <<= 4;
        if (c2 >= 49 && c2 <= 54) {
          r2 |= c2 - 49 + 10;
        } else if (c2 >= 17 && c2 <= 22) {
          r2 |= c2 - 17 + 10;
        } else {
          r2 |= c2 & 15;
        }
      }
      return r2;
    }
    BN2.prototype._parseHex = function _parseHex(number2, start) {
      this.length = Math.ceil((number2.length - start) / 6);
      this.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        this.words[i2] = 0;
      }
      var j2, w2;
      var off = 0;
      for (i2 = number2.length - 6, j2 = 0; i2 >= start; i2 -= 6) {
        w2 = parseHex(number2, i2, i2 + 6);
        this.words[j2] |= w2 << off & 67108863;
        this.words[j2 + 1] |= w2 >>> 26 - off & 4194303;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j2++;
        }
      }
      if (i2 + 6 !== start) {
        w2 = parseHex(number2, start, i2 + 6);
        this.words[j2] |= w2 << off & 67108863;
        this.words[j2 + 1] |= w2 >>> 26 - off & 4194303;
      }
      this.strip();
    };
    function parseBase(str2, start, end, mul8) {
      var r2 = 0;
      var len2 = Math.min(str2.length, end);
      for (var i2 = start; i2 < len2; i2++) {
        var c2 = str2.charCodeAt(i2) - 48;
        r2 *= mul8;
        if (c2 >= 49) {
          r2 += c2 - 49 + 10;
        } else if (c2 >= 17) {
          r2 += c2 - 17 + 10;
        } else {
          r2 += c2;
        }
      }
      return r2;
    }
    BN2.prototype._parseBase = function _parseBase(number2, base2, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base2) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base2 | 0;
      var total = number2.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word2 = 0;
      for (var i2 = start; i2 < end; i2 += limbLen) {
        word2 = parseBase(number2, i2, i2 + limbLen, base2);
        this.imuln(limbPow);
        if (this.words[0] + word2 < 67108864) {
          this.words[0] += word2;
        } else {
          this._iaddn(word2);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word2 = parseBase(number2, i2, number2.length, base2);
        for (i2 = 0; i2 < mod; i2++) {
          pow *= base2;
        }
        this.imuln(pow);
        if (this.words[0] + word2 < 67108864) {
          this.words[0] += word2;
        } else {
          this._iaddn(word2);
        }
      }
    };
    BN2.prototype.copy = function copy3(dest) {
      dest.words = new Array(this.length);
      for (var i2 = 0; i2 < this.length; i2++) {
        dest.words[i2] = this.words[i2];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN2.prototype.clone = function clone() {
      var r2 = new BN2(null);
      this.copy(r2);
      return r2;
    };
    BN2.prototype._expand = function _expand(size2) {
      while (this.length < size2) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN2.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN2.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN2.prototype.inspect = function inspect10() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var zeros2 = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN2.prototype.toString = function toString2(base2, padding2) {
      base2 = base2 || 10;
      padding2 = padding2 | 0 || 1;
      var out;
      if (base2 === 16 || base2 === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = this.words[i2];
          var word2 = ((w2 << off | carry) & 16777215).toString(16);
          carry = w2 >>> 24 - off & 16777215;
          if (carry !== 0 || i2 !== this.length - 1) {
            out = zeros2[6 - word2.length] + word2 + out;
          } else {
            out = word2 + out;
          }
          off += 2;
          if (off >= 26) {
            off -= 26;
            i2--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base2 === (base2 | 0) && base2 >= 2 && base2 <= 36) {
        var groupSize = groupSizes[base2];
        var groupBase = groupBases[base2];
        out = "";
        var c2 = this.clone();
        c2.negative = 0;
        while (!c2.isZero()) {
          var r2 = c2.modn(groupBase).toString(base2);
          c2 = c2.idivn(groupBase);
          if (!c2.isZero()) {
            out = zeros2[groupSize - r2.length] + r2 + out;
          } else {
            out = r2 + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding2 !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert2(false, "Base should be between 2 and 36");
    };
    BN2.prototype.toNumber = function toNumber2() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN2.prototype.toJSON = function toJSON3() {
      return this.toString(16);
    };
    BN2.prototype.toBuffer = function toBuffer2(endian, length) {
      assert2(typeof Buffer2 !== "undefined");
      return this.toArrayLike(Buffer2, endian, length);
    };
    BN2.prototype.toArray = function toArray2(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength2 = this.byteLength();
      var reqLength = length || Math.max(1, byteLength2);
      assert2(byteLength2 <= reqLength, "byte array longer than desired length");
      assert2(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b2, i2;
      var q2 = this.clone();
      if (!littleEndian) {
        for (i2 = 0; i2 < reqLength - byteLength2; i2++) {
          res[i2] = 0;
        }
        for (i2 = 0; !q2.isZero(); i2++) {
          b2 = q2.andln(255);
          q2.iushrn(8);
          res[reqLength - i2 - 1] = b2;
        }
      } else {
        for (i2 = 0; !q2.isZero(); i2++) {
          b2 = q2.andln(255);
          q2.iushrn(8);
          res[i2] = b2;
        }
        for (; i2 < reqLength; i2++) {
          res[i2] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN2.prototype._countBits = function _countBits(w2) {
        return 32 - Math.clz32(w2);
      };
    } else {
      BN2.prototype._countBits = function _countBits(w2) {
        var t2 = w2;
        var r2 = 0;
        if (t2 >= 4096) {
          r2 += 13;
          t2 >>>= 13;
        }
        if (t2 >= 64) {
          r2 += 7;
          t2 >>>= 7;
        }
        if (t2 >= 8) {
          r2 += 4;
          t2 >>>= 4;
        }
        if (t2 >= 2) {
          r2 += 2;
          t2 >>>= 2;
        }
        return r2 + t2;
      };
    }
    BN2.prototype._zeroBits = function _zeroBits(w2) {
      if (w2 === 0)
        return 26;
      var t2 = w2;
      var r2 = 0;
      if ((t2 & 8191) === 0) {
        r2 += 13;
        t2 >>>= 13;
      }
      if ((t2 & 127) === 0) {
        r2 += 7;
        t2 >>>= 7;
      }
      if ((t2 & 15) === 0) {
        r2 += 4;
        t2 >>>= 4;
      }
      if ((t2 & 3) === 0) {
        r2 += 2;
        t2 >>>= 2;
      }
      if ((t2 & 1) === 0) {
        r2++;
      }
      return r2;
    };
    BN2.prototype.bitLength = function bitLength() {
      var w2 = this.words[this.length - 1];
      var hi = this._countBits(w2);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w2 = new Array(num.bitLength());
      for (var bit = 0; bit < w2.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w2[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }
      return w2;
    }
    BN2.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r2 = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var b2 = this._zeroBits(this.words[i2]);
        r2 += b2;
        if (b2 !== 26)
          break;
      }
      return r2;
    };
    BN2.prototype.byteLength = function byteLength2() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN2.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN2.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN2.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN2.prototype.neg = function neg6() {
      return this.clone().ineg();
    };
    BN2.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN2.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i2 = 0; i2 < num.length; i2++) {
        this.words[i2] = this.words[i2] | num.words[i2];
      }
      return this.strip();
    };
    BN2.prototype.ior = function ior(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN2.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN2.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN2.prototype.iuand = function iuand(num) {
      var b2;
      if (this.length > num.length) {
        b2 = num;
      } else {
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = this.words[i2] & num.words[i2];
      }
      this.length = b2.length;
      return this.strip();
    };
    BN2.prototype.iand = function iand(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN2.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN2.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN2.prototype.iuxor = function iuxor(num) {
      var a2;
      var b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      for (var i2 = 0; i2 < b2.length; i2++) {
        this.words[i2] = a2.words[i2] ^ b2.words[i2];
      }
      if (this !== a2) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = a2.length;
      return this.strip();
    };
    BN2.prototype.ixor = function ixor(num) {
      assert2((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN2.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN2.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN2.prototype.inotn = function inotn(width) {
      assert2(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i2 = 0; i2 < bytesNeeded; i2++) {
        this.words[i2] = ~this.words[i2] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
      }
      return this.strip();
    };
    BN2.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN2.prototype.setn = function setn(bit, val) {
      assert2(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN2.prototype.iadd = function iadd(num) {
      var r2;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r2 = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r2 = this.isub(num);
        num.negative = 1;
        return r2._normSign();
      }
      var a2, b2;
      if (this.length > num.length) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        this.words[i2] = r2 & 67108863;
        carry = r2 >>> 26;
      }
      this.length = a2.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      return this;
    };
    BN2.prototype.add = function add8(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN2.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r2 = this.iadd(num);
        num.negative = 1;
        return r2._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a2, b2;
      if (cmp > 0) {
        a2 = this;
        b2 = num;
      } else {
        a2 = num;
        b2 = this;
      }
      var carry = 0;
      for (var i2 = 0; i2 < b2.length; i2++) {
        r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      for (; carry !== 0 && i2 < a2.length; i2++) {
        r2 = (a2.words[i2] | 0) + carry;
        carry = r2 >> 26;
        this.words[i2] = r2 & 67108863;
      }
      if (carry === 0 && i2 < a2.length && a2 !== this) {
        for (; i2 < a2.length; i2++) {
          this.words[i2] = a2.words[i2];
        }
      }
      this.length = Math.max(this.length, i2);
      if (a2 !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN2.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len2 = self2.length + num.length | 0;
      out.length = len2;
      len2 = len2 - 1 | 0;
      var a2 = self2.words[0] | 0;
      var b2 = num.words[0] | 0;
      var r2 = a2 * b2;
      var lo = r2 & 67108863;
      var carry = r2 / 67108864 | 0;
      out.words[0] = lo;
      for (var k2 = 1; k2 < len2; k2++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k2 - j2 | 0;
          a2 = self2.words[i2] | 0;
          b2 = num.words[j2] | 0;
          r2 = a2 * b2 + rword;
          ncarry += r2 / 67108864 | 0;
          rword = r2 & 67108863;
        }
        out.words[k2] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k2] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a2 = self2.words;
      var b2 = num.words;
      var o2 = out.words;
      var c2 = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a2[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a2[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a22 = a2[2] | 0;
      var al2 = a22 & 8191;
      var ah2 = a22 >>> 13;
      var a3 = a2[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a2[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a2[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a2[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a2[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a2[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a2[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b2[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b2[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b22 = b2[2] | 0;
      var bl2 = b22 & 8191;
      var bh2 = b22 >>> 13;
      var b3 = b2[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b2[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b2[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b2[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b2[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b2[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b2[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
      c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o2[0] = w0;
      o2[1] = w1;
      o2[2] = w2;
      o2[3] = w3;
      o2[4] = w4;
      o2[5] = w5;
      o2[6] = w6;
      o2[7] = w7;
      o2[8] = w8;
      o2[9] = w9;
      o2[10] = w10;
      o2[11] = w11;
      o2[12] = w12;
      o2[13] = w13;
      o2[14] = w14;
      o2[15] = w15;
      o2[16] = w16;
      o2[17] = w17;
      o2[18] = w18;
      if (c2 !== 0) {
        o2[19] = c2;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k2 = 0; k2 < out.length - 1; k2++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k2, num.length - 1);
        for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
          var i2 = k2 - j2;
          var a2 = self2.words[i2] | 0;
          var b2 = num.words[j2] | 0;
          var r2 = a2 * b2;
          var lo = r2 & 67108863;
          ncarry = ncarry + (r2 / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k2] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k2] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo(self2, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self2, num, out);
    }
    BN2.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len2 = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len2 < 63) {
        res = smallMulTo(this, num, out);
      } else if (len2 < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x2, y2) {
      this.x = x2;
      this.y = y2;
    }
    FFTM.prototype.makeRBT = function makeRBT(N2) {
      var t2 = new Array(N2);
      var l2 = BN2.prototype._countBits(N2) - 1;
      for (var i2 = 0; i2 < N2; i2++) {
        t2[i2] = this.revBin(i2, l2, N2);
      }
      return t2;
    };
    FFTM.prototype.revBin = function revBin(x2, l2, N2) {
      if (x2 === 0 || x2 === N2 - 1)
        return x2;
      var rb = 0;
      for (var i2 = 0; i2 < l2; i2++) {
        rb |= (x2 & 1) << l2 - i2 - 1;
        x2 >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
      for (var i2 = 0; i2 < N2; i2++) {
        rtws[i2] = rws[rbt[i2]];
        itws[i2] = iws[rbt[i2]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N2);
      for (var s2 = 1; s2 < N2; s2 <<= 1) {
        var l2 = s2 << 1;
        var rtwdf = Math.cos(2 * Math.PI / l2);
        var itwdf = Math.sin(2 * Math.PI / l2);
        for (var p2 = 0; p2 < N2; p2 += l2) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j2 = 0; j2 < s2; j2++) {
            var re = rtws[p2 + j2];
            var ie = itws[p2 + j2];
            var ro = rtws[p2 + j2 + s2];
            var io = itws[p2 + j2 + s2];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p2 + j2] = re + ro;
            itws[p2 + j2] = ie + io;
            rtws[p2 + j2 + s2] = re - ro;
            itws[p2 + j2 + s2] = ie - io;
            if (j2 !== l2) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n2, m2) {
      var N2 = Math.max(m2, n2) | 1;
      var odd = N2 & 1;
      var i2 = 0;
      for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
        i2++;
      }
      return 1 << i2 + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
      if (N2 <= 1)
        return;
      for (var i2 = 0; i2 < N2 / 2; i2++) {
        var t2 = rws[i2];
        rws[i2] = rws[N2 - i2 - 1];
        rws[N2 - i2 - 1] = t2;
        t2 = iws[i2];
        iws[i2] = -iws[N2 - i2 - 1];
        iws[N2 - i2 - 1] = -t2;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
      var carry = 0;
      for (var i2 = 0; i2 < N2 / 2; i2++) {
        var w2 = Math.round(ws[2 * i2 + 1] / N2) * 8192 + Math.round(ws[2 * i2] / N2) + carry;
        ws[i2] = w2 & 67108863;
        if (w2 < 67108864) {
          carry = 0;
        } else {
          carry = w2 / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N2) {
      var carry = 0;
      for (var i2 = 0; i2 < len2; i2++) {
        carry = carry + (ws[i2] | 0);
        rws[2 * i2] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i2 + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i2 = 2 * len2; i2 < N2; ++i2) {
        rws[i2] = 0;
      }
      assert2(carry === 0);
      assert2((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N2) {
      var ph = new Array(N2);
      for (var i2 = 0; i2 < N2; i2++) {
        ph[i2] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x2, y2, out) {
      var N2 = 2 * this.guessLen13b(x2.length, y2.length);
      var rbt = this.makeRBT(N2);
      var _2 = this.stub(N2);
      var rws = new Array(N2);
      var rwst = new Array(N2);
      var iwst = new Array(N2);
      var nrws = new Array(N2);
      var nrwst = new Array(N2);
      var niwst = new Array(N2);
      var rmws = out.words;
      rmws.length = N2;
      this.convert13b(x2.words, x2.length, rws, N2);
      this.convert13b(y2.words, y2.length, nrws, N2);
      this.transform(rws, _2, rwst, iwst, N2, rbt);
      this.transform(nrws, _2, nrwst, niwst, N2, rbt);
      for (var i2 = 0; i2 < N2; i2++) {
        var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
        iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
        rwst[i2] = rx;
      }
      this.conjugate(rwst, iwst, N2);
      this.transform(rwst, iwst, rmws, _2, N2, rbt);
      this.conjugate(rmws, _2, N2);
      this.normalize13b(rmws, N2);
      out.negative = x2.negative ^ y2.negative;
      out.length = x2.length + y2.length;
      return out.strip();
    };
    BN2.prototype.mul = function mul8(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN2.prototype.mulf = function mulf(num) {
      var out = new BN2(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN2.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN2.prototype.imuln = function imuln(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      var carry = 0;
      for (var i2 = 0; i2 < this.length; i2++) {
        var w2 = (this.words[i2] | 0) * num;
        var lo = (w2 & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w2 / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i2] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN2.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN2.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN2.prototype.pow = function pow(num) {
      var w2 = toBitArray(num);
      if (w2.length === 0)
        return new BN2(1);
      var res = this;
      for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
        if (w2[i2] !== 0)
          break;
      }
      if (++i2 < w2.length) {
        for (var q2 = res.sqr(); i2 < w2.length; i2++, q2 = q2.sqr()) {
          if (w2[i2] === 0)
            continue;
          res = res.mul(q2);
        }
      }
      return res;
    };
    BN2.prototype.iushln = function iushln(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
      var i2;
      if (r2 !== 0) {
        var carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          var newCarry = this.words[i2] & carryMask;
          var c2 = (this.words[i2] | 0) - newCarry << r2;
          this.words[i2] = c2 | carry;
          carry = newCarry >>> 26 - r2;
        }
        if (carry) {
          this.words[i2] = carry;
          this.length++;
        }
      }
      if (s2 !== 0) {
        for (i2 = this.length - 1; i2 >= 0; i2--) {
          this.words[i2 + s2] = this.words[i2];
        }
        for (i2 = 0; i2 < s2; i2++) {
          this.words[i2] = 0;
        }
        this.length += s2;
      }
      return this.strip();
    };
    BN2.prototype.ishln = function ishln(bits) {
      assert2(this.negative === 0);
      return this.iushln(bits);
    };
    BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert2(typeof bits === "number" && bits >= 0);
      var h2;
      if (hint) {
        h2 = (hint - hint % 26) / 26;
      } else {
        h2 = 0;
      }
      var r2 = bits % 26;
      var s2 = Math.min((bits - r2) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r2 << r2;
      var maskedWords = extended;
      h2 -= s2;
      h2 = Math.max(0, h2);
      if (maskedWords) {
        for (var i2 = 0; i2 < s2; i2++) {
          maskedWords.words[i2] = this.words[i2];
        }
        maskedWords.length = s2;
      }
      if (s2 === 0)
        ;
      else if (this.length > s2) {
        this.length -= s2;
        for (i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = this.words[i2 + s2];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
        var word2 = this.words[i2] | 0;
        this.words[i2] = carry << 26 - r2 | word2 >>> r2;
        carry = word2 & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert2(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN2.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN2.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN2.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN2.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN2.prototype.testn = function testn(bit) {
      assert2(typeof bit === "number" && bit >= 0);
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2)
        return false;
      var w2 = this.words[s2];
      return !!(w2 & q2);
    };
    BN2.prototype.imaskn = function imaskn(bits) {
      assert2(typeof bits === "number" && bits >= 0);
      var r2 = bits % 26;
      var s2 = (bits - r2) / 26;
      assert2(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s2) {
        return this;
      }
      if (r2 !== 0) {
        s2++;
      }
      this.length = Math.min(s2, this.length);
      if (r2 !== 0) {
        var mask = 67108863 ^ 67108863 >>> r2 << r2;
        this.words[this.length - 1] &= mask;
      }
      return this.strip();
    };
    BN2.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN2.prototype.iaddn = function iaddn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN2.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
        this.words[i2] -= 67108864;
        if (i2 === this.length - 1) {
          this.words[i2 + 1] = 1;
        } else {
          this.words[i2 + 1]++;
        }
      }
      this.length = Math.max(this.length, i2 + 1);
      return this;
    };
    BN2.prototype.isubn = function isubn(num) {
      assert2(typeof num === "number");
      assert2(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
          this.words[i2] += 67108864;
          this.words[i2 + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN2.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN2.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN2.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN2.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul8, shift) {
      var len2 = num.length + shift;
      var i2;
      this._expand(len2);
      var w2;
      var carry = 0;
      for (i2 = 0; i2 < num.length; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        var right = (num.words[i2] | 0) * mul8;
        w2 -= right & 67108863;
        carry = (w2 >> 26) - (right / 67108864 | 0);
        this.words[i2 + shift] = w2 & 67108863;
      }
      for (; i2 < this.length - shift; i2++) {
        w2 = (this.words[i2 + shift] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2 + shift] = w2 & 67108863;
      }
      if (carry === 0)
        return this.strip();
      assert2(carry === -1);
      carry = 0;
      for (i2 = 0; i2 < this.length; i2++) {
        w2 = -(this.words[i2] | 0) + carry;
        carry = w2 >> 26;
        this.words[i2] = w2 & 67108863;
      }
      this.negative = 1;
      return this.strip();
    };
    BN2.prototype._wordDiv = function _wordDiv(num, mode2) {
      var shift = this.length - num.length;
      var a2 = this.clone();
      var b2 = num;
      var bhi = b2.words[b2.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b2 = b2.ushln(shift);
        a2.iushln(shift);
        bhi = b2.words[b2.length - 1] | 0;
      }
      var m2 = a2.length - b2.length;
      var q2;
      if (mode2 !== "mod") {
        q2 = new BN2(null);
        q2.length = m2 + 1;
        q2.words = new Array(q2.length);
        for (var i2 = 0; i2 < q2.length; i2++) {
          q2.words[i2] = 0;
        }
      }
      var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
      if (diff.negative === 0) {
        a2 = diff;
        if (q2) {
          q2.words[m2] = 1;
        }
      }
      for (var j2 = m2 - 1; j2 >= 0; j2--) {
        var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a2._ishlnsubmul(b2, qj, j2);
        while (a2.negative !== 0) {
          qj--;
          a2.negative = 0;
          a2._ishlnsubmul(b2, 1, j2);
          if (!a2.isZero()) {
            a2.negative ^= 1;
          }
        }
        if (q2) {
          q2.words[j2] = qj;
        }
      }
      if (q2) {
        q2.strip();
      }
      a2.strip();
      if (mode2 !== "div" && shift !== 0) {
        a2.iushrn(shift);
      }
      return {
        div: q2 || null,
        mod: a2
      };
    };
    BN2.prototype.divmod = function divmod(num, mode2, positive) {
      assert2(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN2(0),
          mod: new BN2(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode2);
        if (mode2 !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode2);
        if (mode2 !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN2(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode2 === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode2 === "mod") {
          return {
            div: null,
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN2(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode2);
    };
    BN2.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN2.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN2.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN2.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN2.prototype.modn = function modn(num) {
      assert2(num <= 67108863);
      var p2 = (1 << 26) % num;
      var acc = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        acc = (p2 * acc + (this.words[i2] | 0)) % num;
      }
      return acc;
    };
    BN2.prototype.idivn = function idivn(num) {
      assert2(num <= 67108863);
      var carry = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var w2 = (this.words[i2] | 0) + carry * 67108864;
        this.words[i2] = w2 / num | 0;
        carry = w2 % num;
      }
      return this.strip();
    };
    BN2.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN2.prototype.egcd = function egcd(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var x2 = this;
      var y2 = p2.clone();
      if (x2.negative !== 0) {
        x2 = x2.umod(p2);
      } else {
        x2 = x2.clone();
      }
      var A2 = new BN2(1);
      var B2 = new BN2(0);
      var C2 = new BN2(0);
      var D2 = new BN2(1);
      var g2 = 0;
      while (x2.isEven() && y2.isEven()) {
        x2.iushrn(1);
        y2.iushrn(1);
        ++g2;
      }
      var yp = y2.clone();
      var xp = x2.clone();
      while (!x2.isZero()) {
        for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          x2.iushrn(i2);
          while (i2-- > 0) {
            if (A2.isOdd() || B2.isOdd()) {
              A2.iadd(yp);
              B2.isub(xp);
            }
            A2.iushrn(1);
            B2.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          y2.iushrn(j2);
          while (j2-- > 0) {
            if (C2.isOdd() || D2.isOdd()) {
              C2.iadd(yp);
              D2.isub(xp);
            }
            C2.iushrn(1);
            D2.iushrn(1);
          }
        }
        if (x2.cmp(y2) >= 0) {
          x2.isub(y2);
          A2.isub(C2);
          B2.isub(D2);
        } else {
          y2.isub(x2);
          C2.isub(A2);
          D2.isub(B2);
        }
      }
      return {
        a: C2,
        b: D2,
        gcd: y2.iushln(g2)
      };
    };
    BN2.prototype._invmp = function _invmp(p2) {
      assert2(p2.negative === 0);
      assert2(!p2.isZero());
      var a2 = this;
      var b2 = p2.clone();
      if (a2.negative !== 0) {
        a2 = a2.umod(p2);
      } else {
        a2 = a2.clone();
      }
      var x1 = new BN2(1);
      var x2 = new BN2(0);
      var delta = b2.clone();
      while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
        for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
          ;
        if (i2 > 0) {
          a2.iushrn(i2);
          while (i2-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
          ;
        if (j2 > 0) {
          b2.iushrn(j2);
          while (j2-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a2.cmp(b2) >= 0) {
          a2.isub(b2);
          x1.isub(x2);
        } else {
          b2.isub(a2);
          x2.isub(x1);
        }
      }
      var res;
      if (a2.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p2);
      }
      return res;
    };
    BN2.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a2 = this.clone();
      var b2 = num.clone();
      a2.negative = 0;
      b2.negative = 0;
      for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
        a2.iushrn(1);
        b2.iushrn(1);
      }
      do {
        while (a2.isEven()) {
          a2.iushrn(1);
        }
        while (b2.isEven()) {
          b2.iushrn(1);
        }
        var r2 = a2.cmp(b2);
        if (r2 < 0) {
          var t2 = a2;
          a2 = b2;
          b2 = t2;
        } else if (r2 === 0 || b2.cmpn(1) === 0) {
          break;
        }
        a2.isub(b2);
      } while (true);
      return b2.iushln(shift);
    };
    BN2.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN2.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN2.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN2.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN2.prototype.bincn = function bincn(bit) {
      assert2(typeof bit === "number");
      var r2 = bit % 26;
      var s2 = (bit - r2) / 26;
      var q2 = 1 << r2;
      if (this.length <= s2) {
        this._expand(s2 + 1);
        this.words[s2] |= q2;
        return this;
      }
      var carry = q2;
      for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
        var w2 = this.words[i2] | 0;
        w2 += carry;
        carry = w2 >>> 26;
        w2 &= 67108863;
        this.words[i2] = w2;
      }
      if (carry !== 0) {
        this.words[i2] = carry;
        this.length++;
      }
      return this;
    };
    BN2.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN2.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert2(num <= 67108863, "Number is too big");
        var w2 = this.words[0] | 0;
        res = w2 === num ? 0 : w2 < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN2.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i2 = this.length - 1; i2 >= 0; i2--) {
        var a2 = this.words[i2] | 0;
        var b2 = num.words[i2] | 0;
        if (a2 === b2)
          continue;
        if (a2 < b2) {
          res = -1;
        } else if (a2 > b2) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN2.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN2.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN2.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN2.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN2.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN2.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN2.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN2.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN2.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN2.prototype.eq = function eq9(num) {
      return this.cmp(num) === 0;
    };
    BN2.red = function red(num) {
      return new Red(num);
    };
    BN2.prototype.toRed = function toRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      assert2(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN2.prototype.fromRed = function fromRed() {
      assert2(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN2.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN2.prototype.forceRed = function forceRed(ctx) {
      assert2(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN2.prototype.redAdd = function redAdd(num) {
      assert2(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN2.prototype.redIAdd = function redIAdd(num) {
      assert2(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN2.prototype.redSub = function redSub(num) {
      assert2(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN2.prototype.redISub = function redISub(num) {
      assert2(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN2.prototype.redShl = function redShl(num) {
      assert2(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN2.prototype.redMul = function redMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN2.prototype.redIMul = function redIMul(num) {
      assert2(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN2.prototype.redSqr = function redSqr() {
      assert2(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN2.prototype.redISqr = function redISqr() {
      assert2(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN2.prototype.redSqrt = function redSqrt() {
      assert2(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN2.prototype.redInvm = function redInvm() {
      assert2(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN2.prototype.redNeg = function redNeg() {
      assert2(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN2.prototype.redPow = function redPow(num) {
      assert2(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name2, p2) {
      this.name = name2;
      this.p = new BN2(p2, 16);
      this.n = this.p.bitLength();
      this.k = new BN2(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN2(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r2 = num;
      var rlen;
      do {
        this.split(r2, this.tmp);
        r2 = this.imulK(r2);
        r2 = r2.iadd(this.tmp);
        rlen = r2.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
      if (cmp === 0) {
        r2.words[0] = 0;
        r2.length = 1;
      } else if (cmp > 0) {
        r2.isub(this.p);
      } else {
        r2.strip();
      }
      return r2;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits2(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i2 = 0; i2 < outLen; i2++) {
        output.words[i2] = input.words[i2];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i2 = 10; i2 < input.length; i2++) {
        var next3 = input.words[i2] | 0;
        input.words[i2 - 10] = (next3 & mask) << 4 | prev >>> 22;
        prev = next3;
      }
      prev >>>= 22;
      input.words[i2 - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var w2 = num.words[i2] | 0;
        lo += w2 * 977;
        num.words[i2] = lo & 67108863;
        lo = w2 * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits2(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits2(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits2(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i2 = 0; i2 < num.length; i2++) {
        var hi = (num.words[i2] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i2] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN2._prime = function prime(name2) {
      if (primes[name2])
        return primes[name2];
      var prime2;
      if (name2 === "k256") {
        prime2 = new K256();
      } else if (name2 === "p224") {
        prime2 = new P224();
      } else if (name2 === "p192") {
        prime2 = new P192();
      } else if (name2 === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name2);
      }
      primes[name2] = prime2;
      return prime2;
    };
    function Red(m2) {
      if (typeof m2 === "string") {
        var prime = BN2._prime(m2);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert2(m2.gtn(1), "modulus must be greater than 1");
        this.m = m2;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a2) {
      assert2(a2.negative === 0, "red works only with positives");
      assert2(a2.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a2, b2) {
      assert2((a2.negative | b2.negative) === 0, "red works only with positives");
      assert2(a2.red && a2.red === b2.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a2) {
      if (this.prime)
        return this.prime.ireduce(a2)._forceRed(this);
      return a2.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg6(a2) {
      if (a2.isZero()) {
        return a2.clone();
      }
      return this.m.sub(a2)._forceRed(this);
    };
    Red.prototype.add = function add8(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.add(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.iadd(b2);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.sub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a2, b2) {
      this._verify2(a2, b2);
      var res = a2.isub(b2);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a2, num) {
      this._verify1(a2);
      return this.imod(a2.ushln(num));
    };
    Red.prototype.imul = function imul(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.imul(b2));
    };
    Red.prototype.mul = function mul8(a2, b2) {
      this._verify2(a2, b2);
      return this.imod(a2.mul(b2));
    };
    Red.prototype.isqr = function isqr(a2) {
      return this.imul(a2, a2.clone());
    };
    Red.prototype.sqr = function sqr(a2) {
      return this.mul(a2, a2);
    };
    Red.prototype.sqrt = function sqrt(a2) {
      if (a2.isZero())
        return a2.clone();
      var mod3 = this.m.andln(3);
      assert2(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN2(1)).iushrn(2);
        return this.pow(a2, pow);
      }
      var q2 = this.m.subn(1);
      var s2 = 0;
      while (!q2.isZero() && q2.andln(1) === 0) {
        s2++;
        q2.iushrn(1);
      }
      assert2(!q2.isZero());
      var one = new BN2(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z2 = this.m.bitLength();
      z2 = new BN2(2 * z2 * z2).toRed(this);
      while (this.pow(z2, lpow).cmp(nOne) !== 0) {
        z2.redIAdd(nOne);
      }
      var c2 = this.pow(z2, q2);
      var r2 = this.pow(a2, q2.addn(1).iushrn(1));
      var t2 = this.pow(a2, q2);
      var m2 = s2;
      while (t2.cmp(one) !== 0) {
        var tmp = t2;
        for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
          tmp = tmp.redSqr();
        }
        assert2(i2 < m2);
        var b2 = this.pow(c2, new BN2(1).iushln(m2 - i2 - 1));
        r2 = r2.redMul(b2);
        c2 = b2.redSqr();
        t2 = t2.redMul(c2);
        m2 = i2;
      }
      return r2;
    };
    Red.prototype.invm = function invm(a2) {
      var inv = a2._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a2, num) {
      if (num.isZero())
        return new BN2(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a2.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN2(1).toRed(this);
      wnd[1] = a2;
      for (var i2 = 2; i2 < wnd.length; i2++) {
        wnd[i2] = this.mul(wnd[i2 - 1], a2);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i2 = num.length - 1; i2 >= 0; i2--) {
        var word2 = num.words[i2];
        for (var j2 = start - 1; j2 >= 0; j2--) {
          var bit = word2 >> j2 & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r2 = num.umod(this.m);
      return r2 === num ? r2.clone() : r2;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN2.mont = function mont2(num) {
      return new Mont(num);
    };
    function Mont(m2) {
      Red.call(this, m2);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN2(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits2(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r2 = this.imod(num.mul(this.rinv));
      r2.red = null;
      return r2;
    };
    Mont.prototype.imul = function imul(a2, b2) {
      if (a2.isZero() || b2.isZero()) {
        a2.words[0] = 0;
        a2.length = 1;
        return a2;
      }
      var t2 = a2.imul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul8(a2, b2) {
      if (a2.isZero() || b2.isZero())
        return new BN2(0)._forceRed(this);
      var t2 = a2.mul(b2);
      var c2 = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u2 = t2.isub(c2).iushrn(this.shift);
      var res = u2;
      if (u2.cmp(this.m) >= 0) {
        res = u2.isub(this.m);
      } else if (u2.cmpn(0) < 0) {
        res = u2.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a2) {
      var res = this.imod(a2._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module2, commonjsGlobal);
})(bn);
var BN$2 = bn.exports;
var cjs$2 = {};
var isTypedarray = isTypedArray$2;
isTypedArray$2.strict = isStrictTypedArray;
isTypedArray$2.loose = isLooseTypedArray;
var toString$1 = Object.prototype.toString;
var names = {
  "[object Int8Array]": true,
  "[object Int16Array]": true,
  "[object Int32Array]": true,
  "[object Uint8Array]": true,
  "[object Uint8ClampedArray]": true,
  "[object Uint16Array]": true,
  "[object Uint32Array]": true,
  "[object Float32Array]": true,
  "[object Float64Array]": true
};
function isTypedArray$2(arr2) {
  return isStrictTypedArray(arr2) || isLooseTypedArray(arr2);
}
function isStrictTypedArray(arr2) {
  return arr2 instanceof Int8Array || arr2 instanceof Int16Array || arr2 instanceof Int32Array || arr2 instanceof Uint8Array || arr2 instanceof Uint8ClampedArray || arr2 instanceof Uint16Array || arr2 instanceof Uint32Array || arr2 instanceof Float32Array || arr2 instanceof Float64Array;
}
function isLooseTypedArray(arr2) {
  return names[toString$1.call(arr2)];
}
var isTypedArray$1 = isTypedarray.strict;
var typedarrayToBuffer = function typedarrayToBuffer2(arr2) {
  if (isTypedArray$1(arr2)) {
    var buf = buffer$2.Buffer.from(arr2.buffer);
    if (arr2.byteLength !== arr2.buffer.byteLength) {
      buf = buf.slice(arr2.byteOffset, arr2.byteOffset + arr2.byteLength);
    }
    return buf;
  } else {
    return buffer$2.Buffer.from(arr2);
  }
};
var __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(cjs$2, "__esModule", { value: true });
var removeHexLeadingZeros_1 = cjs$2.removeHexLeadingZeros = sanitizeHex_1 = cjs$2.sanitizeHex = addHexPrefix_1 = cjs$2.addHexPrefix = removeHexPrefix_1 = cjs$2.removeHexPrefix = cjs$2.padRight = cjs$2.padLeft = cjs$2.sanitizeBytes = cjs$2.swapHex = cjs$2.swapBytes = cjs$2.splitBytes = cjs$2.calcByteLength = cjs$2.trimRight = cjs$2.trimLeft = concatArrays_1 = cjs$2.concatArrays = cjs$2.concatBuffers = cjs$2.getEncoding = cjs$2.getType = cjs$2.isArrayBuffer = cjs$2.isTypedArray = cjs$2.isBuffer = isHexString_1 = cjs$2.isHexString = cjs$2.isBinaryString = cjs$2.binaryToNumber = cjs$2.binaryToUtf8 = cjs$2.binaryToHex = cjs$2.binaryToArray = cjs$2.binaryToBuffer = cjs$2.numberToBinary = cjs$2.numberToUtf8 = cjs$2.numberToHex = cjs$2.numberToArray = cjs$2.numberToBuffer = cjs$2.utf8ToBinary = cjs$2.utf8ToNumber = utf8ToHex_1 = cjs$2.utf8ToHex = utf8ToArray_1 = cjs$2.utf8ToArray = utf8ToBuffer_1 = cjs$2.utf8ToBuffer = cjs$2.hexToBinary = cjs$2.hexToNumber = cjs$2.hexToUtf8 = hexToArray_1 = cjs$2.hexToArray = cjs$2.hexToBuffer = cjs$2.arrayToBinary = cjs$2.arrayToNumber = arrayToUtf8_1 = cjs$2.arrayToUtf8 = arrayToHex_1 = cjs$2.arrayToHex = arrayToBuffer_1 = cjs$2.arrayToBuffer = cjs$2.bufferToBinary = cjs$2.bufferToNumber = cjs$2.bufferToUtf8 = cjs$2.bufferToHex = bufferToArray_1 = cjs$2.bufferToArray = void 0;
const is_typedarray_1 = __importDefault$9(isTypedarray);
const typedarray_to_buffer_1 = __importDefault$9(typedarrayToBuffer);
const ENC_HEX = "hex";
const ENC_UTF8 = "utf8";
const ENC_BIN = "binary";
const TYPE_BUFFER = "buffer";
const TYPE_ARRAY = "array";
const TYPE_TYPED_ARRAY = "typed-array";
const TYPE_ARRAY_BUFFER = "array-buffer";
const STRING_ZERO = "0";
function bufferToArray(buf) {
  return new Uint8Array(buf);
}
var bufferToArray_1 = cjs$2.bufferToArray = bufferToArray;
function bufferToHex$1(buf, prefixed = false) {
  const hex = buf.toString(ENC_HEX);
  return prefixed ? addHexPrefix(hex) : hex;
}
cjs$2.bufferToHex = bufferToHex$1;
function bufferToUtf8(buf) {
  return buf.toString(ENC_UTF8);
}
cjs$2.bufferToUtf8 = bufferToUtf8;
function bufferToNumber(buf) {
  return buf.readUIntBE(0, buf.length);
}
cjs$2.bufferToNumber = bufferToNumber;
function bufferToBinary(buf) {
  return arrayToBinary(bufferToArray(buf));
}
cjs$2.bufferToBinary = bufferToBinary;
function arrayToBuffer(arr2) {
  return typedarray_to_buffer_1.default(arr2);
}
var arrayToBuffer_1 = cjs$2.arrayToBuffer = arrayToBuffer;
function arrayToHex(arr2, prefixed = false) {
  return bufferToHex$1(arrayToBuffer(arr2), prefixed);
}
var arrayToHex_1 = cjs$2.arrayToHex = arrayToHex;
function arrayToUtf8(arr2) {
  return bufferToUtf8(arrayToBuffer(arr2));
}
var arrayToUtf8_1 = cjs$2.arrayToUtf8 = arrayToUtf8;
function arrayToNumber(arr2) {
  return bufferToNumber(arrayToBuffer(arr2));
}
cjs$2.arrayToNumber = arrayToNumber;
function arrayToBinary(arr2) {
  return Array.from(arr2).map(numberToBinary).join("");
}
cjs$2.arrayToBinary = arrayToBinary;
function hexToBuffer(hex) {
  return buffer$2.Buffer.from(removeHexPrefix(hex), ENC_HEX);
}
cjs$2.hexToBuffer = hexToBuffer;
function hexToArray(hex) {
  return bufferToArray(hexToBuffer(hex));
}
var hexToArray_1 = cjs$2.hexToArray = hexToArray;
function hexToUtf8(hex) {
  return bufferToUtf8(hexToBuffer(hex));
}
cjs$2.hexToUtf8 = hexToUtf8;
function hexToNumber(hex) {
  return arrayToNumber(hexToArray(hex));
}
cjs$2.hexToNumber = hexToNumber;
function hexToBinary(hex) {
  return arrayToBinary(hexToArray(hex));
}
cjs$2.hexToBinary = hexToBinary;
function utf8ToBuffer(utf8) {
  return buffer$2.Buffer.from(utf8, ENC_UTF8);
}
var utf8ToBuffer_1 = cjs$2.utf8ToBuffer = utf8ToBuffer;
function utf8ToArray(utf8) {
  return bufferToArray(utf8ToBuffer(utf8));
}
var utf8ToArray_1 = cjs$2.utf8ToArray = utf8ToArray;
function utf8ToHex(utf8, prefixed = false) {
  return bufferToHex$1(utf8ToBuffer(utf8), prefixed);
}
var utf8ToHex_1 = cjs$2.utf8ToHex = utf8ToHex;
function utf8ToNumber(utf8) {
  const num = parseInt(utf8, 10);
  assert(isDefined(num), "Number can only safely store up to 53 bits");
  return num;
}
cjs$2.utf8ToNumber = utf8ToNumber;
function utf8ToBinary(utf8) {
  return arrayToBinary(utf8ToArray(utf8));
}
cjs$2.utf8ToBinary = utf8ToBinary;
function numberToBuffer(num) {
  return binaryToBuffer(numberToBinary(num));
}
cjs$2.numberToBuffer = numberToBuffer;
function numberToArray(num) {
  return binaryToArray(numberToBinary(num));
}
cjs$2.numberToArray = numberToArray;
function numberToHex(num, prefixed) {
  return binaryToHex(numberToBinary(num), prefixed);
}
cjs$2.numberToHex = numberToHex;
function numberToUtf8(num) {
  return `${num}`;
}
cjs$2.numberToUtf8 = numberToUtf8;
function numberToBinary(num) {
  const bin = (num >>> 0).toString(2);
  return sanitizeBytes(bin);
}
cjs$2.numberToBinary = numberToBinary;
function binaryToBuffer(bin) {
  return arrayToBuffer(binaryToArray(bin));
}
cjs$2.binaryToBuffer = binaryToBuffer;
function binaryToArray(bin) {
  return new Uint8Array(splitBytes(bin).map((x2) => parseInt(x2, 2)));
}
cjs$2.binaryToArray = binaryToArray;
function binaryToHex(bin, prefixed) {
  return arrayToHex(binaryToArray(bin), prefixed);
}
cjs$2.binaryToHex = binaryToHex;
function binaryToUtf8(bin) {
  return arrayToUtf8(binaryToArray(bin));
}
cjs$2.binaryToUtf8 = binaryToUtf8;
function binaryToNumber(bin) {
  return arrayToNumber(binaryToArray(bin));
}
cjs$2.binaryToNumber = binaryToNumber;
function isBinaryString(str2) {
  if (typeof str2 !== "string" || !new RegExp(/^[01]+$/).test(str2)) {
    return false;
  }
  if (str2.length % 8 !== 0) {
    return false;
  }
  return true;
}
cjs$2.isBinaryString = isBinaryString;
function isHexString$3(str2, length) {
  if (typeof str2 !== "string" || !str2.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && str2.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
var isHexString_1 = cjs$2.isHexString = isHexString$3;
function isBuffer(val) {
  return buffer$2.Buffer.isBuffer(val);
}
cjs$2.isBuffer = isBuffer;
function isTypedArray(val) {
  return is_typedarray_1.default.strict(val) && !isBuffer(val);
}
cjs$2.isTypedArray = isTypedArray;
function isArrayBuffer(val) {
  return !isTypedArray(val) && !isBuffer(val) && typeof val.byteLength !== "undefined";
}
cjs$2.isArrayBuffer = isArrayBuffer;
function getType(val) {
  if (isBuffer(val)) {
    return TYPE_BUFFER;
  } else if (isTypedArray(val)) {
    return TYPE_TYPED_ARRAY;
  } else if (isArrayBuffer(val)) {
    return TYPE_ARRAY_BUFFER;
  } else if (Array.isArray(val)) {
    return TYPE_ARRAY;
  } else {
    return typeof val;
  }
}
cjs$2.getType = getType;
function getEncoding(str2) {
  if (isBinaryString(str2)) {
    return ENC_BIN;
  }
  if (isHexString$3(str2)) {
    return ENC_HEX;
  }
  return ENC_UTF8;
}
cjs$2.getEncoding = getEncoding;
function concatBuffers(...args) {
  const result = buffer$2.Buffer.concat(args);
  return result;
}
cjs$2.concatBuffers = concatBuffers;
function concatArrays(...args) {
  let result = [];
  args.forEach((arg) => result = result.concat(Array.from(arg)));
  return new Uint8Array([...result]);
}
var concatArrays_1 = cjs$2.concatArrays = concatArrays;
function trimLeft(data, length) {
  const diff = data.length - length;
  if (diff > 0) {
    data = data.slice(diff);
  }
  return data;
}
cjs$2.trimLeft = trimLeft;
function trimRight(data, length) {
  return data.slice(0, length);
}
cjs$2.trimRight = trimRight;
function calcByteLength(length, byteSize = 8) {
  const remainder = length % byteSize;
  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
}
cjs$2.calcByteLength = calcByteLength;
function splitBytes(str2, byteSize = 8) {
  const bytes3 = sanitizeBytes(str2).match(new RegExp(`.{${byteSize}}`, "gi"));
  return Array.from(bytes3 || []);
}
cjs$2.splitBytes = splitBytes;
function swapBytes(str2) {
  return splitBytes(str2).map(reverseString).join("");
}
cjs$2.swapBytes = swapBytes;
function swapHex(str2) {
  return binaryToHex(swapBytes(hexToBinary(str2)));
}
cjs$2.swapHex = swapHex;
function sanitizeBytes(str2, byteSize = 8, padding2 = STRING_ZERO) {
  return padLeft(str2, calcByteLength(str2.length, byteSize), padding2);
}
cjs$2.sanitizeBytes = sanitizeBytes;
function padLeft(str2, length, padding2 = STRING_ZERO) {
  return padString(str2, length, true, padding2);
}
cjs$2.padLeft = padLeft;
function padRight(str2, length, padding2 = STRING_ZERO) {
  return padString(str2, length, false, padding2);
}
cjs$2.padRight = padRight;
function removeHexPrefix(hex) {
  return hex.replace(/^0x/, "");
}
var removeHexPrefix_1 = cjs$2.removeHexPrefix = removeHexPrefix;
function addHexPrefix(hex) {
  return hex.startsWith("0x") ? hex : `0x${hex}`;
}
var addHexPrefix_1 = cjs$2.addHexPrefix = addHexPrefix;
function sanitizeHex$1(hex) {
  hex = removeHexPrefix(hex);
  hex = sanitizeBytes(hex, 2);
  if (hex) {
    hex = addHexPrefix(hex);
  }
  return hex;
}
var sanitizeHex_1 = cjs$2.sanitizeHex = sanitizeHex$1;
function removeHexLeadingZeros$1(hex) {
  const prefixed = hex.startsWith("0x");
  hex = removeHexPrefix(hex);
  hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
  return prefixed ? addHexPrefix(hex) : hex;
}
removeHexLeadingZeros_1 = cjs$2.removeHexLeadingZeros = removeHexLeadingZeros$1;
function isUndefined(value2) {
  return typeof value2 === "undefined";
}
function isDefined(value2) {
  return !isUndefined(value2);
}
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}
function reverseString(str2) {
  return str2.split("").reverse().join("");
}
function padString(str2, length, left, padding2 = STRING_ZERO) {
  const diff = length - str2.length;
  let result = str2;
  if (diff > 0) {
    const pad2 = padding2.repeat(diff);
    result = left ? pad2 + str2 : str2 + pad2;
  }
  return result;
}
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer_1(new Uint8Array(arrBuf));
}
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex_1(new Uint8Array(arrBuf), !noPrefix);
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray_1(buf).buffer;
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer_1(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex_1(utf8, !noPrefix);
}
function convertHexToArrayBuffer(hex) {
  return hexToArray_1(hex).buffer;
}
function convertNumberToHex(num, noPrefix) {
  const hex = removeHexPrefix_1(sanitizeHex_1(new BN$2(num).toString(16)));
  return noPrefix ? hex : addHexPrefix_1(hex);
}
var cjs$1 = {};
var crypto$1 = {};
Object.defineProperty(crypto$1, "__esModule", { value: true });
crypto$1.isBrowserCryptoAvailable = crypto$1.getSubtleCrypto = crypto$1.getBrowerCrypto = void 0;
function getBrowerCrypto() {
  return (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.msCrypto) || {};
}
crypto$1.getBrowerCrypto = getBrowerCrypto;
function getSubtleCrypto() {
  const browserCrypto = getBrowerCrypto();
  return browserCrypto.subtle || browserCrypto.webkitSubtle;
}
crypto$1.getSubtleCrypto = getSubtleCrypto;
function isBrowserCryptoAvailable() {
  return !!getBrowerCrypto() && !!getSubtleCrypto();
}
crypto$1.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
var env = {};
Object.defineProperty(env, "__esModule", { value: true });
env.isBrowser = env.isNode = env.isReactNative = void 0;
function isReactNative() {
  return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
}
env.isReactNative = isReactNative;
function isNode$1() {
  return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
}
env.isNode = isNode$1;
function isBrowser() {
  return !isReactNative() && !isNode$1();
}
env.isBrowser = isBrowser;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !exports3.hasOwnProperty(p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(crypto$1, exports2);
  __exportStar(env, exports2);
})(cjs$1);
function payloadId$1() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}
function sanitizeHex(hex) {
  return sanitizeHex_1(hex);
}
function removeHexLeadingZeros(hex) {
  return removeHexLeadingZeros_1(addHexPrefix_1(hex));
}
const payloadId = payloadId$1;
function uuid() {
  const result = ((a2, b2) => {
    for (b2 = a2 = ""; a2++ < 36; b2 += a2 * 51 & 52 ? (a2 ^ 15 ? 8 ^ Math.random() * (a2 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b2;
  })();
  return result;
}
function getInfuraRpcUrl(chainId, infuraId) {
  let rpcUrl;
  const network = infuraNetworks[chainId];
  if (network) {
    rpcUrl = `https://${network}.infura.io/v3/${infuraId}`;
  }
  return rpcUrl;
}
function getRpcUrl(chainId, rpc) {
  let rpcUrl;
  const infuraUrl = getInfuraRpcUrl(chainId, rpc.infuraId);
  if (rpc.custom && rpc.custom[chainId]) {
    rpcUrl = rpc.custom[chainId];
  } else if (infuraUrl) {
    rpcUrl = infuraUrl;
  }
  return rpcUrl;
}
function isEmptyString(value2) {
  return value2 === "" || typeof value2 === "string" && value2.trim() === "";
}
function isEmptyArray(array2) {
  return !(array2 && array2.length);
}
function isHexString$2(value2, length) {
  return isHexString_1(value2, length);
}
function isJsonRpcRequest(object2) {
  return typeof object2.method !== "undefined";
}
function isJsonRpcResponseSuccess(object2) {
  return typeof object2.result !== "undefined";
}
function isJsonRpcResponseError(object2) {
  return typeof object2.error !== "undefined";
}
function isInternalEvent(object2) {
  return typeof object2.event !== "undefined";
}
function isReservedEvent(event) {
  return reservedEvents.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request) {
  if (request.method.startsWith("wc_")) {
    return true;
  }
  if (signingMethods.includes(request.method)) {
    return false;
  }
  return true;
}
function toChecksumAddress(address) {
  address = removeHexPrefix_1(address.toLowerCase());
  const hash3 = removeHexPrefix_1(sha3$1.exports.keccak_256(convertUtf8ToBuffer(address)));
  let checksum = "";
  for (let i2 = 0; i2 < address.length; i2++) {
    if (parseInt(hash3[i2], 16) > 7) {
      checksum += address[i2].toUpperCase();
    } else {
      checksum += address[i2];
    }
  }
  return addHexPrefix_1(checksum);
}
const isValidAddress = (address) => {
  if (!address) {
    return false;
  } else if (address.toLowerCase().substring(0, 2) !== "0x") {
    return false;
  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  } else {
    return address === toChecksumAddress(address);
  }
};
function parsePersonalSign(params) {
  if (!isEmptyArray(params) && !isHexString$2(params[0])) {
    params[0] = convertUtf8ToHex(params[0]);
  }
  return params;
}
function parseTransactionData(txData) {
  if (typeof txData.type !== "undefined" && txData.type !== "0")
    return txData;
  if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
    throw new Error(`Transaction object must include a valid 'from' value.`);
  }
  function parseHexValues(value2) {
    let result = value2;
    if (typeof value2 === "number" || typeof value2 === "string" && !isEmptyString(value2)) {
      if (!isHexString$2(value2)) {
        result = convertNumberToHex(value2);
      } else if (typeof value2 === "string") {
        result = sanitizeHex(value2);
      }
    }
    if (typeof result === "string") {
      result = removeHexLeadingZeros(result);
    }
    return result;
  }
  const txDataRPC = {
    from: sanitizeHex(txData.from),
    to: typeof txData.to === "undefined" ? "" : sanitizeHex(txData.to),
    gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
    gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
    value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
    nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
    data: typeof txData.data === "undefined" ? "" : sanitizeHex(txData.data) || "0x"
  };
  const prunable = ["gasPrice", "gas", "value", "nonce"];
  Object.keys(txDataRPC).forEach((key2) => {
    if (!txDataRPC[key2].trim().length && prunable.includes(key2)) {
      delete txDataRPC[key2];
    }
  });
  return txDataRPC;
}
function formatRpcError(error2) {
  const message = error2.message || "Failed or Rejected Request";
  let code2 = -32e3;
  if (error2 && !error2.code) {
    switch (message) {
      case "Parse error":
        code2 = -32700;
        break;
      case "Invalid request":
        code2 = -32600;
        break;
      case "Method not found":
        code2 = -32601;
        break;
      case "Invalid params":
        code2 = -32602;
        break;
      case "Internal error":
        code2 = -32603;
        break;
      default:
        code2 = -32e3;
        break;
    }
  }
  const result = {
    code: code2,
    message
  };
  return result;
}
var queryString = {};
var strictUriEncode = (str2) => encodeURIComponent(str2).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`);
var token = "%[a-f0-9]{2}";
var singleMatcher = new RegExp(token, "gi");
var multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components, split) {
  try {
    return decodeURIComponent(components.join(""));
  } catch (err) {
  }
  if (components.length === 1) {
    return components;
  }
  split = split || 1;
  var left = components.slice(0, split);
  var right = components.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode$2(input) {
  try {
    return decodeURIComponent(input);
  } catch (err) {
    var tokens = input.match(singleMatcher);
    for (var i2 = 1; i2 < tokens.length; i2++) {
      input = decodeComponents(tokens, i2).join("");
      tokens = input.match(singleMatcher);
    }
    return input;
  }
}
function customDecodeURIComponent(input) {
  var replaceMap = {
    "%FE%FF": "\uFFFD\uFFFD",
    "%FF%FE": "\uFFFD\uFFFD"
  };
  var match = multiMatcher.exec(input);
  while (match) {
    try {
      replaceMap[match[0]] = decodeURIComponent(match[0]);
    } catch (err) {
      var result = decode$2(match[0]);
      if (result !== match[0]) {
        replaceMap[match[0]] = result;
      }
    }
    match = multiMatcher.exec(input);
  }
  replaceMap["%C2"] = "\uFFFD";
  var entries = Object.keys(replaceMap);
  for (var i2 = 0; i2 < entries.length; i2++) {
    var key2 = entries[i2];
    input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
  }
  return input;
}
var decodeUriComponent = function(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    encodedURI = encodedURI.replace(/\+/g, " ");
    return decodeURIComponent(encodedURI);
  } catch (err) {
    return customDecodeURIComponent(encodedURI);
  }
};
var splitOnFirst = (string2, separator) => {
  if (!(typeof string2 === "string" && typeof separator === "string")) {
    throw new TypeError("Expected the arguments to be of type `string`");
  }
  if (separator === "") {
    return [string2];
  }
  const separatorIndex = string2.indexOf(separator);
  if (separatorIndex === -1) {
    return [string2];
  }
  return [
    string2.slice(0, separatorIndex),
    string2.slice(separatorIndex + separator.length)
  ];
};
(function(exports2) {
  const strictUriEncode$1 = strictUriEncode;
  const decodeComponent = decodeUriComponent;
  const splitOnFirst$1 = splitOnFirst;
  const isNullOrUndefined = (value2) => value2 === null || value2 === void 0;
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case "index":
        return (key2) => (result, value2) => {
          const index2 = result.length;
          if (value2 === void 0 || options.skipNull && value2 === null || options.skipEmptyString && value2 === "") {
            return result;
          }
          if (value2 === null) {
            return [...result, [encode5(key2, options), "[", index2, "]"].join("")];
          }
          return [
            ...result,
            [encode5(key2, options), "[", encode5(index2, options), "]=", encode5(value2, options)].join("")
          ];
        };
      case "bracket":
        return (key2) => (result, value2) => {
          if (value2 === void 0 || options.skipNull && value2 === null || options.skipEmptyString && value2 === "") {
            return result;
          }
          if (value2 === null) {
            return [...result, [encode5(key2, options), "[]"].join("")];
          }
          return [...result, [encode5(key2, options), "[]=", encode5(value2, options)].join("")];
        };
      case "comma":
      case "separator":
        return (key2) => (result, value2) => {
          if (value2 === null || value2 === void 0 || value2.length === 0) {
            return result;
          }
          if (result.length === 0) {
            return [[encode5(key2, options), "=", encode5(value2, options)].join("")];
          }
          return [[result, encode5(value2, options)].join(options.arrayFormatSeparator)];
        };
      default:
        return (key2) => (result, value2) => {
          if (value2 === void 0 || options.skipNull && value2 === null || options.skipEmptyString && value2 === "") {
            return result;
          }
          if (value2 === null) {
            return [...result, encode5(key2, options)];
          }
          return [...result, [encode5(key2, options), "=", encode5(value2, options)].join("")];
        };
    }
  }
  function parserForArrayFormat(options) {
    let result;
    switch (options.arrayFormat) {
      case "index":
        return (key2, value2, accumulator) => {
          result = /\[(\d*)\]$/.exec(key2);
          key2 = key2.replace(/\[\d*\]$/, "");
          if (!result) {
            accumulator[key2] = value2;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = {};
          }
          accumulator[key2][result[1]] = value2;
        };
      case "bracket":
        return (key2, value2, accumulator) => {
          result = /(\[\])$/.exec(key2);
          key2 = key2.replace(/\[\]$/, "");
          if (!result) {
            accumulator[key2] = value2;
            return;
          }
          if (accumulator[key2] === void 0) {
            accumulator[key2] = [value2];
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value2);
        };
      case "comma":
      case "separator":
        return (key2, value2, accumulator) => {
          const isArray2 = typeof value2 === "string" && value2.split("").indexOf(options.arrayFormatSeparator) > -1;
          const newValue = isArray2 ? value2.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value2 === null ? value2 : decode2(value2, options);
          accumulator[key2] = newValue;
        };
      default:
        return (key2, value2, accumulator) => {
          if (accumulator[key2] === void 0) {
            accumulator[key2] = value2;
            return;
          }
          accumulator[key2] = [].concat(accumulator[key2], value2);
        };
    }
  }
  function validateArrayFormatSeparator(value2) {
    if (typeof value2 !== "string" || value2.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode5(value2, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode$1(value2) : encodeURIComponent(value2);
    }
    return value2;
  }
  function decode2(value2, options) {
    if (options.decode) {
      return decodeComponent(value2);
    }
    return value2;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === "object") {
      return keysSorter(Object.keys(input)).sort((a2, b2) => Number(a2) - Number(b2)).map((key2) => input[key2]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash(url2) {
    let hash3 = "";
    const hashStart = url2.indexOf("#");
    if (hashStart !== -1) {
      hash3 = url2.slice(hashStart);
    }
    return hash3;
  }
  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input.slice(queryStart + 1);
  }
  function parseValue2(value2, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value2)) && (typeof value2 === "string" && value2.trim() !== "")) {
      value2 = Number(value2);
    } else if (options.parseBooleans && value2 !== null && (value2.toLowerCase() === "true" || value2.toLowerCase() === "false")) {
      value2 = value2.toLowerCase() === "true";
    }
    return value2;
  }
  function parse2(input, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options);
    const ret = Object.create(null);
    if (typeof input !== "string") {
      return ret;
    }
    input = input.trim().replace(/^[?#&]/, "");
    if (!input) {
      return ret;
    }
    for (const param of input.split("&")) {
      let [key2, value2] = splitOnFirst$1(options.decode ? param.replace(/\+/g, " ") : param, "=");
      value2 = value2 === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value2 : decode2(value2, options);
      formatter(decode2(key2, options), value2, ret);
    }
    for (const key2 of Object.keys(ret)) {
      const value2 = ret[key2];
      if (typeof value2 === "object" && value2 !== null) {
        for (const k2 of Object.keys(value2)) {
          value2[k2] = parseValue2(value2[k2], options);
        }
      } else {
        ret[key2] = parseValue2(value2, options);
      }
    }
    if (options.sort === false) {
      return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key2) => {
      const value2 = ret[key2];
      if (Boolean(value2) && typeof value2 === "object" && !Array.isArray(value2)) {
        result[key2] = keysSorter(value2);
      } else {
        result[key2] = value2;
      }
      return result;
    }, Object.create(null));
  }
  exports2.extract = extract;
  exports2.parse = parse2;
  exports2.stringify = (object2, options) => {
    if (!object2) {
      return "";
    }
    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = (key2) => options.skipNull && isNullOrUndefined(object2[key2]) || options.skipEmptyString && object2[key2] === "";
    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const key2 of Object.keys(object2)) {
      if (!shouldFilter(key2)) {
        objectCopy[key2] = object2[key2];
      }
    }
    const keys2 = Object.keys(objectCopy);
    if (options.sort !== false) {
      keys2.sort(options.sort);
    }
    return keys2.map((key2) => {
      const value2 = object2[key2];
      if (value2 === void 0) {
        return "";
      }
      if (value2 === null) {
        return encode5(key2, options);
      }
      if (Array.isArray(value2)) {
        return value2.reduce(formatter(key2), []).join("&");
      }
      return encode5(key2, options) + "=" + encode5(value2, options);
    }).filter((x2) => x2.length > 0).join("&");
  };
  exports2.parseUrl = (input, options) => {
    options = Object.assign({
      decode: true
    }, options);
    const [url2, hash3] = splitOnFirst$1(input, "#");
    return Object.assign({
      url: url2.split("?")[0] || "",
      query: parse2(extract(input), options)
    }, options && options.parseFragmentIdentifier && hash3 ? { fragmentIdentifier: decode2(hash3, options) } : {});
  };
  exports2.stringifyUrl = (input, options) => {
    options = Object.assign({
      encode: true,
      strict: true
    }, options);
    const url2 = removeHash(input.url).split("?")[0] || "";
    const queryFromUrl = exports2.extract(input.url);
    const parsedQueryFromUrl = exports2.parse(queryFromUrl, { sort: false });
    const query2 = Object.assign(parsedQueryFromUrl, input.query);
    let queryString2 = exports2.stringify(query2, options);
    if (queryString2) {
      queryString2 = `?${queryString2}`;
    }
    let hash3 = getHash(input.url);
    if (input.fragmentIdentifier) {
      hash3 = `#${encode5(input.fragmentIdentifier, options)}`;
    }
    return `${url2}${queryString2}${hash3}`;
  };
})(queryString);
function getQueryString(url2) {
  const pathEnd = url2.indexOf("?") !== -1 ? url2.indexOf("?") : void 0;
  const queryString2 = typeof pathEnd !== "undefined" ? url2.substr(pathEnd) : "";
  return queryString2;
}
function appendToQueryString(queryString2, newQueryParams) {
  let queryParams = parseQueryString(queryString2);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString2 = formatQueryString(queryParams);
  return queryString2;
}
function parseQueryString(queryString$1) {
  return queryString.parse(queryString$1);
}
function formatQueryString(queryParams) {
  return queryString.stringify(queryParams);
}
function isWalletConnectSession(object2) {
  return typeof object2.bridge !== "undefined";
}
function parseWalletConnectUri(str2) {
  const pathStart = str2.indexOf(":");
  const pathEnd = str2.indexOf("?") !== -1 ? str2.indexOf("?") : void 0;
  const protocol = str2.substring(0, pathStart);
  const path = str2.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path2) {
    const separator = "@";
    const values = path2.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path);
  const queryString2 = typeof pathEnd !== "undefined" ? str2.substr(pathEnd) : "";
  function parseQueryParams(queryString3) {
    const result2 = parseQueryString(queryString3);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString2);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}
var browser$2 = function() {
  throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
};
class NetworkMonitor {
  constructor() {
    this._eventEmitters = [];
    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
      window.addEventListener("online", () => this.trigger("online"));
      window.addEventListener("offline", () => this.trigger("offline"));
    }
  }
  on(event, callback) {
    this._eventEmitters.push({
      event,
      callback
    });
  }
  trigger(event) {
    let eventEmitters = [];
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    eventEmitters.forEach((eventEmitter) => {
      eventEmitter.callback();
    });
  }
}
const WS = typeof global.WebSocket !== "undefined" ? global.WebSocket : browser$2;
class SocketTransport {
  constructor(opts) {
    this.opts = opts;
    this._queue = [];
    this._events = [];
    this._subscriptions = [];
    this._protocol = opts.protocol;
    this._version = opts.version;
    this._url = "";
    this._netMonitor = null;
    this._socket = null;
    this._nextSocket = null;
    this._subscriptions = opts.subscriptions || [];
    this._netMonitor = opts.netMonitor || new NetworkMonitor();
    if (!opts.url || typeof opts.url !== "string") {
      throw new Error("Missing or invalid WebSocket url");
    }
    this._url = opts.url;
    this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(value2) {
  }
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(value2) {
  }
  get connecting() {
    return this.readyState === 0;
  }
  set connected(value2) {
  }
  get connected() {
    return this.readyState === 1;
  }
  set closing(value2) {
  }
  get closing() {
    return this.readyState === 2;
  }
  set closed(value2) {
  }
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(message, topic, silent) {
    if (!topic || typeof topic !== "string") {
      throw new Error("Missing or invalid topic field");
    }
    this._socketSend({
      topic,
      type: "pub",
      payload: message,
      silent: !!silent
    });
  }
  subscribe(topic) {
    this._socketSend({
      topic,
      type: "sub",
      payload: "",
      silent: true
    });
  }
  on(event, callback) {
    this._events.push({ event, callback });
  }
  _socketCreate() {
    if (this._nextSocket) {
      return;
    }
    const url2 = getWebSocketUrl(this._url, this._protocol, this._version);
    this._nextSocket = new WS(url2);
    if (!this._nextSocket) {
      throw new Error("Failed to create socket");
    }
    this._nextSocket.onmessage = (event) => this._socketReceive(event);
    this._nextSocket.onopen = () => this._socketOpen();
    this._nextSocket.onerror = (event) => this._socketError(event);
    this._nextSocket.onclose = () => {
      setTimeout(() => {
        this._nextSocket = null;
        this._socketCreate();
      }, 1e3);
    };
  }
  _socketOpen() {
    this._socketClose();
    this._socket = this._nextSocket;
    this._nextSocket = null;
    this._queueSubscriptions();
    this._pushQueue();
  }
  _socketClose() {
    if (this._socket) {
      this._socket.onclose = () => {
      };
      this._socket.close();
    }
  }
  _socketSend(socketMessage) {
    const message = JSON.stringify(socketMessage);
    if (this._socket && this._socket.readyState === 1) {
      this._socket.send(message);
    } else {
      this._setToQueue(socketMessage);
      this._socketCreate();
    }
  }
  async _socketReceive(event) {
    let socketMessage;
    try {
      socketMessage = JSON.parse(event.data);
    } catch (error2) {
      return;
    }
    this._socketSend({
      topic: socketMessage.topic,
      type: "ack",
      payload: "",
      silent: true
    });
    if (this._socket && this._socket.readyState === 1) {
      const events2 = this._events.filter((event2) => event2.event === "message");
      if (events2 && events2.length) {
        events2.forEach((event2) => event2.callback(socketMessage));
      }
    }
  }
  _socketError(e2) {
    const events2 = this._events.filter((event) => event.event === "error");
    if (events2 && events2.length) {
      events2.forEach((event) => event.callback(e2));
    }
  }
  _queueSubscriptions() {
    const subscriptions2 = this._subscriptions;
    subscriptions2.forEach((topic) => this._queue.push({
      topic,
      type: "sub",
      payload: "",
      silent: true
    }));
    this._subscriptions = this.opts.subscriptions || [];
  }
  _setToQueue(socketMessage) {
    this._queue.push(socketMessage);
  }
  _pushQueue() {
    const queue2 = this._queue;
    queue2.forEach((socketMessage) => this._socketSend(socketMessage));
    this._queue = [];
  }
}
function getWebSocketUrl(_url, protocol, version2) {
  var _a2, _b2;
  const url2 = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url2.split("?");
  const params = isBrowser$1() ? {
    protocol,
    version: version2,
    env: "browser",
    host: ((_a2 = getLocation()) === null || _a2 === void 0 ? void 0 : _a2.host) || ""
  } : {
    protocol,
    version: version2,
    env: ((_b2 = detectEnv()) === null || _b2 === void 0 ? void 0 : _b2.name) || ""
  };
  const queryString2 = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString2;
}
const ERROR_SESSION_CONNECTED = "Session currently connected";
const ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
const ERROR_SESSION_REJECTED = "Session Rejected";
const ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
const ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
const ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
const ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
const ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
const ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
const ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
const ERROR_INVALID_URI = "URI format is invalid";
const ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
const ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";
class EventManager {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(eventEmitter) {
    this._eventEmitters.push(eventEmitter);
  }
  unsubscribe(event) {
    this._eventEmitters = this._eventEmitters.filter((x2) => x2.event !== event);
  }
  trigger(payload) {
    let eventEmitters = [];
    let event;
    if (isJsonRpcRequest(payload)) {
      event = payload.method;
    } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
      event = `response:${payload.id}`;
    } else if (isInternalEvent(payload)) {
      event = payload.event;
    } else {
      event = "";
    }
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
    }
    eventEmitters.forEach((eventEmitter) => {
      if (isJsonRpcResponseError(payload)) {
        const error2 = new Error(payload.error.message);
        eventEmitter.callback(error2, null);
      } else {
        eventEmitter.callback(null, payload);
      }
    });
  }
}
class SessionStorage {
  constructor(storageId = "walletconnect") {
    this.storageId = storageId;
  }
  getSession() {
    let session = null;
    const json2 = getLocal(this.storageId);
    if (json2 && isWalletConnectSession(json2)) {
      session = json2;
    }
    return session;
  }
  setSession(session) {
    setLocal(this.storageId, session);
    return session;
  }
  removeSession() {
    removeLocal(this.storageId);
  }
}
const domain = "walletconnect.org";
const alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
const bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
function extractHostname(url2) {
  let hostname = url2.indexOf("//") > -1 ? url2.split("/")[2] : url2.split("/")[0];
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
}
function extractRootDomain(url2) {
  return extractHostname(url2).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url2) {
  return extractRootDomain(url2) === domain;
}
function getBridgeUrl(url2) {
  if (shouldSelectRandomly(url2)) {
    return selectRandomBridgeUrl();
  }
  return url2;
}
class Connector {
  constructor(opts) {
    this.protocol = "wc";
    this.version = 1;
    this._bridge = "";
    this._key = null;
    this._clientId = "";
    this._clientMeta = null;
    this._peerId = "";
    this._peerMeta = null;
    this._handshakeId = 0;
    this._handshakeTopic = "";
    this._connected = false;
    this._accounts = [];
    this._chainId = 0;
    this._networkId = 0;
    this._rpcUrl = "";
    this._eventManager = new EventManager();
    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
    this._cryptoLib = opts.cryptoLib;
    this._sessionStorage = opts.sessionStorage || new SessionStorage(opts.connectorOpts.storageId);
    this._qrcodeModal = opts.connectorOpts.qrcodeModal;
    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
    this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
      throw new Error(ERROR_MISSING_REQUIRED);
    }
    if (opts.connectorOpts.bridge) {
      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
    }
    if (opts.connectorOpts.uri) {
      this.uri = opts.connectorOpts.uri;
    }
    const session = opts.connectorOpts.session || this._getStorageSession();
    if (session) {
      this.session = session;
    }
    if (this.handshakeId) {
      this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
    }
    this._transport = opts.transport || new SocketTransport({
      protocol: this.protocol,
      version: this.version,
      url: this.bridge,
      subscriptions: [this.clientId]
    });
    this._subscribeToInternalEvents();
    this._initTransport();
    if (opts.connectorOpts.uri) {
      this._subscribeToSessionRequest();
    }
    if (opts.pushServerOpts) {
      this._registerPushServer(opts.pushServerOpts);
    }
  }
  set bridge(value2) {
    if (!value2) {
      return;
    }
    this._bridge = value2;
  }
  get bridge() {
    return this._bridge;
  }
  set key(value2) {
    if (!value2) {
      return;
    }
    const key2 = convertHexToArrayBuffer(value2);
    this._key = key2;
  }
  get key() {
    if (this._key) {
      const key2 = convertArrayBufferToHex(this._key, true);
      return key2;
    }
    return "";
  }
  set clientId(value2) {
    if (!value2) {
      return;
    }
    this._clientId = value2;
  }
  get clientId() {
    let clientId = this._clientId;
    if (!clientId) {
      clientId = this._clientId = uuid();
    }
    return this._clientId;
  }
  set peerId(value2) {
    if (!value2) {
      return;
    }
    this._peerId = value2;
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(value2) {
  }
  get clientMeta() {
    let clientMeta = this._clientMeta;
    if (!clientMeta) {
      clientMeta = this._clientMeta = getClientMeta();
    }
    return clientMeta;
  }
  set peerMeta(value2) {
    this._peerMeta = value2;
  }
  get peerMeta() {
    const peerMeta = this._peerMeta;
    return peerMeta;
  }
  set handshakeTopic(value2) {
    if (!value2) {
      return;
    }
    this._handshakeTopic = value2;
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(value2) {
    if (!value2) {
      return;
    }
    this._handshakeId = value2;
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    const _uri = this._formatUri();
    return _uri;
  }
  set uri(value2) {
    if (!value2) {
      return;
    }
    const { handshakeTopic, bridge, key: key2 } = this._parseUri(value2);
    this.handshakeTopic = handshakeTopic;
    this.bridge = bridge;
    this.key = key2;
  }
  set chainId(value2) {
    this._chainId = value2;
  }
  get chainId() {
    const chainId = this._chainId;
    return chainId;
  }
  set networkId(value2) {
    this._networkId = value2;
  }
  get networkId() {
    const networkId = this._networkId;
    return networkId;
  }
  set accounts(value2) {
    this._accounts = value2;
  }
  get accounts() {
    const accounts = this._accounts;
    return accounts;
  }
  set rpcUrl(value2) {
    this._rpcUrl = value2;
  }
  get rpcUrl() {
    const rpcUrl = this._rpcUrl;
    return rpcUrl;
  }
  set connected(value2) {
  }
  get connected() {
    return this._connected;
  }
  set pending(value2) {
  }
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return {
      connected: this.connected,
      accounts: this.accounts,
      chainId: this.chainId,
      bridge: this.bridge,
      key: this.key,
      clientId: this.clientId,
      clientMeta: this.clientMeta,
      peerId: this.peerId,
      peerMeta: this.peerMeta,
      handshakeId: this.handshakeId,
      handshakeTopic: this.handshakeTopic
    };
  }
  set session(value2) {
    if (!value2) {
      return;
    }
    this._connected = value2.connected;
    this.accounts = value2.accounts;
    this.chainId = value2.chainId;
    this.bridge = value2.bridge;
    this.key = value2.key;
    this.clientId = value2.clientId;
    this.clientMeta = value2.clientMeta;
    this.peerId = value2.peerId;
    this.peerMeta = value2.peerMeta;
    this.handshakeId = value2.handshakeId;
    this.handshakeTopic = value2.handshakeTopic;
  }
  on(event, callback) {
    const eventEmitter = {
      event,
      callback
    };
    this._eventManager.subscribe(eventEmitter);
  }
  off(event) {
    this._eventManager.unsubscribe(event);
  }
  async createInstantRequest(instantRequest) {
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_instantRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          request: this._formatRequest(instantRequest)
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
    this.on("modal_closed", () => {
      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
    });
    const endInstantRequest = () => {
      this.killSession();
    };
    try {
      const result = await this._sendCallRequest(request);
      if (result) {
        endInstantRequest();
      }
      return result;
    } catch (error2) {
      endInstantRequest();
      throw error2;
    }
  }
  async connect(opts) {
    if (!this._qrcodeModal) {
      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
    }
    if (this.connected) {
      return {
        chainId: this.chainId,
        accounts: this.accounts
      };
    }
    await this.createSession(opts);
    return new Promise(async (resolve2, reject) => {
      this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
      this.on("connect", (error2, payload) => {
        if (error2) {
          return reject(error2);
        }
        resolve2(payload.params[0]);
      });
    });
  }
  async createSession(opts) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    if (this.pending) {
      return;
    }
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_sessionRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          chainId: opts && opts.chainId ? opts.chainId : null
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._sendSessionRequest(request, "Session update rejected", {
      topic: this.handshakeTopic
    });
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
  }
  approveSession(sessionStatus) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl,
      peerId: this.clientId,
      peerMeta: this.clientMeta
    };
    const response = {
      id: this.handshakeId,
      jsonrpc: "2.0",
      result: sessionParams
    };
    this._sendResponse(response);
    this._connected = true;
    this._setStorageSession();
    this._eventManager.trigger({
      event: "connect",
      params: [
        {
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
  }
  rejectSession(sessionError) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
    const response = this._formatResponse({
      id: this.handshakeId,
      error: { message }
    });
    this._sendResponse(response);
    this._connected = false;
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
  }
  updateSession(sessionStatus) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    this._sendSessionRequest(request, "Session update rejected");
    this._eventManager.trigger({
      event: "session_update",
      params: [
        {
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
    this._manageStorageSession();
  }
  async killSession(sessionError) {
    const message = sessionError ? sessionError.message : "Session Disconnected";
    const sessionParams = {
      approved: false,
      chainId: null,
      networkId: null,
      accounts: null
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    await this._sendRequest(request);
    this._handleSessionDisconnect(message);
  }
  async sendTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_sendTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_signTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signPersonalMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    params = parsePersonalSign(params);
    const request = this._formatRequest({
      method: "personal_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTypedData(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_signTypedData",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async updateChain(chainParams) {
    if (!this._connected) {
      throw new Error("Session currently disconnected");
    }
    const request = this._formatRequest({
      method: "wallet_updateChain",
      params: [chainParams]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  unsafeSend(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return new Promise((resolve2, reject) => {
      this._subscribeToResponse(request.id, (error2, payload) => {
        if (error2) {
          reject(error2);
          return;
        }
        if (!payload) {
          throw new Error(ERROR_MISSING_JSON_RPC);
        }
        resolve2(payload);
      });
    });
  }
  async sendCustomRequest(request, options) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    switch (request.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return convertNumberToHex(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        if (request.params) {
          request.params[0] = parseTransactionData(request.params[0]);
        }
        break;
      case "personal_sign":
        if (request.params) {
          request.params = parsePersonalSign(request.params);
        }
        break;
    }
    const formattedRequest = this._formatRequest(request);
    const result = await this._sendCallRequest(formattedRequest, options);
    return result;
  }
  approveRequest(response) {
    if (isJsonRpcResponseSuccess(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_RESULT);
    }
  }
  rejectRequest(response) {
    if (isJsonRpcResponseError(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_ERROR);
    }
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(request, options) {
    const callRequest = this._formatRequest(request);
    const encryptionPayload = await this._encrypt(callRequest);
    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
    this._transport.send(payload, topic, silent);
  }
  async _sendResponse(response) {
    const encryptionPayload = await this._encrypt(response);
    const topic = this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = true;
    this._transport.send(payload, topic, silent);
  }
  async _sendSessionRequest(request, errorMsg, options) {
    this._sendRequest(request, options);
    this._subscribeToSessionResponse(request.id, errorMsg);
  }
  _sendCallRequest(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return this._subscribeToCallResponse(request.id);
  }
  _formatRequest(request) {
    if (typeof request.method === "undefined") {
      throw new Error(ERROR_MISSING_METHOD);
    }
    const formattedRequest = {
      id: typeof request.id === "undefined" ? payloadId() : request.id,
      jsonrpc: "2.0",
      method: request.method,
      params: typeof request.params === "undefined" ? [] : request.params
    };
    return formattedRequest;
  }
  _formatResponse(response) {
    if (typeof response.id === "undefined") {
      throw new Error(ERROR_MISSING_ID);
    }
    const baseResponse = { id: response.id, jsonrpc: "2.0" };
    if (isJsonRpcResponseError(response)) {
      const error2 = formatRpcError(response.error);
      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error: error2 });
      return errorResponse;
    } else if (isJsonRpcResponseSuccess(response)) {
      const successResponse = Object.assign(Object.assign({}, baseResponse), response);
      return successResponse;
    }
    throw new Error(ERROR_INVALID_RESPONSE);
  }
  _handleSessionDisconnect(errorMsg) {
    const message = errorMsg || "Session Disconnected";
    if (!this._connected) {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
      removeLocal(mobileLinkChoiceKey);
    }
    if (this._connected) {
      this._connected = false;
    }
    if (this._handshakeId) {
      this._handshakeId = 0;
    }
    if (this._handshakeTopic) {
      this._handshakeTopic = "";
    }
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
    this.transportClose();
  }
  _handleSessionResponse(errorMsg, sessionParams) {
    if (sessionParams) {
      if (sessionParams.approved) {
        if (!this._connected) {
          this._connected = true;
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          if (sessionParams.peerId && !this.peerId) {
            this.peerId = sessionParams.peerId;
          }
          if (sessionParams.peerMeta && !this.peerMeta) {
            this.peerMeta = sessionParams.peerMeta;
          }
          this._eventManager.trigger({
            event: "connect",
            params: [
              {
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        } else {
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          this._eventManager.trigger({
            event: "session_update",
            params: [
              {
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        }
        this._manageStorageSession();
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    } else {
      this._handleSessionDisconnect(errorMsg);
    }
  }
  async _handleIncomingMessages(socketMessage) {
    const activeTopics = [this.clientId, this.handshakeTopic];
    if (!activeTopics.includes(socketMessage.topic)) {
      return;
    }
    let encryptionPayload;
    try {
      encryptionPayload = JSON.parse(socketMessage.payload);
    } catch (error2) {
      return;
    }
    const payload = await this._decrypt(encryptionPayload);
    if (payload) {
      this._eventManager.trigger(payload);
    }
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(id2, callback) {
    this.on(`response:${id2}`, callback);
  }
  _subscribeToSessionResponse(id2, errorMsg) {
    this._subscribeToResponse(id2, (error2, payload) => {
      if (error2) {
        this._handleSessionResponse(error2.message);
        return;
      }
      if (payload.result) {
        this._handleSessionResponse(errorMsg, payload.result);
      } else if (payload.error && payload.error.message) {
        this._handleSessionResponse(payload.error.message);
      } else {
        this._handleSessionResponse(errorMsg);
      }
    });
  }
  _subscribeToCallResponse(id2) {
    return new Promise((resolve2, reject) => {
      this._subscribeToResponse(id2, (error2, payload) => {
        if (error2) {
          reject(error2);
          return;
        }
        if (payload.result) {
          resolve2(payload.result);
        } else if (payload.error && payload.error.message) {
          reject(new Error(payload.error.message));
        } else {
          reject(new Error(ERROR_INVALID_RESPONSE));
        }
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.open(this.uri, () => {
          this._eventManager.trigger({
            event: "modal_closed",
            params: []
          });
        }, this._qrcodeModalOptions);
      }
    });
    this.on("connect", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
    });
    this.on("call_request_sent", (error2, payload) => {
      const { request } = payload.params[0];
      if (isMobile() && this._signingMethods.includes(request.method)) {
        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
        if (mobileLinkUrl) {
          window.location.href = mobileLinkUrl.href;
        }
      }
    });
    this.on("wc_sessionRequest", (error2, payload) => {
      if (error2) {
        this._eventManager.trigger({
          event: "error",
          params: [
            {
              code: "SESSION_REQUEST_ERROR",
              message: error2.toString()
            }
          ]
        });
      }
      this.handshakeId = payload.id;
      this.peerId = payload.params[0].peerId;
      this.peerMeta = payload.params[0].peerMeta;
      const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
      this._eventManager.trigger(internalPayload);
    });
    this.on("wc_sessionUpdate", (error2, payload) => {
      if (error2) {
        this._handleSessionResponse(error2.message);
      }
      this._handleSessionResponse("Session disconnected", payload.params[0]);
    });
  }
  _initTransport() {
    this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
    this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
    this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
    this._transport.on("error", () => this._eventManager.trigger({
      event: "transport_error",
      params: ["Websocket connection failed"]
    }));
    this._transport.open();
  }
  _formatUri() {
    const protocol = this.protocol;
    const handshakeTopic = this.handshakeTopic;
    const version2 = this.version;
    const bridge = encodeURIComponent(this.bridge);
    const key2 = this.key;
    const uri = `${protocol}:${handshakeTopic}@${version2}?bridge=${bridge}&key=${key2}`;
    return uri;
  }
  _parseUri(uri) {
    const result = parseWalletConnectUri(uri);
    if (result.protocol === this.protocol) {
      if (!result.handshakeTopic) {
        throw Error("Invalid or missing handshakeTopic parameter value");
      }
      const handshakeTopic = result.handshakeTopic;
      if (!result.bridge) {
        throw Error("Invalid or missing bridge url parameter value");
      }
      const bridge = decodeURIComponent(result.bridge);
      if (!result.key) {
        throw Error("Invalid or missing key parameter value");
      }
      const key2 = result.key;
      return { handshakeTopic, bridge, key: key2 };
    } else {
      throw new Error(ERROR_INVALID_URI);
    }
  }
  async _generateKey() {
    if (this._cryptoLib) {
      const result = await this._cryptoLib.generateKey();
      return result;
    }
    return null;
  }
  async _encrypt(data) {
    const key2 = this._key;
    if (this._cryptoLib && key2) {
      const result = await this._cryptoLib.encrypt(data, key2);
      return result;
    }
    return null;
  }
  async _decrypt(payload) {
    const key2 = this._key;
    if (this._cryptoLib && key2) {
      const result = await this._cryptoLib.decrypt(payload, key2);
      return result;
    }
    return null;
  }
  _getStorageSession() {
    let result = null;
    if (this._sessionStorage) {
      result = this._sessionStorage.getSession();
    }
    return result;
  }
  _setStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.setSession(this.session);
    }
  }
  _removeStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.removeSession();
    }
  }
  _manageStorageSession() {
    if (this._connected) {
      this._setStorageSession();
    } else {
      this._removeStorageSession();
    }
  }
  _registerPushServer(pushServerOpts) {
    if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    }
    if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    }
    if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    }
    const pushSubscription = {
      bridge: this.bridge,
      topic: this.clientId,
      type: pushServerOpts.type,
      token: pushServerOpts.token,
      peerName: "",
      language: pushServerOpts.language || ""
    };
    this.on("connect", async (error2, payload) => {
      if (error2) {
        throw error2;
      }
      if (pushServerOpts.peerMeta) {
        const peerName = payload.params[0].peerMeta.name;
        pushSubscription.peerName = peerName;
      }
      try {
        const response = await fetch(`${pushServerOpts.url}/new`, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(pushSubscription)
        });
        const json2 = await response.json();
        if (!json2.success) {
          throw Error("Failed to register in Push Server");
        }
      } catch (error3) {
        throw Error("Failed to register in Push Server");
      }
    });
  }
}
function randomBytes(length) {
  const browserCrypto = cjs$1.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length));
}
const LENGTH_256 = 256;
const AES_LENGTH = LENGTH_256;
const HMAC_LENGTH = LENGTH_256;
const AES_BROWSER_ALGO = "AES-CBC";
const HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
const HMAC_BROWSER = "HMAC";
const ENCRYPT_OP = "encrypt";
const DECRYPT_OP = "decrypt";
const SIGN_OP = "sign";
const VERIFY_OP = "verify";
function getAlgo(type) {
  return type === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
    hash: { name: HMAC_BROWSER_ALGO },
    name: HMAC_BROWSER
  };
}
function getOps(type) {
  return type === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserImportKey(buffer2, type = AES_BROWSER_ALGO) {
  return cjs$1.getSubtleCrypto().importKey("raw", buffer2, getAlgo(type), true, getOps(type));
}
async function browserAesEncrypt(iv, key2, data) {
  const subtle = cjs$1.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key2, data) {
  const subtle = cjs$1.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key2, data) {
  const subtle = cjs$1.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key2, HMAC_BROWSER);
  const signature2 = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature2);
}
function aesCbcEncrypt(iv, key2, data) {
  return browserAesEncrypt(iv, key2, data);
}
function aesCbcDecrypt(iv, key2, data) {
  return browserAesDecrypt(iv, key2, data);
}
async function hmacSha256Sign(key2, msg) {
  const result = await browserHmacSha256Sign(key2, msg);
  return result;
}
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes3 = randomBytes(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer_1(bytes3));
  return result;
}
async function verifyHmac(payload, key2) {
  const cipherText = hexToArray_1(payload.data);
  const iv = hexToArray_1(payload.iv);
  const hmac4 = hexToArray_1(payload.hmac);
  const hmacHex = arrayToHex_1(hmac4, false);
  const unsigned = concatArrays_1(cipherText, iv);
  const chmac = await hmacSha256Sign(key2, unsigned);
  const chmacHex = arrayToHex_1(chmac, false);
  if (removeHexPrefix_1(hmacHex) === removeHexPrefix_1(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt$1(data, key2, providedIv) {
  const _key = bufferToArray_1(convertArrayBufferToBuffer(key2));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray_1(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex_1(iv, false);
  const contentString = JSON.stringify(data);
  const content = utf8ToArray_1(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content);
  const cipherTextHex = arrayToHex_1(cipherText, false);
  const unsigned = concatArrays_1(cipherText, iv);
  const hmac4 = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex_1(hmac4, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt$1(payload, key2) {
  const _key = bufferToArray_1(convertArrayBufferToBuffer(key2));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray_1(payload.data);
  const iv = hexToArray_1(payload.iv);
  const buffer2 = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8_1(buffer2);
  let data;
  try {
    data = JSON.parse(utf8);
  } catch (error2) {
    return null;
  }
  return data;
}
var cryptoLib = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  generateKey,
  verifyHmac,
  encrypt: encrypt$1,
  decrypt: decrypt$1
});
class WalletConnect extends Connector {
  constructor(connectorOpts, pushServerOpts) {
    super({
      cryptoLib,
      connectorOpts,
      pushServerOpts
    });
  }
}
var require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(esm);
var browser$1 = {};
var canPromise$1 = function() {
  return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
};
var qrcode = {};
var typedarrayBuffer = {};
var toString = {}.toString;
var isarray = Array.isArray || function(arr2) {
  return toString.call(arr2) == "[object Array]";
};
var isArray$3 = isarray;
function typedArraySupport() {
  try {
    var arr2 = new Uint8Array(1);
    arr2.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
      return 42;
    } };
    return arr2.foo() === 42;
  } catch (e2) {
    return false;
  }
}
Buffer$1.TYPED_ARRAY_SUPPORT = typedArraySupport();
var K_MAX_LENGTH = Buffer$1.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
function Buffer$1(arg, offset, length) {
  if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
    return new Buffer$1(arg, offset, length);
  }
  if (typeof arg === "number") {
    return allocUnsafe(this, arg);
  }
  return from$1(this, arg, offset, length);
}
if (Buffer$1.TYPED_ARRAY_SUPPORT) {
  Buffer$1.prototype.__proto__ = Uint8Array.prototype;
  Buffer$1.__proto__ = Uint8Array;
  if (typeof Symbol !== "undefined" && Symbol.species && Buffer$1[Symbol.species] === Buffer$1) {
    Object.defineProperty(Buffer$1, Symbol.species, {
      value: null,
      configurable: true,
      enumerable: false,
      writable: false
    });
  }
}
function checked(length) {
  if (length >= K_MAX_LENGTH) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
  }
  return length | 0;
}
function isnan(val) {
  return val !== val;
}
function createBuffer(that, length) {
  var buf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    buf = new Uint8Array(length);
    buf.__proto__ = Buffer$1.prototype;
  } else {
    buf = that;
    if (buf === null) {
      buf = new Buffer$1(length);
    }
    buf.length = length;
  }
  return buf;
}
function allocUnsafe(that, size2) {
  var buf = createBuffer(that, size2 < 0 ? 0 : checked(size2) | 0);
  if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (var i2 = 0; i2 < size2; ++i2) {
      buf[i2] = 0;
    }
  }
  return buf;
}
function fromString(that, string2) {
  var length = byteLength(string2) | 0;
  var buf = createBuffer(that, length);
  var actual = buf.write(string2);
  if (actual !== length) {
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike(that, array2) {
  var length = array2.length < 0 ? 0 : checked(array2.length) | 0;
  var buf = createBuffer(that, length);
  for (var i2 = 0; i2 < length; i2 += 1) {
    buf[i2] = array2[i2] & 255;
  }
  return buf;
}
function fromArrayBuffer(that, array2, byteOffset, length) {
  if (byteOffset < 0 || array2.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array2.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  var buf;
  if (byteOffset === void 0 && length === void 0) {
    buf = new Uint8Array(array2);
  } else if (length === void 0) {
    buf = new Uint8Array(array2, byteOffset);
  } else {
    buf = new Uint8Array(array2, byteOffset, length);
  }
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    buf.__proto__ = Buffer$1.prototype;
  } else {
    buf = fromArrayLike(that, buf);
  }
  return buf;
}
function fromObject(that, obj) {
  if (Buffer$1.isBuffer(obj)) {
    var len2 = checked(obj.length) | 0;
    var buf = createBuffer(that, len2);
    if (buf.length === 0) {
      return buf;
    }
    obj.copy(buf, 0, 0, len2);
    return buf;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function utf8ToBytes(string2, units) {
  units = units || Infinity;
  var codePoint;
  var length = string2.length;
  var leadSurrogate = null;
  var bytes3 = [];
  for (var i2 = 0; i2 < length; ++i2) {
    codePoint = string2.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes3.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes3.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes3.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes3.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes3.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes3.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes3;
}
function byteLength(string2) {
  if (Buffer$1.isBuffer(string2)) {
    return string2.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string2) || string2 instanceof ArrayBuffer)) {
    return string2.byteLength;
  }
  if (typeof string2 !== "string") {
    string2 = "" + string2;
  }
  var len2 = string2.length;
  if (len2 === 0)
    return 0;
  return utf8ToBytes(string2).length;
}
function blitBuffer(src2, dst, offset, length) {
  for (var i2 = 0; i2 < length; ++i2) {
    if (i2 + offset >= dst.length || i2 >= src2.length)
      break;
    dst[i2 + offset] = src2[i2];
  }
  return i2;
}
function utf8Write(buf, string2, offset, length) {
  return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
}
function from$1(that, value2, offset, length) {
  if (typeof value2 === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value2 instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value2, offset, length);
  }
  if (typeof value2 === "string") {
    return fromString(that, value2);
  }
  return fromObject(that, value2);
}
Buffer$1.prototype.write = function write(string2, offset, length) {
  if (offset === void 0) {
    length = this.length;
    offset = 0;
  } else if (length === void 0 && typeof offset === "string") {
    length = this.length;
    offset = 0;
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
    } else {
      length = void 0;
    }
  }
  var remaining = this.length - offset;
  if (length === void 0 || length > remaining)
    length = remaining;
  if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError("Attempt to write outside buffer bounds");
  }
  return utf8Write(this, string2, offset, length);
};
Buffer$1.prototype.slice = function slice2(start, end) {
  var len2 = this.length;
  start = ~~start;
  end = end === void 0 ? len2 : ~~end;
  if (start < 0) {
    start += len2;
    if (start < 0)
      start = 0;
  } else if (start > len2) {
    start = len2;
  }
  if (end < 0) {
    end += len2;
    if (end < 0)
      end = 0;
  } else if (end > len2) {
    end = len2;
  }
  if (end < start)
    end = start;
  var newBuf;
  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer$1.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer$1(sliceLen, void 0);
    for (var i2 = 0; i2 < sliceLen; ++i2) {
      newBuf[i2] = this[i2 + start];
    }
  }
  return newBuf;
};
Buffer$1.prototype.copy = function copy2(target, targetStart, start, end) {
  if (!start)
    start = 0;
  if (!end && end !== 0)
    end = this.length;
  if (targetStart >= target.length)
    targetStart = target.length;
  if (!targetStart)
    targetStart = 0;
  if (end > 0 && end < start)
    end = start;
  if (end === start)
    return 0;
  if (target.length === 0 || this.length === 0)
    return 0;
  if (targetStart < 0) {
    throw new RangeError("targetStart out of bounds");
  }
  if (start < 0 || start >= this.length)
    throw new RangeError("sourceStart out of bounds");
  if (end < 0)
    throw new RangeError("sourceEnd out of bounds");
  if (end > this.length)
    end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len2 = end - start;
  var i2;
  if (this === target && start < targetStart && targetStart < end) {
    for (i2 = len2 - 1; i2 >= 0; --i2) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else if (len2 < 1e3 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
    for (i2 = 0; i2 < len2; ++i2) {
      target[i2 + targetStart] = this[i2 + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len2), targetStart);
  }
  return len2;
};
Buffer$1.prototype.fill = function fill(val, start, end) {
  if (typeof val === "string") {
    if (typeof start === "string") {
      start = 0;
      end = this.length;
    } else if (typeof end === "string") {
      end = this.length;
    }
    if (val.length === 1) {
      var code2 = val.charCodeAt(0);
      if (code2 < 256) {
        val = code2;
      }
    }
  } else if (typeof val === "number") {
    val = val & 255;
  }
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError("Out of range index");
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === void 0 ? this.length : end >>> 0;
  if (!val)
    val = 0;
  var i2;
  if (typeof val === "number") {
    for (i2 = start; i2 < end; ++i2) {
      this[i2] = val;
    }
  } else {
    var bytes3 = Buffer$1.isBuffer(val) ? val : new Buffer$1(val);
    var len2 = bytes3.length;
    for (i2 = 0; i2 < end - start; ++i2) {
      this[i2 + start] = bytes3[i2 % len2];
    }
  }
  return this;
};
Buffer$1.concat = function concat2(list, length) {
  if (!isArray$3(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return createBuffer(null, 0);
  }
  var i2;
  if (length === void 0) {
    length = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      length += list[i2].length;
    }
  }
  var buffer2 = allocUnsafe(null, length);
  var pos = 0;
  for (i2 = 0; i2 < list.length; ++i2) {
    var buf = list[i2];
    if (!Buffer$1.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer2, pos);
    pos += buf.length;
  }
  return buffer2;
};
Buffer$1.byteLength = byteLength;
Buffer$1.prototype._isBuffer = true;
Buffer$1.isBuffer = function isBuffer3(b2) {
  return !!(b2 != null && b2._isBuffer);
};
typedarrayBuffer.alloc = function(size2) {
  var buffer2 = new Buffer$1(size2);
  buffer2.fill(0);
  return buffer2;
};
typedarrayBuffer.from = function(data) {
  return new Buffer$1(data);
};
var utils$1 = {};
var toSJISFunction;
var CODEWORDS_COUNT = [
  0,
  26,
  44,
  70,
  100,
  134,
  172,
  196,
  242,
  292,
  346,
  404,
  466,
  532,
  581,
  655,
  733,
  815,
  901,
  991,
  1085,
  1156,
  1258,
  1364,
  1474,
  1588,
  1706,
  1828,
  1921,
  2051,
  2185,
  2323,
  2465,
  2611,
  2761,
  2876,
  3034,
  3196,
  3362,
  3532,
  3706
];
utils$1.getSymbolSize = function getSymbolSize2(version2) {
  if (!version2)
    throw new Error('"version" cannot be null or undefined');
  if (version2 < 1 || version2 > 40)
    throw new Error('"version" should be in range from 1 to 40');
  return version2 * 4 + 17;
};
utils$1.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
  return CODEWORDS_COUNT[version2];
};
utils$1.getBCHDigit = function(data) {
  var digit = 0;
  while (data !== 0) {
    digit++;
    data >>>= 1;
  }
  return digit;
};
utils$1.setToSJISFunction = function setToSJISFunction(f2) {
  if (typeof f2 !== "function") {
    throw new Error('"toSJISFunc" is not a valid function.');
  }
  toSJISFunction = f2;
};
utils$1.isKanjiModeEnabled = function() {
  return typeof toSJISFunction !== "undefined";
};
utils$1.toSJIS = function toSJIS(kanji2) {
  return toSJISFunction(kanji2);
};
var errorCorrectionLevel = {};
(function(exports2) {
  exports2.L = { bit: 1 };
  exports2.M = { bit: 0 };
  exports2.Q = { bit: 3 };
  exports2.H = { bit: 2 };
  function fromString2(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    var lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "l":
      case "low":
        return exports2.L;
      case "m":
      case "medium":
        return exports2.M;
      case "q":
      case "quartile":
        return exports2.Q;
      case "h":
      case "high":
        return exports2.H;
      default:
        throw new Error("Unknown EC Level: " + string2);
    }
  }
  exports2.isValid = function isValid2(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
  };
  exports2.from = function from2(value2, defaultValue) {
    if (exports2.isValid(value2)) {
      return value2;
    }
    try {
      return fromString2(value2);
    } catch (e2) {
      return defaultValue;
    }
  };
})(errorCorrectionLevel);
function BitBuffer$1() {
  this.buffer = [];
  this.length = 0;
}
BitBuffer$1.prototype = {
  get: function(index2) {
    var bufIndex = Math.floor(index2 / 8);
    return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
  },
  put: function(num, length) {
    for (var i2 = 0; i2 < length; i2++) {
      this.putBit((num >>> length - i2 - 1 & 1) === 1);
    }
  },
  getLengthInBits: function() {
    return this.length;
  },
  putBit: function(bit) {
    var bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8;
    }
    this.length++;
  }
};
var bitBuffer = BitBuffer$1;
var BufferUtil$4 = typedarrayBuffer;
function BitMatrix$1(size2) {
  if (!size2 || size2 < 1) {
    throw new Error("BitMatrix size must be defined and greater than 0");
  }
  this.size = size2;
  this.data = BufferUtil$4.alloc(size2 * size2);
  this.reservedBit = BufferUtil$4.alloc(size2 * size2);
}
BitMatrix$1.prototype.set = function(row, col, value2, reserved) {
  var index2 = row * this.size + col;
  this.data[index2] = value2;
  if (reserved)
    this.reservedBit[index2] = true;
};
BitMatrix$1.prototype.get = function(row, col) {
  return this.data[row * this.size + col];
};
BitMatrix$1.prototype.xor = function(row, col, value2) {
  this.data[row * this.size + col] ^= value2;
};
BitMatrix$1.prototype.isReserved = function(row, col) {
  return this.reservedBit[row * this.size + col];
};
var bitMatrix = BitMatrix$1;
var alignmentPattern = {};
(function(exports2) {
  var getSymbolSize3 = utils$1.getSymbolSize;
  exports2.getRowColCoords = function getRowColCoords(version2) {
    if (version2 === 1)
      return [];
    var posCount = Math.floor(version2 / 7) + 2;
    var size2 = getSymbolSize3(version2);
    var intervals = size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2;
    var positions = [size2 - 7];
    for (var i2 = 1; i2 < posCount - 1; i2++) {
      positions[i2] = positions[i2 - 1] - intervals;
    }
    positions.push(6);
    return positions.reverse();
  };
  exports2.getPositions = function getPositions2(version2) {
    var coords = [];
    var pos = exports2.getRowColCoords(version2);
    var posLength = pos.length;
    for (var i2 = 0; i2 < posLength; i2++) {
      for (var j2 = 0; j2 < posLength; j2++) {
        if (i2 === 0 && j2 === 0 || i2 === 0 && j2 === posLength - 1 || i2 === posLength - 1 && j2 === 0) {
          continue;
        }
        coords.push([pos[i2], pos[j2]]);
      }
    }
    return coords;
  };
})(alignmentPattern);
var finderPattern = {};
var getSymbolSize = utils$1.getSymbolSize;
var FINDER_PATTERN_SIZE = 7;
finderPattern.getPositions = function getPositions(version2) {
  var size2 = getSymbolSize(version2);
  return [
    [0, 0],
    [size2 - FINDER_PATTERN_SIZE, 0],
    [0, size2 - FINDER_PATTERN_SIZE]
  ];
};
var maskPattern = {};
(function(exports2) {
  exports2.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  var PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  exports2.isValid = function isValid2(mask) {
    return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
  };
  exports2.from = function from2(value2) {
    return exports2.isValid(value2) ? parseInt(value2, 10) : void 0;
  };
  exports2.getPenaltyN1 = function getPenaltyN1(data) {
    var size2 = data.size;
    var points = 0;
    var sameCountCol = 0;
    var sameCountRow = 0;
    var lastCol = null;
    var lastRow = null;
    for (var row = 0; row < size2; row++) {
      sameCountCol = sameCountRow = 0;
      lastCol = lastRow = null;
      for (var col = 0; col < size2; col++) {
        var module2 = data.get(row, col);
        if (module2 === lastCol) {
          sameCountCol++;
        } else {
          if (sameCountCol >= 5)
            points += PenaltyScores.N1 + (sameCountCol - 5);
          lastCol = module2;
          sameCountCol = 1;
        }
        module2 = data.get(col, row);
        if (module2 === lastRow) {
          sameCountRow++;
        } else {
          if (sameCountRow >= 5)
            points += PenaltyScores.N1 + (sameCountRow - 5);
          lastRow = module2;
          sameCountRow = 1;
        }
      }
      if (sameCountCol >= 5)
        points += PenaltyScores.N1 + (sameCountCol - 5);
      if (sameCountRow >= 5)
        points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
  };
  exports2.getPenaltyN2 = function getPenaltyN2(data) {
    var size2 = data.size;
    var points = 0;
    for (var row = 0; row < size2 - 1; row++) {
      for (var col = 0; col < size2 - 1; col++) {
        var last2 = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
        if (last2 === 4 || last2 === 0)
          points++;
      }
    }
    return points * PenaltyScores.N2;
  };
  exports2.getPenaltyN3 = function getPenaltyN3(data) {
    var size2 = data.size;
    var points = 0;
    var bitsCol = 0;
    var bitsRow = 0;
    for (var row = 0; row < size2; row++) {
      bitsCol = bitsRow = 0;
      for (var col = 0; col < size2; col++) {
        bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
          points++;
        bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
          points++;
      }
    }
    return points * PenaltyScores.N3;
  };
  exports2.getPenaltyN4 = function getPenaltyN4(data) {
    var darkCount = 0;
    var modulesCount = data.data.length;
    for (var i2 = 0; i2 < modulesCount; i2++)
      darkCount += data.data[i2];
    var k2 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k2 * PenaltyScores.N4;
  };
  function getMaskAt(maskPattern2, i2, j2) {
    switch (maskPattern2) {
      case exports2.Patterns.PATTERN000:
        return (i2 + j2) % 2 === 0;
      case exports2.Patterns.PATTERN001:
        return i2 % 2 === 0;
      case exports2.Patterns.PATTERN010:
        return j2 % 3 === 0;
      case exports2.Patterns.PATTERN011:
        return (i2 + j2) % 3 === 0;
      case exports2.Patterns.PATTERN100:
        return (Math.floor(i2 / 2) + Math.floor(j2 / 3)) % 2 === 0;
      case exports2.Patterns.PATTERN101:
        return i2 * j2 % 2 + i2 * j2 % 3 === 0;
      case exports2.Patterns.PATTERN110:
        return (i2 * j2 % 2 + i2 * j2 % 3) % 2 === 0;
      case exports2.Patterns.PATTERN111:
        return (i2 * j2 % 3 + (i2 + j2) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern2);
    }
  }
  exports2.applyMask = function applyMask(pattern, data) {
    var size2 = data.size;
    for (var col = 0; col < size2; col++) {
      for (var row = 0; row < size2; row++) {
        if (data.isReserved(row, col))
          continue;
        data.xor(row, col, getMaskAt(pattern, row, col));
      }
    }
  };
  exports2.getBestMask = function getBestMask(data, setupFormatFunc) {
    var numPatterns = Object.keys(exports2.Patterns).length;
    var bestPattern = 0;
    var lowerPenalty = Infinity;
    for (var p2 = 0; p2 < numPatterns; p2++) {
      setupFormatFunc(p2);
      exports2.applyMask(p2, data);
      var penalty = exports2.getPenaltyN1(data) + exports2.getPenaltyN2(data) + exports2.getPenaltyN3(data) + exports2.getPenaltyN4(data);
      exports2.applyMask(p2, data);
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty;
        bestPattern = p2;
      }
    }
    return bestPattern;
  };
})(maskPattern);
var errorCorrectionCode = {};
var ECLevel$1 = errorCorrectionLevel;
var EC_BLOCKS_TABLE = [
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  1,
  2,
  2,
  4,
  1,
  2,
  4,
  4,
  2,
  4,
  4,
  4,
  2,
  4,
  6,
  5,
  2,
  4,
  6,
  6,
  2,
  5,
  8,
  8,
  4,
  5,
  8,
  8,
  4,
  5,
  8,
  11,
  4,
  8,
  10,
  11,
  4,
  9,
  12,
  16,
  4,
  9,
  16,
  16,
  6,
  10,
  12,
  18,
  6,
  10,
  17,
  16,
  6,
  11,
  16,
  19,
  6,
  13,
  18,
  21,
  7,
  14,
  21,
  25,
  8,
  16,
  20,
  25,
  8,
  17,
  23,
  25,
  9,
  17,
  23,
  34,
  9,
  18,
  25,
  30,
  10,
  20,
  27,
  32,
  12,
  21,
  29,
  35,
  12,
  23,
  34,
  37,
  12,
  25,
  34,
  40,
  13,
  26,
  35,
  42,
  14,
  28,
  38,
  45,
  15,
  29,
  40,
  48,
  16,
  31,
  43,
  51,
  17,
  33,
  45,
  54,
  18,
  35,
  48,
  57,
  19,
  37,
  51,
  60,
  19,
  38,
  53,
  63,
  20,
  40,
  56,
  66,
  21,
  43,
  59,
  70,
  22,
  45,
  62,
  74,
  24,
  47,
  65,
  77,
  25,
  49,
  68,
  81
];
var EC_CODEWORDS_TABLE = [
  7,
  10,
  13,
  17,
  10,
  16,
  22,
  28,
  15,
  26,
  36,
  44,
  20,
  36,
  52,
  64,
  26,
  48,
  72,
  88,
  36,
  64,
  96,
  112,
  40,
  72,
  108,
  130,
  48,
  88,
  132,
  156,
  60,
  110,
  160,
  192,
  72,
  130,
  192,
  224,
  80,
  150,
  224,
  264,
  96,
  176,
  260,
  308,
  104,
  198,
  288,
  352,
  120,
  216,
  320,
  384,
  132,
  240,
  360,
  432,
  144,
  280,
  408,
  480,
  168,
  308,
  448,
  532,
  180,
  338,
  504,
  588,
  196,
  364,
  546,
  650,
  224,
  416,
  600,
  700,
  224,
  442,
  644,
  750,
  252,
  476,
  690,
  816,
  270,
  504,
  750,
  900,
  300,
  560,
  810,
  960,
  312,
  588,
  870,
  1050,
  336,
  644,
  952,
  1110,
  360,
  700,
  1020,
  1200,
  390,
  728,
  1050,
  1260,
  420,
  784,
  1140,
  1350,
  450,
  812,
  1200,
  1440,
  480,
  868,
  1290,
  1530,
  510,
  924,
  1350,
  1620,
  540,
  980,
  1440,
  1710,
  570,
  1036,
  1530,
  1800,
  570,
  1064,
  1590,
  1890,
  600,
  1120,
  1680,
  1980,
  630,
  1204,
  1770,
  2100,
  660,
  1260,
  1860,
  2220,
  720,
  1316,
  1950,
  2310,
  750,
  1372,
  2040,
  2430
];
errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
  switch (errorCorrectionLevel2) {
    case ECLevel$1.L:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
    case ECLevel$1.M:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
    case ECLevel$1.Q:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
    case ECLevel$1.H:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
    default:
      return void 0;
  }
};
var polynomial = {};
var galoisField = {};
var BufferUtil$3 = typedarrayBuffer;
var EXP_TABLE = BufferUtil$3.alloc(512);
var LOG_TABLE = BufferUtil$3.alloc(256);
(function initTables() {
  var x2 = 1;
  for (var i2 = 0; i2 < 255; i2++) {
    EXP_TABLE[i2] = x2;
    LOG_TABLE[x2] = i2;
    x2 <<= 1;
    if (x2 & 256) {
      x2 ^= 285;
    }
  }
  for (i2 = 255; i2 < 512; i2++) {
    EXP_TABLE[i2] = EXP_TABLE[i2 - 255];
  }
})();
galoisField.log = function log(n2) {
  if (n2 < 1)
    throw new Error("log(" + n2 + ")");
  return LOG_TABLE[n2];
};
galoisField.exp = function exp(n2) {
  return EXP_TABLE[n2];
};
galoisField.mul = function mul7(x2, y2) {
  if (x2 === 0 || y2 === 0)
    return 0;
  return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y2]];
};
(function(exports2) {
  var BufferUtil2 = typedarrayBuffer;
  var GF = galoisField;
  exports2.mul = function mul8(p1, p2) {
    var coeff = BufferUtil2.alloc(p1.length + p2.length - 1);
    for (var i2 = 0; i2 < p1.length; i2++) {
      for (var j2 = 0; j2 < p2.length; j2++) {
        coeff[i2 + j2] ^= GF.mul(p1[i2], p2[j2]);
      }
    }
    return coeff;
  };
  exports2.mod = function mod(divident, divisor) {
    var result = BufferUtil2.from(divident);
    while (result.length - divisor.length >= 0) {
      var coeff = result[0];
      for (var i2 = 0; i2 < divisor.length; i2++) {
        result[i2] ^= GF.mul(divisor[i2], coeff);
      }
      var offset = 0;
      while (offset < result.length && result[offset] === 0)
        offset++;
      result = result.slice(offset);
    }
    return result;
  };
  exports2.generateECPolynomial = function generateECPolynomial(degree) {
    var poly = BufferUtil2.from([1]);
    for (var i2 = 0; i2 < degree; i2++) {
      poly = exports2.mul(poly, [1, GF.exp(i2)]);
    }
    return poly;
  };
})(polynomial);
var buffer$1 = {};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  var base64 = base64Js;
  var ieee754$1 = ieee754;
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH2 = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH2;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport2();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport2() {
    try {
      var arr2 = new Uint8Array(1);
      var proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr2, proto);
      return arr2.foo() === 42;
    } catch (e2) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer2(length) {
    if (length > K_MAX_LENGTH2) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from2(value2, encodingOrOffset, length) {
    if (typeof value2 === "string") {
      return fromString2(value2, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value2)) {
      return fromArrayView(value2);
    }
    if (value2 == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2);
    }
    if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
      return fromArrayBuffer2(value2, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer2(value2, encodingOrOffset, length);
    }
    if (typeof value2 === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value2.valueOf && value2.valueOf();
    if (valueOf != null && valueOf !== value2) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    var b2 = fromObject2(value2);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2);
  }
  Buffer2.from = function(value2, encodingOrOffset, length) {
    return from2(value2, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill2, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer2(size2);
    }
    if (fill2 !== void 0) {
      return typeof encoding === "string" ? createBuffer2(size2).fill(fill2, encoding) : createBuffer2(size2).fill(fill2);
    }
    return createBuffer2(size2);
  }
  Buffer2.alloc = function(size2, fill2, encoding) {
    return alloc(size2, fill2, encoding);
  };
  function allocUnsafe2(size2) {
    assertSize(size2);
    return createBuffer2(size2 < 0 ? 0 : checked2(size2) | 0);
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe2(size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe2(size2);
  };
  function fromString2(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length = byteLength2(string2, encoding) | 0;
    var buf = createBuffer2(length);
    var actual = buf.write(string2, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike2(array2) {
    var length = array2.length < 0 ? 0 : checked2(array2.length) | 0;
    var buf = createBuffer2(length);
    for (var i2 = 0; i2 < length; i2 += 1) {
      buf[i2] = array2[i2] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy3 = new Uint8Array(arrayView);
      return fromArrayBuffer2(copy3.buffer, copy3.byteOffset, copy3.byteLength);
    }
    return fromArrayLike2(arrayView);
  }
  function fromArrayBuffer2(array2, byteOffset, length) {
    if (byteOffset < 0 || array2.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array2.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array2);
    } else if (length === void 0) {
      buf = new Uint8Array(array2, byteOffset);
    } else {
      buf = new Uint8Array(array2, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject2(obj) {
    if (Buffer2.isBuffer(obj)) {
      var len2 = checked2(obj.length) | 0;
      var buf = createBuffer2(len2);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len2);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer2(0);
      }
      return fromArrayLike2(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike2(obj.data);
    }
  }
  function checked2(length) {
    if (length >= K_MAX_LENGTH2) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH2.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer4(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a2, b2) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a2 === b2)
      return 0;
    var x2 = a2.length;
    var y2 = b2.length;
    for (var i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
      if (a2[i2] !== b2[i2]) {
        x2 = a2[i2];
        y2 = b2[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding2(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat3(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    var i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length += list[i2].length;
      }
    }
    var buffer2 = Buffer2.allocUnsafe(length);
    var pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      var buf = list[i2];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          Buffer2.from(buf).copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2);
    }
    var len2 = string2.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n2, m2) {
    var i2 = b2[n2];
    b2[n2] = b2[m2];
    b2[m2] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    var len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i2 = 0; i2 < len2; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    var len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i2 = 0; i2 < len2; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    var len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i2 = 0; i2 < len2; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    var length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect10() {
    var str2 = "";
    var max2 = exports2.INSPECT_MAX_BYTES;
    str2 = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2)
      str2 += " ... ";
    return "<Buffer " + str2 + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x2 = thisEnd - thisStart;
    var y2 = end - start;
    var len2 = Math.min(x2, y2);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y2 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr2, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr2.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr2.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    var i2;
    if (dir) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read(arr2, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var j2 = 0; j2 < valLength; j2++) {
          if (read(arr2, i2 + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf3(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string2.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i2 = 0; i2 < length; ++i2) {
      var parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write2(buf, string2, offset, length) {
    return blitBuffer2(utf8ToBytes2(string2, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string2, offset, length) {
    return blitBuffer2(asciiToBytes(string2), buf, offset, length);
  }
  function base64Write(buf, string2, offset, length) {
    return blitBuffer2(base64ToBytes(string2), buf, offset, length);
  }
  function ucs2Write(buf, string2, offset, length) {
    return blitBuffer2(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write4(string2, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write2(this, string2, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length);
        case "base64":
          return base64Write(this, string2, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON3() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i2 = start;
    while (i2 < end) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len2 = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len2)
      end = len2;
    var out = "";
    for (var i2 = start; i2 < end; ++i2) {
      out += hexSliceLookupTable[buf[i2]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes3 = buf.slice(start, end);
    var res = "";
    for (var i2 = 0; i2 < bytes3.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes3[i2] + bytes3[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice3(start, end) {
    var len2 = this.length;
    start = ~~start;
    end = end === void 0 ? len2 : ~~end;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end < 0) {
      end += len2;
      if (end < 0)
        end = 0;
    } else if (end > len2) {
      end = len2;
    }
    if (end < start)
      end = start;
    var newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul8 = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul8 *= 256)) {
      val += this[offset + i2] * mul8;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    var val = this[offset + --byteLength3];
    var mul8 = 1;
    while (byteLength3 > 0 && (mul8 *= 256)) {
      val += this[offset + --byteLength3] * mul8;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul8 = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul8 *= 256)) {
      val += this[offset + i2] * mul8;
    }
    mul8 *= 128;
    if (val >= mul8)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var i2 = byteLength3;
    var mul8 = 1;
    var val = this[offset + --i2];
    while (i2 > 0 && (mul8 *= 256)) {
      val += this[offset + --i2] * mul8;
    }
    mul8 *= 128;
    if (val >= mul8)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value2, offset, ext, max2, min2) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value2 > max2 || value2 < min2)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset, byteLength3, maxBytes, 0);
    }
    var mul8 = 1;
    var i2 = 0;
    this[offset] = value2 & 255;
    while (++i2 < byteLength3 && (mul8 *= 256)) {
      this[offset + i2] = value2 / mul8 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value2, offset, byteLength3, maxBytes, 0);
    }
    var i2 = byteLength3 - 1;
    var mul8 = 1;
    this[offset + i2] = value2 & 255;
    while (--i2 >= 0 && (mul8 *= 256)) {
      this[offset + i2] = value2 / mul8 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 1, 255, 0);
    this[offset] = value2 & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 65535, 0);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 65535, 0);
    this[offset] = value2 >>> 8;
    this[offset + 1] = value2 & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 4294967295, 0);
    this[offset + 3] = value2 >>> 24;
    this[offset + 2] = value2 >>> 16;
    this[offset + 1] = value2 >>> 8;
    this[offset] = value2 & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 4294967295, 0);
    this[offset] = value2 >>> 24;
    this[offset + 1] = value2 >>> 16;
    this[offset + 2] = value2 >>> 8;
    this[offset + 3] = value2 & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
    }
    var i2 = 0;
    var mul8 = 1;
    var sub = 0;
    this[offset] = value2 & 255;
    while (++i2 < byteLength3 && (mul8 *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value2 / mul8 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset, byteLength3, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value2, offset, byteLength3, limit - 1, -limit);
    }
    var i2 = byteLength3 - 1;
    var mul8 = 1;
    var sub = 0;
    this[offset + i2] = value2 & 255;
    while (--i2 >= 0 && (mul8 *= 256)) {
      if (value2 < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value2 / mul8 >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 1, 127, -128);
    if (value2 < 0)
      value2 = 255 + value2 + 1;
    this[offset] = value2 & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 32767, -32768);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 2, 32767, -32768);
    this[offset] = value2 >>> 8;
    this[offset + 1] = value2 & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 2147483647, -2147483648);
    this[offset] = value2 & 255;
    this[offset + 1] = value2 >>> 8;
    this[offset + 2] = value2 >>> 16;
    this[offset + 3] = value2 >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value2, offset, 4, 2147483647, -2147483648);
    if (value2 < 0)
      value2 = 4294967295 + value2 + 1;
    this[offset] = value2 >>> 24;
    this[offset + 1] = value2 >>> 16;
    this[offset + 2] = value2 >>> 8;
    this[offset + 3] = value2 & 255;
    return offset + 4;
  };
  function checkIEEE754(buf, value2, offset, ext, max2, min2) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value2, offset, littleEndian, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value2, offset, 4);
    }
    ieee754$1.write(buf, value2, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset, noAssert) {
    return writeFloat(this, value2, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset, noAssert) {
    return writeFloat(this, value2, offset, false, noAssert);
  };
  function writeDouble(buf, value2, offset, littleEndian, noAssert) {
    value2 = +value2;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value2, offset, 8);
    }
    ieee754$1.write(buf, value2, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset, noAssert) {
    return writeDouble(this, value2, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset, noAssert) {
    return writeDouble(this, value2, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy3(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len2 = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill2(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    var i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      var bytes3 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      var len2 = bytes3.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes3[i2 % len2];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str2) {
    str2 = str2.split("=")[0];
    str2 = str2.trim().replace(INVALID_BASE64_RE, "");
    if (str2.length < 2)
      return "";
    while (str2.length % 4 !== 0) {
      str2 = str2 + "=";
    }
    return str2;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    var codePoint;
    var length = string2.length;
    var leadSurrogate = null;
    var bytes3 = [];
    for (var i2 = 0; i2 < length; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes3.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1)
              bytes3.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes3.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes3.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes3.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes3.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes3.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes3;
  }
  function asciiToBytes(str2) {
    var byteArray = [];
    for (var i2 = 0; i2 < str2.length; ++i2) {
      byteArray.push(str2.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str2, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str2.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str2.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str2) {
    return base64.toByteArray(base64clean(str2));
  }
  function blitBuffer2(src2, dst, offset, length) {
    for (var i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length)
        break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for (var i2 = 0; i2 < 16; ++i2) {
      var i16 = i2 * 16;
      for (var j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i2] + alphabet[j2];
      }
    }
    return table;
  }();
})(buffer$1);
var BufferUtil$2 = typedarrayBuffer;
var Polynomial = polynomial;
var Buffer = buffer$1.Buffer;
function ReedSolomonEncoder$1(degree) {
  this.genPoly = void 0;
  this.degree = degree;
  if (this.degree)
    this.initialize(this.degree);
}
ReedSolomonEncoder$1.prototype.initialize = function initialize(degree) {
  this.degree = degree;
  this.genPoly = Polynomial.generateECPolynomial(this.degree);
};
ReedSolomonEncoder$1.prototype.encode = function encode4(data) {
  if (!this.genPoly) {
    throw new Error("Encoder not initialized");
  }
  var pad2 = BufferUtil$2.alloc(this.degree);
  var paddedData = Buffer.concat([data, pad2], data.length + this.degree);
  var remainder = Polynomial.mod(paddedData, this.genPoly);
  var start = this.degree - remainder.length;
  if (start > 0) {
    var buff = BufferUtil$2.alloc(this.degree);
    remainder.copy(buff, start);
    return buff;
  }
  return remainder;
};
var reedSolomonEncoder = ReedSolomonEncoder$1;
var version$3 = {};
var mode = {};
var versionCheck = {};
versionCheck.isValid = function isValid(version2) {
  return !isNaN(version2) && version2 >= 1 && version2 <= 40;
};
var regex = {};
var numeric = "[0-9]+";
var alphanumeric = "[A-Z $%*+\\-./:]+";
var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
regex.KANJI = new RegExp(kanji, "g");
regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
regex.BYTE = new RegExp(byte, "g");
regex.NUMERIC = new RegExp(numeric, "g");
regex.ALPHANUMERIC = new RegExp(alphanumeric, "g");
var TEST_KANJI = new RegExp("^" + kanji + "$");
var TEST_NUMERIC = new RegExp("^" + numeric + "$");
var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
regex.testKanji = function testKanji(str2) {
  return TEST_KANJI.test(str2);
};
regex.testNumeric = function testNumeric(str2) {
  return TEST_NUMERIC.test(str2);
};
regex.testAlphanumeric = function testAlphanumeric(str2) {
  return TEST_ALPHANUMERIC.test(str2);
};
(function(exports2) {
  var VersionCheck = versionCheck;
  var Regex = regex;
  exports2.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  };
  exports2.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  };
  exports2.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  };
  exports2.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  };
  exports2.MIXED = {
    bit: -1
  };
  exports2.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
    if (!mode2.ccBits)
      throw new Error("Invalid mode: " + mode2);
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid version: " + version2);
    }
    if (version2 >= 1 && version2 < 10)
      return mode2.ccBits[0];
    else if (version2 < 27)
      return mode2.ccBits[1];
    return mode2.ccBits[2];
  };
  exports2.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr))
      return exports2.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr))
      return exports2.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr))
      return exports2.KANJI;
    else
      return exports2.BYTE;
  };
  exports2.toString = function toString2(mode2) {
    if (mode2 && mode2.id)
      return mode2.id;
    throw new Error("Invalid mode");
  };
  exports2.isValid = function isValid2(mode2) {
    return mode2 && mode2.bit && mode2.ccBits;
  };
  function fromString2(string2) {
    if (typeof string2 !== "string") {
      throw new Error("Param is not a string");
    }
    var lcStr = string2.toLowerCase();
    switch (lcStr) {
      case "numeric":
        return exports2.NUMERIC;
      case "alphanumeric":
        return exports2.ALPHANUMERIC;
      case "kanji":
        return exports2.KANJI;
      case "byte":
        return exports2.BYTE;
      default:
        throw new Error("Unknown mode: " + string2);
    }
  }
  exports2.from = function from2(value2, defaultValue) {
    if (exports2.isValid(value2)) {
      return value2;
    }
    try {
      return fromString2(value2);
    } catch (e2) {
      return defaultValue;
    }
  };
})(mode);
(function(exports2) {
  var Utils2 = utils$1;
  var ECCode2 = errorCorrectionCode;
  var ECLevel2 = errorCorrectionLevel;
  var Mode2 = mode;
  var VersionCheck = versionCheck;
  var isArray2 = isarray;
  var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
  var G18_BCH = Utils2.getBCHDigit(G18);
  function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
    for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
      if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  function getReservedBitsCount(mode2, version2) {
    return Mode2.getCharCountIndicator(mode2, version2) + 4;
  }
  function getTotalBitsFromDataArray(segments2, version2) {
    var totalBits = 0;
    segments2.forEach(function(data) {
      var reservedBits = getReservedBitsCount(data.mode, version2);
      totalBits += reservedBits + data.getBitsLength();
    });
    return totalBits;
  }
  function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
    for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
      var length = getTotalBitsFromDataArray(segments2, currentVersion);
      if (length <= exports2.getCapacity(currentVersion, errorCorrectionLevel2, Mode2.MIXED)) {
        return currentVersion;
      }
    }
    return void 0;
  }
  exports2.from = function from2(value2, defaultValue) {
    if (VersionCheck.isValid(value2)) {
      return parseInt(value2, 10);
    }
    return defaultValue;
  };
  exports2.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
    if (!VersionCheck.isValid(version2)) {
      throw new Error("Invalid QR Code version");
    }
    if (typeof mode2 === "undefined")
      mode2 = Mode2.BYTE;
    var totalCodewords = Utils2.getSymbolTotalCodewords(version2);
    var ecTotalCodewords = ECCode2.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode2 === Mode2.MIXED)
      return dataTotalCodewordsBits;
    var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
    switch (mode2) {
      case Mode2.NUMERIC:
        return Math.floor(usableBits / 10 * 3);
      case Mode2.ALPHANUMERIC:
        return Math.floor(usableBits / 11 * 2);
      case Mode2.KANJI:
        return Math.floor(usableBits / 13);
      case Mode2.BYTE:
      default:
        return Math.floor(usableBits / 8);
    }
  };
  exports2.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel2) {
    var seg;
    var ecl = ECLevel2.from(errorCorrectionLevel2, ECLevel2.M);
    if (isArray2(data)) {
      if (data.length > 1) {
        return getBestVersionForMixedData(data, ecl);
      }
      if (data.length === 0) {
        return 1;
      }
      seg = data[0];
    } else {
      seg = data;
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
  };
  exports2.getEncodedBits = function getEncodedBits2(version2) {
    if (!VersionCheck.isValid(version2) || version2 < 7) {
      throw new Error("Invalid QR Code version");
    }
    var d2 = version2 << 12;
    while (Utils2.getBCHDigit(d2) - G18_BCH >= 0) {
      d2 ^= G18 << Utils2.getBCHDigit(d2) - G18_BCH;
    }
    return version2 << 12 | d2;
  };
})(version$3);
var formatInfo = {};
var Utils$3 = utils$1;
var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
var G15_BCH = Utils$3.getBCHDigit(G15);
formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask) {
  var data = errorCorrectionLevel2.bit << 3 | mask;
  var d2 = data << 10;
  while (Utils$3.getBCHDigit(d2) - G15_BCH >= 0) {
    d2 ^= G15 << Utils$3.getBCHDigit(d2) - G15_BCH;
  }
  return (data << 10 | d2) ^ G15_MASK;
};
var segments = {};
var Mode$4 = mode;
function NumericData(data) {
  this.mode = Mode$4.NUMERIC;
  this.data = data.toString();
}
NumericData.getBitsLength = function getBitsLength(length) {
  return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
};
NumericData.prototype.getLength = function getLength2() {
  return this.data.length;
};
NumericData.prototype.getBitsLength = function getBitsLength2() {
  return NumericData.getBitsLength(this.data.length);
};
NumericData.prototype.write = function write2(bitBuffer2) {
  var i2, group, value2;
  for (i2 = 0; i2 + 3 <= this.data.length; i2 += 3) {
    group = this.data.substr(i2, 3);
    value2 = parseInt(group, 10);
    bitBuffer2.put(value2, 10);
  }
  var remainingNum = this.data.length - i2;
  if (remainingNum > 0) {
    group = this.data.substr(i2);
    value2 = parseInt(group, 10);
    bitBuffer2.put(value2, remainingNum * 3 + 1);
  }
};
var numericData = NumericData;
var Mode$3 = mode;
var ALPHA_NUM_CHARS = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
function AlphanumericData(data) {
  this.mode = Mode$3.ALPHANUMERIC;
  this.data = data;
}
AlphanumericData.getBitsLength = function getBitsLength3(length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2);
};
AlphanumericData.prototype.getLength = function getLength3() {
  return this.data.length;
};
AlphanumericData.prototype.getBitsLength = function getBitsLength4() {
  return AlphanumericData.getBitsLength(this.data.length);
};
AlphanumericData.prototype.write = function write3(bitBuffer2) {
  var i2;
  for (i2 = 0; i2 + 2 <= this.data.length; i2 += 2) {
    var value2 = ALPHA_NUM_CHARS.indexOf(this.data[i2]) * 45;
    value2 += ALPHA_NUM_CHARS.indexOf(this.data[i2 + 1]);
    bitBuffer2.put(value2, 11);
  }
  if (this.data.length % 2) {
    bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i2]), 6);
  }
};
var alphanumericData = AlphanumericData;
var BufferUtil$1 = typedarrayBuffer;
var Mode$2 = mode;
function ByteData(data) {
  this.mode = Mode$2.BYTE;
  this.data = BufferUtil$1.from(data);
}
ByteData.getBitsLength = function getBitsLength5(length) {
  return length * 8;
};
ByteData.prototype.getLength = function getLength4() {
  return this.data.length;
};
ByteData.prototype.getBitsLength = function getBitsLength6() {
  return ByteData.getBitsLength(this.data.length);
};
ByteData.prototype.write = function(bitBuffer2) {
  for (var i2 = 0, l2 = this.data.length; i2 < l2; i2++) {
    bitBuffer2.put(this.data[i2], 8);
  }
};
var byteData = ByteData;
var Mode$1 = mode;
var Utils$2 = utils$1;
function KanjiData(data) {
  this.mode = Mode$1.KANJI;
  this.data = data;
}
KanjiData.getBitsLength = function getBitsLength7(length) {
  return length * 13;
};
KanjiData.prototype.getLength = function getLength5() {
  return this.data.length;
};
KanjiData.prototype.getBitsLength = function getBitsLength8() {
  return KanjiData.getBitsLength(this.data.length);
};
KanjiData.prototype.write = function(bitBuffer2) {
  var i2;
  for (i2 = 0; i2 < this.data.length; i2++) {
    var value2 = Utils$2.toSJIS(this.data[i2]);
    if (value2 >= 33088 && value2 <= 40956) {
      value2 -= 33088;
    } else if (value2 >= 57408 && value2 <= 60351) {
      value2 -= 49472;
    } else {
      throw new Error("Invalid SJIS character: " + this.data[i2] + "\nMake sure your charset is UTF-8");
    }
    value2 = (value2 >>> 8 & 255) * 192 + (value2 & 255);
    bitBuffer2.put(value2, 13);
  }
};
var kanjiData = KanjiData;
var dijkstra = { exports: {} };
(function(module2) {
  var dijkstra2 = {
    single_source_shortest_paths: function(graph, s2, d2) {
      var predecessors = {};
      var costs = {};
      costs[s2] = 0;
      var open2 = dijkstra2.PriorityQueue.make();
      open2.push(s2, 0);
      var closest, u2, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
      while (!open2.empty()) {
        closest = open2.pop();
        u2 = closest.value;
        cost_of_s_to_u = closest.cost;
        adjacent_nodes = graph[u2] || {};
        for (v2 in adjacent_nodes) {
          if (adjacent_nodes.hasOwnProperty(v2)) {
            cost_of_e = adjacent_nodes[v2];
            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
            cost_of_s_to_v = costs[v2];
            first_visit = typeof costs[v2] === "undefined";
            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
              costs[v2] = cost_of_s_to_u_plus_cost_of_e;
              open2.push(v2, cost_of_s_to_u_plus_cost_of_e);
              predecessors[v2] = u2;
            }
          }
        }
      }
      if (typeof d2 !== "undefined" && typeof costs[d2] === "undefined") {
        var msg = ["Could not find a path from ", s2, " to ", d2, "."].join("");
        throw new Error(msg);
      }
      return predecessors;
    },
    extract_shortest_path_from_predecessor_list: function(predecessors, d2) {
      var nodes = [];
      var u2 = d2;
      while (u2) {
        nodes.push(u2);
        u2 = predecessors[u2];
      }
      nodes.reverse();
      return nodes;
    },
    find_path: function(graph, s2, d2) {
      var predecessors = dijkstra2.single_source_shortest_paths(graph, s2, d2);
      return dijkstra2.extract_shortest_path_from_predecessor_list(predecessors, d2);
    },
    PriorityQueue: {
      make: function(opts) {
        var T2 = dijkstra2.PriorityQueue, t2 = {}, key2;
        opts = opts || {};
        for (key2 in T2) {
          if (T2.hasOwnProperty(key2)) {
            t2[key2] = T2[key2];
          }
        }
        t2.queue = [];
        t2.sorter = opts.sorter || T2.default_sorter;
        return t2;
      },
      default_sorter: function(a2, b2) {
        return a2.cost - b2.cost;
      },
      push: function(value2, cost) {
        var item = { value: value2, cost };
        this.queue.push(item);
        this.queue.sort(this.sorter);
      },
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  {
    module2.exports = dijkstra2;
  }
})(dijkstra);
(function(exports2) {
  var Mode2 = mode;
  var NumericData2 = numericData;
  var AlphanumericData2 = alphanumericData;
  var ByteData2 = byteData;
  var KanjiData2 = kanjiData;
  var Regex = regex;
  var Utils2 = utils$1;
  var dijkstra$1 = dijkstra.exports;
  function getStringByteLength(str2) {
    return unescape(encodeURIComponent(str2)).length;
  }
  function getSegments(regex2, mode2, str2) {
    var segments2 = [];
    var result;
    while ((result = regex2.exec(str2)) !== null) {
      segments2.push({
        data: result[0],
        index: result.index,
        mode: mode2,
        length: result[0].length
      });
    }
    return segments2;
  }
  function getSegmentsFromString(dataStr) {
    var numSegs = getSegments(Regex.NUMERIC, Mode2.NUMERIC, dataStr);
    var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode2.ALPHANUMERIC, dataStr);
    var byteSegs;
    var kanjiSegs;
    if (Utils2.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode2.BYTE, dataStr);
      kanjiSegs = getSegments(Regex.KANJI, Mode2.KANJI, dataStr);
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode2.BYTE, dataStr);
      kanjiSegs = [];
    }
    var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s2) {
      return s1.index - s2.index;
    }).map(function(obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      };
    });
  }
  function getSegmentBitsLength(length, mode2) {
    switch (mode2) {
      case Mode2.NUMERIC:
        return NumericData2.getBitsLength(length);
      case Mode2.ALPHANUMERIC:
        return AlphanumericData2.getBitsLength(length);
      case Mode2.KANJI:
        return KanjiData2.getBitsLength(length);
      case Mode2.BYTE:
        return ByteData2.getBitsLength(length);
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
      var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data;
        return acc;
      }
      acc.push(curr);
      return acc;
    }, []);
  }
  function buildNodes(segs) {
    var nodes = [];
    for (var i2 = 0; i2 < segs.length; i2++) {
      var seg = segs[i2];
      switch (seg.mode) {
        case Mode2.NUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.ALPHANUMERIC, length: seg.length },
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.ALPHANUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: seg.length }
          ]);
          break;
        case Mode2.KANJI:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
          break;
        case Mode2.BYTE:
          nodes.push([
            { data: seg.data, mode: Mode2.BYTE, length: getStringByteLength(seg.data) }
          ]);
      }
    }
    return nodes;
  }
  function buildGraph(nodes, version2) {
    var table = {};
    var graph = { "start": {} };
    var prevNodeIds = ["start"];
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var nodeGroup = nodes[i2];
      var currentNodeIds = [];
      for (var j2 = 0; j2 < nodeGroup.length; j2++) {
        var node = nodeGroup[j2];
        var key2 = "" + i2 + j2;
        currentNodeIds.push(key2);
        table[key2] = { node, lastCount: 0 };
        graph[key2] = {};
        for (var n2 = 0; n2 < prevNodeIds.length; n2++) {
          var prevNodeId = prevNodeIds[n2];
          if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
            graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
            table[prevNodeId].lastCount += node.length;
          } else {
            if (table[prevNodeId])
              table[prevNodeId].lastCount = node.length;
            graph[prevNodeId][key2] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode2.getCharCountIndicator(node.mode, version2);
          }
        }
      }
      prevNodeIds = currentNodeIds;
    }
    for (n2 = 0; n2 < prevNodeIds.length; n2++) {
      graph[prevNodeIds[n2]]["end"] = 0;
    }
    return { map: graph, table };
  }
  function buildSingleSegment(data, modesHint) {
    var mode2;
    var bestMode = Mode2.getBestModeForData(data);
    mode2 = Mode2.from(modesHint, bestMode);
    if (mode2 !== Mode2.BYTE && mode2.bit < bestMode.bit) {
      throw new Error('"' + data + '" cannot be encoded with mode ' + Mode2.toString(mode2) + ".\n Suggested mode is: " + Mode2.toString(bestMode));
    }
    if (mode2 === Mode2.KANJI && !Utils2.isKanjiModeEnabled()) {
      mode2 = Mode2.BYTE;
    }
    switch (mode2) {
      case Mode2.NUMERIC:
        return new NumericData2(data);
      case Mode2.ALPHANUMERIC:
        return new AlphanumericData2(data);
      case Mode2.KANJI:
        return new KanjiData2(data);
      case Mode2.BYTE:
        return new ByteData2(data);
    }
  }
  exports2.fromArray = function fromArray2(array2) {
    return array2.reduce(function(acc, seg) {
      if (typeof seg === "string") {
        acc.push(buildSingleSegment(seg, null));
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode));
      }
      return acc;
    }, []);
  };
  exports2.fromString = function fromString2(data, version2) {
    var segs = getSegmentsFromString(data, Utils2.isKanjiModeEnabled());
    var nodes = buildNodes(segs);
    var graph = buildGraph(nodes, version2);
    var path = dijkstra$1.find_path(graph.map, "start", "end");
    var optimizedSegs = [];
    for (var i2 = 1; i2 < path.length - 1; i2++) {
      optimizedSegs.push(graph.table[path[i2]].node);
    }
    return exports2.fromArray(mergeSegments(optimizedSegs));
  };
  exports2.rawSplit = function rawSplit(data) {
    return exports2.fromArray(getSegmentsFromString(data, Utils2.isKanjiModeEnabled()));
  };
})(segments);
var BufferUtil = typedarrayBuffer;
var Utils$1 = utils$1;
var ECLevel = errorCorrectionLevel;
var BitBuffer = bitBuffer;
var BitMatrix = bitMatrix;
var AlignmentPattern = alignmentPattern;
var FinderPattern = finderPattern;
var MaskPattern = maskPattern;
var ECCode = errorCorrectionCode;
var ReedSolomonEncoder = reedSolomonEncoder;
var Version = version$3;
var FormatInfo = formatInfo;
var Mode = mode;
var Segments = segments;
var isArray$2 = isarray;
function setupFinderPattern(matrix, version2) {
  var size2 = matrix.size;
  var pos = FinderPattern.getPositions(version2);
  for (var i2 = 0; i2 < pos.length; i2++) {
    var row = pos[i2][0];
    var col = pos[i2][1];
    for (var r2 = -1; r2 <= 7; r2++) {
      if (row + r2 <= -1 || size2 <= row + r2)
        continue;
      for (var c2 = -1; c2 <= 7; c2++) {
        if (col + c2 <= -1 || size2 <= col + c2)
          continue;
        if (r2 >= 0 && r2 <= 6 && (c2 === 0 || c2 === 6) || c2 >= 0 && c2 <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c2 >= 2 && c2 <= 4) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupTimingPattern(matrix) {
  var size2 = matrix.size;
  for (var r2 = 8; r2 < size2 - 8; r2++) {
    var value2 = r2 % 2 === 0;
    matrix.set(r2, 6, value2, true);
    matrix.set(6, r2, value2, true);
  }
}
function setupAlignmentPattern(matrix, version2) {
  var pos = AlignmentPattern.getPositions(version2);
  for (var i2 = 0; i2 < pos.length; i2++) {
    var row = pos[i2][0];
    var col = pos[i2][1];
    for (var r2 = -2; r2 <= 2; r2++) {
      for (var c2 = -2; c2 <= 2; c2++) {
        if (r2 === -2 || r2 === 2 || c2 === -2 || c2 === 2 || r2 === 0 && c2 === 0) {
          matrix.set(row + r2, col + c2, true, true);
        } else {
          matrix.set(row + r2, col + c2, false, true);
        }
      }
    }
  }
}
function setupVersionInfo(matrix, version2) {
  var size2 = matrix.size;
  var bits = Version.getEncodedBits(version2);
  var row, col, mod;
  for (var i2 = 0; i2 < 18; i2++) {
    row = Math.floor(i2 / 3);
    col = i2 % 3 + size2 - 8 - 3;
    mod = (bits >> i2 & 1) === 1;
    matrix.set(row, col, mod, true);
    matrix.set(col, row, mod, true);
  }
}
function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
  var size2 = matrix.size;
  var bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
  var i2, mod;
  for (i2 = 0; i2 < 15; i2++) {
    mod = (bits >> i2 & 1) === 1;
    if (i2 < 6) {
      matrix.set(i2, 8, mod, true);
    } else if (i2 < 8) {
      matrix.set(i2 + 1, 8, mod, true);
    } else {
      matrix.set(size2 - 15 + i2, 8, mod, true);
    }
    if (i2 < 8) {
      matrix.set(8, size2 - i2 - 1, mod, true);
    } else if (i2 < 9) {
      matrix.set(8, 15 - i2 - 1 + 1, mod, true);
    } else {
      matrix.set(8, 15 - i2 - 1, mod, true);
    }
  }
  matrix.set(size2 - 8, 8, 1, true);
}
function setupData(matrix, data) {
  var size2 = matrix.size;
  var inc = -1;
  var row = size2 - 1;
  var bitIndex = 7;
  var byteIndex = 0;
  for (var col = size2 - 1; col > 0; col -= 2) {
    if (col === 6)
      col--;
    while (true) {
      for (var c2 = 0; c2 < 2; c2++) {
        if (!matrix.isReserved(row, col - c2)) {
          var dark = false;
          if (byteIndex < data.length) {
            dark = (data[byteIndex] >>> bitIndex & 1) === 1;
          }
          matrix.set(row, col - c2, dark);
          bitIndex--;
          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc;
      if (row < 0 || size2 <= row) {
        row -= inc;
        inc = -inc;
        break;
      }
    }
  }
}
function createData(version2, errorCorrectionLevel2, segments2) {
  var buffer2 = new BitBuffer();
  segments2.forEach(function(data) {
    buffer2.put(data.mode.bit, 4);
    buffer2.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version2));
    data.write(buffer2);
  });
  var totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  var ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
  if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 !== 0) {
    buffer2.putBit(0);
  }
  var remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
  for (var i2 = 0; i2 < remainingByte; i2++) {
    buffer2.put(i2 % 2 ? 17 : 236, 8);
  }
  return createCodewords(buffer2, version2, errorCorrectionLevel2);
}
function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
  var totalCodewords = Utils$1.getSymbolTotalCodewords(version2);
  var ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
  var dataTotalCodewords = totalCodewords - ecTotalCodewords;
  var ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
  var blocksInGroup2 = totalCodewords % ecTotalBlocks;
  var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
  var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
  var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
  var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
  var rs = new ReedSolomonEncoder(ecCount);
  var offset = 0;
  var dcData = new Array(ecTotalBlocks);
  var ecData = new Array(ecTotalBlocks);
  var maxDataSize = 0;
  var buffer2 = BufferUtil.from(bitBuffer2.buffer);
  for (var b2 = 0; b2 < ecTotalBlocks; b2++) {
    var dataSize = b2 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
    dcData[b2] = buffer2.slice(offset, offset + dataSize);
    ecData[b2] = rs.encode(dcData[b2]);
    offset += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }
  var data = BufferUtil.alloc(totalCodewords);
  var index2 = 0;
  var i2, r2;
  for (i2 = 0; i2 < maxDataSize; i2++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      if (i2 < dcData[r2].length) {
        data[index2++] = dcData[r2][i2];
      }
    }
  }
  for (i2 = 0; i2 < ecCount; i2++) {
    for (r2 = 0; r2 < ecTotalBlocks; r2++) {
      data[index2++] = ecData[r2][i2];
    }
  }
  return data;
}
function createSymbol(data, version2, errorCorrectionLevel2, maskPattern2) {
  var segments2;
  if (isArray$2(data)) {
    segments2 = Segments.fromArray(data);
  } else if (typeof data === "string") {
    var estimatedVersion = version2;
    if (!estimatedVersion) {
      var rawSegments = Segments.rawSplit(data);
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
    }
    segments2 = Segments.fromString(data, estimatedVersion || 40);
  } else {
    throw new Error("Invalid data");
  }
  var bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
  if (!bestVersion) {
    throw new Error("The amount of data is too big to be stored in a QR Code");
  }
  if (!version2) {
    version2 = bestVersion;
  } else if (version2 < bestVersion) {
    throw new Error("\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n");
  }
  var dataBits = createData(version2, errorCorrectionLevel2, segments2);
  var moduleCount = Utils$1.getSymbolSize(version2);
  var modules = new BitMatrix(moduleCount);
  setupFinderPattern(modules, version2);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version2);
  setupFormatInfo(modules, errorCorrectionLevel2, 0);
  if (version2 >= 7) {
    setupVersionInfo(modules, version2);
  }
  setupData(modules, dataBits);
  if (isNaN(maskPattern2)) {
    maskPattern2 = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel2));
  }
  MaskPattern.applyMask(maskPattern2, modules);
  setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
  return {
    modules,
    version: version2,
    errorCorrectionLevel: errorCorrectionLevel2,
    maskPattern: maskPattern2,
    segments: segments2
  };
}
qrcode.create = function create(data, options) {
  if (typeof data === "undefined" || data === "") {
    throw new Error("No input text");
  }
  var errorCorrectionLevel2 = ECLevel.M;
  var version2;
  var mask;
  if (typeof options !== "undefined") {
    errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
    version2 = Version.from(options.version);
    mask = MaskPattern.from(options.maskPattern);
    if (options.toSJISFunc) {
      Utils$1.setToSJISFunction(options.toSJISFunc);
    }
  }
  return createSymbol(data, version2, errorCorrectionLevel2, mask);
};
var canvas = {};
var utils = {};
(function(exports2) {
  function hex2rgba(hex) {
    if (typeof hex === "number") {
      hex = hex.toString();
    }
    if (typeof hex !== "string") {
      throw new Error("Color should be defined as hex string");
    }
    var hexCode = hex.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error("Invalid hex color: " + hex);
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply([], hexCode.map(function(c2) {
        return [c2, c2];
      }));
    }
    if (hexCode.length === 6)
      hexCode.push("F", "F");
    var hexValue2 = parseInt(hexCode.join(""), 16);
    return {
      r: hexValue2 >> 24 & 255,
      g: hexValue2 >> 16 & 255,
      b: hexValue2 >> 8 & 255,
      a: hexValue2 & 255,
      hex: "#" + hexCode.slice(0, 6).join("")
    };
  }
  exports2.getOptions = function getOptions(options) {
    if (!options)
      options = {};
    if (!options.color)
      options.color = {};
    var margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    var width = options.width && options.width >= 21 ? options.width : void 0;
    var scale = options.scale || 4;
    return {
      width,
      scale: width ? 4 : scale,
      margin,
      color: {
        dark: hex2rgba(options.color.dark || "#000000ff"),
        light: hex2rgba(options.color.light || "#ffffffff")
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {}
    };
  };
  exports2.getScale = function getScale(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
  };
  exports2.getImageWidth = function getImageWidth(qrSize, opts) {
    var scale = exports2.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale);
  };
  exports2.qrToImageData = function qrToImageData(imgData, qr, opts) {
    var size2 = qr.modules.size;
    var data = qr.modules.data;
    var scale = exports2.getScale(size2, opts);
    var symbolSize = Math.floor((size2 + opts.margin * 2) * scale);
    var scaledMargin = opts.margin * scale;
    var palette = [opts.color.light, opts.color.dark];
    for (var i2 = 0; i2 < symbolSize; i2++) {
      for (var j2 = 0; j2 < symbolSize; j2++) {
        var posDst = (i2 * symbolSize + j2) * 4;
        var pxColor = opts.color.light;
        if (i2 >= scaledMargin && j2 >= scaledMargin && i2 < symbolSize - scaledMargin && j2 < symbolSize - scaledMargin) {
          var iSrc = Math.floor((i2 - scaledMargin) / scale);
          var jSrc = Math.floor((j2 - scaledMargin) / scale);
          pxColor = palette[data[iSrc * size2 + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
      }
    }
  };
})(utils);
(function(exports2) {
  var Utils2 = utils;
  function clearCanvas(ctx, canvas2, size2) {
    ctx.clearRect(0, 0, canvas2.width, canvas2.height);
    if (!canvas2.style)
      canvas2.style = {};
    canvas2.height = size2;
    canvas2.width = size2;
    canvas2.style.height = size2 + "px";
    canvas2.style.width = size2 + "px";
  }
  function getCanvasElement() {
    try {
      return document.createElement("canvas");
    } catch (e2) {
      throw new Error("You need to specify a canvas element");
    }
  }
  exports2.render = function render3(qrData, canvas2, options) {
    var opts = options;
    var canvasEl = canvas2;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!canvas2) {
      canvasEl = getCanvasElement();
    }
    opts = Utils2.getOptions(opts);
    var size2 = Utils2.getImageWidth(qrData.modules.size, opts);
    var ctx = canvasEl.getContext("2d");
    var image = ctx.createImageData(size2, size2);
    Utils2.qrToImageData(image.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size2);
    ctx.putImageData(image, 0, 0);
    return canvasEl;
  };
  exports2.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
    var opts = options;
    if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2;
      canvas2 = void 0;
    }
    if (!opts)
      opts = {};
    var canvasEl = exports2.render(qrData, canvas2, opts);
    var type = opts.type || "image/png";
    var rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type, rendererOpts.quality);
  };
})(canvas);
var svgTag = {};
var Utils = utils;
function getColorAttrib(color, attrib) {
  var alpha = color.a / 255;
  var str2 = attrib + '="' + color.hex + '"';
  return alpha < 1 ? str2 + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str2;
}
function svgCmd(cmd, x2, y2) {
  var str2 = cmd + x2;
  if (typeof y2 !== "undefined")
    str2 += " " + y2;
  return str2;
}
function qrToPath(data, size2, margin) {
  var path = "";
  var moveBy = 0;
  var newRow = false;
  var lineLength = 0;
  for (var i2 = 0; i2 < data.length; i2++) {
    var col = Math.floor(i2 % size2);
    var row = Math.floor(i2 / size2);
    if (!col && !newRow)
      newRow = true;
    if (data[i2]) {
      lineLength++;
      if (!(i2 > 0 && col > 0 && data[i2 - 1])) {
        path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
        moveBy = 0;
        newRow = false;
      }
      if (!(col + 1 < size2 && data[i2 + 1])) {
        path += svgCmd("h", lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }
  return path;
}
svgTag.render = function render2(qrData, options, cb) {
  var opts = Utils.getOptions(options);
  var size2 = qrData.modules.size;
  var data = qrData.modules.data;
  var qrcodesize = size2 + opts.margin * 2;
  var bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
  var path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size2, opts.margin) + '"/>';
  var viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
  var width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
  var svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
  if (typeof cb === "function") {
    cb(null, svgTag2);
  }
  return svgTag2;
};
var canPromise = canPromise$1;
var QRCode$4 = qrcode;
var CanvasRenderer = canvas;
var SvgRenderer = svgTag;
function renderCanvas(renderFunc, canvas2, text2, opts, cb) {
  var args = [].slice.call(arguments, 1);
  var argsNum = args.length;
  var isLastArgCb = typeof args[argsNum - 1] === "function";
  if (!isLastArgCb && !canPromise()) {
    throw new Error("Callback required as last argument");
  }
  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 2) {
      cb = text2;
      text2 = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 3) {
      if (canvas2.getContext && typeof cb === "undefined") {
        cb = opts;
        opts = void 0;
      } else {
        cb = opts;
        opts = text2;
        text2 = canvas2;
        canvas2 = void 0;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error("Too few arguments provided");
    }
    if (argsNum === 1) {
      text2 = canvas2;
      canvas2 = opts = void 0;
    } else if (argsNum === 2 && !canvas2.getContext) {
      opts = text2;
      text2 = canvas2;
      canvas2 = void 0;
    }
    return new Promise(function(resolve2, reject) {
      try {
        var data2 = QRCode$4.create(text2, opts);
        resolve2(renderFunc(data2, canvas2, opts));
      } catch (e2) {
        reject(e2);
      }
    });
  }
  try {
    var data = QRCode$4.create(text2, opts);
    cb(null, renderFunc(data, canvas2, opts));
  } catch (e2) {
    cb(e2);
  }
}
browser$1.create = QRCode$4.create;
browser$1.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
browser$1.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
browser$1.toString = renderCanvas.bind(null, function(data, _2, opts) {
  return SvgRenderer.render(data, opts);
});
var toggleSelection = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i2 = 0; i2 < selection.rangeCount; i2++) {
    ranges.push(selection.getRangeAt(i2));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range2) {
        selection.addRange(range2);
      });
    }
    active && active.focus();
  };
};
var deselectCurrent = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
function copy$1(text2, options) {
  var debug2, message, reselectPrevious, range2, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  debug2 = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range2 = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text2;
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug2 && console.warn("unable to use e.clipboardData");
          debug2 && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format2, text2);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options.format, text2);
        }
      }
      if (options.onCopy) {
        e2.preventDefault();
        options.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range2.selectNodeContents(mark);
    selection.addRange(range2);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug2 && console.error("unable to copy using execCommand: ", err);
    debug2 && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text2);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug2 && console.error("unable to copy using clipboardData: ", err2);
      debug2 && console.error("falling back to prompt");
      message = format("message" in options ? options.message : defaultMessage);
      window.prompt(message, text2);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range2);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard = copy$1;
var n$1, u$3, i$4, t$3, r$3, o$3, f$3, e$3 = {}, c$3 = [], s$3 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function a$3(n2, l2) {
  for (var u2 in l2)
    n2[u2] = l2[u2];
  return n2;
}
function v$3(n2) {
  var l2 = n2.parentNode;
  l2 && l2.removeChild(n2);
}
function h$3(n2, l2, u2) {
  var i2, t2 = arguments, r2 = {};
  for (i2 in l2)
    i2 !== "key" && i2 !== "ref" && (r2[i2] = l2[i2]);
  if (arguments.length > 3)
    for (u2 = [u2], i2 = 3; i2 < arguments.length; i2++)
      u2.push(t2[i2]);
  if (u2 != null && (r2.children = u2), typeof n2 == "function" && n2.defaultProps != null)
    for (i2 in n2.defaultProps)
      r2[i2] === void 0 && (r2[i2] = n2.defaultProps[i2]);
  return p$3(n2, r2, l2 && l2.key, l2 && l2.ref, null);
}
function p$3(l2, u2, i2, t2, r2) {
  var o2 = { type: l2, props: u2, key: i2, ref: t2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: r2 };
  return r2 == null && (o2.__v = o2), n$1.vnode && n$1.vnode(o2), o2;
}
function y$3() {
  return {};
}
function d$3(n2) {
  return n2.children;
}
function m$3(n2, l2) {
  this.props = n2, this.context = l2;
}
function w$4(n2, l2) {
  if (l2 == null)
    return n2.__ ? w$4(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u2; l2 < n2.__k.length; l2++)
    if ((u2 = n2.__k[l2]) != null && u2.__e != null)
      return u2.__e;
  return typeof n2.type == "function" ? w$4(n2) : null;
}
function k$3(n2) {
  var l2, u2;
  if ((n2 = n2.__) != null && n2.__c != null) {
    for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++)
      if ((u2 = n2.__k[l2]) != null && u2.__e != null) {
        n2.__e = n2.__c.base = u2.__e;
        break;
      }
    return k$3(n2);
  }
}
function g$3(l2) {
  (!l2.__d && (l2.__d = true) && u$3.push(l2) && !i$4++ || r$3 !== n$1.debounceRendering) && ((r$3 = n$1.debounceRendering) || t$3)(_$4);
}
function _$4() {
  for (var n2; i$4 = u$3.length; )
    n2 = u$3.sort(function(n3, l2) {
      return n3.__v.__b - l2.__v.__b;
    }), u$3 = [], n2.some(function(n3) {
      var l2, u2, i2, t2, r2, o2, f2;
      n3.__d && (o2 = (r2 = (l2 = n3).__v).__e, (f2 = l2.__P) && (u2 = [], (i2 = a$3({}, r2)).__v = i2, t2 = A$4(f2, r2, i2, l2.__n, f2.ownerSVGElement !== void 0, null, u2, o2 == null ? w$4(r2) : o2), T$4(u2, r2), t2 != o2 && k$3(r2)));
    });
}
function b$2(n2, l2, u2, i2, t2, r2, o2, f2, s2) {
  var a2, h2, p2, y2, d2, m2, k2, g2 = u2 && u2.__k || c$3, _2 = g2.length;
  if (f2 == e$3 && (f2 = r2 != null ? r2[0] : _2 ? w$4(u2, 0) : null), a2 = 0, l2.__k = x$4(l2.__k, function(u3) {
    if (u3 != null) {
      if (u3.__ = l2, u3.__b = l2.__b + 1, (p2 = g2[a2]) === null || p2 && u3.key == p2.key && u3.type === p2.type)
        g2[a2] = void 0;
      else
        for (h2 = 0; h2 < _2; h2++) {
          if ((p2 = g2[h2]) && u3.key == p2.key && u3.type === p2.type) {
            g2[h2] = void 0;
            break;
          }
          p2 = null;
        }
      if (y2 = A$4(n2, u3, p2 = p2 || e$3, i2, t2, r2, o2, f2, s2), (h2 = u3.ref) && p2.ref != h2 && (k2 || (k2 = []), p2.ref && k2.push(p2.ref, null, u3), k2.push(h2, u3.__c || y2, u3)), y2 != null) {
        var c2;
        if (m2 == null && (m2 = y2), u3.__d !== void 0)
          c2 = u3.__d, u3.__d = void 0;
        else if (r2 == p2 || y2 != f2 || y2.parentNode == null) {
          n:
            if (f2 == null || f2.parentNode !== n2)
              n2.appendChild(y2), c2 = null;
            else {
              for (d2 = f2, h2 = 0; (d2 = d2.nextSibling) && h2 < _2; h2 += 2)
                if (d2 == y2)
                  break n;
              n2.insertBefore(y2, f2), c2 = f2;
            }
          l2.type == "option" && (n2.value = "");
        }
        f2 = c2 !== void 0 ? c2 : y2.nextSibling, typeof l2.type == "function" && (l2.__d = f2);
      } else
        f2 && p2.__e == f2 && f2.parentNode != n2 && (f2 = w$4(p2));
    }
    return a2++, u3;
  }), l2.__e = m2, r2 != null && typeof l2.type != "function")
    for (a2 = r2.length; a2--; )
      r2[a2] != null && v$3(r2[a2]);
  for (a2 = _2; a2--; )
    g2[a2] != null && D$2(g2[a2], g2[a2]);
  if (k2)
    for (a2 = 0; a2 < k2.length; a2++)
      j$3(k2[a2], k2[++a2], k2[++a2]);
}
function x$4(n2, l2, u2) {
  if (u2 == null && (u2 = []), n2 == null || typeof n2 == "boolean")
    l2 && u2.push(l2(null));
  else if (Array.isArray(n2))
    for (var i2 = 0; i2 < n2.length; i2++)
      x$4(n2[i2], l2, u2);
  else
    u2.push(l2 ? l2(typeof n2 == "string" || typeof n2 == "number" ? p$3(null, n2, null, null, n2) : n2.__e != null || n2.__c != null ? p$3(n2.type, n2.props, n2.key, null, n2.__v) : n2) : n2);
  return u2;
}
function P$2(n2, l2, u2, i2, t2) {
  var r2;
  for (r2 in u2)
    r2 === "children" || r2 === "key" || r2 in l2 || N$2(n2, r2, null, u2[r2], i2);
  for (r2 in l2)
    t2 && typeof l2[r2] != "function" || r2 === "children" || r2 === "key" || r2 === "value" || r2 === "checked" || u2[r2] === l2[r2] || N$2(n2, r2, l2[r2], u2[r2], i2);
}
function C$2(n2, l2, u2) {
  l2[0] === "-" ? n2.setProperty(l2, u2) : n2[l2] = typeof u2 == "number" && s$3.test(l2) === false ? u2 + "px" : u2 == null ? "" : u2;
}
function N$2(n2, l2, u2, i2, t2) {
  var r2, o2, f2, e2, c2;
  if (t2 ? l2 === "className" && (l2 = "class") : l2 === "class" && (l2 = "className"), l2 === "style")
    if (r2 = n2.style, typeof u2 == "string")
      r2.cssText = u2;
    else {
      if (typeof i2 == "string" && (r2.cssText = "", i2 = null), i2)
        for (e2 in i2)
          u2 && e2 in u2 || C$2(r2, e2, "");
      if (u2)
        for (c2 in u2)
          i2 && u2[c2] === i2[c2] || C$2(r2, c2, u2[c2]);
    }
  else
    l2[0] === "o" && l2[1] === "n" ? (o2 = l2 !== (l2 = l2.replace(/Capture$/, "")), f2 = l2.toLowerCase(), l2 = (f2 in n2 ? f2 : l2).slice(2), u2 ? (i2 || n2.addEventListener(l2, z$3, o2), (n2.l || (n2.l = {}))[l2] = u2) : n2.removeEventListener(l2, z$3, o2)) : l2 !== "list" && l2 !== "tagName" && l2 !== "form" && l2 !== "type" && l2 !== "size" && !t2 && l2 in n2 ? n2[l2] = u2 == null ? "" : u2 : typeof u2 != "function" && l2 !== "dangerouslySetInnerHTML" && (l2 !== (l2 = l2.replace(/^xlink:?/, "")) ? u2 == null || u2 === false ? n2.removeAttributeNS("http://www.w3.org/1999/xlink", l2.toLowerCase()) : n2.setAttributeNS("http://www.w3.org/1999/xlink", l2.toLowerCase(), u2) : u2 == null || u2 === false && !/^ar/.test(l2) ? n2.removeAttribute(l2) : n2.setAttribute(l2, u2));
}
function z$3(l2) {
  this.l[l2.type](n$1.event ? n$1.event(l2) : l2);
}
function A$4(l2, u2, i2, t2, r2, o2, f2, e2, c2) {
  var s2, v2, h2, p2, y2, w2, k2, g2, _2, x2, P2 = u2.type;
  if (u2.constructor !== void 0)
    return null;
  (s2 = n$1.__b) && s2(u2);
  try {
    n:
      if (typeof P2 == "function") {
        if (g2 = u2.props, _2 = (s2 = P2.contextType) && t2[s2.__c], x2 = s2 ? _2 ? _2.props.value : s2.__ : t2, i2.__c ? k2 = (v2 = u2.__c = i2.__c).__ = v2.__E : ("prototype" in P2 && P2.prototype.render ? u2.__c = v2 = new P2(g2, x2) : (u2.__c = v2 = new m$3(g2, x2), v2.constructor = P2, v2.render = E$2), _2 && _2.sub(v2), v2.props = g2, v2.state || (v2.state = {}), v2.context = x2, v2.__n = t2, h2 = v2.__d = true, v2.__h = []), v2.__s == null && (v2.__s = v2.state), P2.getDerivedStateFromProps != null && (v2.__s == v2.state && (v2.__s = a$3({}, v2.__s)), a$3(v2.__s, P2.getDerivedStateFromProps(g2, v2.__s))), p2 = v2.props, y2 = v2.state, h2)
          P2.getDerivedStateFromProps == null && v2.componentWillMount != null && v2.componentWillMount(), v2.componentDidMount != null && v2.__h.push(v2.componentDidMount);
        else {
          if (P2.getDerivedStateFromProps == null && g2 !== p2 && v2.componentWillReceiveProps != null && v2.componentWillReceiveProps(g2, x2), !v2.__e && v2.shouldComponentUpdate != null && v2.shouldComponentUpdate(g2, v2.__s, x2) === false || u2.__v === i2.__v && !v2.__) {
            for (v2.props = g2, v2.state = v2.__s, u2.__v !== i2.__v && (v2.__d = false), v2.__v = u2, u2.__e = i2.__e, u2.__k = i2.__k, v2.__h.length && f2.push(v2), s2 = 0; s2 < u2.__k.length; s2++)
              u2.__k[s2] && (u2.__k[s2].__ = u2);
            break n;
          }
          v2.componentWillUpdate != null && v2.componentWillUpdate(g2, v2.__s, x2), v2.componentDidUpdate != null && v2.__h.push(function() {
            v2.componentDidUpdate(p2, y2, w2);
          });
        }
        v2.context = x2, v2.props = g2, v2.state = v2.__s, (s2 = n$1.__r) && s2(u2), v2.__d = false, v2.__v = u2, v2.__P = l2, s2 = v2.render(v2.props, v2.state, v2.context), u2.__k = s2 != null && s2.type == d$3 && s2.key == null ? s2.props.children : Array.isArray(s2) ? s2 : [s2], v2.getChildContext != null && (t2 = a$3(a$3({}, t2), v2.getChildContext())), h2 || v2.getSnapshotBeforeUpdate == null || (w2 = v2.getSnapshotBeforeUpdate(p2, y2)), b$2(l2, u2, i2, t2, r2, o2, f2, e2, c2), v2.base = u2.__e, v2.__h.length && f2.push(v2), k2 && (v2.__E = v2.__ = null), v2.__e = false;
      } else
        o2 == null && u2.__v === i2.__v ? (u2.__k = i2.__k, u2.__e = i2.__e) : u2.__e = $$2(i2.__e, u2, i2, t2, r2, o2, f2, c2);
    (s2 = n$1.diffed) && s2(u2);
  } catch (l3) {
    u2.__v = null, n$1.__e(l3, u2, i2);
  }
  return u2.__e;
}
function T$4(l2, u2) {
  n$1.__c && n$1.__c(u2, l2), l2.some(function(u3) {
    try {
      l2 = u3.__h, u3.__h = [], l2.some(function(n2) {
        n2.call(u3);
      });
    } catch (l3) {
      n$1.__e(l3, u3.__v);
    }
  });
}
function $$2(n2, l2, u2, i2, t2, r2, o2, f2) {
  var s2, a2, v2, h2, p2, y2 = u2.props, d2 = l2.props;
  if (t2 = l2.type === "svg" || t2, r2 != null) {
    for (s2 = 0; s2 < r2.length; s2++)
      if ((a2 = r2[s2]) != null && ((l2.type === null ? a2.nodeType === 3 : a2.localName === l2.type) || n2 == a2)) {
        n2 = a2, r2[s2] = null;
        break;
      }
  }
  if (n2 == null) {
    if (l2.type === null)
      return document.createTextNode(d2);
    n2 = t2 ? document.createElementNS("http://www.w3.org/2000/svg", l2.type) : document.createElement(l2.type, d2.is && { is: d2.is }), r2 = null, f2 = false;
  }
  if (l2.type === null)
    y2 !== d2 && n2.data != d2 && (n2.data = d2);
  else {
    if (r2 != null && (r2 = c$3.slice.call(n2.childNodes)), v2 = (y2 = u2.props || e$3).dangerouslySetInnerHTML, h2 = d2.dangerouslySetInnerHTML, !f2) {
      if (y2 === e$3)
        for (y2 = {}, p2 = 0; p2 < n2.attributes.length; p2++)
          y2[n2.attributes[p2].name] = n2.attributes[p2].value;
      (h2 || v2) && (h2 && v2 && h2.__html == v2.__html || (n2.innerHTML = h2 && h2.__html || ""));
    }
    P$2(n2, d2, y2, t2, f2), h2 ? l2.__k = [] : (l2.__k = l2.props.children, b$2(n2, l2, u2, i2, l2.type !== "foreignObject" && t2, r2, o2, e$3, f2)), f2 || ("value" in d2 && (s2 = d2.value) !== void 0 && s2 !== n2.value && N$2(n2, "value", s2, y2.value, false), "checked" in d2 && (s2 = d2.checked) !== void 0 && s2 !== n2.checked && N$2(n2, "checked", s2, y2.checked, false));
  }
  return n2;
}
function j$3(l2, u2, i2) {
  try {
    typeof l2 == "function" ? l2(u2) : l2.current = u2;
  } catch (l3) {
    n$1.__e(l3, i2);
  }
}
function D$2(l2, u2, i2) {
  var t2, r2, o2;
  if (n$1.unmount && n$1.unmount(l2), (t2 = l2.ref) && (t2.current && t2.current !== l2.__e || j$3(t2, null, u2)), i2 || typeof l2.type == "function" || (i2 = (r2 = l2.__e) != null), l2.__e = l2.__d = void 0, (t2 = l2.__c) != null) {
    if (t2.componentWillUnmount)
      try {
        t2.componentWillUnmount();
      } catch (l3) {
        n$1.__e(l3, u2);
      }
    t2.base = t2.__P = null;
  }
  if (t2 = l2.__k)
    for (o2 = 0; o2 < t2.length; o2++)
      t2[o2] && D$2(t2[o2], u2, i2);
  r2 != null && v$3(r2);
}
function E$2(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function H$2(l2, u2, i2) {
  var t2, r2, f2;
  n$1.__ && n$1.__(l2, u2), r2 = (t2 = i2 === o$3) ? null : i2 && i2.__k || u2.__k, l2 = h$3(d$3, null, [l2]), f2 = [], A$4(u2, (t2 ? u2 : i2 || u2).__k = l2, r2 || e$3, e$3, u2.ownerSVGElement !== void 0, i2 && !t2 ? [i2] : r2 ? null : c$3.slice.call(u2.childNodes), f2, i2 || e$3, t2), T$4(f2, l2);
}
function I$2(n2, l2) {
  H$2(n2, l2, o$3);
}
function L$2(n2, l2) {
  var u2, i2;
  for (i2 in l2 = a$3(a$3({}, n2.props), l2), arguments.length > 2 && (l2.children = c$3.slice.call(arguments, 2)), u2 = {}, l2)
    i2 !== "key" && i2 !== "ref" && (u2[i2] = l2[i2]);
  return p$3(n2.type, u2, l2.key || n2.key, l2.ref || n2.ref, null);
}
function M$2(n2) {
  var l2 = {}, u2 = { __c: "__cC" + f$3++, __: n2, Consumer: function(n3, l3) {
    return n3.children(l3);
  }, Provider: function(n3) {
    var i2, t2 = this;
    return this.getChildContext || (i2 = [], this.getChildContext = function() {
      return l2[u2.__c] = t2, l2;
    }, this.shouldComponentUpdate = function(n4) {
      t2.props.value !== n4.value && i2.some(function(l3) {
        l3.context = n4.value, g$3(l3);
      });
    }, this.sub = function(n4) {
      i2.push(n4);
      var l3 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        i2.splice(i2.indexOf(n4), 1), l3 && l3.call(n4);
      };
    }), n3.children;
  } };
  return u2.Consumer.contextType = u2, u2.Provider.__ = u2, u2;
}
n$1 = { __e: function(n2, l2) {
  for (var u2, i2; l2 = l2.__; )
    if ((u2 = l2.__c) && !u2.__)
      try {
        if (u2.constructor && u2.constructor.getDerivedStateFromError != null && (i2 = true, u2.setState(u2.constructor.getDerivedStateFromError(n2))), u2.componentDidCatch != null && (i2 = true, u2.componentDidCatch(n2)), i2)
          return g$3(u2.__E = u2);
      } catch (l3) {
        n2 = l3;
      }
  throw n2;
} }, m$3.prototype.setState = function(n2, l2) {
  var u2;
  u2 = this.__s !== this.state ? this.__s : this.__s = a$3({}, this.state), typeof n2 == "function" && (n2 = n2(u2, this.props)), n2 && a$3(u2, n2), n2 != null && this.__v && (l2 && this.__h.push(l2), g$3(this));
}, m$3.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), g$3(this));
}, m$3.prototype.render = d$3, u$3 = [], i$4 = 0, t$3 = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o$3 = e$3, f$3 = 0;
var t$2, u$2, r$2, i$3 = 0, o$2 = [], c$2 = n$1.__r, f$2 = n$1.diffed, e$2 = n$1.__c, a$2 = n$1.unmount;
function v$2(t2, r2) {
  n$1.__h && n$1.__h(u$2, t2, i$3 || r2), i$3 = 0;
  var o2 = u$2.__H || (u$2.__H = { __: [], __h: [] });
  return t2 >= o2.__.length && o2.__.push({}), o2.__[t2];
}
function m$2(n2) {
  return i$3 = 1, p$2(E$1, n2);
}
function p$2(n2, r2, i2) {
  var o2 = v$2(t$2++, 2);
  return o2.__c || (o2.__c = u$2, o2.__ = [i2 ? i2(r2) : E$1(void 0, r2), function(t2) {
    var u2 = n2(o2.__[0], t2);
    o2.__[0] !== u2 && (o2.__[0] = u2, o2.__c.setState({}));
  }]), o2.__;
}
function l$2(r2, i2) {
  var o2 = v$2(t$2++, 3);
  !n$1.__s && x$3(o2.__H, i2) && (o2.__ = r2, o2.__H = i2, u$2.__H.__h.push(o2));
}
function y$2(r2, i2) {
  var o2 = v$2(t$2++, 4);
  !n$1.__s && x$3(o2.__H, i2) && (o2.__ = r2, o2.__H = i2, u$2.__h.push(o2));
}
function d$2(n2) {
  return i$3 = 5, h$2(function() {
    return { current: n2 };
  }, []);
}
function s$2(n2, t2, u2) {
  i$3 = 6, y$2(function() {
    typeof n2 == "function" ? n2(t2()) : n2 && (n2.current = t2());
  }, u2 == null ? u2 : u2.concat(n2));
}
function h$2(n2, u2) {
  var r2 = v$2(t$2++, 7);
  return x$3(r2.__H, u2) ? (r2.__H = u2, r2.__h = n2, r2.__ = n2()) : r2.__;
}
function T$3(n2, t2) {
  return i$3 = 8, h$2(function() {
    return n2;
  }, t2);
}
function w$3(n2) {
  var r2 = u$2.context[n2.__c], i2 = v$2(t$2++, 9);
  return i2.__c = n2, r2 ? (i2.__ == null && (i2.__ = true, r2.sub(u$2)), r2.props.value) : n2.__;
}
function A$3(t2, u2) {
  n$1.useDebugValue && n$1.useDebugValue(u2 ? u2(t2) : t2);
}
function F$2(n2) {
  var r2 = v$2(t$2++, 10), i2 = m$2();
  return r2.__ = n2, u$2.componentDidCatch || (u$2.componentDidCatch = function(n3) {
    r2.__ && r2.__(n3), i2[1](n3);
  }), [i2[0], function() {
    i2[1](void 0);
  }];
}
function _$3() {
  o$2.some(function(t2) {
    if (t2.__P)
      try {
        t2.__H.__h.forEach(g$2), t2.__H.__h.forEach(q$3), t2.__H.__h = [];
      } catch (u2) {
        return t2.__H.__h = [], n$1.__e(u2, t2.__v), true;
      }
  }), o$2 = [];
}
function g$2(n2) {
  n2.t && n2.t();
}
function q$3(n2) {
  var t2 = n2.__();
  typeof t2 == "function" && (n2.t = t2);
}
function x$3(n2, t2) {
  return !n2 || t2.some(function(t3, u2) {
    return t3 !== n2[u2];
  });
}
function E$1(n2, t2) {
  return typeof t2 == "function" ? t2(n2) : t2;
}
n$1.__r = function(n2) {
  c$2 && c$2(n2), t$2 = 0, (u$2 = n2.__c).__H && (u$2.__H.__h.forEach(g$2), u$2.__H.__h.forEach(q$3), u$2.__H.__h = []);
}, n$1.diffed = function(t2) {
  f$2 && f$2(t2);
  var u2 = t2.__c;
  if (u2) {
    var i2 = u2.__H;
    i2 && i2.__h.length && (o$2.push(u2) !== 1 && r$2 === n$1.requestAnimationFrame || ((r$2 = n$1.requestAnimationFrame) || function(n2) {
      var t3, u3 = function() {
        clearTimeout(r2), cancelAnimationFrame(t3), setTimeout(n2);
      }, r2 = setTimeout(u3, 100);
      typeof window != "undefined" && (t3 = requestAnimationFrame(u3));
    })(_$3));
  }
}, n$1.__c = function(t2, u2) {
  u2.some(function(t3) {
    try {
      t3.__h.forEach(g$2), t3.__h = t3.__h.filter(function(n2) {
        return !n2.__ || q$3(n2);
      });
    } catch (r2) {
      u2.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), u2 = [], n$1.__e(r2, t3.__v);
    }
  }), e$2 && e$2(t2, u2);
}, n$1.unmount = function(t2) {
  a$2 && a$2(t2);
  var u2 = t2.__c;
  if (u2) {
    var r2 = u2.__H;
    if (r2)
      try {
        r2.__.forEach(function(n2) {
          return n2.t && n2.t();
        });
      } catch (t3) {
        n$1.__e(t3, u2.__v);
      }
  }
};
function E(n2, t2) {
  for (var e2 in t2)
    n2[e2] = t2[e2];
  return n2;
}
function w$2(n2, t2) {
  for (var e2 in n2)
    if (e2 !== "__source" && !(e2 in t2))
      return true;
  for (var r2 in t2)
    if (r2 !== "__source" && n2[r2] !== t2[r2])
      return true;
  return false;
}
var C$1 = function(n2) {
  var t2, e2;
  function r2(t3) {
    var e3;
    return (e3 = n2.call(this, t3) || this).isPureReactComponent = true, e3;
  }
  return e2 = n2, (t2 = r2).prototype = Object.create(e2.prototype), t2.prototype.constructor = t2, t2.__proto__ = e2, r2.prototype.shouldComponentUpdate = function(n3, t3) {
    return w$2(this.props, n3) || w$2(this.state, t3);
  }, r2;
}(m$3);
function _$2(n2, t2) {
  function e2(n3) {
    var e3 = this.props.ref, r3 = e3 == n3.ref;
    return !r3 && e3 && (e3.call ? e3(null) : e3.current = null), t2 ? !t2(this.props, n3) || !r3 : w$2(this.props, n3);
  }
  function r2(t3) {
    return this.shouldComponentUpdate = e2, h$3(n2, E({}, t3));
  }
  return r2.prototype.isReactComponent = true, r2.displayName = "Memo(" + (n2.displayName || n2.name) + ")", r2.t = true, r2;
}
var A$2 = n$1.__b;
function S$1(n2) {
  function t2(t3) {
    var e2 = E({}, t3);
    return delete e2.ref, n2(e2, t3.ref);
  }
  return t2.prototype.isReactComponent = t2.t = true, t2.displayName = "ForwardRef(" + (n2.displayName || n2.name) + ")", t2;
}
n$1.__b = function(n2) {
  n2.type && n2.type.t && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), A$2 && A$2(n2);
};
var k$2 = function(n2, t2) {
  return n2 ? x$4(n2).reduce(function(n3, e2, r2) {
    return n3.concat(t2(e2, r2));
  }, []) : null;
}, R = { map: k$2, forEach: k$2, count: function(n2) {
  return n2 ? x$4(n2).length : 0;
}, only: function(n2) {
  if ((n2 = x$4(n2)).length !== 1)
    throw new Error("Children.only() expects only one child.");
  return n2[0];
}, toArray: x$4 }, F$1 = n$1.__e;
function N$1(n2) {
  return n2 && ((n2 = E({}, n2)).__c = null, n2.__k = n2.__k && n2.__k.map(N$1)), n2;
}
function U() {
  this.__u = 0, this.o = null, this.__b = null;
}
function M$1(n2) {
  var t2 = n2.__.__c;
  return t2 && t2.u && t2.u(n2);
}
function L$1(n2) {
  var t2, e2, r2;
  function o2(o3) {
    if (t2 || (t2 = n2()).then(function(n3) {
      e2 = n3.default || n3;
    }, function(n3) {
      r2 = n3;
    }), r2)
      throw r2;
    if (!e2)
      throw t2;
    return h$3(e2, o3);
  }
  return o2.displayName = "Lazy", o2.t = true, o2;
}
function O$1() {
  this.i = null, this.l = null;
}
n$1.__e = function(n2, t2, e2) {
  if (n2.then) {
    for (var r2, o2 = t2; o2 = o2.__; )
      if ((r2 = o2.__c) && r2.__c)
        return r2.__c(n2, t2.__c);
  }
  F$1(n2, t2, e2);
}, (U.prototype = new m$3()).__c = function(n2, t2) {
  var e2 = this;
  e2.o == null && (e2.o = []), e2.o.push(t2);
  var r2 = M$1(e2.__v), o2 = false, u2 = function() {
    o2 || (o2 = true, r2 ? r2(i2) : i2());
  };
  t2.__c = t2.componentWillUnmount, t2.componentWillUnmount = function() {
    u2(), t2.__c && t2.__c();
  };
  var i2 = function() {
    var n3;
    if (!--e2.__u)
      for (e2.__v.__k[0] = e2.state.u, e2.setState({ u: e2.__b = null }); n3 = e2.o.pop(); )
        n3.forceUpdate();
  };
  e2.__u++ || e2.setState({ u: e2.__b = e2.__v.__k[0] }), n2.then(u2, u2);
}, U.prototype.render = function(n2, t2) {
  return this.__b && (this.__v.__k[0] = N$1(this.__b), this.__b = null), [h$3(m$3, null, t2.u ? null : n2.children), t2.u && n2.fallback];
};
var P$1 = function(n2, t2, e2) {
  if (++e2[1] === e2[0] && n2.l.delete(t2), n2.props.revealOrder && (n2.props.revealOrder[0] !== "t" || !n2.l.size))
    for (e2 = n2.i; e2; ) {
      for (; e2.length > 3; )
        e2.pop()();
      if (e2[1] < e2[0])
        break;
      n2.i = e2 = e2[2];
    }
};
(O$1.prototype = new m$3()).u = function(n2) {
  var t2 = this, e2 = M$1(t2.__v), r2 = t2.l.get(n2);
  return r2[0]++, function(o2) {
    var u2 = function() {
      t2.props.revealOrder ? (r2.push(o2), P$1(t2, n2, r2)) : o2();
    };
    e2 ? e2(u2) : u2();
  };
}, O$1.prototype.render = function(n2) {
  this.i = null, this.l = new Map();
  var t2 = x$4(n2.children);
  n2.revealOrder && n2.revealOrder[0] === "b" && t2.reverse();
  for (var e2 = t2.length; e2--; )
    this.l.set(t2[e2], this.i = [1, 0, this.i]);
  return n2.children;
}, O$1.prototype.componentDidUpdate = O$1.prototype.componentDidMount = function() {
  var n2 = this;
  n2.l.forEach(function(t2, e2) {
    P$1(n2, e2, t2);
  });
};
var W = function() {
  function n2() {
  }
  var t2 = n2.prototype;
  return t2.getChildContext = function() {
    return this.props.context;
  }, t2.render = function(n3) {
    return n3.children;
  }, n2;
}();
function j$2(n2) {
  var t2 = this, e2 = n2.container, r2 = h$3(W, { context: t2.context }, n2.vnode);
  return t2.s && t2.s !== e2 && (t2.v.parentNode && t2.s.removeChild(t2.v), D$2(t2.h), t2.p = false), n2.vnode ? t2.p ? (e2.__k = t2.__k, H$2(r2, e2), t2.__k = e2.__k) : (t2.v = document.createTextNode(""), I$2("", e2), e2.appendChild(t2.v), t2.p = true, t2.s = e2, H$2(r2, e2, t2.v), t2.__k = t2.v.__k) : t2.p && (t2.v.parentNode && t2.s.removeChild(t2.v), D$2(t2.h)), t2.h = r2, t2.componentWillUnmount = function() {
    t2.v.parentNode && t2.s.removeChild(t2.v), D$2(t2.h);
  }, null;
}
function z$2(n2, t2) {
  return h$3(j$2, { vnode: n2, container: t2 });
}
var D$1 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
m$3.prototype.isReactComponent = {};
var H$1 = typeof Symbol != "undefined" && Symbol.for && Symbol.for("react.element") || 60103;
function T$2(n2, t2, e2) {
  if (t2.__k == null)
    for (; t2.firstChild; )
      t2.removeChild(t2.firstChild);
  return H$2(n2, t2), typeof e2 == "function" && e2(), n2 ? n2.__c : null;
}
function V(n2, t2, e2) {
  return I$2(n2, t2), typeof e2 == "function" && e2(), n2 ? n2.__c : null;
}
var Z = n$1.event;
function I$1(n2, t2) {
  n2["UNSAFE_" + t2] && !n2[t2] && Object.defineProperty(n2, t2, { configurable: false, get: function() {
    return this["UNSAFE_" + t2];
  }, set: function(n3) {
    this["UNSAFE_" + t2] = n3;
  } });
}
n$1.event = function(n2) {
  Z && (n2 = Z(n2)), n2.persist = function() {
  };
  var t2 = false, e2 = false, r2 = n2.stopPropagation;
  n2.stopPropagation = function() {
    r2.call(n2), t2 = true;
  };
  var o2 = n2.preventDefault;
  return n2.preventDefault = function() {
    o2.call(n2), e2 = true;
  }, n2.isPropagationStopped = function() {
    return t2;
  }, n2.isDefaultPrevented = function() {
    return e2;
  }, n2.nativeEvent = n2;
};
var $$1 = { configurable: true, get: function() {
  return this.class;
} }, q$2 = n$1.vnode;
n$1.vnode = function(n2) {
  n2.$$typeof = H$1;
  var t2 = n2.type, e2 = n2.props;
  if (t2) {
    if (e2.class != e2.className && ($$1.enumerable = "className" in e2, e2.className != null && (e2.class = e2.className), Object.defineProperty(e2, "className", $$1)), typeof t2 != "function") {
      var r2, o2, u2;
      for (u2 in e2.defaultValue && e2.value !== void 0 && (e2.value || e2.value === 0 || (e2.value = e2.defaultValue), delete e2.defaultValue), Array.isArray(e2.value) && e2.multiple && t2 === "select" && (x$4(e2.children).forEach(function(n3) {
        e2.value.indexOf(n3.props.value) != -1 && (n3.props.selected = true);
      }), delete e2.value), e2)
        if (r2 = D$1.test(u2))
          break;
      if (r2)
        for (u2 in o2 = n2.props = {}, e2)
          o2[D$1.test(u2) ? u2.replace(/[A-Z0-9]/, "-$&").toLowerCase() : u2] = e2[u2];
    }
    !function(t3) {
      var e3 = n2.type, r3 = n2.props;
      if (r3 && typeof e3 == "string") {
        var o3 = {};
        for (var u3 in r3)
          /^on(Ani|Tra|Tou)/.test(u3) && (r3[u3.toLowerCase()] = r3[u3], delete r3[u3]), o3[u3.toLowerCase()] = u3;
        if (o3.ondoubleclick && (r3.ondblclick = r3[o3.ondoubleclick], delete r3[o3.ondoubleclick]), o3.onbeforeinput && (r3.onbeforeinput = r3[o3.onbeforeinput], delete r3[o3.onbeforeinput]), o3.onchange && (e3 === "textarea" || e3.toLowerCase() === "input" && !/^fil|che|ra/i.test(r3.type))) {
          var i2 = o3.oninput || "oninput";
          r3[i2] || (r3[i2] = r3[o3.onchange], delete r3[o3.onchange]);
        }
      }
    }(), typeof t2 == "function" && !t2.m && t2.prototype && (I$1(t2.prototype, "componentWillMount"), I$1(t2.prototype, "componentWillReceiveProps"), I$1(t2.prototype, "componentWillUpdate"), t2.m = true);
  }
  q$2 && q$2(n2);
};
var B$1 = "16.8.0";
function G(n2) {
  return h$3.bind(null, n2);
}
function J(n2) {
  return !!n2 && n2.$$typeof === H$1;
}
function K(n2) {
  return J(n2) ? L$2.apply(null, arguments) : n2;
}
function Q(n2) {
  return !!n2.__k && (H$2(null, n2), true);
}
function X(n2) {
  return n2 && (n2.base || n2.nodeType === 1 && n2) || null;
}
var Y = function(n2, t2) {
  return n2(t2);
};
var compat_module = { useState: m$2, useReducer: p$2, useEffect: l$2, useLayoutEffect: y$2, useRef: d$2, useImperativeHandle: s$2, useMemo: h$2, useCallback: T$3, useContext: w$3, useDebugValue: A$3, version: "16.8.0", Children: R, render: T$2, hydrate: T$2, unmountComponentAtNode: Q, createPortal: z$2, createElement: h$3, createContext: M$2, createFactory: G, cloneElement: K, createRef: y$3, Fragment: d$3, isValidElement: J, findDOMNode: X, Component: m$3, PureComponent: C$1, memo: _$2, forwardRef: S$1, unstable_batchedUpdates: Y, Suspense: U, SuspenseList: O$1, lazy: L$1 };
var compat_module$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": compat_module,
  version: B$1,
  Children: R,
  render: T$2,
  hydrate: V,
  unmountComponentAtNode: Q,
  createPortal: z$2,
  createFactory: G,
  cloneElement: K,
  isValidElement: J,
  findDOMNode: X,
  PureComponent: C$1,
  memo: _$2,
  forwardRef: S$1,
  unstable_batchedUpdates: Y,
  Suspense: U,
  SuspenseList: O$1,
  lazy: L$1,
  createElement: h$3,
  createContext: M$2,
  createRef: y$3,
  Fragment: d$3,
  Component: m$3,
  useState: m$2,
  useReducer: p$2,
  useEffect: l$2,
  useLayoutEffect: y$2,
  useRef: d$2,
  useImperativeHandle: s$2,
  useMemo: h$2,
  useCallback: T$3,
  useContext: w$3,
  useDebugValue: A$3,
  useErrorBoundary: F$2
});
var require$$3 = /* @__PURE__ */ getAugmentedNamespace(compat_module$1);
function _interopDefault(ex) {
  return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
}
var browserUtils = require$$0$1;
var QRCode$3 = _interopDefault(browser$1);
var copy = _interopDefault(copyToClipboard);
var React = require$$3;
function open(uri) {
  QRCode$3.toString(uri, {
    type: "terminal"
  }).then(console.log);
}
var WALLETCONNECT_STYLE_SHEET = ':root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, "SF Pro Rounded", "SF Pro Text", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,\n    "Open Sans", "Helvetica Neue", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url("images/wc-logo.svg") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n';
typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
function _catch(body, recover3) {
  try {
    var result = body();
  } catch (e2) {
    return recover3(e2);
  }
  if (result && result.then) {
    return result.then(void 0, recover3);
  }
  return result;
}
var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8'?%3E %3Csvg width='300px' height='185px' viewBox='0 0 300 185' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E %3C!-- Generator: Sketch 49.3 (51167) - http://www.bohemiancoding.com/sketch --%3E %3Ctitle%3EWalletConnect%3C/title%3E %3Cdesc%3ECreated with Sketch.%3C/desc%3E %3Cdefs%3E%3C/defs%3E %3Cg id='Page-1' stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'%3E %3Cg id='walletconnect-logo-alt' fill='%233B99FC' fill-rule='nonzero'%3E %3Cpath d='M61.4385429,36.2562612 C110.349767,-11.6319051 189.65053,-11.6319051 238.561752,36.2562612 L244.448297,42.0196786 C246.893858,44.4140867 246.893858,48.2961898 244.448297,50.690599 L224.311602,70.406102 C223.088821,71.6033071 221.106302,71.6033071 219.883521,70.406102 L211.782937,62.4749541 C177.661245,29.0669724 122.339051,29.0669724 88.2173582,62.4749541 L79.542302,70.9685592 C78.3195204,72.1657633 76.337001,72.1657633 75.1142214,70.9685592 L54.9775265,51.2530561 C52.5319653,48.8586469 52.5319653,44.9765439 54.9775265,42.5821357 L61.4385429,36.2562612 Z M280.206339,77.0300061 L298.128036,94.5769031 C300.573585,96.9713 300.573599,100.85338 298.128067,103.247793 L217.317896,182.368927 C214.872352,184.763353 210.907314,184.76338 208.461736,182.368989 C208.461726,182.368979 208.461714,182.368967 208.461704,182.368957 L151.107561,126.214385 C150.496171,125.615783 149.504911,125.615783 148.893521,126.214385 C148.893517,126.214389 148.893514,126.214393 148.89351,126.214396 L91.5405888,182.368927 C89.095052,184.763359 85.1300133,184.763399 82.6844276,182.369014 C82.6844133,182.369 82.684398,182.368986 82.6843827,182.36897 L1.87196327,103.246785 C-0.573596939,100.852377 -0.573596939,96.9702735 1.87196327,94.5758653 L19.7936929,77.028998 C22.2392531,74.6345898 26.2042918,74.6345898 28.6498531,77.028998 L86.0048306,133.184355 C86.6162214,133.782957 87.6074796,133.782957 88.2188704,133.184355 C88.2188796,133.184346 88.2188878,133.184338 88.2188969,133.184331 L145.571,77.028998 C148.016505,74.6345347 151.981544,74.6344449 154.427161,77.028798 C154.427195,77.0288316 154.427229,77.0288653 154.427262,77.028899 L211.782164,133.184331 C212.393554,133.782932 213.384814,133.782932 213.996204,133.184331 L271.350179,77.0300061 C273.79574,74.6355969 277.760778,74.6355969 280.206339,77.0300061 Z' id='WalletConnect'%3E%3C/path%3E %3C/g%3E %3C/g%3E %3C/svg%3E";
var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
var ANIMATION_DURATION = 300;
var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";
function Header(props) {
  return React.createElement("div", {
    className: "walletconnect-modal__header"
  }, React.createElement("img", {
    src: WALLETCONNECT_LOGO_SVG_URL,
    className: "walletconnect-modal__headerLogo"
  }), React.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React.createElement("div", {
    className: "walletconnect-modal__close__wrapper",
    onClick: props.onClose
  }, React.createElement("div", {
    id: WALLETCONNECT_CLOSE_BUTTON_ID,
    className: "walletconnect-modal__close__icon"
  }, React.createElement("div", {
    className: "walletconnect-modal__close__line1"
  }), React.createElement("div", {
    className: "walletconnect-modal__close__line2"
  }))));
}
function ConnectButton(props) {
  return React.createElement("a", {
    className: "walletconnect-connect__button",
    href: props.href,
    id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props.name,
    onClick: props.onClick,
    rel: "noopener noreferrer",
    style: {
      backgroundColor: props.color
    },
    target: "_blank"
  }, props.name);
}
var CARET_SVG_URL = "data:image/svg+xml,%3Csvg width='8' height='18' viewBox='0 0 8 18' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M0.586301 0.213898C0.150354 0.552968 0.0718197 1.18124 0.41089 1.61719L5.2892 7.88931C5.57007 8.25042 5.57007 8.75608 5.2892 9.11719L0.410889 15.3893C0.071819 15.8253 0.150353 16.4535 0.586301 16.7926C1.02225 17.1317 1.65052 17.0531 1.98959 16.6172L6.86791 10.3451C7.7105 9.26174 7.7105 7.74476 6.86791 6.66143L1.98959 0.38931C1.65052 -0.0466374 1.02225 -0.125172 0.586301 0.213898Z' fill='%233C4252'/%3E %3C/svg%3E";
function WalletButton(props) {
  var color = props.color;
  var href = props.href;
  var name2 = props.name;
  var logo = props.logo;
  var onClick = props.onClick;
  return React.createElement("a", {
    className: "walletconnect-modal__base__row",
    href,
    onClick,
    rel: "noopener noreferrer",
    target: "_blank"
  }, React.createElement("h3", {
    className: "walletconnect-modal__base__row__h3"
  }, name2), React.createElement("div", {
    className: "walletconnect-modal__base__row__right"
  }, React.createElement("div", {
    className: "walletconnect-modal__base__row__right__app-icon",
    style: {
      background: "url('" + logo + "') " + color,
      backgroundSize: "100%"
    }
  }), React.createElement("img", {
    src: CARET_SVG_URL,
    className: "walletconnect-modal__base__row__right__caret"
  })));
}
function WalletIcon(props) {
  var color = props.color;
  var href = props.href;
  var name2 = props.name;
  var logo = props.logo;
  var onClick = props.onClick;
  var fontSize = window.innerWidth < 768 ? (name2.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
  return React.createElement("a", {
    className: "walletconnect-connect__button__icon_anchor",
    href,
    onClick,
    rel: "noopener noreferrer",
    target: "_blank"
  }, React.createElement("div", {
    className: "walletconnect-connect__button__icon",
    style: {
      background: "url('" + logo + "') " + color,
      backgroundSize: "100%"
    }
  }), React.createElement("div", {
    style: {
      fontSize
    },
    className: "walletconnect-connect__button__text"
  }, name2));
}
var GRID_MIN_COUNT = 5;
var LINKS_PER_PAGE = 12;
function LinkDisplay(props) {
  var android = browserUtils.isAndroid();
  var ref2 = React.useState("");
  var input = ref2[0];
  var setInput = ref2[1];
  var ref$1 = React.useState("");
  var filter2 = ref$1[0];
  var setFilter = ref$1[1];
  var ref$2 = React.useState(1);
  var page = ref$2[0];
  var setPage = ref$2[1];
  var links = filter2 ? props.links.filter(function(link) {
    return link.name.toLowerCase().includes(filter2.toLowerCase());
  }) : props.links;
  var errorMessage = props.errorMessage;
  var grid = filter2 || links.length > GRID_MIN_COUNT;
  var pages = Math.ceil(links.length / LINKS_PER_PAGE);
  var range2 = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
  var pageLinks = links.length ? links.filter(function(_2, index2) {
    return index2 + 1 >= range2[0] && index2 + 1 <= range2[1];
  }) : [];
  var hasPaging = !!(!android && pages > 1);
  var filterTimeout = void 0;
  function handleInput(e2) {
    setInput(e2.target.value);
    clearTimeout(filterTimeout);
    if (e2.target.value) {
      filterTimeout = setTimeout(function() {
        setFilter(e2.target.value);
        setPage(1);
      }, 1e3);
    } else {
      setInput("");
      setFilter("");
      setPage(1);
    }
  }
  return React.createElement("div", null, React.createElement("p", {
    id: WALLETCONNECT_CTA_TEXT_ID,
    className: "walletconnect-qrcode__text"
  }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React.createElement("input", {
    className: "walletconnect-search__input",
    placeholder: "Search",
    value: input,
    onChange: handleInput
  }), React.createElement("div", {
    className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
  }, !android ? pageLinks.length ? pageLinks.map(function(entry) {
    var color = entry.color;
    var name2 = entry.name;
    var shortName = entry.shortName;
    var logo = entry.logo;
    var href = browserUtils.formatIOSMobile(props.uri, entry);
    var handleClickIOS = React.useCallback(function() {
      browserUtils.saveMobileLinkInfo({
        name: name2,
        href
      });
    }, [pageLinks]);
    return !grid ? React.createElement(WalletButton, {
      color,
      href,
      name: name2,
      logo,
      onClick: handleClickIOS
    }) : React.createElement(WalletIcon, {
      color,
      href,
      name: shortName,
      logo,
      onClick: handleClickIOS
    });
  }) : React.createElement(React.Fragment, null, React.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React.createElement(ConnectButton, {
    name: props.text.connect,
    color: DEFAULT_BUTTON_COLOR,
    href: props.uri,
    onClick: React.useCallback(function() {
      browserUtils.saveMobileLinkInfo({
        name: "Unknown",
        href: props.uri
      });
    }, [])
  })), hasPaging && React.createElement("div", {
    className: "walletconnect-modal__footer"
  }, Array(pages).fill(0).map(function(_2, index2) {
    var pageNumber = index2 + 1;
    var selected = page === pageNumber;
    return React.createElement("a", {
      style: {
        margin: "auto 10px",
        fontWeight: selected ? "bold" : "normal"
      },
      onClick: function() {
        return setPage(pageNumber);
      }
    }, pageNumber);
  })));
}
function Notification$1(props) {
  var show = !!props.message.trim();
  return React.createElement("div", {
    className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
  }, props.message);
}
var formatQRCodeImage = function(data) {
  try {
    var result = "";
    return Promise.resolve(QRCode$3.toString(data, {
      margin: 0,
      type: "svg"
    })).then(function(dataString) {
      if (typeof dataString === "string") {
        result = dataString.replace("<svg", '<svg class="walletconnect-qrcode__image"');
      }
      return result;
    });
  } catch (e2) {
    return Promise.reject(e2);
  }
};
function QRCodeDisplay(props) {
  var ref2 = React.useState("");
  var notification = ref2[0];
  var setNotification = ref2[1];
  var ref$1 = React.useState("");
  var svg = ref$1[0];
  var setSvg = ref$1[1];
  React.useEffect(function() {
    try {
      return Promise.resolve(formatQRCodeImage(props.uri)).then(function(_formatQRCodeImage) {
        setSvg(_formatQRCodeImage);
      });
    } catch (e2) {
      Promise.reject(e2);
    }
  }, []);
  var copyToClipboard2 = function() {
    var success = copy(props.uri);
    if (success) {
      setNotification(props.text.copied_to_clipboard);
      setInterval(function() {
        return setNotification("");
      }, 1200);
    } else {
      setNotification("Error");
      setInterval(function() {
        return setNotification("");
      }, 1200);
    }
  };
  return React.createElement("div", null, React.createElement("p", {
    id: WALLETCONNECT_CTA_TEXT_ID,
    className: "walletconnect-qrcode__text"
  }, props.text.scan_qrcode_with_wallet), React.createElement("div", {
    dangerouslySetInnerHTML: {
      __html: svg
    }
  }), React.createElement("div", {
    className: "walletconnect-modal__footer"
  }, React.createElement("a", {
    onClick: copyToClipboard2
  }, props.text.copy_to_clipboard)), React.createElement(Notification$1, {
    message: notification
  }));
}
function Modal(props) {
  var android = browserUtils.isAndroid();
  var mobile = browserUtils.isMobile();
  var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : void 0 : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : void 0;
  var ref2 = React.useState(false);
  var loading = ref2[0];
  var setLoading = ref2[1];
  var ref$1 = React.useState(false);
  var fetched = ref$1[0];
  var setFetched = ref$1[1];
  var ref$2 = React.useState(!mobile);
  var displayQRCode = ref$2[0];
  var setDisplayQRCode = ref$2[1];
  var displayProps = {
    mobile,
    text: props.text,
    uri: props.uri,
    qrcodeModalOptions: props.qrcodeModalOptions
  };
  var ref$3 = React.useState("");
  var singleLinkHref = ref$3[0];
  var setSingleLinkHref = ref$3[1];
  var ref$4 = React.useState(false);
  var hasSingleLink = ref$4[0];
  var setHasSingleLink = ref$4[1];
  var ref$5 = React.useState([]);
  var links = ref$5[0];
  var setLinks = ref$5[1];
  var ref$6 = React.useState("");
  var errorMessage = ref$6[0];
  var setErrorMessage = ref$6[1];
  var getLinksIfNeeded = function() {
    if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
      return;
    }
    React.useEffect(function() {
      var initLinks = function() {
        try {
          if (android) {
            return Promise.resolve();
          }
          setLoading(true);
          var _temp = _catch(function() {
            var url2 = props.qrcodeModalOptions && props.qrcodeModalOptions.registryUrl ? props.qrcodeModalOptions.registryUrl : browserUtils.getWalletRegistryUrl();
            return Promise.resolve(fetch(url2).then(function(x2) {
              return x2.json();
            })).then(function(registry) {
              var platform = mobile ? "mobile" : "desktop";
              var _links = browserUtils.getMobileLinkRegistry(browserUtils.formatMobileRegistry(registry, platform), whitelist);
              setLoading(false);
              setFetched(true);
              setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
              setLinks(_links);
              var hasSingleLink2 = _links.length === 1;
              if (hasSingleLink2) {
                setSingleLinkHref(browserUtils.formatIOSMobile(props.uri, _links[0]));
                setDisplayQRCode(true);
              }
              setHasSingleLink(hasSingleLink2);
            });
          }, function(e2) {
            setLoading(false);
            setFetched(true);
            setErrorMessage(props.text.something_went_wrong);
            console.error(e2);
          });
          return Promise.resolve(_temp && _temp.then ? _temp.then(function() {
          }) : void 0);
        } catch (e2) {
          return Promise.reject(e2);
        }
      };
      initLinks();
    });
  };
  getLinksIfNeeded();
  var rightSelected = mobile ? displayQRCode : !displayQRCode;
  return React.createElement("div", {
    id: WALLETCONNECT_MODAL_ID,
    className: "walletconnect-qrcode__base animated fadeIn"
  }, React.createElement("div", {
    className: "walletconnect-modal__base"
  }, React.createElement(Header, {
    onClose: props.onClose
  }), hasSingleLink && displayQRCode ? React.createElement("div", {
    className: "walletconnect-modal__single_wallet"
  }, React.createElement("a", {
    onClick: function() {
      return browserUtils.saveMobileLinkInfo({
        name: links[0].name,
        href: singleLinkHref
      });
    },
    href: singleLinkHref,
    rel: "noopener noreferrer",
    target: "_blank"
  }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " \u203A")) : android || loading || !loading && links.length ? React.createElement("div", {
    className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
  }, React.createElement("div", {
    className: "walletconnect-modal__mobile__toggle_selector"
  }), mobile ? React.createElement(React.Fragment, null, React.createElement("a", {
    onClick: function() {
      return setDisplayQRCode(false), getLinksIfNeeded();
    }
  }, props.text.mobile), React.createElement("a", {
    onClick: function() {
      return setDisplayQRCode(true);
    }
  }, props.text.qrcode)) : React.createElement(React.Fragment, null, React.createElement("a", {
    onClick: function() {
      return setDisplayQRCode(true);
    }
  }, props.text.qrcode), React.createElement("a", {
    onClick: function() {
      return setDisplayQRCode(false), getLinksIfNeeded();
    }
  }, props.text.desktop))) : null, React.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React.createElement(LinkDisplay, Object.assign({}, displayProps, {
    links,
    errorMessage
  })))));
}
var de = {
  choose_preferred_wallet: "W\xE4hle bevorzugte Wallet",
  connect_mobile_wallet: "Verbinde mit Mobile Wallet",
  scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
  connect: "Verbinden",
  qrcode: "QR-Code",
  mobile: "Mobile",
  desktop: "Desktop",
  copy_to_clipboard: "In die Zwischenablage kopieren",
  copied_to_clipboard: "In die Zwischenablage kopiert!",
  connect_with: "Verbinden mit Hilfe von",
  loading: "Laden...",
  something_went_wrong: "Etwas ist schief gelaufen",
  no_supported_wallets: "Es gibt noch keine unterst\xFCtzten Wallet",
  no_wallets_found: "keine Wallet gefunden"
};
var en = {
  choose_preferred_wallet: "Choose your preferred wallet",
  connect_mobile_wallet: "Connect to Mobile Wallet",
  scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
  connect: "Connect",
  qrcode: "QR Code",
  mobile: "Mobile",
  desktop: "Desktop",
  copy_to_clipboard: "Copy to clipboard",
  copied_to_clipboard: "Copied to clipboard!",
  connect_with: "Connect with",
  loading: "Loading...",
  something_went_wrong: "Something went wrong",
  no_supported_wallets: "There are no supported wallets yet",
  no_wallets_found: "No wallets found"
};
var es = {
  choose_preferred_wallet: "Elige tu billetera preferida",
  connect_mobile_wallet: "Conectar a billetera m\xF3vil",
  scan_qrcode_with_wallet: "Escanea el c\xF3digo QR con una billetera compatible con WalletConnect",
  connect: "Conectar",
  qrcode: "C\xF3digo QR",
  mobile: "M\xF3vil",
  desktop: "Desktop",
  copy_to_clipboard: "Copiar",
  copied_to_clipboard: "Copiado!",
  connect_with: "Conectar mediante",
  loading: "Cargando...",
  something_went_wrong: "Algo sali\xF3 mal",
  no_supported_wallets: "Todav\xEDa no hay billeteras compatibles",
  no_wallets_found: "No se encontraron billeteras"
};
var fr = {
  choose_preferred_wallet: "Choisissez votre portefeuille pr\xE9f\xE9r\xE9",
  connect_mobile_wallet: "Se connecter au portefeuille mobile",
  scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
  connect: "Se connecter",
  qrcode: "QR Code",
  mobile: "Mobile",
  desktop: "Desktop",
  copy_to_clipboard: "Copier",
  copied_to_clipboard: "Copi\xE9!",
  connect_with: "Connectez-vous \xE0 l'aide de",
  loading: "Chargement...",
  something_went_wrong: "Quelque chose a mal tourn\xE9",
  no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
  no_wallets_found: "Aucun portefeuille trouv\xE9"
};
var ko = {
  choose_preferred_wallet: "\uC6D0\uD558\uB294 \uC9C0\uAC11\uC744 \uC120\uD0DD\uD558\uC138\uC694",
  connect_mobile_wallet: "\uBAA8\uBC14\uC77C \uC9C0\uAC11\uACFC \uC5F0\uACB0",
  scan_qrcode_with_wallet: "WalletConnect \uC9C0\uC6D0 \uC9C0\uAC11\uC5D0\uC11C QR\uCF54\uB4DC\uB97C \uC2A4\uCE94\uD558\uC138\uC694",
  connect: "\uC5F0\uACB0",
  qrcode: "QR \uCF54\uB4DC",
  mobile: "\uBAA8\uBC14\uC77C",
  desktop: "\uB370\uC2A4\uD06C\uD0D1",
  copy_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC",
  copied_to_clipboard: "\uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4!",
  connect_with: "\uC640 \uC5F0\uACB0\uD558\uB2E4",
  loading: "\uB85C\uB4DC \uC911...",
  something_went_wrong: "\uBB38\uC81C\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.",
  no_supported_wallets: "\uC544\uC9C1 \uC9C0\uC6D0\uB418\uB294 \uC9C0\uAC11\uC774 \uC5C6\uC2B5\uB2C8\uB2E4",
  no_wallets_found: "\uC9C0\uAC11\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4"
};
var pt = {
  choose_preferred_wallet: "Escolha sua carteira preferida",
  connect_mobile_wallet: "Conectar-se \xE0 carteira m\xF3vel",
  scan_qrcode_with_wallet: "Ler o c\xF3digo QR com uma carteira compat\xEDvel com WalletConnect",
  connect: "Conectar",
  qrcode: "C\xF3digo QR",
  mobile: "M\xF3vel",
  desktop: "Desktop",
  copy_to_clipboard: "Copiar",
  copied_to_clipboard: "Copiado!",
  connect_with: "Ligar por meio de",
  loading: "Carregamento...",
  something_went_wrong: "Algo correu mal",
  no_supported_wallets: "Ainda n\xE3o h\xE1 carteiras suportadas",
  no_wallets_found: "Nenhuma carteira encontrada"
};
var zh = {
  choose_preferred_wallet: "\u9009\u62E9\u4F60\u7684\u94B1\u5305",
  connect_mobile_wallet: "\u8FDE\u63A5\u81F3\u79FB\u52A8\u7AEF\u94B1\u5305",
  scan_qrcode_with_wallet: "\u4F7F\u7528\u517C\u5BB9 WalletConnect \u7684\u94B1\u5305\u626B\u63CF\u4E8C\u7EF4\u7801",
  connect: "\u8FDE\u63A5",
  qrcode: "\u4E8C\u7EF4\u7801",
  mobile: "\u79FB\u52A8",
  desktop: "\u684C\u9762",
  copy_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
  copied_to_clipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F\u6210\u529F\uFF01",
  connect_with: "\u901A\u8FC7\u4EE5\u4E0B\u65B9\u5F0F\u8FDE\u63A5",
  loading: "\u6B63\u5728\u52A0\u8F7D...",
  something_went_wrong: "\u51FA\u4E86\u95EE\u9898",
  no_supported_wallets: "\u76EE\u524D\u8FD8\u6CA1\u6709\u652F\u6301\u7684\u94B1\u5305",
  no_wallets_found: "\u6CA1\u6709\u627E\u5230\u94B1\u5305"
};
var fa = {
  choose_preferred_wallet: "\u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0631\u062F \u0646\u0638\u0631 \u062E\u0648\u062F \u0631\u0627 \u0627\u0646\u062A\u062E\u0627\u0628 \u06A9\u0646\u06CC\u062F",
  connect_mobile_wallet: "\u0628\u0647 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0645\u0648\u0628\u0627\u06CC\u0644 \u0648\u0635\u0644 \u0634\u0648\u06CC\u062F",
  scan_qrcode_with_wallet: "\u06A9\u062F QR \u0631\u0627 \u0628\u0627 \u06CC\u06A9 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u0633\u0627\u0632\u06AF\u0627\u0631 \u0628\u0627 WalletConnect \u0627\u0633\u06A9\u0646 \u06A9\u0646\u06CC\u062F",
  connect: "\u0627\u062A\u0635\u0627\u0644",
  qrcode: "\u06A9\u062F QR",
  mobile: "\u0633\u06CC\u0627\u0631",
  desktop: "\u062F\u0633\u06A9\u062A\u0627\u067E",
  copy_to_clipboard: "\u06A9\u067E\u06CC \u0628\u0647 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F",
  copied_to_clipboard: "\u062F\u0631 \u06A9\u0644\u06CC\u067E \u0628\u0648\u0631\u062F \u06A9\u067E\u06CC \u0634\u062F!",
  connect_with: "\u0627\u0631\u062A\u0628\u0627\u0637 \u0628\u0627",
  loading: "...\u0628\u0627\u0631\u06AF\u0630\u0627\u0631\u06CC",
  something_went_wrong: "\u0645\u0634\u06A9\u0644\u06CC \u067E\u06CC\u0634 \u0622\u0645\u062F",
  no_supported_wallets: "\u0647\u0646\u0648\u0632 \u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644 \u067E\u0634\u062A\u06CC\u0628\u0627\u0646\u06CC \u0634\u062F\u0647 \u0627\u06CC \u0648\u062C\u0648\u062F \u0646\u062F\u0627\u0631\u062F",
  no_wallets_found: "\u0647\u06CC\u0686 \u06A9\u06CC\u0641 \u067E\u0648\u0644\u06CC \u067E\u06CC\u062F\u0627 \u0646\u0634\u062F"
};
var languages = {
  de,
  en,
  es,
  fr,
  ko,
  pt,
  zh,
  fa
};
function injectStyleSheet() {
  var doc2 = browserUtils.getDocumentOrThrow();
  var prev = doc2.getElementById(WALLETCONNECT_STYLE_ID);
  if (prev) {
    doc2.head.removeChild(prev);
  }
  var style = doc2.createElement("style");
  style.setAttribute("id", WALLETCONNECT_STYLE_ID);
  style.innerText = WALLETCONNECT_STYLE_SHEET;
  doc2.head.appendChild(style);
}
function renderWrapper() {
  var doc2 = browserUtils.getDocumentOrThrow();
  var wrapper = doc2.createElement("div");
  wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
  doc2.body.appendChild(wrapper);
  return wrapper;
}
function triggerCloseAnimation() {
  var doc2 = browserUtils.getDocumentOrThrow();
  var modal = doc2.getElementById(WALLETCONNECT_MODAL_ID);
  if (modal) {
    modal.className = modal.className.replace("fadeIn", "fadeOut");
    setTimeout(function() {
      var wrapper = doc2.getElementById(WALLETCONNECT_WRAPPER_ID);
      if (wrapper) {
        doc2.body.removeChild(wrapper);
      }
    }, ANIMATION_DURATION);
  }
}
function getWrappedCallback(cb) {
  return function() {
    triggerCloseAnimation();
    if (cb) {
      cb();
    }
  };
}
function getText() {
  var lang = browserUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
  return languages[lang] || languages["en"];
}
function open$1(uri, cb, qrcodeModalOptions) {
  injectStyleSheet();
  var wrapper = renderWrapper();
  React.render(React.createElement(Modal, {
    text: getText(),
    uri,
    onClose: getWrappedCallback(cb),
    qrcodeModalOptions
  }), wrapper);
}
function close$1() {
  triggerCloseAnimation();
}
var isNode = function() {
  return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
};
function open$2(uri, cb, qrcodeModalOptions) {
  console.log(uri);
  if (isNode()) {
    open(uri);
  } else {
    open$1(uri, cb, qrcodeModalOptions);
  }
}
function close$2() {
  if (isNode())
    ;
  else {
    close$1();
  }
}
var index = {
  open: open$2,
  close: close$2
};
var cjs = index;
var eventemitter3 = { exports: {} };
(function(module2) {
  var has2 = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once3) {
    this.fn = fn;
    this.context = context;
    this.once = once3 || false;
  }
  function addListener2(emitter, event, fn, context, once3) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once3), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames2() {
    var names2 = [], events2, name2;
    if (this._eventsCount === 0)
      return names2;
    for (name2 in events2 = this._events) {
      if (has2.call(events2, name2))
        names2.push(prefix ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events2));
    }
    return names2;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers2 = this._events[evt];
    if (!handlers2)
      return [];
    if (handlers2.fn)
      return [handlers2.fn];
    for (var i2 = 0, l2 = handlers2.length, ee = new Array(l2); i2 < l2; i2++) {
      ee[i2] = handlers2[i2].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len2 = arguments.length, args, i2;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len2) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len2 - 1); i2 < len2; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length = listeners2.length, j2;
      for (i2 = 0; i2 < length; i2++) {
        if (listeners2[i2].once)
          this.removeListener(event, listeners2[i2].fn, void 0, true);
        switch (len2) {
          case 1:
            listeners2[i2].fn.call(listeners2[i2].context);
            break;
          case 2:
            listeners2[i2].fn.call(listeners2[i2].context, a1);
            break;
          case 3:
            listeners2[i2].fn.call(listeners2[i2].context, a1, a2);
            break;
          case 4:
            listeners2[i2].fn.call(listeners2[i2].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j2 = 1, args = new Array(len2 - 1); j2 < len2; j2++) {
                args[j2 - 1] = arguments[j2];
              }
            listeners2[i2].fn.apply(listeners2[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener2(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once3(event, fn, context) {
    return addListener2(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener2(event, fn, context, once3) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn && (!once3 || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events2 = [], length = listeners2.length; i2 < length; i2++) {
        if (listeners2[i2].fn !== fn || once3 && !listeners2[i2].once || context && listeners2[i2].context !== context) {
          events2.push(listeners2[i2]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module2.exports = EventEmitter2;
  }
})(eventemitter3);
var EventEmitter = eventemitter3.exports;
var dist$1 = {};
var xmlHttpRequest = {};
var url$1 = {};
var punycode$1 = { exports: {} };
/*! https://mths.be/punycode v1.3.2 by @mathias */
(function(module2, exports2) {
  (function(root2) {
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = module2 && !module2.nodeType && module2;
    var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal;
    if (freeGlobal2.global === freeGlobal2 || freeGlobal2.window === freeGlobal2 || freeGlobal2.self === freeGlobal2) {
      root2 = freeGlobal2;
    }
    var punycode2, maxInt = 2147483647, base2 = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors2 = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, baseMinusTMin = base2 - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key2;
    function error2(type) {
      throw RangeError(errors2[type]);
    }
    function map2(array2, fn) {
      var length = array2.length;
      var result = [];
      while (length--) {
        result[length] = fn(array2[length]);
      }
      return result;
    }
    function mapDomain(string2, fn) {
      var parts = string2.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string2 = parts[1];
      }
      string2 = string2.replace(regexSeparators, ".");
      var labels = string2.split(".");
      var encoded = map2(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string2) {
      var output = [], counter = 0, length = string2.length, value2, extra;
      while (counter < length) {
        value2 = string2.charCodeAt(counter++);
        if (value2 >= 55296 && value2 <= 56319 && counter < length) {
          extra = string2.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value2 & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value2);
            counter--;
          }
        } else {
          output.push(value2);
        }
      }
      return output;
    }
    function ucs2encode(array2) {
      return map2(array2, function(value2) {
        var output = "";
        if (value2 > 65535) {
          value2 -= 65536;
          output += stringFromCharCode(value2 >>> 10 & 1023 | 55296);
          value2 = 56320 | value2 & 1023;
        }
        output += stringFromCharCode(value2);
        return output;
      }).join("");
    }
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base2;
    }
    function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    function adapt(delta, numPoints, firstTime) {
      var k2 = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k2 += base2) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    function decode2(input) {
      var output = [], inputLength = input.length, out, i2 = 0, n2 = initialN, bias = initialBias, basic, j2, index2, oldi, w2, k2, digit, t2, baseMinusT;
      basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (j2 = 0; j2 < basic; ++j2) {
        if (input.charCodeAt(j2) >= 128) {
          error2("not-basic");
        }
        output.push(input.charCodeAt(j2));
      }
      for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
        for (oldi = i2, w2 = 1, k2 = base2; ; k2 += base2) {
          if (index2 >= inputLength) {
            error2("invalid-input");
          }
          digit = basicToDigit(input.charCodeAt(index2++));
          if (digit >= base2 || digit > floor((maxInt - i2) / w2)) {
            error2("overflow");
          }
          i2 += digit * w2;
          t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (digit < t2) {
            break;
          }
          baseMinusT = base2 - t2;
          if (w2 > floor(maxInt / baseMinusT)) {
            error2("overflow");
          }
          w2 *= baseMinusT;
        }
        out = output.length + 1;
        bias = adapt(i2 - oldi, out, oldi == 0);
        if (floor(i2 / out) > maxInt - n2) {
          error2("overflow");
        }
        n2 += floor(i2 / out);
        i2 %= out;
        output.splice(i2++, 0, n2);
      }
      return ucs2encode(output);
    }
    function encode5(input) {
      var n2, delta, handledCPCount, basicLength, bias, j2, m2, q2, k2, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
      input = ucs2decode(input);
      inputLength = input.length;
      n2 = initialN;
      delta = 0;
      bias = initialBias;
      for (j2 = 0; j2 < inputLength; ++j2) {
        currentValue = input[j2];
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      handledCPCount = basicLength = output.length;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue >= n2 && currentValue < m2) {
            m2 = currentValue;
          }
        }
        handledCPCountPlusOne = handledCPCount + 1;
        if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error2("overflow");
        }
        delta += (m2 - n2) * handledCPCountPlusOne;
        n2 = m2;
        for (j2 = 0; j2 < inputLength; ++j2) {
          currentValue = input[j2];
          if (currentValue < n2 && ++delta > maxInt) {
            error2("overflow");
          }
          if (currentValue == n2) {
            for (q2 = delta, k2 = base2; ; k2 += base2) {
              t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (q2 < t2) {
                break;
              }
              qMinusT = q2 - t2;
              baseMinusT = base2 - t2;
              output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
              q2 = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q2, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n2;
      }
      return output.join("");
    }
    function toUnicode(input) {
      return mapDomain(input, function(string2) {
        return regexPunycode.test(string2) ? decode2(string2.slice(4).toLowerCase()) : string2;
      });
    }
    function toASCII(input) {
      return mapDomain(input, function(string2) {
        return regexNonASCII.test(string2) ? "xn--" + encode5(string2) : string2;
      });
    }
    punycode2 = {
      "version": "1.3.2",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode2,
      "encode": encode5,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    if (freeExports && freeModule) {
      if (module2.exports == freeExports) {
        freeModule.exports = punycode2;
      } else {
        for (key2 in punycode2) {
          punycode2.hasOwnProperty(key2) && (freeExports[key2] = punycode2[key2]);
        }
      }
    } else {
      root2.punycode = punycode2;
    }
  })(commonjsGlobal);
})(punycode$1, punycode$1.exports);
var util$5 = {
  isString: function(arg) {
    return typeof arg === "string";
  },
  isObject: function(arg) {
    return typeof arg === "object" && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};
var querystring$1 = {};
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var decode$1 = function(qs, sep, eq9, options) {
  sep = sep || "&";
  eq9 = eq9 || "=";
  var obj = {};
  if (typeof qs !== "string" || qs.length === 0) {
    return obj;
  }
  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1e3;
  if (options && typeof options.maxKeys === "number") {
    maxKeys = options.maxKeys;
  }
  var len2 = qs.length;
  if (maxKeys > 0 && len2 > maxKeys) {
    len2 = maxKeys;
  }
  for (var i2 = 0; i2 < len2; ++i2) {
    var x2 = qs[i2].replace(regexp, "%20"), idx = x2.indexOf(eq9), kstr, vstr, k2, v2;
    if (idx >= 0) {
      kstr = x2.substr(0, idx);
      vstr = x2.substr(idx + 1);
    } else {
      kstr = x2;
      vstr = "";
    }
    k2 = decodeURIComponent(kstr);
    v2 = decodeURIComponent(vstr);
    if (!hasOwnProperty(obj, k2)) {
      obj[k2] = v2;
    } else if (Array.isArray(obj[k2])) {
      obj[k2].push(v2);
    } else {
      obj[k2] = [obj[k2], v2];
    }
  }
  return obj;
};
var stringifyPrimitive = function(v2) {
  switch (typeof v2) {
    case "string":
      return v2;
    case "boolean":
      return v2 ? "true" : "false";
    case "number":
      return isFinite(v2) ? v2 : "";
    default:
      return "";
  }
};
var encode$1 = function(obj, sep, eq9, name2) {
  sep = sep || "&";
  eq9 = eq9 || "=";
  if (obj === null) {
    obj = void 0;
  }
  if (typeof obj === "object") {
    return Object.keys(obj).map(function(k2) {
      var ks = encodeURIComponent(stringifyPrimitive(k2)) + eq9;
      if (Array.isArray(obj[k2])) {
        return obj[k2].map(function(v2) {
          return ks + encodeURIComponent(stringifyPrimitive(v2));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k2]));
      }
    }).join(sep);
  }
  if (!name2)
    return "";
  return encodeURIComponent(stringifyPrimitive(name2)) + eq9 + encodeURIComponent(stringifyPrimitive(obj));
};
querystring$1.decode = querystring$1.parse = decode$1;
querystring$1.encode = querystring$1.stringify = encode$1;
var punycode = punycode$1.exports;
var util$4 = util$5;
url$1.parse = urlParse;
url$1.resolve = urlResolve;
url$1.resolveObject = urlResolveObject;
url$1.format = urlFormat;
url$1.Url = Url;
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  "javascript": true,
  "javascript:": true
}, hostlessProtocol = {
  "javascript": true,
  "javascript:": true
}, slashedProtocol = {
  "http": true,
  "https": true,
  "ftp": true,
  "gopher": true,
  "file": true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
}, querystring = querystring$1;
function urlParse(url2, parseQueryString2, slashesDenoteHost) {
  if (url2 && util$4.isObject(url2) && url2 instanceof Url)
    return url2;
  var u2 = new Url();
  u2.parse(url2, parseQueryString2, slashesDenoteHost);
  return u2;
}
Url.prototype.parse = function(url2, parseQueryString2, slashesDenoteHost) {
  if (!util$4.isString(url2)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url2);
  }
  var queryIndex = url2.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url2.indexOf("#") ? "?" : "#", uSplit = url2.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url2 = uSplit.join(splitter);
  var rest = url2;
  rest = rest.trim();
  if (!slashesDenoteHost && url2.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString2) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString2) {
        this.search = "";
        this.query = {};
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (var i2 = 0; i2 < hostEndingChars.length; i2++) {
      var hec = rest.indexOf(hostEndingChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (var i2 = 0; i2 < nonHostChars.length; i2++) {
      var hec = rest.indexOf(nonHostChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost();
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
        var part = hostparts[i2];
        if (!part)
          continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j2 = 0, k2 = part.length; j2 < k2; j2++) {
            if (part.charCodeAt(j2) > 127) {
              newpart += "x";
            } else {
              newpart += part[j2];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i2);
            var notHost = hostparts.slice(i2 + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    } else {
      this.hostname = this.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      this.hostname = punycode.toASCII(this.hostname);
    }
    var p2 = this.port ? ":" + this.port : "";
    var h2 = this.hostname || "";
    this.host = h2 + p2;
    this.href += this.host;
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (var i2 = 0, l2 = autoEscape.length; i2 < l2; i2++) {
      var ae = autoEscape[i2];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }
  var hash3 = rest.indexOf("#");
  if (hash3 !== -1) {
    this.hash = rest.substr(hash3);
    rest = rest.slice(0, hash3);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString2) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString2) {
    this.search = "";
    this.query = {};
  }
  if (rest)
    this.pathname = rest;
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "/";
  }
  if (this.pathname || this.search) {
    var p2 = this.pathname || "";
    var s2 = this.search || "";
    this.path = p2 + s2;
  }
  this.href = this.format();
  return this;
};
function urlFormat(obj) {
  if (util$4.isString(obj))
    obj = urlParse(obj);
  if (!(obj instanceof Url))
    return Url.prototype.format.call(obj);
  return obj.format();
}
Url.prototype.format = function() {
  var auth = this.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = this.protocol || "", pathname = this.pathname || "", hash3 = this.hash || "", host = false, query2 = "";
  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
    if (this.port) {
      host += ":" + this.port;
    }
  }
  if (this.query && util$4.isObject(this.query) && Object.keys(this.query).length) {
    query2 = querystring.stringify(this.query);
  }
  var search = this.search || query2 && "?" + query2 || "";
  if (protocol && protocol.substr(-1) !== ":")
    protocol += ":";
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash3 && hash3.charAt(0) !== "#")
    hash3 = "#" + hash3;
  if (search && search.charAt(0) !== "?")
    search = "?" + search;
  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash3;
};
function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}
Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};
function urlResolveObject(source, relative) {
  if (!source)
    return relative;
  return urlParse(source, false, true).resolveObject(relative);
}
Url.prototype.resolveObject = function(relative) {
  if (util$4.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }
  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }
  result.hash = relative.hash;
  if (relative.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative.slashes && !relative.protocol) {
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== "protocol")
        result[rkey] = relative[rkey];
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = "/";
    }
    result.href = result.format();
    return result;
  }
  if (relative.protocol && relative.protocol !== result.protocol) {
    if (!slashedProtocol[relative.protocol]) {
      var keys2 = Object.keys(relative);
      for (var v2 = 0; v2 < keys2.length; v2++) {
        var k2 = keys2[v2];
        result[k2] = relative[k2];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || "").split("/");
      while (relPath.length && !(relative.host = relPath.shift()))
        ;
      if (!relative.host)
        relative.host = "";
      if (!relative.hostname)
        relative.hostname = "";
      if (relPath[0] !== "")
        relPath.unshift("");
      if (relPath.length < 2)
        relPath.unshift("");
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || "";
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    if (result.pathname || result.search) {
      var p2 = result.pathname || "";
      var s2 = result.search || "";
      result.path = p2 + s2;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "")
        srcPath[0] = result.host;
      else
        srcPath.unshift(result.host);
    }
    result.host = "";
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === "")
          relPath[0] = relative.host;
        else
          relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  if (isRelAbs) {
    result.host = relative.host || relative.host === "" ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath)
      srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util$4.isNullOrUndefined(relative.search)) {
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    if (!util$4.isNull(result.pathname) || !util$4.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last2 = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last2 === "." || last2 === "..") || last2 === "";
  var up = 0;
  for (var i2 = srcPath.length; i2 >= 0; i2--) {
    last2 = srcPath[i2];
    if (last2 === ".") {
      srcPath.splice(i2, 1);
    } else if (last2 === "..") {
      srcPath.splice(i2, 1);
      up++;
    } else if (up) {
      srcPath.splice(i2, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift("");
  }
  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join("/");
  }
  if (!util$4.isNull(result.pathname) || !util$4.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};
Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host)
    this.hostname = host;
};
var progressEvent = {};
Object.defineProperty(progressEvent, "__esModule", { value: true });
var ProgressEvent = function() {
  function ProgressEvent2(type) {
    this.type = type;
    this.bubbles = false;
    this.cancelable = false;
    this.loaded = 0;
    this.lengthComputable = false;
    this.total = 0;
  }
  return ProgressEvent2;
}();
progressEvent.ProgressEvent = ProgressEvent;
var errors = {};
var __extends$3 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2)
      if (b2.hasOwnProperty(p2))
        d2[p2] = b2[p2];
  };
  return function(d2, b2) {
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(errors, "__esModule", { value: true });
var SecurityError = function(_super) {
  __extends$3(SecurityError2, _super);
  function SecurityError2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return SecurityError2;
}(Error);
errors.SecurityError = SecurityError;
var InvalidStateError = function(_super) {
  __extends$3(InvalidStateError2, _super);
  function InvalidStateError2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return InvalidStateError2;
}(Error);
errors.InvalidStateError = InvalidStateError;
var NetworkError = function(_super) {
  __extends$3(NetworkError2, _super);
  function NetworkError2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return NetworkError2;
}(Error);
errors.NetworkError = NetworkError;
var SyntaxError$1 = function(_super) {
  __extends$3(SyntaxError2, _super);
  function SyntaxError2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return SyntaxError2;
}(Error);
errors.SyntaxError = SyntaxError$1;
var xmlHttpRequestEventTarget = {};
Object.defineProperty(xmlHttpRequestEventTarget, "__esModule", { value: true });
var XMLHttpRequestEventTarget = function() {
  function XMLHttpRequestEventTarget2() {
    this.listeners = {};
  }
  XMLHttpRequestEventTarget2.prototype.addEventListener = function(eventType, listener) {
    eventType = eventType.toLowerCase();
    this.listeners[eventType] = this.listeners[eventType] || [];
    this.listeners[eventType].push(listener.handleEvent || listener);
  };
  XMLHttpRequestEventTarget2.prototype.removeEventListener = function(eventType, listener) {
    eventType = eventType.toLowerCase();
    if (!this.listeners[eventType]) {
      return;
    }
    var index2 = this.listeners[eventType].indexOf(listener.handleEvent || listener);
    if (index2 < 0) {
      return;
    }
    this.listeners[eventType].splice(index2, 1);
  };
  XMLHttpRequestEventTarget2.prototype.dispatchEvent = function(event) {
    var eventType = event.type.toLowerCase();
    event.target = this;
    if (this.listeners[eventType]) {
      for (var _i = 0, _a2 = this.listeners[eventType]; _i < _a2.length; _i++) {
        var listener_1 = _a2[_i];
        listener_1.call(this, event);
      }
    }
    var listener = this["on" + eventType];
    if (listener) {
      listener.call(this, event);
    }
    return true;
  };
  return XMLHttpRequestEventTarget2;
}();
xmlHttpRequestEventTarget.XMLHttpRequestEventTarget = XMLHttpRequestEventTarget;
var xmlHttpRequestUpload = {};
var __extends$2 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2)
      if (b2.hasOwnProperty(p2))
        d2[p2] = b2[p2];
  };
  return function(d2, b2) {
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
Object.defineProperty(xmlHttpRequestUpload, "__esModule", { value: true });
var xml_http_request_event_target_1$1 = xmlHttpRequestEventTarget;
var XMLHttpRequestUpload = function(_super) {
  __extends$2(XMLHttpRequestUpload2, _super);
  function XMLHttpRequestUpload2() {
    var _this = _super.call(this) || this;
    _this._contentType = null;
    _this._body = null;
    _this._reset();
    return _this;
  }
  XMLHttpRequestUpload2.prototype._reset = function() {
    this._contentType = null;
    this._body = null;
  };
  XMLHttpRequestUpload2.prototype._setData = function(data) {
    if (data == null) {
      return;
    }
    if (typeof data === "string") {
      if (data.length !== 0) {
        this._contentType = "text/plain;charset=UTF-8";
      }
      this._body = new buffer$2.Buffer(data, "utf-8");
    } else if (buffer$2.Buffer.isBuffer(data)) {
      this._body = data;
    } else if (data instanceof ArrayBuffer) {
      var body = new buffer$2.Buffer(data.byteLength);
      var view = new Uint8Array(data);
      for (var i2 = 0; i2 < data.byteLength; i2++) {
        body[i2] = view[i2];
      }
      this._body = body;
    } else if (data.buffer && data.buffer instanceof ArrayBuffer) {
      var body = new buffer$2.Buffer(data.byteLength);
      var offset = data.byteOffset;
      var view = new Uint8Array(data.buffer);
      for (var i2 = 0; i2 < data.byteLength; i2++) {
        body[i2] = view[i2 + offset];
      }
      this._body = body;
    } else {
      throw new Error("Unsupported send() data " + data);
    }
  };
  XMLHttpRequestUpload2.prototype._finalizeHeaders = function(headers, loweredHeaders) {
    if (this._contentType && !loweredHeaders["content-type"]) {
      headers["Content-Type"] = this._contentType;
    }
    if (this._body) {
      headers["Content-Length"] = this._body.length.toString();
    }
  };
  XMLHttpRequestUpload2.prototype._startUpload = function(request) {
    if (this._body) {
      request.write(this._body);
    }
    request.end();
  };
  return XMLHttpRequestUpload2;
}(xml_http_request_event_target_1$1.XMLHttpRequestEventTarget);
xmlHttpRequestUpload.XMLHttpRequestUpload = XMLHttpRequestUpload;
var cookiejar = {};
(function() {
  function CookieAccessInfo(domain2, path, secure, script2) {
    if (this instanceof CookieAccessInfo) {
      this.domain = domain2 || void 0;
      this.path = path || "/";
      this.secure = !!secure;
      this.script = !!script2;
      return this;
    }
    return new CookieAccessInfo(domain2, path, secure, script2);
  }
  CookieAccessInfo.All = Object.freeze(Object.create(null));
  cookiejar.CookieAccessInfo = CookieAccessInfo;
  function Cookie2(cookiestr, request_domain, request_path) {
    if (cookiestr instanceof Cookie2) {
      return cookiestr;
    }
    if (this instanceof Cookie2) {
      this.name = null;
      this.value = null;
      this.expiration_date = Infinity;
      this.path = String(request_path || "/");
      this.explicit_path = false;
      this.domain = request_domain || null;
      this.explicit_domain = false;
      this.secure = false;
      this.noscript = false;
      if (cookiestr) {
        this.parse(cookiestr, request_domain, request_path);
      }
      return this;
    }
    return new Cookie2(cookiestr, request_domain, request_path);
  }
  cookiejar.Cookie = Cookie2;
  Cookie2.prototype.toString = function toString2() {
    var str2 = [this.name + "=" + this.value];
    if (this.expiration_date !== Infinity) {
      str2.push("expires=" + new Date(this.expiration_date).toGMTString());
    }
    if (this.domain) {
      str2.push("domain=" + this.domain);
    }
    if (this.path) {
      str2.push("path=" + this.path);
    }
    if (this.secure) {
      str2.push("secure");
    }
    if (this.noscript) {
      str2.push("httponly");
    }
    return str2.join("; ");
  };
  Cookie2.prototype.toValueString = function toValueString() {
    return this.name + "=" + this.value;
  };
  var cookie_str_splitter = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;
  Cookie2.prototype.parse = function parse2(str2, request_domain, request_path) {
    if (this instanceof Cookie2) {
      var parts = str2.split(";").filter(function(value3) {
        return !!value3;
      });
      var i2;
      var pair = parts[0].match(/([^=]+)=([\s\S]*)/);
      if (!pair) {
        console.warn("Invalid cookie header encountered. Header: '" + str2 + "'");
        return;
      }
      var key2 = pair[1];
      var value2 = pair[2];
      if (typeof key2 !== "string" || key2.length === 0 || typeof value2 !== "string") {
        console.warn("Unable to extract values from cookie header. Cookie: '" + str2 + "'");
        return;
      }
      this.name = key2;
      this.value = value2;
      for (i2 = 1; i2 < parts.length; i2 += 1) {
        pair = parts[i2].match(/([^=]+)(?:=([\s\S]*))?/);
        key2 = pair[1].trim().toLowerCase();
        value2 = pair[2];
        switch (key2) {
          case "httponly":
            this.noscript = true;
            break;
          case "expires":
            this.expiration_date = value2 ? Number(Date.parse(value2)) : Infinity;
            break;
          case "path":
            this.path = value2 ? value2.trim() : "";
            this.explicit_path = true;
            break;
          case "domain":
            this.domain = value2 ? value2.trim() : "";
            this.explicit_domain = !!this.domain;
            break;
          case "secure":
            this.secure = true;
            break;
        }
      }
      if (!this.explicit_path) {
        this.path = request_path || "/";
      }
      if (!this.explicit_domain) {
        this.domain = request_domain;
      }
      return this;
    }
    return new Cookie2().parse(str2, request_domain, request_path);
  };
  Cookie2.prototype.matches = function matches(access_info) {
    if (access_info === CookieAccessInfo.All) {
      return true;
    }
    if (this.noscript && access_info.script || this.secure && !access_info.secure || !this.collidesWith(access_info)) {
      return false;
    }
    return true;
  };
  Cookie2.prototype.collidesWith = function collidesWith(access_info) {
    if (this.path && !access_info.path || this.domain && !access_info.domain) {
      return false;
    }
    if (this.path && access_info.path.indexOf(this.path) !== 0) {
      return false;
    }
    if (this.explicit_path && access_info.path.indexOf(this.path) !== 0) {
      return false;
    }
    var access_domain = access_info.domain && access_info.domain.replace(/^[\.]/, "");
    var cookie_domain = this.domain && this.domain.replace(/^[\.]/, "");
    if (cookie_domain === access_domain) {
      return true;
    }
    if (cookie_domain) {
      if (!this.explicit_domain) {
        return false;
      }
      var wildcard = access_domain.indexOf(cookie_domain);
      if (wildcard === -1 || wildcard !== access_domain.length - cookie_domain.length) {
        return false;
      }
      return true;
    }
    return true;
  };
  function CookieJar() {
    var cookies, cookies_list, collidable_cookie;
    if (this instanceof CookieJar) {
      cookies = Object.create(null);
      this.setCookie = function setCookie(cookie, request_domain, request_path) {
        var remove2, i2;
        cookie = new Cookie2(cookie, request_domain, request_path);
        remove2 = cookie.expiration_date <= Date.now();
        if (cookies[cookie.name] !== void 0) {
          cookies_list = cookies[cookie.name];
          for (i2 = 0; i2 < cookies_list.length; i2 += 1) {
            collidable_cookie = cookies_list[i2];
            if (collidable_cookie.collidesWith(cookie)) {
              if (remove2) {
                cookies_list.splice(i2, 1);
                if (cookies_list.length === 0) {
                  delete cookies[cookie.name];
                }
                return false;
              }
              cookies_list[i2] = cookie;
              return cookie;
            }
          }
          if (remove2) {
            return false;
          }
          cookies_list.push(cookie);
          return cookie;
        }
        if (remove2) {
          return false;
        }
        cookies[cookie.name] = [cookie];
        return cookies[cookie.name];
      };
      this.getCookie = function getCookie(cookie_name, access_info) {
        var cookie, i2;
        cookies_list = cookies[cookie_name];
        if (!cookies_list) {
          return;
        }
        for (i2 = 0; i2 < cookies_list.length; i2 += 1) {
          cookie = cookies_list[i2];
          if (cookie.expiration_date <= Date.now()) {
            if (cookies_list.length === 0) {
              delete cookies[cookie.name];
            }
            continue;
          }
          if (cookie.matches(access_info)) {
            return cookie;
          }
        }
      };
      this.getCookies = function getCookies(access_info) {
        var matches = [], cookie_name, cookie;
        for (cookie_name in cookies) {
          cookie = this.getCookie(cookie_name, access_info);
          if (cookie) {
            matches.push(cookie);
          }
        }
        matches.toString = function toString2() {
          return matches.join(":");
        };
        matches.toValueString = function toValueString() {
          return matches.map(function(c2) {
            return c2.toValueString();
          }).join("; ");
        };
        return matches;
      };
      return this;
    }
    return new CookieJar();
  }
  cookiejar.CookieJar = CookieJar;
  CookieJar.prototype.setCookies = function setCookies(cookies, request_domain, request_path) {
    cookies = Array.isArray(cookies) ? cookies : cookies.split(cookie_str_splitter);
    var successful = [], i2, cookie;
    cookies = cookies.map(function(item) {
      return new Cookie2(item, request_domain, request_path);
    });
    for (i2 = 0; i2 < cookies.length; i2 += 1) {
      cookie = cookies[i2];
      if (this.setCookie(cookie, request_domain, request_path)) {
        successful.push(cookie);
      }
    }
    return successful;
  };
})();
var __extends$1 = commonjsGlobal && commonjsGlobal.__extends || function() {
  var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2)
      if (b2.hasOwnProperty(p2))
        d2[p2] = b2[p2];
  };
  return function(d2, b2) {
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign = commonjsGlobal && commonjsGlobal.__assign || Object.assign || function(t2) {
  for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
    s2 = arguments[i2];
    for (var p2 in s2)
      if (Object.prototype.hasOwnProperty.call(s2, p2))
        t2[p2] = s2[p2];
  }
  return t2;
};
Object.defineProperty(xmlHttpRequest, "__esModule", { value: true });
var http = require$$2$2;
var https = require$$2$2;
var os = require$$2$2;
var url = url$1;
var progress_event_1 = progressEvent;
var errors_1 = errors;
var xml_http_request_event_target_1 = xmlHttpRequestEventTarget;
var xml_http_request_upload_1 = xmlHttpRequestUpload;
var Cookie = cookiejar;
var XMLHttpRequest = function(_super) {
  __extends$1(XMLHttpRequest2, _super);
  function XMLHttpRequest2(options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this) || this;
    _this.UNSENT = XMLHttpRequest2.UNSENT;
    _this.OPENED = XMLHttpRequest2.OPENED;
    _this.HEADERS_RECEIVED = XMLHttpRequest2.HEADERS_RECEIVED;
    _this.LOADING = XMLHttpRequest2.LOADING;
    _this.DONE = XMLHttpRequest2.DONE;
    _this.onreadystatechange = null;
    _this.readyState = XMLHttpRequest2.UNSENT;
    _this.response = null;
    _this.responseText = "";
    _this.responseType = "";
    _this.status = 0;
    _this.statusText = "";
    _this.timeout = 0;
    _this.upload = new xml_http_request_upload_1.XMLHttpRequestUpload();
    _this.responseUrl = "";
    _this.withCredentials = false;
    _this._method = null;
    _this._url = null;
    _this._sync = false;
    _this._headers = {};
    _this._loweredHeaders = {};
    _this._mimeOverride = null;
    _this._request = null;
    _this._response = null;
    _this._responseParts = null;
    _this._responseHeaders = null;
    _this._aborting = null;
    _this._error = null;
    _this._loadedBytes = 0;
    _this._totalBytes = 0;
    _this._lengthComputable = false;
    _this._restrictedMethods = { CONNECT: true, TRACE: true, TRACK: true };
    _this._restrictedHeaders = {
      "accept-charset": true,
      "accept-encoding": true,
      "access-control-request-headers": true,
      "access-control-request-method": true,
      connection: true,
      "content-length": true,
      cookie: true,
      cookie2: true,
      date: true,
      dnt: true,
      expect: true,
      host: true,
      "keep-alive": true,
      origin: true,
      referer: true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true,
      "user-agent": true,
      via: true
    };
    _this._privateHeaders = { "set-cookie": true, "set-cookie2": true };
    _this._userAgent = "Mozilla/5.0 (" + os.type() + " " + os.arch() + ") node.js/" + process.versions.node + " v8/" + process.versions.v8;
    _this._anonymous = options.anon || false;
    return _this;
  }
  XMLHttpRequest2.prototype.open = function(method2, url2, async2, user, password) {
    if (async2 === void 0) {
      async2 = true;
    }
    method2 = method2.toUpperCase();
    if (this._restrictedMethods[method2]) {
      throw new XMLHttpRequest2.SecurityError("HTTP method " + method2 + " is not allowed in XHR");
    }
    var xhrUrl = this._parseUrl(url2, user, password);
    if (this.readyState === XMLHttpRequest2.HEADERS_RECEIVED || this.readyState === XMLHttpRequest2.LOADING)
      ;
    this._method = method2;
    this._url = xhrUrl;
    this._sync = !async2;
    this._headers = {};
    this._loweredHeaders = {};
    this._mimeOverride = null;
    this._setReadyState(XMLHttpRequest2.OPENED);
    this._request = null;
    this._response = null;
    this.status = 0;
    this.statusText = "";
    this._responseParts = [];
    this._responseHeaders = null;
    this._loadedBytes = 0;
    this._totalBytes = 0;
    this._lengthComputable = false;
  };
  XMLHttpRequest2.prototype.setRequestHeader = function(name2, value2) {
    if (this.readyState !== XMLHttpRequest2.OPENED) {
      throw new XMLHttpRequest2.InvalidStateError("XHR readyState must be OPENED");
    }
    var loweredName = name2.toLowerCase();
    if (this._restrictedHeaders[loweredName] || /^sec-/.test(loweredName) || /^proxy-/.test(loweredName)) {
      console.warn('Refused to set unsafe header "' + name2 + '"');
      return;
    }
    value2 = value2.toString();
    if (this._loweredHeaders[loweredName] != null) {
      name2 = this._loweredHeaders[loweredName];
      this._headers[name2] = this._headers[name2] + ", " + value2;
    } else {
      this._loweredHeaders[loweredName] = name2;
      this._headers[name2] = value2;
    }
  };
  XMLHttpRequest2.prototype.send = function(data) {
    if (this.readyState !== XMLHttpRequest2.OPENED) {
      throw new XMLHttpRequest2.InvalidStateError("XHR readyState must be OPENED");
    }
    if (this._request) {
      throw new XMLHttpRequest2.InvalidStateError("send() already called");
    }
    switch (this._url.protocol) {
      case "file:":
        return this._sendFile(data);
      case "http:":
      case "https:":
        return this._sendHttp(data);
      default:
        throw new XMLHttpRequest2.NetworkError("Unsupported protocol " + this._url.protocol);
    }
  };
  XMLHttpRequest2.prototype.abort = function() {
    if (this._request == null) {
      return;
    }
    this._request.abort();
    this._setError();
    this._dispatchProgress("abort");
    this._dispatchProgress("loadend");
  };
  XMLHttpRequest2.prototype.getResponseHeader = function(name2) {
    if (this._responseHeaders == null || name2 == null) {
      return null;
    }
    var loweredName = name2.toLowerCase();
    return this._responseHeaders.hasOwnProperty(loweredName) ? this._responseHeaders[name2.toLowerCase()] : null;
  };
  XMLHttpRequest2.prototype.getAllResponseHeaders = function() {
    var _this = this;
    if (this._responseHeaders == null) {
      return "";
    }
    return Object.keys(this._responseHeaders).map(function(key2) {
      return key2 + ": " + _this._responseHeaders[key2];
    }).join("\r\n");
  };
  XMLHttpRequest2.prototype.overrideMimeType = function(mimeType) {
    if (this.readyState === XMLHttpRequest2.LOADING || this.readyState === XMLHttpRequest2.DONE) {
      throw new XMLHttpRequest2.InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
    }
    this._mimeOverride = mimeType.toLowerCase();
  };
  XMLHttpRequest2.prototype.nodejsSet = function(options) {
    this.nodejsHttpAgent = options.httpAgent || this.nodejsHttpAgent;
    this.nodejsHttpsAgent = options.httpsAgent || this.nodejsHttpsAgent;
    if (options.hasOwnProperty("baseUrl")) {
      if (options.baseUrl != null) {
        var parsedUrl = url.parse(options.baseUrl, false, true);
        if (!parsedUrl.protocol) {
          throw new XMLHttpRequest2.SyntaxError("baseUrl must be an absolute URL");
        }
      }
      this.nodejsBaseUrl = options.baseUrl;
    }
  };
  XMLHttpRequest2.nodejsSet = function(options) {
    XMLHttpRequest2.prototype.nodejsSet(options);
  };
  XMLHttpRequest2.prototype._setReadyState = function(readyState) {
    this.readyState = readyState;
    this.dispatchEvent(new progress_event_1.ProgressEvent("readystatechange"));
  };
  XMLHttpRequest2.prototype._sendFile = function(data) {
    throw new Error("Protocol file: not implemented");
  };
  XMLHttpRequest2.prototype._sendHttp = function(data) {
    if (this._sync) {
      throw new Error("Synchronous XHR processing not implemented");
    }
    if (data && (this._method === "GET" || this._method === "HEAD")) {
      console.warn("Discarding entity body for " + this._method + " requests");
      data = null;
    } else {
      data = data || "";
    }
    this.upload._setData(data);
    this._finalizeHeaders();
    this._sendHxxpRequest();
  };
  XMLHttpRequest2.prototype._sendHxxpRequest = function() {
    var _this = this;
    if (this.withCredentials) {
      var cookie = XMLHttpRequest2.cookieJar.getCookies(Cookie.CookieAccessInfo(this._url.hostname, this._url.pathname, this._url.protocol === "https:")).toValueString();
      this._headers.cookie = this._headers.cookie2 = cookie;
    }
    var _a2 = this._url.protocol === "http:" ? [http, this.nodejsHttpAgent] : [https, this.nodejsHttpsAgent], hxxp = _a2[0], agent = _a2[1];
    var requestMethod = hxxp.request.bind(hxxp);
    var request = requestMethod({
      hostname: this._url.hostname,
      port: +this._url.port,
      path: this._url.path,
      auth: this._url.auth,
      method: this._method,
      headers: this._headers,
      agent
    });
    this._request = request;
    if (this.timeout) {
      request.setTimeout(this.timeout, function() {
        return _this._onHttpTimeout(request);
      });
    }
    request.on("response", function(response) {
      return _this._onHttpResponse(request, response);
    });
    request.on("error", function(error2) {
      return _this._onHttpRequestError(request, error2);
    });
    this.upload._startUpload(request);
    if (this._request === request) {
      this._dispatchProgress("loadstart");
    }
  };
  XMLHttpRequest2.prototype._finalizeHeaders = function() {
    this._headers = __assign({}, this._headers, { Connection: "keep-alive", Host: this._url.host, "User-Agent": this._userAgent }, this._anonymous ? { Referer: "about:blank" } : {});
    this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
  };
  XMLHttpRequest2.prototype._onHttpResponse = function(request, response) {
    var _this = this;
    if (this._request !== request) {
      return;
    }
    if (this.withCredentials && (response.headers["set-cookie"] || response.headers["set-cookie2"])) {
      XMLHttpRequest2.cookieJar.setCookies(response.headers["set-cookie"] || response.headers["set-cookie2"]);
    }
    if ([301, 302, 303, 307, 308].indexOf(response.statusCode) >= 0) {
      this._url = this._parseUrl(response.headers.location);
      this._method = "GET";
      if (this._loweredHeaders["content-type"]) {
        delete this._headers[this._loweredHeaders["content-type"]];
        delete this._loweredHeaders["content-type"];
      }
      if (this._headers["Content-Type"] != null) {
        delete this._headers["Content-Type"];
      }
      delete this._headers["Content-Length"];
      this.upload._reset();
      this._finalizeHeaders();
      this._sendHxxpRequest();
      return;
    }
    this._response = response;
    this._response.on("data", function(data) {
      return _this._onHttpResponseData(response, data);
    });
    this._response.on("end", function() {
      return _this._onHttpResponseEnd(response);
    });
    this._response.on("close", function() {
      return _this._onHttpResponseClose(response);
    });
    this.responseUrl = this._url.href.split("#")[0];
    this.status = response.statusCode;
    this.statusText = http.STATUS_CODES[this.status];
    this._parseResponseHeaders(response);
    var lengthString = this._responseHeaders["content-length"] || "";
    this._totalBytes = +lengthString;
    this._lengthComputable = !!lengthString;
    this._setReadyState(XMLHttpRequest2.HEADERS_RECEIVED);
  };
  XMLHttpRequest2.prototype._onHttpResponseData = function(response, data) {
    if (this._response !== response) {
      return;
    }
    this._responseParts.push(new buffer$2.Buffer(data));
    this._loadedBytes += data.length;
    if (this.readyState !== XMLHttpRequest2.LOADING) {
      this._setReadyState(XMLHttpRequest2.LOADING);
    }
    this._dispatchProgress("progress");
  };
  XMLHttpRequest2.prototype._onHttpResponseEnd = function(response) {
    if (this._response !== response) {
      return;
    }
    this._parseResponse();
    this._request = null;
    this._response = null;
    this._setReadyState(XMLHttpRequest2.DONE);
    this._dispatchProgress("load");
    this._dispatchProgress("loadend");
  };
  XMLHttpRequest2.prototype._onHttpResponseClose = function(response) {
    if (this._response !== response) {
      return;
    }
    var request = this._request;
    this._setError();
    request.abort();
    this._setReadyState(XMLHttpRequest2.DONE);
    this._dispatchProgress("error");
    this._dispatchProgress("loadend");
  };
  XMLHttpRequest2.prototype._onHttpTimeout = function(request) {
    if (this._request !== request) {
      return;
    }
    this._setError();
    request.abort();
    this._setReadyState(XMLHttpRequest2.DONE);
    this._dispatchProgress("timeout");
    this._dispatchProgress("loadend");
  };
  XMLHttpRequest2.prototype._onHttpRequestError = function(request, error2) {
    if (this._request !== request) {
      return;
    }
    this._setError();
    request.abort();
    this._setReadyState(XMLHttpRequest2.DONE);
    this._dispatchProgress("error");
    this._dispatchProgress("loadend");
  };
  XMLHttpRequest2.prototype._dispatchProgress = function(eventType) {
    var event = new XMLHttpRequest2.ProgressEvent(eventType);
    event.lengthComputable = this._lengthComputable;
    event.loaded = this._loadedBytes;
    event.total = this._totalBytes;
    this.dispatchEvent(event);
  };
  XMLHttpRequest2.prototype._setError = function() {
    this._request = null;
    this._response = null;
    this._responseHeaders = null;
    this._responseParts = null;
  };
  XMLHttpRequest2.prototype._parseUrl = function(urlString, user, password) {
    var absoluteUrl = this.nodejsBaseUrl == null ? urlString : url.resolve(this.nodejsBaseUrl, urlString);
    var xhrUrl = url.parse(absoluteUrl, false, true);
    xhrUrl.hash = null;
    var _a2 = (xhrUrl.auth || "").split(":"), xhrUser = _a2[0], xhrPassword = _a2[1];
    if (xhrUser || xhrPassword || user || password) {
      xhrUrl.auth = (user || xhrUser || "") + ":" + (password || xhrPassword || "");
    }
    return xhrUrl;
  };
  XMLHttpRequest2.prototype._parseResponseHeaders = function(response) {
    this._responseHeaders = {};
    for (var name_1 in response.headers) {
      var loweredName = name_1.toLowerCase();
      if (this._privateHeaders[loweredName]) {
        continue;
      }
      this._responseHeaders[loweredName] = response.headers[name_1];
    }
    if (this._mimeOverride != null) {
      this._responseHeaders["content-type"] = this._mimeOverride;
    }
  };
  XMLHttpRequest2.prototype._parseResponse = function() {
    var buffer2 = buffer$2.Buffer.concat(this._responseParts);
    this._responseParts = null;
    switch (this.responseType) {
      case "json":
        this.responseText = null;
        try {
          this.response = JSON.parse(buffer2.toString("utf-8"));
        } catch (_a2) {
          this.response = null;
        }
        return;
      case "buffer":
        this.responseText = null;
        this.response = buffer2;
        return;
      case "arraybuffer":
        this.responseText = null;
        var arrayBuffer = new ArrayBuffer(buffer2.length);
        var view = new Uint8Array(arrayBuffer);
        for (var i2 = 0; i2 < buffer2.length; i2++) {
          view[i2] = buffer2[i2];
        }
        this.response = arrayBuffer;
        return;
      case "text":
      default:
        try {
          this.responseText = buffer2.toString(this._parseResponseEncoding());
        } catch (_b2) {
          this.responseText = buffer2.toString("binary");
        }
        this.response = this.responseText;
    }
  };
  XMLHttpRequest2.prototype._parseResponseEncoding = function() {
    return /;\s*charset=(.*)$/.exec(this._responseHeaders["content-type"] || "")[1] || "utf-8";
  };
  XMLHttpRequest2.ProgressEvent = progress_event_1.ProgressEvent;
  XMLHttpRequest2.InvalidStateError = errors_1.InvalidStateError;
  XMLHttpRequest2.NetworkError = errors_1.NetworkError;
  XMLHttpRequest2.SecurityError = errors_1.SecurityError;
  XMLHttpRequest2.SyntaxError = errors_1.SyntaxError;
  XMLHttpRequest2.XMLHttpRequestUpload = xml_http_request_upload_1.XMLHttpRequestUpload;
  XMLHttpRequest2.UNSENT = 0;
  XMLHttpRequest2.OPENED = 1;
  XMLHttpRequest2.HEADERS_RECEIVED = 2;
  XMLHttpRequest2.LOADING = 3;
  XMLHttpRequest2.DONE = 4;
  XMLHttpRequest2.cookieJar = Cookie.CookieJar();
  return XMLHttpRequest2;
}(xml_http_request_event_target_1.XMLHttpRequestEventTarget);
xmlHttpRequest.XMLHttpRequest = XMLHttpRequest;
XMLHttpRequest.prototype.nodejsHttpAgent = http.globalAgent;
XMLHttpRequest.prototype.nodejsHttpsAgent = https.globalAgent;
XMLHttpRequest.prototype.nodejsBaseUrl = null;
(function(exports2) {
  function __export(m2) {
    for (var p2 in m2)
      if (!exports2.hasOwnProperty(p2))
        exports2[p2] = m2[p2];
  }
  Object.defineProperty(exports2, "__esModule", { value: true });
  __export(xmlHttpRequest);
  var xml_http_request_event_target_12 = xmlHttpRequestEventTarget;
  exports2.XMLHttpRequestEventTarget = xml_http_request_event_target_12.XMLHttpRequestEventTarget;
})(dist$1);
const XHR = getFromWindow("XMLHttpRequest") || dist$1.XMLHttpRequest;
class HTTPConnection extends EventEmitter {
  constructor(url2) {
    super();
    this.url = url2;
  }
  formatError(payload, message, code2 = -1) {
    return {
      error: { message, code: code2 },
      id: payload.id,
      jsonrpc: payload.jsonrpc
    };
  }
  send(payload, internal) {
    return new Promise((resolve2) => {
      if (payload.method === "eth_subscribe") {
        const error2 = this.formatError(payload, "Subscriptions are not supported by this HTTP endpoint");
        this.emit("error", error2);
        return resolve2(error2);
      }
      const xhr = new XHR();
      let responded = false;
      const res = (err, result) => {
        if (!responded) {
          xhr.abort();
          responded = true;
          if (internal) {
            internal(err, result);
          } else {
            const { id: id2, jsonrpc } = payload;
            const response = err ? { id: id2, jsonrpc, error: { message: err.message, code: err.code } } : { id: id2, jsonrpc, result };
            this.emit("payload", response);
            resolve2(response);
          }
        }
      };
      xhr.open("POST", this.url, true);
      xhr.setRequestHeader("Content-Type", "application/json");
      xhr.timeout = 60 * 1e3;
      xhr.onerror = res;
      xhr.ontimeout = res;
      xhr.onreadystatechange = () => {
        if (xhr.readyState === 4) {
          try {
            const response = JSON.parse(xhr.responseText);
            res(response.error, response.result);
          } catch (e2) {
            res(e2);
          }
        }
      };
      xhr.send(JSON.stringify(payload));
    });
  }
}
const ProviderEngine = web3ProviderEngine;
const CacheSubprovider = cache;
const FixtureSubprovider = fixture;
const FilterSubprovider = filters;
const HookedWalletSubprovider = hookedWallet;
const NonceSubprovider = nonceTracker;
const SubscriptionsSubprovider = subscriptions;
class WalletConnectProvider extends ProviderEngine {
  constructor(opts) {
    super({ pollingInterval: opts.pollingInterval || 8e3 });
    this.bridge = "https://bridge.walletconnect.org";
    this.qrcode = true;
    this.qrcodeModal = cjs;
    this.qrcodeModalOptions = void 0;
    this.rpc = null;
    this.infuraId = "";
    this.http = null;
    this.isConnecting = false;
    this.connected = false;
    this.connectCallbacks = [];
    this.accounts = [];
    this.chainId = 1;
    this.rpcUrl = "";
    this.enable = async () => {
      const wc = await this.getWalletConnector();
      if (wc) {
        this.start();
        this.subscribeWalletConnector();
        return wc.accounts;
      } else {
        throw new Error("Failed to connect to WalleConnect");
      }
    };
    this.request = async (payload) => {
      return this.send(payload);
    };
    this.send = async (payload, callback) => {
      if (typeof payload === "string") {
        const method2 = payload;
        let params = callback;
        if (method2 === "personal_sign") {
          params = parsePersonalSign(params);
        }
        return this.sendAsyncPromise(method2, params);
      }
      payload = Object.assign({ id: payloadId(), jsonrpc: "2.0" }, payload);
      if (payload.method === "personal_sign") {
        payload.params = parsePersonalSign(payload.params);
      }
      if (callback) {
        this.sendAsync(payload, callback);
        return;
      }
      return this.sendAsyncPromise(payload.method, payload.params);
    };
    this.onConnect = (callback) => {
      this.connectCallbacks.push(callback);
    };
    this.triggerConnect = (result) => {
      if (this.connectCallbacks && this.connectCallbacks.length) {
        this.connectCallbacks.forEach((callback) => callback(result));
      }
    };
    this.bridge = opts.connector ? opts.connector.bridge : opts.bridge || "https://bridge.walletconnect.org";
    this.qrcode = typeof opts.qrcode === "undefined" || opts.qrcode !== false;
    this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;
    this.qrcodeModalOptions = opts.qrcodeModalOptions;
    this.wc = opts.connector || new WalletConnect({
      bridge: this.bridge,
      qrcodeModal: this.qrcode ? this.qrcodeModal : void 0,
      qrcodeModalOptions: this.qrcodeModalOptions,
      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,
      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,
      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta
    });
    this.rpc = opts.rpc || null;
    if (!this.rpc && (!opts.infuraId || typeof opts.infuraId !== "string" || !opts.infuraId.trim())) {
      throw new Error("Missing one of the required parameters: rpc or infuraId");
    }
    this.infuraId = opts.infuraId || "";
    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;
    this.initialize();
  }
  get isWalletConnect() {
    return true;
  }
  get connector() {
    return this.wc;
  }
  get walletMeta() {
    return this.wc.peerMeta;
  }
  async disconnect() {
    this.close();
  }
  async close() {
    const wc = await this.getWalletConnector({ disableSessionCreation: true });
    await wc.killSession();
    await this.onDisconnect();
  }
  async handleRequest(payload) {
    try {
      let response;
      let result = null;
      const wc = await this.getWalletConnector();
      switch (payload.method) {
        case "wc_killSession":
          await this.close();
          result = null;
          break;
        case "eth_accounts":
          result = wc.accounts;
          break;
        case "eth_coinbase":
          result = wc.accounts[0];
          break;
        case "eth_chainId":
          result = wc.chainId;
          break;
        case "net_version":
          result = wc.chainId;
          break;
        case "eth_uninstallFilter":
          this.sendAsync(payload, (_2) => _2);
          result = true;
          break;
        default:
          response = await this.handleOtherRequests(payload);
      }
      if (response) {
        return response;
      }
      return this.formatResponse(payload, result);
    } catch (error2) {
      this.emit("error", error2);
      throw error2;
    }
  }
  async handleOtherRequests(payload) {
    if (!signingMethods.includes(payload.method) && payload.method.startsWith("eth_")) {
      return this.handleReadRequests(payload);
    }
    const wc = await this.getWalletConnector();
    const result = await wc.sendCustomRequest(payload);
    return this.formatResponse(payload, result);
  }
  async handleReadRequests(payload) {
    if (!this.http) {
      const error2 = new Error("HTTP Connection not available");
      this.emit("error", error2);
      throw error2;
    }
    return this.http.send(payload);
  }
  formatResponse(payload, result) {
    return {
      id: payload.id,
      jsonrpc: payload.jsonrpc,
      result
    };
  }
  getWalletConnector(opts = {}) {
    const { disableSessionCreation = false } = opts;
    return new Promise((resolve2, reject) => {
      const wc = this.wc;
      if (this.isConnecting) {
        this.onConnect((x2) => resolve2(x2));
      } else if (!wc.connected && !disableSessionCreation) {
        this.isConnecting = true;
        wc.on("modal_closed", () => {
          reject(new Error("User closed modal"));
        });
        wc.createSession({ chainId: this.chainId }).then(() => {
          wc.on("connect", (error2, payload) => {
            if (error2) {
              this.isConnecting = false;
              return reject(error2);
            }
            this.isConnecting = false;
            this.connected = true;
            if (payload) {
              this.updateState(payload.params[0]);
            }
            this.emit("connect");
            this.triggerConnect(wc);
            resolve2(wc);
          });
        }).catch((error2) => {
          this.isConnecting = false;
          reject(error2);
        });
      } else {
        if (!this.connected) {
          this.connected = true;
          this.updateState(wc.session);
        }
        resolve2(wc);
      }
    });
  }
  async subscribeWalletConnector() {
    const wc = await this.getWalletConnector();
    wc.on("disconnect", (error2) => {
      if (error2) {
        this.emit("error", error2);
        return;
      }
      this.onDisconnect();
    });
    wc.on("session_update", (error2, payload) => {
      if (error2) {
        this.emit("error", error2);
        return;
      }
      this.updateState(payload.params[0]);
    });
  }
  async onDisconnect() {
    await this.stop();
    this.emit("close", 1e3, "Connection closed");
    this.emit("disconnect", 1e3, "Connection disconnected");
    this.connected = false;
  }
  async updateState(sessionParams) {
    const { accounts, chainId, networkId, rpcUrl } = sessionParams;
    if (!this.accounts || accounts && this.accounts !== accounts) {
      this.accounts = accounts;
      this.emit("accountsChanged", accounts);
    }
    if (!this.chainId || chainId && this.chainId !== chainId) {
      this.chainId = chainId;
      this.emit("chainChanged", chainId);
    }
    if (!this.networkId || networkId && this.networkId !== networkId) {
      this.networkId = networkId;
      this.emit("networkChanged", networkId);
    }
    this.updateRpcUrl(this.chainId, rpcUrl || "");
  }
  updateRpcUrl(chainId, rpcUrl = "") {
    const rpc = { infuraId: this.infuraId, custom: this.rpc || void 0 };
    rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);
    if (rpcUrl) {
      this.rpcUrl = rpcUrl;
      this.updateHttpConnection();
    } else {
      this.emit("error", new Error(`No RPC Url available for chainId: ${chainId}`));
    }
  }
  updateHttpConnection() {
    if (this.rpcUrl) {
      this.http = new HTTPConnection(this.rpcUrl);
      this.http.on("payload", (payload) => this.emit("payload", payload));
      this.http.on("error", (error2) => this.emit("error", error2));
    }
  }
  sendAsyncPromise(method2, params) {
    return new Promise((resolve2, reject) => {
      this.sendAsync({
        id: payloadId(),
        jsonrpc: "2.0",
        method: method2,
        params: params || []
      }, (error2, response) => {
        if (error2) {
          reject(error2);
          return;
        }
        resolve2(response.result);
      });
    });
  }
  initialize() {
    this.updateRpcUrl(this.chainId);
    this.addProvider(new FixtureSubprovider({
      eth_hashrate: "0x00",
      eth_mining: false,
      eth_syncing: true,
      net_listening: true,
      web3_clientVersion: `WalletConnect/v1.x.x/javascript`
    }));
    this.addProvider(new CacheSubprovider());
    this.addProvider(new SubscriptionsSubprovider());
    this.addProvider(new FilterSubprovider());
    this.addProvider(new NonceSubprovider());
    this.addProvider(new HookedWalletSubprovider(this.configWallet()));
    this.addProvider({
      handleRequest: async (payload, next3, end) => {
        try {
          const { error: error2, result } = await this.handleRequest(payload);
          end(error2, result);
        } catch (error2) {
          end(error2);
        }
      },
      setEngine: (_2) => _2
    });
  }
  configWallet() {
    return {
      getAccounts: async (cb) => {
        try {
          const wc = await this.getWalletConnector();
          const accounts = wc.accounts;
          if (accounts && accounts.length) {
            cb(null, accounts);
          } else {
            cb(new Error("Failed to get accounts"));
          }
        } catch (error2) {
          cb(error2);
        }
      },
      processMessage: async (msgParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signMessage([msgParams.from, msgParams.data]);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      },
      processPersonalMessage: async (msgParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signPersonalMessage([msgParams.data, msgParams.from]);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      },
      processSignTransaction: async (txParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signTransaction(txParams);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      },
      processTransaction: async (txParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.sendTransaction(txParams);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      },
      processTypedMessage: async (msgParams, cb) => {
        try {
          const wc = await this.getWalletConnector();
          const result = await wc.signTypedData([msgParams.from, msgParams.data]);
          cb(null, result);
        } catch (error2) {
          cb(error2);
        }
      }
    };
  }
}
var dist = {};
var WalletLinkProvider$1 = {};
var WalletLinkAnalytics$1 = {};
Object.defineProperty(WalletLinkAnalytics$1, "__esModule", { value: true });
WalletLinkAnalytics$1.WalletLinkAnalytics = void 0;
class WalletLinkAnalytics {
  sendEvent(_eventType, _eventProperties) {
  }
}
WalletLinkAnalytics$1.WalletLinkAnalytics = WalletLinkAnalytics;
var EthereumChain = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.EthereumChain = void 0;
  (function(EthereumChain2) {
    EthereumChain2[EthereumChain2["ETHEREUM_MAINNET"] = 1] = "ETHEREUM_MAINNET";
    EthereumChain2[EthereumChain2["OPTIMISM_MAINNET"] = 10] = "OPTIMISM_MAINNET";
    EthereumChain2[EthereumChain2["POLYGON_MAINNET"] = 137] = "POLYGON_MAINNET";
    EthereumChain2[EthereumChain2["ETHEREUM_CLASSIC_MAINNET"] = 61] = "ETHEREUM_CLASSIC_MAINNET";
    EthereumChain2[EthereumChain2["BSC_MAINNET"] = 56] = "BSC_MAINNET";
    EthereumChain2[EthereumChain2["FANTOM_MAINNET"] = 250] = "FANTOM_MAINNET";
    EthereumChain2[EthereumChain2["ARBITRUM_MAINNET"] = 42161] = "ARBITRUM_MAINNET";
    EthereumChain2[EthereumChain2["XDAI_MAINNET"] = 100] = "XDAI_MAINNET";
    EthereumChain2[EthereumChain2["AVALANCHE_MAINNET"] = 43114] = "AVALANCHE_MAINNET";
    EthereumChain2[EthereumChain2["ROPSTEN"] = 3] = "ROPSTEN";
    EthereumChain2[EthereumChain2["RINKEBY"] = 4] = "RINKEBY";
    EthereumChain2[EthereumChain2["GOERLI"] = 5] = "GOERLI";
    EthereumChain2[EthereumChain2["KOVAN"] = 42] = "KOVAN";
    EthereumChain2[EthereumChain2["OPTIMISM_KOVAN"] = 69] = "OPTIMISM_KOVAN";
    EthereumChain2[EthereumChain2["POLYGON_TESTNET"] = 80001] = "POLYGON_TESTNET";
    EthereumChain2[EthereumChain2["BSC_TESTNET"] = 97] = "BSC_TESTNET";
    EthereumChain2[EthereumChain2["FANTOM_TESTNET"] = 4002] = "FANTOM_TESTNET";
    EthereumChain2[EthereumChain2["ARBITRUM_TESTNET"] = 421611] = "ARBITRUM_TESTNET";
    EthereumChain2[EthereumChain2["AVALANCHE_FUJI"] = 43113] = "AVALANCHE_FUJI";
  })(exports2.EthereumChain || (exports2.EthereumChain = {}));
  (function(EthereumChain2) {
    function rpcUrl(thiz) {
      switch (thiz) {
        case EthereumChain2.ETHEREUM_MAINNET:
          return "https://mainnet-infura.wallet.coinbase.com";
        case EthereumChain2.ROPSTEN:
          return "https://ropsten-infura.wallet.coinbase.com";
        case EthereumChain2.RINKEBY:
          return "https://rinkeby-infura.wallet.coinbase.com";
        case EthereumChain2.KOVAN:
          return "https://kovan-infura.wallet.coinbase.com";
        case EthereumChain2.GOERLI:
          return "https://goerli-node.wallet.coinbase.com";
        case EthereumChain2.OPTIMISM_KOVAN:
          return "https://optimism-node.wallet.coinbase.com";
        case EthereumChain2.OPTIMISM_MAINNET:
          return "https://optimism-mainnet.wallet.coinbase.com";
        case EthereumChain2.POLYGON_MAINNET:
          return "https://polygon-mainnet-infura.wallet.coinbase.com";
        case EthereumChain2.POLYGON_TESTNET:
          return "https://polygon-mumbai-infura.wallet.coinbase.com";
        case EthereumChain2.BSC_MAINNET:
          return "https://bsc-dataseed.binance.org";
        case EthereumChain2.BSC_TESTNET:
          return "https://data-seed-prebsc-1-s1.binance.org:8545";
        case EthereumChain2.FANTOM_MAINNET:
          return "https://rpcapi.fantom.network";
        case EthereumChain2.FANTOM_TESTNET:
          return "https://rpc.testnet.fantom.network";
        case EthereumChain2.ARBITRUM_MAINNET:
          return "https://l2-mainnet.wallet.coinbase.com?targetName=arbitrum";
        case EthereumChain2.ARBITRUM_TESTNET:
          return "https://rinkeby.arbitrum.io/rpc";
        case EthereumChain2.XDAI_MAINNET:
          return "https://rpc.xdaichain.com";
        case EthereumChain2.AVALANCHE_MAINNET:
          return "https://api.avax.network/ext/bc/C/rpc";
        case EthereumChain2.AVALANCHE_FUJI:
          return "https://api.avax-test.network/ext/bc/C/rpc";
        default:
          return void 0;
      }
    }
    EthereumChain2.rpcUrl = rpcUrl;
    function fromChainId(chainId) {
      switch (Number(chainId)) {
        case EthereumChain2.ETHEREUM_MAINNET.valueOf():
          return EthereumChain2.ETHEREUM_MAINNET;
        case EthereumChain2.OPTIMISM_MAINNET.valueOf():
          return EthereumChain2.OPTIMISM_MAINNET;
        case EthereumChain2.POLYGON_MAINNET.valueOf():
          return EthereumChain2.POLYGON_MAINNET;
        case EthereumChain2.ETHEREUM_CLASSIC_MAINNET.valueOf():
          return EthereumChain2.ETHEREUM_CLASSIC_MAINNET;
        case EthereumChain2.BSC_MAINNET.valueOf():
          return EthereumChain2.BSC_MAINNET;
        case EthereumChain2.FANTOM_MAINNET.valueOf():
          return EthereumChain2.FANTOM_MAINNET;
        case EthereumChain2.ARBITRUM_MAINNET.valueOf():
          return EthereumChain2.ARBITRUM_MAINNET;
        case EthereumChain2.AVALANCHE_MAINNET.valueOf():
          return EthereumChain2.AVALANCHE_MAINNET;
        case EthereumChain2.XDAI_MAINNET.valueOf():
          return EthereumChain2.XDAI_MAINNET;
        case EthereumChain2.ROPSTEN.valueOf():
          return EthereumChain2.ROPSTEN;
        case EthereumChain2.RINKEBY.valueOf():
          return EthereumChain2.RINKEBY;
        case EthereumChain2.GOERLI.valueOf():
          return EthereumChain2.GOERLI;
        case EthereumChain2.KOVAN.valueOf():
          return EthereumChain2.KOVAN;
        case EthereumChain2.OPTIMISM_KOVAN.valueOf():
          return EthereumChain2.OPTIMISM_KOVAN;
        case EthereumChain2.POLYGON_TESTNET.valueOf():
          return EthereumChain2.POLYGON_TESTNET;
        case EthereumChain2.BSC_TESTNET.valueOf():
          return EthereumChain2.BSC_TESTNET;
        case EthereumChain2.FANTOM_TESTNET.valueOf():
          return EthereumChain2.FANTOM_TESTNET;
        case EthereumChain2.ARBITRUM_TESTNET.valueOf():
          return EthereumChain2.ARBITRUM_TESTNET;
        case EthereumChain2.AVALANCHE_FUJI.valueOf():
          return EthereumChain2.AVALANCHE_FUJI;
        default:
          return void 0;
      }
    }
    EthereumChain2.fromChainId = fromChainId;
  })(exports2.EthereumChain || (exports2.EthereumChain = {}));
})(EthereumChain);
var init = {};
var events = {};
Object.defineProperty(events, "__esModule", { value: true });
events.EVENTS = void 0;
events.EVENTS = {
  REQUEST_CHILD_ETHEREUM_ACCOUNTS_START: "walletlink_sdk.request_child_ethereum_accounts.start",
  REQUEST_CHILD_ETHEREUM_ACCOUNTS_RESPONSE: "walletlink_sdk.request_child_ethereum_accounts.response",
  STARTED_CONNECTING: "walletlink_sdk.started.connecting",
  CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
  DISCONNECTED: "walletlink_sdk.disconnected",
  METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
  LINKED: "walletlink_sdk.linked",
  FAILURE: "walletlink_sdk.generic_failure",
  SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
  ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
  SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
  UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
  GENERAL_ERROR: "walletlink_sdk.general_error"
};
var WalletLinkAnalyticsAbstract$1 = {};
Object.defineProperty(WalletLinkAnalyticsAbstract$1, "__esModule", { value: true });
WalletLinkAnalyticsAbstract$1.WalletLinkAnalyticsAbstract = void 0;
class WalletLinkAnalyticsAbstract {
}
WalletLinkAnalyticsAbstract$1.WalletLinkAnalyticsAbstract = WalletLinkAnalyticsAbstract;
(function(exports2) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m2[k2];
    } });
  } : function(o2, m2, k2, k22) {
    if (k22 === void 0)
      k22 = k2;
    o2[k22] = m2[k2];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports3) {
    for (var p2 in m2)
      if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
        __createBinding2(exports3, m2, p2);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(events, exports2);
  __exportStar(WalletLinkAnalyticsAbstract$1, exports2);
})(init);
var Session$1 = {};
var sha256 = { exports: {} };
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
(function(module) {
  (function() {
    var ERROR = "input is invalid type";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA256_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && true && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var EXTRA = [-2147483648, 8388608, 32768, 128];
    var SHIFT = [24, 16, 8, 0];
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
    var blocks = [];
    if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(outputType, is2242) {
      return function(message) {
        return new Sha256(is2242, true).update(message)[outputType]();
      };
    };
    var createMethod = function(is2242) {
      var method2 = createOutputMethod("hex", is2242);
      if (NODE_JS) {
        method2 = nodeWrap(method2, is2242);
      }
      method2.create = function() {
        return new Sha256(is2242);
      };
      method2.update = function(message) {
        return method2.create().update(message);
      };
      for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
        var type = OUTPUT_TYPES[i2];
        method2[type] = createOutputMethod(type, is2242);
      }
      return method2;
    };
    var nodeWrap = function(method, is224) {
      var crypto = eval("require('crypto')");
      var Buffer = eval("require('buffer').Buffer");
      var algorithm = is224 ? "sha224" : "sha256";
      var nodeMethod = function(message) {
        if (typeof message === "string") {
          return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
        } else {
          if (message === null || message === void 0) {
            throw new Error(ERROR);
          } else if (message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          }
        }
        if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
          return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
        } else {
          return method(message);
        }
      };
      return nodeMethod;
    };
    var createHmacOutputMethod = function(outputType, is2242) {
      return function(key2, message) {
        return new HmacSha256(key2, is2242, true).update(message)[outputType]();
      };
    };
    var createHmacMethod = function(is2242) {
      var method2 = createHmacOutputMethod("hex", is2242);
      method2.create = function(key2) {
        return new HmacSha256(key2, is2242);
      };
      method2.update = function(key2, message) {
        return method2.create(key2).update(message);
      };
      for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
        var type = OUTPUT_TYPES[i2];
        method2[type] = createHmacOutputMethod(type, is2242);
      }
      return method2;
    };
    function Sha256(is2242, sharedMemory) {
      if (sharedMemory) {
        blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
        this.blocks = blocks;
      } else {
        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      }
      if (is2242) {
        this.h0 = 3238371032;
        this.h1 = 914150663;
        this.h2 = 812702999;
        this.h3 = 4144912697;
        this.h4 = 4290775857;
        this.h5 = 1750603025;
        this.h6 = 1694076839;
        this.h7 = 3204075428;
      } else {
        this.h0 = 1779033703;
        this.h1 = 3144134277;
        this.h2 = 1013904242;
        this.h3 = 2773480762;
        this.h4 = 1359893119;
        this.h5 = 2600822924;
        this.h6 = 528734635;
        this.h7 = 1541459225;
      }
      this.block = this.start = this.bytes = this.hBytes = 0;
      this.finalized = this.hashed = false;
      this.first = true;
      this.is224 = is2242;
    }
    Sha256.prototype.update = function(message) {
      if (this.finalized) {
        return;
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(ERROR);
            }
          }
        } else {
          throw new Error(ERROR);
        }
        notString = true;
      }
      var code2, index2 = 0, i2, length = message.length, blocks2 = this.blocks;
      while (index2 < length) {
        if (this.hashed) {
          this.hashed = false;
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        if (notString) {
          for (i2 = this.start; index2 < length && i2 < 64; ++index2) {
            blocks2[i2 >> 2] |= message[index2] << SHIFT[i2++ & 3];
          }
        } else {
          for (i2 = this.start; index2 < length && i2 < 64; ++index2) {
            code2 = message.charCodeAt(index2);
            if (code2 < 128) {
              blocks2[i2 >> 2] |= code2 << SHIFT[i2++ & 3];
            } else if (code2 < 2048) {
              blocks2[i2 >> 2] |= (192 | code2 >> 6) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            } else if (code2 < 55296 || code2 >= 57344) {
              blocks2[i2 >> 2] |= (224 | code2 >> 12) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            } else {
              code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
              blocks2[i2 >> 2] |= (240 | code2 >> 18) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
              blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
            }
          }
        }
        this.lastByteIndex = i2;
        this.bytes += i2 - this.start;
        if (i2 >= 64) {
          this.block = blocks2[16];
          this.start = i2 - 64;
          this.hash();
          this.hashed = true;
        } else {
          this.start = i2;
        }
      }
      if (this.bytes > 4294967295) {
        this.hBytes += this.bytes / 4294967296 << 0;
        this.bytes = this.bytes % 4294967296;
      }
      return this;
    };
    Sha256.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks2 = this.blocks, i2 = this.lastByteIndex;
      blocks2[16] = this.block;
      blocks2[i2 >> 2] |= EXTRA[i2 & 3];
      this.block = blocks2[16];
      if (i2 >= 56) {
        if (!this.hashed) {
          this.hash();
        }
        blocks2[0] = this.block;
        blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
      }
      blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
      blocks2[15] = this.bytes << 3;
      this.hash();
    };
    Sha256.prototype.hash = function() {
      var a2 = this.h0, b2 = this.h1, c2 = this.h2, d2 = this.h3, e2 = this.h4, f2 = this.h5, g2 = this.h6, h2 = this.h7, blocks2 = this.blocks, j2, s0, s1, maj2, t1, t2, ch2, ab, da, cd, bc;
      for (j2 = 16; j2 < 64; ++j2) {
        t1 = blocks2[j2 - 15];
        s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
        t1 = blocks2[j2 - 2];
        s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
        blocks2[j2] = blocks2[j2 - 16] + s0 + blocks2[j2 - 7] + s1 << 0;
      }
      bc = b2 & c2;
      for (j2 = 0; j2 < 64; j2 += 4) {
        if (this.first) {
          if (this.is224) {
            ab = 300032;
            t1 = blocks2[0] - 1413257819;
            h2 = t1 - 150054599 << 0;
            d2 = t1 + 24177077 << 0;
          } else {
            ab = 704751109;
            t1 = blocks2[0] - 210244248;
            h2 = t1 - 1521486534 << 0;
            d2 = t1 + 143694565 << 0;
          }
          this.first = false;
        } else {
          s0 = (a2 >>> 2 | a2 << 30) ^ (a2 >>> 13 | a2 << 19) ^ (a2 >>> 22 | a2 << 10);
          s1 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
          ab = a2 & b2;
          maj2 = ab ^ a2 & c2 ^ bc;
          ch2 = e2 & f2 ^ ~e2 & g2;
          t1 = h2 + s1 + ch2 + K[j2] + blocks2[j2];
          t2 = s0 + maj2;
          h2 = d2 + t1 << 0;
          d2 = t1 + t2 << 0;
        }
        s0 = (d2 >>> 2 | d2 << 30) ^ (d2 >>> 13 | d2 << 19) ^ (d2 >>> 22 | d2 << 10);
        s1 = (h2 >>> 6 | h2 << 26) ^ (h2 >>> 11 | h2 << 21) ^ (h2 >>> 25 | h2 << 7);
        da = d2 & a2;
        maj2 = da ^ d2 & b2 ^ ab;
        ch2 = h2 & e2 ^ ~h2 & f2;
        t1 = g2 + s1 + ch2 + K[j2 + 1] + blocks2[j2 + 1];
        t2 = s0 + maj2;
        g2 = c2 + t1 << 0;
        c2 = t1 + t2 << 0;
        s0 = (c2 >>> 2 | c2 << 30) ^ (c2 >>> 13 | c2 << 19) ^ (c2 >>> 22 | c2 << 10);
        s1 = (g2 >>> 6 | g2 << 26) ^ (g2 >>> 11 | g2 << 21) ^ (g2 >>> 25 | g2 << 7);
        cd = c2 & d2;
        maj2 = cd ^ c2 & a2 ^ da;
        ch2 = g2 & h2 ^ ~g2 & e2;
        t1 = f2 + s1 + ch2 + K[j2 + 2] + blocks2[j2 + 2];
        t2 = s0 + maj2;
        f2 = b2 + t1 << 0;
        b2 = t1 + t2 << 0;
        s0 = (b2 >>> 2 | b2 << 30) ^ (b2 >>> 13 | b2 << 19) ^ (b2 >>> 22 | b2 << 10);
        s1 = (f2 >>> 6 | f2 << 26) ^ (f2 >>> 11 | f2 << 21) ^ (f2 >>> 25 | f2 << 7);
        bc = b2 & c2;
        maj2 = bc ^ b2 & d2 ^ cd;
        ch2 = f2 & g2 ^ ~f2 & h2;
        t1 = e2 + s1 + ch2 + K[j2 + 3] + blocks2[j2 + 3];
        t2 = s0 + maj2;
        e2 = a2 + t1 << 0;
        a2 = t1 + t2 << 0;
      }
      this.h0 = this.h0 + a2 << 0;
      this.h1 = this.h1 + b2 << 0;
      this.h2 = this.h2 + c2 << 0;
      this.h3 = this.h3 + d2 << 0;
      this.h4 = this.h4 + e2 << 0;
      this.h5 = this.h5 + f2 << 0;
      this.h6 = this.h6 + g2 << 0;
      this.h7 = this.h7 + h2 << 0;
    };
    Sha256.prototype.hex = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
      if (!this.is224) {
        hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
      }
      return hex;
    };
    Sha256.prototype.toString = Sha256.prototype.hex;
    Sha256.prototype.digest = function() {
      this.finalize();
      var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
      var arr2 = [
        h0 >> 24 & 255,
        h0 >> 16 & 255,
        h0 >> 8 & 255,
        h0 & 255,
        h1 >> 24 & 255,
        h1 >> 16 & 255,
        h1 >> 8 & 255,
        h1 & 255,
        h2 >> 24 & 255,
        h2 >> 16 & 255,
        h2 >> 8 & 255,
        h2 & 255,
        h3 >> 24 & 255,
        h3 >> 16 & 255,
        h3 >> 8 & 255,
        h3 & 255,
        h4 >> 24 & 255,
        h4 >> 16 & 255,
        h4 >> 8 & 255,
        h4 & 255,
        h5 >> 24 & 255,
        h5 >> 16 & 255,
        h5 >> 8 & 255,
        h5 & 255,
        h6 >> 24 & 255,
        h6 >> 16 & 255,
        h6 >> 8 & 255,
        h6 & 255
      ];
      if (!this.is224) {
        arr2.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
      }
      return arr2;
    };
    Sha256.prototype.array = Sha256.prototype.digest;
    Sha256.prototype.arrayBuffer = function() {
      this.finalize();
      var buffer2 = new ArrayBuffer(this.is224 ? 28 : 32);
      var dataView = new DataView(buffer2);
      dataView.setUint32(0, this.h0);
      dataView.setUint32(4, this.h1);
      dataView.setUint32(8, this.h2);
      dataView.setUint32(12, this.h3);
      dataView.setUint32(16, this.h4);
      dataView.setUint32(20, this.h5);
      dataView.setUint32(24, this.h6);
      if (!this.is224) {
        dataView.setUint32(28, this.h7);
      }
      return buffer2;
    };
    function HmacSha256(key2, is2242, sharedMemory) {
      var i2, type = typeof key2;
      if (type === "string") {
        var bytes3 = [], length = key2.length, index2 = 0, code2;
        for (i2 = 0; i2 < length; ++i2) {
          code2 = key2.charCodeAt(i2);
          if (code2 < 128) {
            bytes3[index2++] = code2;
          } else if (code2 < 2048) {
            bytes3[index2++] = 192 | code2 >> 6;
            bytes3[index2++] = 128 | code2 & 63;
          } else if (code2 < 55296 || code2 >= 57344) {
            bytes3[index2++] = 224 | code2 >> 12;
            bytes3[index2++] = 128 | code2 >> 6 & 63;
            bytes3[index2++] = 128 | code2 & 63;
          } else {
            code2 = 65536 + ((code2 & 1023) << 10 | key2.charCodeAt(++i2) & 1023);
            bytes3[index2++] = 240 | code2 >> 18;
            bytes3[index2++] = 128 | code2 >> 12 & 63;
            bytes3[index2++] = 128 | code2 >> 6 & 63;
            bytes3[index2++] = 128 | code2 & 63;
          }
        }
        key2 = bytes3;
      } else {
        if (type === "object") {
          if (key2 === null) {
            throw new Error(ERROR);
          } else if (ARRAY_BUFFER && key2.constructor === ArrayBuffer) {
            key2 = new Uint8Array(key2);
          } else if (!Array.isArray(key2)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(key2)) {
              throw new Error(ERROR);
            }
          }
        } else {
          throw new Error(ERROR);
        }
      }
      if (key2.length > 64) {
        key2 = new Sha256(is2242, true).update(key2).array();
      }
      var oKeyPad = [], iKeyPad = [];
      for (i2 = 0; i2 < 64; ++i2) {
        var b2 = key2[i2] || 0;
        oKeyPad[i2] = 92 ^ b2;
        iKeyPad[i2] = 54 ^ b2;
      }
      Sha256.call(this, is2242, sharedMemory);
      this.update(iKeyPad);
      this.oKeyPad = oKeyPad;
      this.inner = true;
      this.sharedMemory = sharedMemory;
    }
    HmacSha256.prototype = new Sha256();
    HmacSha256.prototype.finalize = function() {
      Sha256.prototype.finalize.call(this);
      if (this.inner) {
        this.inner = false;
        var innerHash = this.array();
        Sha256.call(this, this.is224, this.sharedMemory);
        this.update(this.oKeyPad);
        this.update(innerHash);
        Sha256.prototype.finalize.call(this);
      }
    };
    var exports = createMethod();
    exports.sha256 = exports;
    exports.sha224 = createMethod(true);
    exports.sha256.hmac = createHmacMethod();
    exports.sha224.hmac = createHmacMethod(true);
    if (COMMON_JS) {
      module.exports = exports;
    } else {
      root.sha256 = exports.sha256;
      root.sha224 = exports.sha224;
    }
  })();
})(sha256);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function isFunction(x2) {
  return typeof x2 === "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(value2) {
    if (value2) {
      var error2 = /* @__PURE__ */ new Error();
      /* @__PURE__ */ console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error2.stack);
    }
    _enable_super_gross_mode_that_will_cause_bad_things = value2;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var empty$1 = {
  closed: true,
  next: function(value2) {
  },
  error: function(err) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      throw err;
    } else {
      hostReportError(err);
    }
  },
  complete: function() {
  }
};
var isArray$1 = /* @__PURE__ */ function() {
  return Array.isArray || function(x2) {
    return x2 && typeof x2.length === "number";
  };
}();
function isObject(x2) {
  return x2 !== null && typeof x2 === "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function UnsubscriptionErrorImpl2(errors2) {
    Error.call(this);
    this.message = errors2 ? errors2.length + " errors occurred during unsubscription:\n" + errors2.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors2;
    return this;
  }
  UnsubscriptionErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return UnsubscriptionErrorImpl2;
}();
var UnsubscriptionError = UnsubscriptionErrorImpl;
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(unsubscribe) {
    this.closed = false;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (unsubscribe) {
      this._ctorUnsubscribe = true;
      this._unsubscribe = unsubscribe;
    }
  }
  Subscription2.prototype.unsubscribe = function() {
    var errors2;
    if (this.closed) {
      return;
    }
    var _a2 = this, _parentOrParents = _a2._parentOrParents, _ctorUnsubscribe = _a2._ctorUnsubscribe, _unsubscribe = _a2._unsubscribe, _subscriptions = _a2._subscriptions;
    this.closed = true;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (_parentOrParents instanceof Subscription2) {
      _parentOrParents.remove(this);
    } else if (_parentOrParents !== null) {
      for (var index2 = 0; index2 < _parentOrParents.length; ++index2) {
        var parent_1 = _parentOrParents[index2];
        parent_1.remove(this);
      }
    }
    if (isFunction(_unsubscribe)) {
      if (_ctorUnsubscribe) {
        this._unsubscribe = void 0;
      }
      try {
        _unsubscribe.call(this);
      } catch (e2) {
        errors2 = e2 instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e2.errors) : [e2];
      }
    }
    if (isArray$1(_subscriptions)) {
      var index2 = -1;
      var len2 = _subscriptions.length;
      while (++index2 < len2) {
        var sub = _subscriptions[index2];
        if (isObject(sub)) {
          try {
            sub.unsubscribe();
          } catch (e2) {
            errors2 = errors2 || [];
            if (e2 instanceof UnsubscriptionError) {
              errors2 = errors2.concat(flattenUnsubscriptionErrors(e2.errors));
            } else {
              errors2.push(e2);
            }
          }
        }
      }
    }
    if (errors2) {
      throw new UnsubscriptionError(errors2);
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var subscription = teardown;
    if (!teardown) {
      return Subscription2.EMPTY;
    }
    switch (typeof teardown) {
      case "function":
        subscription = new Subscription2(teardown);
      case "object":
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription2)) {
          var tmp = subscription;
          subscription = new Subscription2();
          subscription._subscriptions = [tmp];
        }
        break;
      default: {
        throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
      }
    }
    var _parentOrParents = subscription._parentOrParents;
    if (_parentOrParents === null) {
      subscription._parentOrParents = this;
    } else if (_parentOrParents instanceof Subscription2) {
      if (_parentOrParents === this) {
        return subscription;
      }
      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1) {
      _parentOrParents.push(this);
    } else {
      return subscription;
    }
    var subscriptions2 = this._subscriptions;
    if (subscriptions2 === null) {
      this._subscriptions = [subscription];
    } else {
      subscriptions2.push(subscription);
    }
    return subscription;
  };
  Subscription2.prototype.remove = function(subscription) {
    var subscriptions2 = this._subscriptions;
    if (subscriptions2) {
      var subscriptionIndex = subscriptions2.indexOf(subscription);
      if (subscriptionIndex !== -1) {
        subscriptions2.splice(subscriptionIndex, 1);
      }
    }
  };
  Subscription2.EMPTY = function(empty2) {
    empty2.closed = true;
    return empty2;
  }(new Subscription2());
  return Subscription2;
}();
function flattenUnsubscriptionErrors(errors2) {
  return errors2.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol === "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}();
var Subscriber = /* @__PURE__ */ function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destinationOrNext, error2, complete) {
    var _this = _super.call(this) || this;
    _this.syncErrorValue = null;
    _this.syncErrorThrown = false;
    _this.syncErrorThrowable = false;
    _this.isStopped = false;
    switch (arguments.length) {
      case 0:
        _this.destination = empty$1;
        break;
      case 1:
        if (!destinationOrNext) {
          _this.destination = empty$1;
          break;
        }
        if (typeof destinationOrNext === "object") {
          if (destinationOrNext instanceof Subscriber2) {
            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            _this.destination = destinationOrNext;
            destinationOrNext.add(_this);
          } else {
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext);
          }
          break;
        }
      default:
        _this.syncErrorThrowable = true;
        _this.destination = new SafeSubscriber(_this, destinationOrNext, error2, complete);
        break;
    }
    return _this;
  }
  Subscriber2.prototype[rxSubscriber] = function() {
    return this;
  };
  Subscriber2.create = function(next3, error2, complete) {
    var subscriber = new Subscriber2(next3, error2, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  };
  Subscriber2.prototype.next = function(value2) {
    if (!this.isStopped) {
      this._next(value2);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.isStopped = true;
    _super.prototype.unsubscribe.call(this);
  };
  Subscriber2.prototype._next = function(value2) {
    this.destination.next(value2);
  };
  Subscriber2.prototype._error = function(err) {
    this.destination.error(err);
    this.unsubscribe();
  };
  Subscriber2.prototype._complete = function() {
    this.destination.complete();
    this.unsubscribe();
  };
  Subscriber2.prototype._unsubscribeAndRecycle = function() {
    var _parentOrParents = this._parentOrParents;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  };
  return Subscriber2;
}(Subscription);
var SafeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(_parentSubscriber, observerOrNext, error2, complete) {
    var _this = _super.call(this) || this;
    _this._parentSubscriber = _parentSubscriber;
    var next3;
    var context = _this;
    if (isFunction(observerOrNext)) {
      next3 = observerOrNext;
    } else if (observerOrNext) {
      next3 = observerOrNext.next;
      error2 = observerOrNext.error;
      complete = observerOrNext.complete;
      if (observerOrNext !== empty$1) {
        context = Object.create(observerOrNext);
        if (isFunction(context.unsubscribe)) {
          _this.add(context.unsubscribe.bind(context));
        }
        context.unsubscribe = _this.unsubscribe.bind(_this);
      }
    }
    _this._context = context;
    _this._next = next3;
    _this._error = error2;
    _this._complete = complete;
    return _this;
  }
  SafeSubscriber2.prototype.next = function(value2) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;
      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value2);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value2)) {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);
          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();
        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }
        hostReportError(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          hostReportError(err);
        }
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.complete = function() {
    var _this = this;
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      if (this._complete) {
        var wrappedComplete = function() {
          return _this._complete.call(_this._context);
        };
        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);
          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value2) {
    try {
      fn.call(this._context, value2);
    } catch (err) {
      this.unsubscribe();
      if (config.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError(err);
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn, value2) {
    if (!config.useDeprecatedSynchronousErrorHandling) {
      throw new Error("bad call");
    }
    try {
      fn.call(this._context, value2);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      } else {
        hostReportError(err);
        return true;
      }
    }
    return false;
  };
  SafeSubscriber2.prototype._unsubscribe = function() {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;
    _parentSubscriber.unsubscribe();
  };
  return SafeSubscriber2;
}(Subscriber);
function canReportError(observer) {
  while (observer) {
    var _a2 = observer, closed_1 = _a2.closed, destination = _a2.destination, isStopped = _a2.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
function toSubscriber(nextOrObserver, error2, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error2 && !complete) {
    return new Subscriber(empty$1);
  }
  return new Subscriber(nextOrObserver, error2, complete);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x2) {
  return x2;
}
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = /* @__PURE__ */ function() {
  function Observable2(subscribe) {
    this._isScalar = false;
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
    var operator = this.operator;
    var sink = toSubscriber(observerOrNext, error2, complete);
    if (operator) {
      sink.add(operator.call(sink, this.source));
    } else {
      sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
    }
    if (config.useDeprecatedSynchronousErrorHandling) {
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
    }
    return sink;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }
      if (canReportError(sink)) {
        sink.error(err);
      } else {
        console.warn(err);
      }
    }
  };
  Observable2.prototype.forEach = function(next3, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscription;
      subscription = _this.subscribe(function(value2) {
        try {
          next3(value2);
        } catch (err) {
          reject(err);
          if (subscription) {
            subscription.unsubscribe();
          }
        }
      }, reject, resolve2);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var source = this.source;
    return source && source.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    if (operations.length === 0) {
      return this;
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value2;
      _this.subscribe(function(x2) {
        return value2 = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve2(value2);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config.Promise || Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function ObjectUnsubscribedErrorImpl2() {
    Error.call(this);
    this.message = "object unsubscribed";
    this.name = "ObjectUnsubscribedError";
    return this;
  }
  ObjectUnsubscribedErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ObjectUnsubscribedErrorImpl2;
}();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
var SubjectSubscription = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscription2, _super);
  function SubjectSubscription2(subject, subscriber) {
    var _this = _super.call(this) || this;
    _this.subject = subject;
    _this.subscriber = subscriber;
    _this.closed = false;
    return _this;
  }
  SubjectSubscription2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.closed = true;
    var subject = this.subject;
    var observers = subject.observers;
    this.subject = null;
    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
      return;
    }
    var subscriberIndex = observers.indexOf(this.subscriber);
    if (subscriberIndex !== -1) {
      observers.splice(subscriberIndex, 1);
    }
  };
  return SubjectSubscription2;
}(Subscription);
var SubjectSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubjectSubscriber2, _super);
  function SubjectSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    return _this;
  }
  return SubjectSubscriber2;
}(Subscriber);
var Subject = /* @__PURE__ */ function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.observers = [];
    _this.closed = false;
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  };
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype.next = function(value2) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    if (!this.isStopped) {
      var observers = this.observers;
      var len2 = observers.length;
      var copy3 = observers.slice();
      for (var i2 = 0; i2 < len2; i2++) {
        copy3[i2].next(value2);
      }
    }
  };
  Subject2.prototype.error = function(err) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    var observers = this.observers;
    var len2 = observers.length;
    var copy3 = observers.slice();
    for (var i2 = 0; i2 < len2; i2++) {
      copy3[i2].error(err);
    }
    this.observers.length = 0;
  };
  Subject2.prototype.complete = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.isStopped = true;
    var observers = this.observers;
    var len2 = observers.length;
    var copy3 = observers.slice();
    for (var i2 = 0; i2 < len2; i2++) {
      copy3[i2].complete();
    }
    this.observers.length = 0;
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  };
  Subject2.prototype._trySubscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return _super.prototype._trySubscribe.call(this, subscriber);
    }
  };
  Subject2.prototype._subscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    } else if (this.isStopped) {
      subscriber.complete();
      return Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      return new SubjectSubscription(this, subscriber);
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = /* @__PURE__ */ function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value2) {
    var destination = this.destination;
    if (destination && destination.next) {
      destination.next(value2);
    }
  };
  AnonymousSubject2.prototype.error = function(err) {
    var destination = this.destination;
    if (destination && destination.error) {
      this.destination.error(err);
    }
  };
  AnonymousSubject2.prototype.complete = function() {
    var destination = this.destination;
    if (destination && destination.complete) {
      this.destination.complete();
    }
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var source = this.source;
    if (source) {
      return this.source.subscribe(subscriber);
    } else {
      return Subscription.EMPTY;
    }
  };
  return AnonymousSubject2;
}(Subject);
function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function RefCountOperator2(connectable) {
    this.connectable = connectable;
  }
  RefCountOperator2.prototype.call = function(subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source.subscribe(refCounter);
    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }
    return subscription;
  };
  return RefCountOperator2;
}();
var RefCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RefCountSubscriber2, _super);
  function RefCountSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  RefCountSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (!connectable) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var refCount2 = connectable._refCount;
    if (refCount2 <= 0) {
      this.connection = null;
      return;
    }
    connectable._refCount = refCount2 - 1;
    if (refCount2 > 1) {
      this.connection = null;
      return;
    }
    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;
    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };
  return RefCountSubscriber2;
}(Subscriber);
var ConnectableObservable = /* @__PURE__ */ function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._refCount = 0;
    _this._isComplete = false;
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype.connect = function() {
    var connection = this._connection;
    if (!connection) {
      this._isComplete = false;
      connection = this._connection = new Subscription();
      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);
var connectableObservableDescriptor = /* @__PURE__ */ function() {
  var connectableProto = ConnectableObservable.prototype;
  return {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
  };
}();
var ConnectableSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ConnectableSubscriber2, _super);
  function ConnectableSubscriber2(destination, connectable) {
    var _this = _super.call(this, destination) || this;
    _this.connectable = connectable;
    return _this;
  }
  ConnectableSubscriber2.prototype._error = function(err) {
    this._unsubscribe();
    _super.prototype._error.call(this, err);
  };
  ConnectableSubscriber2.prototype._complete = function() {
    this.connectable._isComplete = true;
    this._unsubscribe();
    _super.prototype._complete.call(this);
  };
  ConnectableSubscriber2.prototype._unsubscribe = function() {
    var connectable = this.connectable;
    if (connectable) {
      this.connectable = null;
      var connection = connectable._connection;
      connectable._refCount = 0;
      connectable._subject = null;
      connectable._connection = null;
      if (connection) {
        connection.unsubscribe();
      }
    }
  };
  return ConnectableSubscriber2;
}(SubjectSubscriber);
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
  return function(source) {
    return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
  };
}
var GroupByOperator = /* @__PURE__ */ function() {
  function GroupByOperator2(keySelector, elementSelector, durationSelector, subjectSelector) {
    this.keySelector = keySelector;
    this.elementSelector = elementSelector;
    this.durationSelector = durationSelector;
    this.subjectSelector = subjectSelector;
  }
  GroupByOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  };
  return GroupByOperator2;
}();
var GroupBySubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupBySubscriber2, _super);
  function GroupBySubscriber2(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.elementSelector = elementSelector;
    _this.durationSelector = durationSelector;
    _this.subjectSelector = subjectSelector;
    _this.groups = null;
    _this.attemptedToUnsubscribe = false;
    _this.count = 0;
    return _this;
  }
  GroupBySubscriber2.prototype._next = function(value2) {
    var key2;
    try {
      key2 = this.keySelector(value2);
    } catch (err) {
      this.error(err);
      return;
    }
    this._group(value2, key2);
  };
  GroupBySubscriber2.prototype._group = function(value2, key2) {
    var groups = this.groups;
    if (!groups) {
      groups = this.groups = new Map();
    }
    var group = groups.get(key2);
    var element;
    if (this.elementSelector) {
      try {
        element = this.elementSelector(value2);
      } catch (err) {
        this.error(err);
      }
    } else {
      element = value2;
    }
    if (!group) {
      group = this.subjectSelector ? this.subjectSelector() : new Subject();
      groups.set(key2, group);
      var groupedObservable = new GroupedObservable(key2, group, this);
      this.destination.next(groupedObservable);
      if (this.durationSelector) {
        var duration = void 0;
        try {
          duration = this.durationSelector(new GroupedObservable(key2, group));
        } catch (err) {
          this.error(err);
          return;
        }
        this.add(duration.subscribe(new GroupDurationSubscriber(key2, group, this)));
      }
    }
    if (!group.closed) {
      group.next(element);
    }
  };
  GroupBySubscriber2.prototype._error = function(err) {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group, key2) {
        group.error(err);
      });
      groups.clear();
    }
    this.destination.error(err);
  };
  GroupBySubscriber2.prototype._complete = function() {
    var groups = this.groups;
    if (groups) {
      groups.forEach(function(group, key2) {
        group.complete();
      });
      groups.clear();
    }
    this.destination.complete();
  };
  GroupBySubscriber2.prototype.removeGroup = function(key2) {
    this.groups.delete(key2);
  };
  GroupBySubscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.attemptedToUnsubscribe = true;
      if (this.count === 0) {
        _super.prototype.unsubscribe.call(this);
      }
    }
  };
  return GroupBySubscriber2;
}(Subscriber);
var GroupDurationSubscriber = /* @__PURE__ */ function(_super) {
  __extends(GroupDurationSubscriber2, _super);
  function GroupDurationSubscriber2(key2, group, parent) {
    var _this = _super.call(this, group) || this;
    _this.key = key2;
    _this.group = group;
    _this.parent = parent;
    return _this;
  }
  GroupDurationSubscriber2.prototype._next = function(value2) {
    this.complete();
  };
  GroupDurationSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, parent = _a2.parent, key2 = _a2.key;
    this.key = this.parent = null;
    if (parent) {
      parent.removeGroup(key2);
    }
  };
  return GroupDurationSubscriber2;
}(Subscriber);
var GroupedObservable = /* @__PURE__ */ function(_super) {
  __extends(GroupedObservable2, _super);
  function GroupedObservable2(key2, groupSubject, refCountSubscription) {
    var _this = _super.call(this) || this;
    _this.key = key2;
    _this.groupSubject = groupSubject;
    _this.refCountSubscription = refCountSubscription;
    return _this;
  }
  GroupedObservable2.prototype._subscribe = function(subscriber) {
    var subscription = new Subscription();
    var _a2 = this, refCountSubscription = _a2.refCountSubscription, groupSubject = _a2.groupSubject;
    if (refCountSubscription && !refCountSubscription.closed) {
      subscription.add(new InnerRefCountSubscription(refCountSubscription));
    }
    subscription.add(groupSubject.subscribe(subscriber));
    return subscription;
  };
  return GroupedObservable2;
}(Observable);
var InnerRefCountSubscription = /* @__PURE__ */ function(_super) {
  __extends(InnerRefCountSubscription2, _super);
  function InnerRefCountSubscription2(parent) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    parent.count++;
    return _this;
  }
  InnerRefCountSubscription2.prototype.unsubscribe = function() {
    var parent = this.parent;
    if (!parent.closed && !this.closed) {
      _super.prototype.unsubscribe.call(this);
      parent.count -= 1;
      if (parent.count === 0 && parent.attemptedToUnsubscribe) {
        parent.unsubscribe();
      }
    }
  };
  return InnerRefCountSubscription2;
}(Subscription);
var BehaviorSubject = /* @__PURE__ */ function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: true,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    if (subscription && !subscription.closed) {
      subscriber.next(this._value);
    }
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    if (this.hasError) {
      throw this.thrownError;
    } else if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return this._value;
    }
  };
  BehaviorSubject2.prototype.next = function(value2) {
    _super.prototype.next.call(this, this._value = value2);
  };
  return BehaviorSubject2;
}(Subject);
var Action = /* @__PURE__ */ function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state2, delay2) {
    return this;
  };
  return Action2;
}(Subscription);
var AsyncAction = /* @__PURE__ */ function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state2;
    var id2 = this.id;
    var scheduler = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && this.delay === delay2 && this.pending === false) {
      return id2;
    }
    clearInterval(id2);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state2, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error2 = this._execute(state2, delay2);
    if (error2) {
      return error2;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state2, delay2) {
    var errored = false;
    var errorValue = void 0;
    try {
      this.work(state2);
    } catch (e2) {
      errored = true;
      errorValue = !!e2 && e2 || new Error(e2);
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype._unsubscribe = function() {
    var id2 = this.id;
    var scheduler = this.scheduler;
    var actions = scheduler.actions;
    var index2 = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;
    if (index2 !== -1) {
      actions.splice(index2, 1);
    }
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, null);
    }
    this.delay = null;
  };
  return AsyncAction2;
}(Action);
var QueueAction = /* @__PURE__ */ function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state2, delay2);
    }
    this.delay = delay2;
    this.state = state2;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state2, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state2, delay2) : this._execute(state2, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    return scheduler.flush(this);
  };
  return QueueAction2;
}(AsyncAction);
var Scheduler = /* @__PURE__ */ function() {
  function Scheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.SchedulerAction = SchedulerAction;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.SchedulerAction(this, work).schedule(state2, delay2);
  };
  Scheduler2.now = function() {
    return Date.now();
  };
  return Scheduler2;
}();
var AsyncScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
        return AsyncScheduler2.delegate.now();
      } else {
        return now();
      }
    }) || this;
    _this.actions = [];
    _this.active = false;
    _this.scheduled = void 0;
    return _this;
  }
  AsyncScheduler2.prototype.schedule = function(work, delay2, state2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
      return AsyncScheduler2.delegate.schedule(work, delay2, state2);
    } else {
      return _super.prototype.schedule.call(this, work, delay2, state2);
    }
  };
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this.active) {
      actions.push(action);
      return;
    }
    var error2;
    this.active = true;
    do {
      if (error2 = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this.active = false;
    if (error2) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error2;
    }
  };
  return AsyncScheduler2;
}(Scheduler);
var QueueScheduler = /* @__PURE__ */ function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);
var queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction);
var queue$1 = queueScheduler;
var EMPTY = /* @__PURE__ */ new Observable(function(subscriber) {
  return subscriber.complete();
});
function empty(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}
function isScheduler(value2) {
  return value2 && typeof value2.schedule === "function";
}
var subscribeToArray = function(array2) {
  return function(subscriber) {
    for (var i2 = 0, len2 = array2.length; i2 < len2 && !subscriber.closed; i2++) {
      subscriber.next(array2[i2]);
    }
    subscriber.complete();
  };
};
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var i2 = 0;
    sub.add(scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
        return;
      }
      subscriber.next(input[i2++]);
      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}
function fromArray(input, scheduler) {
  if (!scheduler) {
    return new Observable(subscribeToArray(input));
  } else {
    return scheduleArray(input, scheduler);
  }
}
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = args[args.length - 1];
  if (isScheduler(scheduler)) {
    args.pop();
    return scheduleArray(args, scheduler);
  } else {
    return fromArray(args);
  }
}
function throwError(error2, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      return subscriber.error(error2);
    });
  } else {
    return new Observable(function(subscriber) {
      return scheduler.schedule(dispatch$7, 0, { error: error2, subscriber });
    });
  }
}
function dispatch$7(_a2) {
  var error2 = _a2.error, subscriber = _a2.subscriber;
  subscriber.error(error2);
}
var NotificationKind;
/* @__PURE__ */ (function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = /* @__PURE__ */ function() {
  function Notification2(kind, value2, error2) {
    this.kind = kind;
    this.value = value2;
    this.error = error2;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    switch (this.kind) {
      case "N":
        return observer.next && observer.next(this.value);
      case "E":
        return observer.error && observer.error(this.error);
      case "C":
        return observer.complete && observer.complete();
    }
  };
  Notification2.prototype.do = function(next3, error2, complete) {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return next3 && next3(this.value);
      case "E":
        return error2 && error2(this.error);
      case "C":
        return complete && complete();
    }
  };
  Notification2.prototype.accept = function(nextOrObserver, error2, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === "function") {
      return this.observe(nextOrObserver);
    } else {
      return this.do(nextOrObserver, error2, complete);
    }
  };
  Notification2.prototype.toObservable = function() {
    var kind = this.kind;
    switch (kind) {
      case "N":
        return of(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty();
    }
    throw new Error("unexpected notification kind value");
  };
  Notification2.createNext = function(value2) {
    if (typeof value2 !== "undefined") {
      return new Notification2("N", value2);
    }
    return Notification2.undefinedValueNotification;
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  Notification2.undefinedValueNotification = new Notification2("N", void 0);
  return Notification2;
}();
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay2));
  };
}
var ObserveOnOperator = /* @__PURE__ */ function() {
  function ObserveOnOperator2(scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.scheduler = scheduler;
    this.delay = delay2;
  }
  ObserveOnOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  };
  return ObserveOnOperator2;
}();
var ObserveOnSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ObserveOnSubscriber2, _super);
  function ObserveOnSubscriber2(destination, scheduler, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    var _this = _super.call(this, destination) || this;
    _this.scheduler = scheduler;
    _this.delay = delay2;
    return _this;
  }
  ObserveOnSubscriber2.dispatch = function(arg) {
    var notification = arg.notification, destination = arg.destination;
    notification.observe(destination);
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype.scheduleMessage = function(notification) {
    var destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber2.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  };
  ObserveOnSubscriber2.prototype._next = function(value2) {
    this.scheduleMessage(Notification.createNext(value2));
  };
  ObserveOnSubscriber2.prototype._error = function(err) {
    this.scheduleMessage(Notification.createError(err));
    this.unsubscribe();
  };
  ObserveOnSubscriber2.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete());
    this.unsubscribe();
  };
  return ObserveOnSubscriber2;
}(Subscriber);
var ObserveOnMessage = /* @__PURE__ */ function() {
  function ObserveOnMessage2(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }
  return ObserveOnMessage2;
}();
var ReplaySubject = /* @__PURE__ */ function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(bufferSize, windowTime2, scheduler) {
    if (bufferSize === void 0) {
      bufferSize = Number.POSITIVE_INFINITY;
    }
    if (windowTime2 === void 0) {
      windowTime2 = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this) || this;
    _this.scheduler = scheduler;
    _this._events = [];
    _this._infiniteTimeWindow = false;
    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    _this._windowTime = windowTime2 < 1 ? 1 : windowTime2;
    if (windowTime2 === Number.POSITIVE_INFINITY) {
      _this._infiniteTimeWindow = true;
      _this.next = _this.nextInfiniteTimeWindow;
    } else {
      _this.next = _this.nextTimeWindow;
    }
    return _this;
  }
  ReplaySubject2.prototype.nextInfiniteTimeWindow = function(value2) {
    if (!this.isStopped) {
      var _events = this._events;
      _events.push(value2);
      if (_events.length > this._bufferSize) {
        _events.shift();
      }
    }
    _super.prototype.next.call(this, value2);
  };
  ReplaySubject2.prototype.nextTimeWindow = function(value2) {
    if (!this.isStopped) {
      this._events.push(new ReplayEvent(this._getNow(), value2));
      this._trimBufferThenGetEvents();
    }
    _super.prototype.next.call(this, value2);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    var _infiniteTimeWindow = this._infiniteTimeWindow;
    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
    var scheduler = this.scheduler;
    var len2 = _events.length;
    var subscription;
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.isStopped || this.hasError) {
      subscription = Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new SubjectSubscription(this, subscriber);
    }
    if (scheduler) {
      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
    }
    if (_infiniteTimeWindow) {
      for (var i2 = 0; i2 < len2 && !subscriber.closed; i2++) {
        subscriber.next(_events[i2]);
      }
    } else {
      for (var i2 = 0; i2 < len2 && !subscriber.closed; i2++) {
        subscriber.next(_events[i2].value);
      }
    }
    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }
    return subscription;
  };
  ReplaySubject2.prototype._getNow = function() {
    return (this.scheduler || queue$1).now();
  };
  ReplaySubject2.prototype._trimBufferThenGetEvents = function() {
    var now = this._getNow();
    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
    var spliceCount = 0;
    while (spliceCount < eventsCount) {
      if (now - _events[spliceCount].time < _windowTime) {
        break;
      }
      spliceCount++;
    }
    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }
    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }
    return _events;
  };
  return ReplaySubject2;
}(Subject);
var ReplayEvent = /* @__PURE__ */ function() {
  function ReplayEvent2(time, value2) {
    this.time = time;
    this.value = value2;
  }
  return ReplayEvent2;
}();
var AsyncSubject = /* @__PURE__ */ function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.value = null;
    _this.hasNext = false;
    _this.hasCompleted = false;
    return _this;
  }
  AsyncSubject2.prototype._subscribe = function(subscriber) {
    if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    } else if (this.hasCompleted && this.hasNext) {
      subscriber.next(this.value);
      subscriber.complete();
      return Subscription.EMPTY;
    }
    return _super.prototype._subscribe.call(this, subscriber);
  };
  AsyncSubject2.prototype.next = function(value2) {
    if (!this.hasCompleted) {
      this.value = value2;
      this.hasNext = true;
    }
  };
  AsyncSubject2.prototype.error = function(error2) {
    if (!this.hasCompleted) {
      _super.prototype.error.call(this, error2);
    }
  };
  AsyncSubject2.prototype.complete = function() {
    this.hasCompleted = true;
    if (this.hasNext) {
      _super.prototype.next.call(this, this.value);
    }
    _super.prototype.complete.call(this);
  };
  return AsyncSubject2;
}(Subject);
var nextHandle = 1;
var RESOLVED = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}();
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    RESOLVED.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};
var AsapAction = /* @__PURE__ */ function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
    }
    if (scheduler.actions.length === 0) {
      Immediate.clearImmediate(id2);
      scheduler.scheduled = void 0;
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);
var AsapScheduler = /* @__PURE__ */ function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this.active = true;
    this.scheduled = void 0;
    var actions = this.actions;
    var error2;
    var index2 = -1;
    var count2 = actions.length;
    action = action || actions.shift();
    do {
      if (error2 = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index2 < count2 && (action = actions.shift()));
    this.active = false;
    if (error2) {
      while (++index2 < count2 && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error2;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);
var asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction);
var asap = asapScheduler;
var asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction);
var async = asyncScheduler;
var AnimationFrameAction = /* @__PURE__ */ function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function() {
      return scheduler.flush(null);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0 || delay2 === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
    }
    if (scheduler.actions.length === 0) {
      cancelAnimationFrame(id2);
      scheduler.scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);
var AnimationFrameScheduler = /* @__PURE__ */ function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this.active = true;
    this.scheduled = void 0;
    var actions = this.actions;
    var error2;
    var index2 = -1;
    var count2 = actions.length;
    action = action || actions.shift();
    do {
      if (error2 = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index2 < count2 && (action = actions.shift()));
    this.active = false;
    if (error2) {
      while (++index2 < count2 && (action = actions.shift())) {
        action.unsubscribe();
      }
      throw error2;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);
var animationFrameScheduler = /* @__PURE__ */ new AnimationFrameScheduler(AnimationFrameAction);
var animationFrame = animationFrameScheduler;
var VirtualTimeScheduler = /* @__PURE__ */ function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(SchedulerAction, maxFrames) {
    if (SchedulerAction === void 0) {
      SchedulerAction = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a2 = this, actions = _a2.actions, maxFrames = _a2.maxFrames;
    var error2, action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error2 = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error2) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error2;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = /* @__PURE__ */ function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index2) {
    if (index2 === void 0) {
      index2 = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index2;
    _this.active = true;
    _this.index = scheduler.index = index2;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (!this.id) {
      return _super.prototype.schedule.call(this, state2, delay2);
    }
    this.active = false;
    var action = new VirtualAction2(this.scheduler, this.work);
    this.add(action);
    return action.schedule(state2, delay2);
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return true;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state2, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state2, delay2);
    }
  };
  VirtualAction2.sortActions = function(a2, b2) {
    if (a2.delay === b2.delay) {
      if (a2.index === b2.index) {
        return 0;
      } else if (a2.index > b2.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a2.delay > b2.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);
function noop$2() {
}
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || typeof obj.lift === "function" && typeof obj.subscribe === "function");
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function ArgumentOutOfRangeErrorImpl2() {
    Error.call(this);
    this.message = "argument out of range";
    this.name = "ArgumentOutOfRangeError";
    return this;
  }
  ArgumentOutOfRangeErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return ArgumentOutOfRangeErrorImpl2;
}();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
var EmptyErrorImpl = /* @__PURE__ */ function() {
  function EmptyErrorImpl2() {
    Error.call(this);
    this.message = "no elements in sequence";
    this.name = "EmptyError";
    return this;
  }
  EmptyErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return EmptyErrorImpl2;
}();
var EmptyError = EmptyErrorImpl;
var TimeoutErrorImpl = /* @__PURE__ */ function() {
  function TimeoutErrorImpl2() {
    Error.call(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    return this;
  }
  TimeoutErrorImpl2.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  return TimeoutErrorImpl2;
}();
var TimeoutError = TimeoutErrorImpl;
function map(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== "function") {
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    }
    return source.lift(new MapOperator(project, thisArg));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function MapOperator2(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }
  MapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  };
  return MapOperator2;
}();
var MapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapSubscriber2, _super);
  function MapSubscriber2(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.count = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  MapSubscriber2.prototype._next = function(value2) {
    var result;
    try {
      result = this.project.call(this.thisArg, value2, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return MapSubscriber2;
}(Subscriber);
function bindCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray$1(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var context = this;
    var subject;
    var params = {
      context,
      subject,
      callbackFunc,
      scheduler
    };
    return new Observable(function(subscriber) {
      if (!scheduler) {
        if (!subject) {
          subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        var state2 = {
          args,
          subscriber,
          params
        };
        return scheduler.schedule(dispatch$6, 0, state2);
      }
    });
  };
}
function dispatch$6(state2) {
  var _this = this;
  var args = state2.args, subscriber = state2.subscriber, params = state2.params;
  var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var value2 = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
      _this.add(scheduler.schedule(dispatchNext$3, 0, { value: value2, subject }));
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      subject.error(err);
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext$3(state2) {
  var value2 = state2.value, subject = state2.subject;
  subject.next(value2);
  subject.complete();
}
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
  if (resultSelector) {
    if (isScheduler(resultSelector)) {
      scheduler = resultSelector;
    } else {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function(args2) {
          return isArray$1(args2) ? resultSelector.apply(void 0, args2) : resultSelector(args2);
        }));
      };
    }
  }
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {
      subject: void 0,
      args,
      callbackFunc,
      scheduler,
      context: this
    };
    return new Observable(function(subscriber) {
      var context = params.context;
      var subject = params.subject;
      if (!scheduler) {
        if (!subject) {
          subject = params.subject = new AsyncSubject();
          var handler = function() {
            var innerArgs = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              innerArgs[_i2] = arguments[_i2];
            }
            var err = innerArgs.shift();
            if (err) {
              subject.error(err);
              return;
            }
            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          };
          try {
            callbackFunc.apply(context, args.concat([handler]));
          } catch (err) {
            if (canReportError(subject)) {
              subject.error(err);
            } else {
              console.warn(err);
            }
          }
        }
        return subject.subscribe(subscriber);
      } else {
        return scheduler.schedule(dispatch$5, 0, { params, subscriber, context });
      }
    });
  };
}
function dispatch$5(state2) {
  var _this = this;
  var params = state2.params, subscriber = state2.subscriber, context = state2.context;
  var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
  var subject = params.subject;
  if (!subject) {
    subject = params.subject = new AsyncSubject();
    var handler = function() {
      var innerArgs = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        innerArgs[_i] = arguments[_i];
      }
      var err = innerArgs.shift();
      if (err) {
        _this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
      } else {
        var value2 = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
        _this.add(scheduler.schedule(dispatchNext$2, 0, { value: value2, subject }));
      }
    };
    try {
      callbackFunc.apply(context, args.concat([handler]));
    } catch (err) {
      this.add(scheduler.schedule(dispatchError, 0, { err, subject }));
    }
  }
  this.add(subject.subscribe(subscriber));
}
function dispatchNext$2(arg) {
  var value2 = arg.value, subject = arg.subject;
  subject.next(value2);
  subject.complete();
}
function dispatchError(arg) {
  var err = arg.err, subject = arg.subject;
  subject.error(err);
}
var OuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OuterSubscriber2, _super);
  function OuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };
  OuterSubscriber2.prototype.notifyError = function(error2, innerSub) {
    this.destination.error(error2);
  };
  OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.destination.complete();
  };
  return OuterSubscriber2;
}(Subscriber);
var InnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(InnerSubscriber2, _super);
  function InnerSubscriber2(parent, outerValue, outerIndex) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    _this.outerValue = outerValue;
    _this.outerIndex = outerIndex;
    _this.index = 0;
    return _this;
  }
  InnerSubscriber2.prototype._next = function(value2) {
    this.parent.notifyNext(this.outerValue, value2, this.outerIndex, this.index++, this);
  };
  InnerSubscriber2.prototype._error = function(error2) {
    this.parent.notifyError(error2, this);
    this.unsubscribe();
  };
  InnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  };
  return InnerSubscriber2;
}(Subscriber);
var subscribeToPromise = function(promise) {
  return function(subscriber) {
    promise.then(function(value2) {
      if (!subscriber.closed) {
        subscriber.next(value2);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, hostReportError);
    return subscriber;
  };
};
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator();
var subscribeToIterable = function(iterable) {
  return function(subscriber) {
    var iterator$12 = iterable[iterator]();
    do {
      var item = void 0;
      try {
        item = iterator$12.next();
      } catch (err) {
        subscriber.error(err);
        return subscriber;
      }
      if (item.done) {
        subscriber.complete();
        break;
      }
      subscriber.next(item.value);
      if (subscriber.closed) {
        break;
      }
    } while (true);
    if (typeof iterator$12.return === "function") {
      subscriber.add(function() {
        if (iterator$12.return) {
          iterator$12.return();
        }
      });
    }
    return subscriber;
  };
};
var subscribeToObservable = function(obj) {
  return function(subscriber) {
    var obs = obj[observable]();
    if (typeof obs.subscribe !== "function") {
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    } else {
      return obs.subscribe(subscriber);
    }
  };
};
var isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};
function isPromise(value2) {
  return !!value2 && typeof value2.subscribe !== "function" && typeof value2.then === "function";
}
var subscribeTo = function(result) {
  if (!!result && typeof result[observable] === "function") {
    return subscribeToObservable(result);
  } else if (isArrayLike(result)) {
    return subscribeToArray(result);
  } else if (isPromise(result)) {
    return subscribeToPromise(result);
  } else if (!!result && typeof result[iterator] === "function") {
    return subscribeToIterable(result);
  } else {
    var value2 = isObject(result) ? "an invalid object" : "'" + result + "'";
    var msg = "You provided " + value2 + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
    throw new TypeError(msg);
  }
};
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0) {
    innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
var NONE = {};
function combineLatest$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = void 0;
  var scheduler = void 0;
  if (isScheduler(observables[observables.length - 1])) {
    scheduler = observables.pop();
  }
  if (typeof observables[observables.length - 1] === "function") {
    resultSelector = observables.pop();
  }
  if (observables.length === 1 && isArray$1(observables[0])) {
    observables = observables[0];
  }
  return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /* @__PURE__ */ function() {
  function CombineLatestOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  CombineLatestOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
  };
  return CombineLatestOperator2;
}();
var CombineLatestSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CombineLatestSubscriber2, _super);
  function CombineLatestSubscriber2(destination, resultSelector) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.active = 0;
    _this.values = [];
    _this.observables = [];
    return _this;
  }
  CombineLatestSubscriber2.prototype._next = function(observable2) {
    this.values.push(NONE);
    this.observables.push(observable2);
  };
  CombineLatestSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len2 = observables.length;
    if (len2 === 0) {
      this.destination.complete();
    } else {
      this.active = len2;
      this.toRespond = len2;
      for (var i2 = 0; i2 < len2; i2++) {
        var observable2 = observables[i2];
        this.add(subscribeToResult(this, observable2, void 0, i2));
      }
    }
  };
  CombineLatestSubscriber2.prototype.notifyComplete = function(unused) {
    if ((this.active -= 1) === 0) {
      this.destination.complete();
    }
  };
  CombineLatestSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    var values = this.values;
    var oldVal = values[outerIndex];
    var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
    values[outerIndex] = innerValue;
    if (toRespond === 0) {
      if (this.resultSelector) {
        this._tryResultSelector(values);
      } else {
        this.destination.next(values.slice());
      }
    }
  };
  CombineLatestSubscriber2.prototype._tryResultSelector = function(values) {
    var result;
    try {
      result = this.resultSelector.apply(this, values);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return CombineLatestSubscriber2;
}(OuterSubscriber);
function scheduleObservable(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      var observable$1 = input[observable]();
      sub.add(observable$1.subscribe({
        next: function(value2) {
          sub.add(scheduler.schedule(function() {
            return subscriber.next(value2);
          }));
        },
        error: function(err) {
          sub.add(scheduler.schedule(function() {
            return subscriber.error(err);
          }));
        },
        complete: function() {
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
function schedulePromise(input, scheduler) {
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    sub.add(scheduler.schedule(function() {
      return input.then(function(value2) {
        sub.add(scheduler.schedule(function() {
          subscriber.next(value2);
          sub.add(scheduler.schedule(function() {
            return subscriber.complete();
          }));
        }));
      }, function(err) {
        sub.add(scheduler.schedule(function() {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    var sub = new Subscription();
    var iterator$12;
    sub.add(function() {
      if (iterator$12 && typeof iterator$12.return === "function") {
        iterator$12.return();
      }
    });
    sub.add(scheduler.schedule(function() {
      iterator$12 = input[iterator]();
      sub.add(scheduler.schedule(function() {
        if (subscriber.closed) {
          return;
        }
        var value2;
        var done2;
        try {
          var result = iterator$12.next();
          value2 = result.value;
          done2 = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done2) {
          subscriber.complete();
        } else {
          subscriber.next(value2);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
function isInteropObservable(input) {
  return input && typeof input[observable] === "function";
}
function isIterable(input) {
  return input && typeof input[iterator] === "function";
}
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    } else if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    } else if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    } else if (isIterable(input) || typeof input === "string") {
      return scheduleIterable(input, scheduler);
    }
  }
  throw new TypeError((input !== null && typeof input || input) + " is not observable");
}
function from(input, scheduler) {
  if (!scheduler) {
    if (input instanceof Observable) {
      return input;
    }
    return new Observable(subscribeTo(input));
  } else {
    return scheduled(input, scheduler);
  }
}
var SimpleInnerSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleInnerSubscriber2, _super);
  function SimpleInnerSubscriber2(parent) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    return _this;
  }
  SimpleInnerSubscriber2.prototype._next = function(value2) {
    this.parent.notifyNext(value2);
  };
  SimpleInnerSubscriber2.prototype._error = function(error2) {
    this.parent.notifyError(error2);
    this.unsubscribe();
  };
  SimpleInnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete();
    this.unsubscribe();
  };
  return SimpleInnerSubscriber2;
}(Subscriber);
var SimpleOuterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SimpleOuterSubscriber2, _super);
  function SimpleOuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  SimpleOuterSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  SimpleOuterSubscriber2.prototype.notifyComplete = function() {
    this.destination.complete();
  };
  return SimpleOuterSubscriber2;
}(Subscriber);
function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  var subscription;
  try {
    subscription = subscribeTo(result)(innerSubscriber);
  } catch (error2) {
    innerSubscriber.error(error2);
  }
  return subscription;
}
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(mergeMap(function(a2, i2) {
        return from(project(a2, i2)).pipe(map(function(b2, ii) {
          return resultSelector(a2, b2, i2, ii);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return function(source) {
    return source.lift(new MergeMapOperator(project, concurrent));
  };
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function MergeMapOperator2(project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    this.project = project;
    this.concurrent = concurrent;
  }
  MergeMapOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  };
  return MergeMapOperator2;
}();
var MergeMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeMapSubscriber2, _super);
  function MergeMapSubscriber2(destination, project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeMapSubscriber2.prototype._next = function(value2) {
    if (this.active < this.concurrent) {
      this._tryNext(value2);
    } else {
      this.buffer.push(value2);
    }
  };
  MergeMapSubscriber2.prototype._tryNext = function(value2) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value2, index2);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.active++;
    this._innerSub(result);
  };
  MergeMapSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  MergeMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  MergeMapSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2.length > 0) {
      this._next(buffer2.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      this.destination.complete();
    }
  };
  return MergeMapSubscriber2;
}(SimpleOuterSubscriber);
var flatMap = mergeMap;
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return mergeMap(identity, concurrent);
}
function concatAll() {
  return mergeAll(1);
}
function concat$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return concatAll()(of.apply(void 0, observables));
}
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    var input;
    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = input ? from(input) : empty();
    return source.subscribe(subscriber);
  });
}
function forkJoin() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 1) {
    var first_1 = sources[0];
    if (isArray$1(first_1)) {
      return forkJoinInternal(first_1, null);
    }
    if (isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
      var keys2 = Object.keys(first_1);
      return forkJoinInternal(keys2.map(function(key2) {
        return first_1[key2];
      }), keys2);
    }
  }
  if (typeof sources[sources.length - 1] === "function") {
    var resultSelector_1 = sources.pop();
    sources = sources.length === 1 && isArray$1(sources[0]) ? sources[0] : sources;
    return forkJoinInternal(sources, null).pipe(map(function(args) {
      return resultSelector_1.apply(void 0, args);
    }));
  }
  return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys2) {
  return new Observable(function(subscriber) {
    var len2 = sources.length;
    if (len2 === 0) {
      subscriber.complete();
      return;
    }
    var values = new Array(len2);
    var completed = 0;
    var emitted = 0;
    var _loop_1 = function(i3) {
      var source = from(sources[i3]);
      var hasValue = false;
      subscriber.add(source.subscribe({
        next: function(value2) {
          if (!hasValue) {
            hasValue = true;
            emitted++;
          }
          values[i3] = value2;
        },
        error: function(err) {
          return subscriber.error(err);
        },
        complete: function() {
          completed++;
          if (completed === len2 || !hasValue) {
            if (emitted === len2) {
              subscriber.next(keys2 ? keys2.reduce(function(result, key2, i4) {
                return result[key2] = values[i4], result;
              }, {}) : values);
            }
            subscriber.complete();
          }
        }
      }));
    };
    for (var i2 = 0; i2 < len2; i2++) {
      _loop_1(i2);
    }
  });
}
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(map(function(args) {
      return isArray$1(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    function handler(e2) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e2);
      }
    }
    setupSubscription(target, eventName, handler, subscriber, options);
  });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  var unsubscribe;
  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);
    unsubscribe = function() {
      return source_1.removeEventListener(eventName, handler, options);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler);
    unsubscribe = function() {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler);
    unsubscribe = function() {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length) {
    for (var i2 = 0, len2 = sourceObj.length; i2 < len2; i2++) {
      setupSubscription(sourceObj[i2], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError("Invalid event target");
  }
  subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === "function" && typeof sourceObj.removeListener === "function";
}
function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === "function" && typeof sourceObj.off === "function";
}
function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === "function" && typeof sourceObj.removeEventListener === "function";
}
function fromEventPattern(addHandler, removeHandler, resultSelector) {
  if (resultSelector) {
    return fromEventPattern(addHandler, removeHandler).pipe(map(function(args) {
      return isArray$1(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var e2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        e2[_i] = arguments[_i];
      }
      return subscriber.next(e2.length === 1 ? e2[0] : e2);
    };
    var retValue;
    try {
      retValue = addHandler(handler);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!isFunction(removeHandler)) {
      return void 0;
    }
    return function() {
      return removeHandler(handler, retValue);
    };
  });
}
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
  var resultSelector;
  var initialState;
  if (arguments.length == 1) {
    var options = initialStateOrOptions;
    initialState = options.initialState;
    condition = options.condition;
    iterate = options.iterate;
    resultSelector = options.resultSelector || identity;
    scheduler = options.scheduler;
  } else if (resultSelectorOrObservable === void 0 || isScheduler(resultSelectorOrObservable)) {
    initialState = initialStateOrOptions;
    resultSelector = identity;
    scheduler = resultSelectorOrObservable;
  } else {
    initialState = initialStateOrOptions;
    resultSelector = resultSelectorOrObservable;
  }
  return new Observable(function(subscriber) {
    var state2 = initialState;
    if (scheduler) {
      return scheduler.schedule(dispatch$4, 0, {
        subscriber,
        iterate,
        condition,
        resultSelector,
        state: state2
      });
    }
    do {
      if (condition) {
        var conditionResult = void 0;
        try {
          conditionResult = condition(state2);
        } catch (err) {
          subscriber.error(err);
          return void 0;
        }
        if (!conditionResult) {
          subscriber.complete();
          break;
        }
      }
      var value2 = void 0;
      try {
        value2 = resultSelector(state2);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
      subscriber.next(value2);
      if (subscriber.closed) {
        break;
      }
      try {
        state2 = iterate(state2);
      } catch (err) {
        subscriber.error(err);
        return void 0;
      }
    } while (true);
    return void 0;
  });
}
function dispatch$4(state2) {
  var subscriber = state2.subscriber, condition = state2.condition;
  if (subscriber.closed) {
    return void 0;
  }
  if (state2.needIterate) {
    try {
      state2.state = state2.iterate(state2.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
  } else {
    state2.needIterate = true;
  }
  if (condition) {
    var conditionResult = void 0;
    try {
      conditionResult = condition(state2.state);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    if (!conditionResult) {
      subscriber.complete();
      return void 0;
    }
    if (subscriber.closed) {
      return void 0;
    }
  }
  var value2;
  try {
    value2 = state2.resultSelector(state2.state);
  } catch (err) {
    subscriber.error(err);
    return void 0;
  }
  if (subscriber.closed) {
    return void 0;
  }
  subscriber.next(value2);
  if (subscriber.closed) {
    return void 0;
  }
  return this.schedule(state2);
}
function iif(condition, trueResult, falseResult) {
  if (trueResult === void 0) {
    trueResult = EMPTY;
  }
  if (falseResult === void 0) {
    falseResult = EMPTY;
  }
  return defer(function() {
    return condition() ? trueResult : falseResult;
  });
}
function isNumeric(val) {
  return !isArray$1(val) && val - parseFloat(val) + 1 >= 0;
}
function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (!isNumeric(period) || period < 0) {
    period = 0;
  }
  if (!scheduler || typeof scheduler.schedule !== "function") {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    subscriber.add(scheduler.schedule(dispatch$3, period, { subscriber, counter: 0, period }));
    return subscriber;
  });
}
function dispatch$3(state2) {
  var subscriber = state2.subscriber, counter = state2.counter, period = state2.period;
  subscriber.next(counter);
  this.schedule({ subscriber, counter: counter + 1, period }, period);
}
function merge$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler = null;
  var last2 = observables[observables.length - 1];
  if (isScheduler(last2)) {
    scheduler = observables.pop();
    if (observables.length > 1 && typeof observables[observables.length - 1] === "number") {
      concurrent = observables.pop();
    }
  } else if (typeof last2 === "number") {
    concurrent = observables.pop();
  }
  if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
    return observables[0];
  }
  return mergeAll(concurrent)(fromArray(observables, scheduler));
}
var NEVER = /* @__PURE__ */ new Observable(noop$2);
function never() {
  return NEVER;
}
function onErrorResumeNext$1() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  if (sources.length === 0) {
    return EMPTY;
  }
  var first2 = sources[0], remainder = sources.slice(1);
  if (sources.length === 1 && isArray$1(first2)) {
    return onErrorResumeNext$1.apply(void 0, first2);
  }
  return new Observable(function(subscriber) {
    var subNext = function() {
      return subscriber.add(onErrorResumeNext$1.apply(void 0, remainder).subscribe(subscriber));
    };
    return from(first2).subscribe({
      next: function(value2) {
        subscriber.next(value2);
      },
      error: subNext,
      complete: subNext
    });
  });
}
function pairs(obj, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      var keys2 = Object.keys(obj);
      for (var i2 = 0; i2 < keys2.length && !subscriber.closed; i2++) {
        var key2 = keys2[i2];
        if (obj.hasOwnProperty(key2)) {
          subscriber.next([key2, obj[key2]]);
        }
      }
      subscriber.complete();
    });
  } else {
    return new Observable(function(subscriber) {
      var keys2 = Object.keys(obj);
      var subscription = new Subscription();
      subscription.add(scheduler.schedule(dispatch$2, 0, { keys: keys2, index: 0, subscriber, subscription, obj }));
      return subscription;
    });
  }
}
function dispatch$2(state2) {
  var keys2 = state2.keys, index2 = state2.index, subscriber = state2.subscriber, subscription = state2.subscription, obj = state2.obj;
  if (!subscriber.closed) {
    if (index2 < keys2.length) {
      var key2 = keys2[index2];
      subscriber.next([key2, obj[key2]]);
      subscription.add(this.schedule({ keys: keys2, index: index2 + 1, subscriber, subscription, obj }));
    } else {
      subscriber.complete();
    }
  }
}
function not(pred, thisArg) {
  function notPred() {
    return !notPred.pred.apply(notPred.thisArg, arguments);
  }
  notPred.pred = pred;
  notPred.thisArg = thisArg;
  return notPred;
}
function filter(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function FilterOperator2(predicate, thisArg) {
    this.predicate = predicate;
    this.thisArg = thisArg;
  }
  FilterOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  };
  return FilterOperator2;
}();
var FilterSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FilterSubscriber2, _super);
  function FilterSubscriber2(destination, predicate, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.count = 0;
    return _this;
  }
  FilterSubscriber2.prototype._next = function(value2) {
    var result;
    try {
      result = this.predicate.call(this.thisArg, value2, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.destination.next(value2);
    }
  };
  return FilterSubscriber2;
}(Subscriber);
function partition$1(source, predicate, thisArg) {
  return [
    filter(predicate, thisArg)(new Observable(subscribeTo(source))),
    filter(not(predicate, thisArg))(new Observable(subscribeTo(source)))
  ];
}
function race$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  if (observables.length === 1) {
    if (isArray$1(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }
  return fromArray(observables, void 0).lift(new RaceOperator());
}
var RaceOperator = /* @__PURE__ */ function() {
  function RaceOperator2() {
  }
  RaceOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RaceSubscriber(subscriber));
  };
  return RaceOperator2;
}();
var RaceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RaceSubscriber2, _super);
  function RaceSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasFirst = false;
    _this.observables = [];
    _this.subscriptions = [];
    return _this;
  }
  RaceSubscriber2.prototype._next = function(observable2) {
    this.observables.push(observable2);
  };
  RaceSubscriber2.prototype._complete = function() {
    var observables = this.observables;
    var len2 = observables.length;
    if (len2 === 0) {
      this.destination.complete();
    } else {
      for (var i2 = 0; i2 < len2 && !this.hasFirst; i2++) {
        var observable2 = observables[i2];
        var subscription = subscribeToResult(this, observable2, void 0, i2);
        if (this.subscriptions) {
          this.subscriptions.push(subscription);
        }
        this.add(subscription);
      }
      this.observables = null;
    }
  };
  RaceSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    if (!this.hasFirst) {
      this.hasFirst = true;
      for (var i2 = 0; i2 < this.subscriptions.length; i2++) {
        if (i2 !== outerIndex) {
          var subscription = this.subscriptions[i2];
          subscription.unsubscribe();
          this.remove(subscription);
        }
      }
      this.subscriptions = null;
    }
    this.destination.next(innerValue);
  };
  return RaceSubscriber2;
}(OuterSubscriber);
function range$1(start, count2, scheduler) {
  if (start === void 0) {
    start = 0;
  }
  return new Observable(function(subscriber) {
    if (count2 === void 0) {
      count2 = start;
      start = 0;
    }
    var index2 = 0;
    var current = start;
    if (scheduler) {
      return scheduler.schedule(dispatch$1, 0, {
        index: index2,
        count: count2,
        start,
        subscriber
      });
    } else {
      do {
        if (index2++ >= count2) {
          subscriber.complete();
          break;
        }
        subscriber.next(current++);
        if (subscriber.closed) {
          break;
        }
      } while (true);
    }
    return void 0;
  });
}
function dispatch$1(state2) {
  var start = state2.start, index2 = state2.index, count2 = state2.count, subscriber = state2.subscriber;
  if (index2 >= count2) {
    subscriber.complete();
    return;
  }
  subscriber.next(start);
  if (subscriber.closed) {
    return;
  }
  state2.index = index2 + 1;
  state2.start = start + 1;
  this.schedule(state2);
}
function timer$1(dueTime, periodOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  var period = -1;
  if (isNumeric(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if (isScheduler(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }
  if (!isScheduler(scheduler)) {
    scheduler = async;
  }
  return new Observable(function(subscriber) {
    var due = isNumeric(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch, due, {
      index: 0,
      period,
      subscriber
    });
  });
}
function dispatch(state2) {
  var index2 = state2.index, period = state2.period, subscriber = state2.subscriber;
  subscriber.next(index2);
  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }
  state2.index = index2 + 1;
  this.schedule(state2, period);
}
function using(resourceFactory, observableFactory) {
  return new Observable(function(subscriber) {
    var resource;
    try {
      resource = resourceFactory();
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var result;
    try {
      result = observableFactory(resource);
    } catch (err) {
      subscriber.error(err);
      return void 0;
    }
    var source = result ? from(result) : EMPTY;
    var subscription = source.subscribe(subscriber);
    return function() {
      subscription.unsubscribe();
      if (resource) {
        resource.unsubscribe();
      }
    };
  });
}
function zip$1() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var resultSelector = observables[observables.length - 1];
  if (typeof resultSelector === "function") {
    observables.pop();
  }
  return fromArray(observables, void 0).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /* @__PURE__ */ function() {
  function ZipOperator2(resultSelector) {
    this.resultSelector = resultSelector;
  }
  ZipOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
  };
  return ZipOperator2;
}();
var ZipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ZipSubscriber2, _super);
  function ZipSubscriber2(destination, resultSelector, values) {
    var _this = _super.call(this, destination) || this;
    _this.resultSelector = resultSelector;
    _this.iterators = [];
    _this.active = 0;
    _this.resultSelector = typeof resultSelector === "function" ? resultSelector : void 0;
    return _this;
  }
  ZipSubscriber2.prototype._next = function(value2) {
    var iterators = this.iterators;
    if (isArray$1(value2)) {
      iterators.push(new StaticArrayIterator(value2));
    } else if (typeof value2[iterator] === "function") {
      iterators.push(new StaticIterator(value2[iterator]()));
    } else {
      iterators.push(new ZipBufferIterator(this.destination, this, value2));
    }
  };
  ZipSubscriber2.prototype._complete = function() {
    var iterators = this.iterators;
    var len2 = iterators.length;
    this.unsubscribe();
    if (len2 === 0) {
      this.destination.complete();
      return;
    }
    this.active = len2;
    for (var i2 = 0; i2 < len2; i2++) {
      var iterator2 = iterators[i2];
      if (iterator2.stillUnsubscribed) {
        var destination = this.destination;
        destination.add(iterator2.subscribe());
      } else {
        this.active--;
      }
    }
  };
  ZipSubscriber2.prototype.notifyInactive = function() {
    this.active--;
    if (this.active === 0) {
      this.destination.complete();
    }
  };
  ZipSubscriber2.prototype.checkIterators = function() {
    var iterators = this.iterators;
    var len2 = iterators.length;
    var destination = this.destination;
    for (var i2 = 0; i2 < len2; i2++) {
      var iterator2 = iterators[i2];
      if (typeof iterator2.hasValue === "function" && !iterator2.hasValue()) {
        return;
      }
    }
    var shouldComplete = false;
    var args = [];
    for (var i2 = 0; i2 < len2; i2++) {
      var iterator2 = iterators[i2];
      var result = iterator2.next();
      if (iterator2.hasCompleted()) {
        shouldComplete = true;
      }
      if (result.done) {
        destination.complete();
        return;
      }
      args.push(result.value);
    }
    if (this.resultSelector) {
      this._tryresultSelector(args);
    } else {
      destination.next(args);
    }
    if (shouldComplete) {
      destination.complete();
    }
  };
  ZipSubscriber2.prototype._tryresultSelector = function(args) {
    var result;
    try {
      result = this.resultSelector.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return ZipSubscriber2;
}(Subscriber);
var StaticIterator = /* @__PURE__ */ function() {
  function StaticIterator2(iterator2) {
    this.iterator = iterator2;
    this.nextResult = iterator2.next();
  }
  StaticIterator2.prototype.hasValue = function() {
    return true;
  };
  StaticIterator2.prototype.next = function() {
    var result = this.nextResult;
    this.nextResult = this.iterator.next();
    return result;
  };
  StaticIterator2.prototype.hasCompleted = function() {
    var nextResult = this.nextResult;
    return Boolean(nextResult && nextResult.done);
  };
  return StaticIterator2;
}();
var StaticArrayIterator = /* @__PURE__ */ function() {
  function StaticArrayIterator2(array2) {
    this.array = array2;
    this.index = 0;
    this.length = 0;
    this.length = array2.length;
  }
  StaticArrayIterator2.prototype[iterator] = function() {
    return this;
  };
  StaticArrayIterator2.prototype.next = function(value2) {
    var i2 = this.index++;
    var array2 = this.array;
    return i2 < this.length ? { value: array2[i2], done: false } : { value: null, done: true };
  };
  StaticArrayIterator2.prototype.hasValue = function() {
    return this.array.length > this.index;
  };
  StaticArrayIterator2.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  };
  return StaticArrayIterator2;
}();
var ZipBufferIterator = /* @__PURE__ */ function(_super) {
  __extends(ZipBufferIterator2, _super);
  function ZipBufferIterator2(destination, parent, observable2) {
    var _this = _super.call(this, destination) || this;
    _this.parent = parent;
    _this.observable = observable2;
    _this.stillUnsubscribed = true;
    _this.buffer = [];
    _this.isComplete = false;
    return _this;
  }
  ZipBufferIterator2.prototype[iterator] = function() {
    return this;
  };
  ZipBufferIterator2.prototype.next = function() {
    var buffer2 = this.buffer;
    if (buffer2.length === 0 && this.isComplete) {
      return { value: null, done: true };
    } else {
      return { value: buffer2.shift(), done: false };
    }
  };
  ZipBufferIterator2.prototype.hasValue = function() {
    return this.buffer.length > 0;
  };
  ZipBufferIterator2.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  };
  ZipBufferIterator2.prototype.notifyComplete = function() {
    if (this.buffer.length > 0) {
      this.isComplete = true;
      this.parent.notifyInactive();
    } else {
      this.destination.complete();
    }
  };
  ZipBufferIterator2.prototype.notifyNext = function(innerValue) {
    this.buffer.push(innerValue);
    this.parent.checkIterators();
  };
  ZipBufferIterator2.prototype.subscribe = function() {
    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
  };
  return ZipBufferIterator2;
}(SimpleOuterSubscriber);
var _esm5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  Observable,
  ConnectableObservable,
  GroupedObservable,
  observable,
  Subject,
  BehaviorSubject,
  ReplaySubject,
  AsyncSubject,
  asap,
  asapScheduler,
  async,
  asyncScheduler,
  queue: queue$1,
  queueScheduler,
  animationFrame,
  animationFrameScheduler,
  VirtualTimeScheduler,
  VirtualAction,
  Scheduler,
  Subscription,
  Subscriber,
  Notification,
  get NotificationKind() {
    return NotificationKind;
  },
  pipe,
  noop: noop$2,
  identity,
  isObservable,
  ArgumentOutOfRangeError,
  EmptyError,
  ObjectUnsubscribedError,
  UnsubscriptionError,
  TimeoutError,
  bindCallback,
  bindNodeCallback,
  combineLatest: combineLatest$1,
  concat: concat$1,
  defer,
  empty,
  forkJoin,
  from,
  fromEvent,
  fromEventPattern,
  generate,
  iif,
  interval,
  merge: merge$1,
  never,
  of,
  onErrorResumeNext: onErrorResumeNext$1,
  pairs,
  partition: partition$1,
  race: race$1,
  range: range$1,
  throwError,
  timer: timer$1,
  using,
  zip: zip$1,
  scheduled,
  EMPTY,
  NEVER,
  config
});
var require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(_esm5);
function audit(durationSelector) {
  return function auditOperatorFunction(source) {
    return source.lift(new AuditOperator(durationSelector));
  };
}
var AuditOperator = /* @__PURE__ */ function() {
  function AuditOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  AuditOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
  };
  return AuditOperator2;
}();
var AuditSubscriber = /* @__PURE__ */ function(_super) {
  __extends(AuditSubscriber2, _super);
  function AuditSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    return _this;
  }
  AuditSubscriber2.prototype._next = function(value2) {
    this.value = value2;
    this.hasValue = true;
    if (!this.throttled) {
      var duration = void 0;
      try {
        var durationSelector = this.durationSelector;
        duration = durationSelector(value2);
      } catch (err) {
        return this.destination.error(err);
      }
      var innerSubscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
      if (!innerSubscription || innerSubscription.closed) {
        this.clearThrottle();
      } else {
        this.add(this.throttled = innerSubscription);
      }
    }
  };
  AuditSubscriber2.prototype.clearThrottle = function() {
    var _a2 = this, value2 = _a2.value, hasValue = _a2.hasValue, throttled = _a2.throttled;
    if (throttled) {
      this.remove(throttled);
      this.throttled = void 0;
      throttled.unsubscribe();
    }
    if (hasValue) {
      this.value = void 0;
      this.hasValue = false;
      this.destination.next(value2);
    }
  };
  AuditSubscriber2.prototype.notifyNext = function() {
    this.clearThrottle();
  };
  AuditSubscriber2.prototype.notifyComplete = function() {
    this.clearThrottle();
  };
  return AuditSubscriber2;
}(SimpleOuterSubscriber);
function auditTime(duration, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return audit(function() {
    return timer$1(duration, scheduler);
  });
}
function buffer(closingNotifier) {
  return function bufferOperatorFunction(source) {
    return source.lift(new BufferOperator(closingNotifier));
  };
}
var BufferOperator = /* @__PURE__ */ function() {
  function BufferOperator2(closingNotifier) {
    this.closingNotifier = closingNotifier;
  }
  BufferOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
  };
  return BufferOperator2;
}();
var BufferSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSubscriber2, _super);
  function BufferSubscriber2(destination, closingNotifier) {
    var _this = _super.call(this, destination) || this;
    _this.buffer = [];
    _this.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(_this)));
    return _this;
  }
  BufferSubscriber2.prototype._next = function(value2) {
    this.buffer.push(value2);
  };
  BufferSubscriber2.prototype.notifyNext = function() {
    var buffer2 = this.buffer;
    this.buffer = [];
    this.destination.next(buffer2);
  };
  return BufferSubscriber2;
}(SimpleOuterSubscriber);
function bufferCount(bufferSize, startBufferEvery) {
  if (startBufferEvery === void 0) {
    startBufferEvery = null;
  }
  return function bufferCountOperatorFunction(source) {
    return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
  };
}
var BufferCountOperator = /* @__PURE__ */ function() {
  function BufferCountOperator2(bufferSize, startBufferEvery) {
    this.bufferSize = bufferSize;
    this.startBufferEvery = startBufferEvery;
    if (!startBufferEvery || bufferSize === startBufferEvery) {
      this.subscriberClass = BufferCountSubscriber;
    } else {
      this.subscriberClass = BufferSkipCountSubscriber;
    }
  }
  BufferCountOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
  };
  return BufferCountOperator2;
}();
var BufferCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferCountSubscriber2, _super);
  function BufferCountSubscriber2(destination, bufferSize) {
    var _this = _super.call(this, destination) || this;
    _this.bufferSize = bufferSize;
    _this.buffer = [];
    return _this;
  }
  BufferCountSubscriber2.prototype._next = function(value2) {
    var buffer2 = this.buffer;
    buffer2.push(value2);
    if (buffer2.length == this.bufferSize) {
      this.destination.next(buffer2);
      this.buffer = [];
    }
  };
  BufferCountSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    if (buffer2.length > 0) {
      this.destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  };
  return BufferCountSubscriber2;
}(Subscriber);
var BufferSkipCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferSkipCountSubscriber2, _super);
  function BufferSkipCountSubscriber2(destination, bufferSize, startBufferEvery) {
    var _this = _super.call(this, destination) || this;
    _this.bufferSize = bufferSize;
    _this.startBufferEvery = startBufferEvery;
    _this.buffers = [];
    _this.count = 0;
    return _this;
  }
  BufferSkipCountSubscriber2.prototype._next = function(value2) {
    var _a2 = this, bufferSize = _a2.bufferSize, startBufferEvery = _a2.startBufferEvery, buffers = _a2.buffers, count2 = _a2.count;
    this.count++;
    if (count2 % startBufferEvery === 0) {
      buffers.push([]);
    }
    for (var i2 = buffers.length; i2--; ) {
      var buffer2 = buffers[i2];
      buffer2.push(value2);
      if (buffer2.length === bufferSize) {
        buffers.splice(i2, 1);
        this.destination.next(buffer2);
      }
    }
  };
  BufferSkipCountSubscriber2.prototype._complete = function() {
    var _a2 = this, buffers = _a2.buffers, destination = _a2.destination;
    while (buffers.length > 0) {
      var buffer2 = buffers.shift();
      if (buffer2.length > 0) {
        destination.next(buffer2);
      }
    }
    _super.prototype._complete.call(this);
  };
  return BufferSkipCountSubscriber2;
}(Subscriber);
function bufferTime(bufferTimeSpan) {
  var length = arguments.length;
  var scheduler = async;
  if (isScheduler(arguments[arguments.length - 1])) {
    scheduler = arguments[arguments.length - 1];
    length--;
  }
  var bufferCreationInterval = null;
  if (length >= 2) {
    bufferCreationInterval = arguments[1];
  }
  var maxBufferSize = Number.POSITIVE_INFINITY;
  if (length >= 3) {
    maxBufferSize = arguments[2];
  }
  return function bufferTimeOperatorFunction(source) {
    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
  };
}
var BufferTimeOperator = /* @__PURE__ */ function() {
  function BufferTimeOperator2(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    this.bufferTimeSpan = bufferTimeSpan;
    this.bufferCreationInterval = bufferCreationInterval;
    this.maxBufferSize = maxBufferSize;
    this.scheduler = scheduler;
  }
  BufferTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  };
  return BufferTimeOperator2;
}();
var Context = /* @__PURE__ */ function() {
  function Context2() {
    this.buffer = [];
  }
  return Context2;
}();
var BufferTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferTimeSubscriber2, _super);
  function BufferTimeSubscriber2(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.bufferTimeSpan = bufferTimeSpan;
    _this.bufferCreationInterval = bufferCreationInterval;
    _this.maxBufferSize = maxBufferSize;
    _this.scheduler = scheduler;
    _this.contexts = [];
    var context = _this.openContext();
    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
    if (_this.timespanOnly) {
      var timeSpanOnlyState = { subscriber: _this, context, bufferTimeSpan };
      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    } else {
      var closeState = { subscriber: _this, context };
      var creationState = { bufferTimeSpan, bufferCreationInterval, subscriber: _this, scheduler };
      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
    }
    return _this;
  }
  BufferTimeSubscriber2.prototype._next = function(value2) {
    var contexts = this.contexts;
    var len2 = contexts.length;
    var filledBufferContext;
    for (var i2 = 0; i2 < len2; i2++) {
      var context_1 = contexts[i2];
      var buffer2 = context_1.buffer;
      buffer2.push(value2);
      if (buffer2.length == this.maxBufferSize) {
        filledBufferContext = context_1;
      }
    }
    if (filledBufferContext) {
      this.onBufferFull(filledBufferContext);
    }
  };
  BufferTimeSubscriber2.prototype._error = function(err) {
    this.contexts.length = 0;
    _super.prototype._error.call(this, err);
  };
  BufferTimeSubscriber2.prototype._complete = function() {
    var _a2 = this, contexts = _a2.contexts, destination = _a2.destination;
    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      destination.next(context_2.buffer);
    }
    _super.prototype._complete.call(this);
  };
  BufferTimeSubscriber2.prototype._unsubscribe = function() {
    this.contexts = null;
  };
  BufferTimeSubscriber2.prototype.onBufferFull = function(context) {
    this.closeContext(context);
    var closeAction = context.closeAction;
    closeAction.unsubscribe();
    this.remove(closeAction);
    if (!this.closed && this.timespanOnly) {
      context = this.openContext();
      var bufferTimeSpan = this.bufferTimeSpan;
      var timeSpanOnlyState = { subscriber: this, context, bufferTimeSpan };
      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
    }
  };
  BufferTimeSubscriber2.prototype.openContext = function() {
    var context = new Context();
    this.contexts.push(context);
    return context;
  };
  BufferTimeSubscriber2.prototype.closeContext = function(context) {
    this.destination.next(context.buffer);
    var contexts = this.contexts;
    var spliceIndex = contexts ? contexts.indexOf(context) : -1;
    if (spliceIndex >= 0) {
      contexts.splice(contexts.indexOf(context), 1);
    }
  };
  return BufferTimeSubscriber2;
}(Subscriber);
function dispatchBufferTimeSpanOnly(state2) {
  var subscriber = state2.subscriber;
  var prevContext = state2.context;
  if (prevContext) {
    subscriber.closeContext(prevContext);
  }
  if (!subscriber.closed) {
    state2.context = subscriber.openContext();
    state2.context.closeAction = this.schedule(state2, state2.bufferTimeSpan);
  }
}
function dispatchBufferCreation(state2) {
  var bufferCreationInterval = state2.bufferCreationInterval, bufferTimeSpan = state2.bufferTimeSpan, subscriber = state2.subscriber, scheduler = state2.scheduler;
  var context = subscriber.openContext();
  var action = this;
  if (!subscriber.closed) {
    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber, context }));
    action.schedule(state2, bufferCreationInterval);
  }
}
function dispatchBufferClose(arg) {
  var subscriber = arg.subscriber, context = arg.context;
  subscriber.closeContext(context);
}
function bufferToggle(openings, closingSelector) {
  return function bufferToggleOperatorFunction(source) {
    return source.lift(new BufferToggleOperator(openings, closingSelector));
  };
}
var BufferToggleOperator = /* @__PURE__ */ function() {
  function BufferToggleOperator2(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }
  BufferToggleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };
  return BufferToggleOperator2;
}();
var BufferToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferToggleSubscriber2, _super);
  function BufferToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.closingSelector = closingSelector;
    _this.contexts = [];
    _this.add(subscribeToResult(_this, openings));
    return _this;
  }
  BufferToggleSubscriber2.prototype._next = function(value2) {
    var contexts = this.contexts;
    var len2 = contexts.length;
    for (var i2 = 0; i2 < len2; i2++) {
      contexts[i2].buffer.push(value2);
    }
  };
  BufferToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    while (contexts.length > 0) {
      var context_1 = contexts.shift();
      context_1.subscription.unsubscribe();
      context_1.buffer = null;
      context_1.subscription = null;
    }
    this.contexts = null;
    _super.prototype._error.call(this, err);
  };
  BufferToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    while (contexts.length > 0) {
      var context_2 = contexts.shift();
      this.destination.next(context_2.buffer);
      context_2.subscription.unsubscribe();
      context_2.buffer = null;
      context_2.subscription = null;
    }
    this.contexts = null;
    _super.prototype._complete.call(this);
  };
  BufferToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue) {
    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
  };
  BufferToggleSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.closeBuffer(innerSub.context);
  };
  BufferToggleSubscriber2.prototype.openBuffer = function(value2) {
    try {
      var closingSelector = this.closingSelector;
      var closingNotifier = closingSelector.call(this, value2);
      if (closingNotifier) {
        this.trySubscribe(closingNotifier);
      }
    } catch (err) {
      this._error(err);
    }
  };
  BufferToggleSubscriber2.prototype.closeBuffer = function(context) {
    var contexts = this.contexts;
    if (contexts && context) {
      var buffer2 = context.buffer, subscription = context.subscription;
      this.destination.next(buffer2);
      contexts.splice(contexts.indexOf(context), 1);
      this.remove(subscription);
      subscription.unsubscribe();
    }
  };
  BufferToggleSubscriber2.prototype.trySubscribe = function(closingNotifier) {
    var contexts = this.contexts;
    var buffer2 = [];
    var subscription = new Subscription();
    var context = { buffer: buffer2, subscription };
    contexts.push(context);
    var innerSubscription = subscribeToResult(this, closingNotifier, context);
    if (!innerSubscription || innerSubscription.closed) {
      this.closeBuffer(context);
    } else {
      innerSubscription.context = context;
      this.add(innerSubscription);
      subscription.add(innerSubscription);
    }
  };
  return BufferToggleSubscriber2;
}(OuterSubscriber);
function bufferWhen(closingSelector) {
  return function(source) {
    return source.lift(new BufferWhenOperator(closingSelector));
  };
}
var BufferWhenOperator = /* @__PURE__ */ function() {
  function BufferWhenOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  BufferWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
  };
  return BufferWhenOperator2;
}();
var BufferWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(BufferWhenSubscriber2, _super);
  function BufferWhenSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.closingSelector = closingSelector;
    _this.subscribing = false;
    _this.openBuffer();
    return _this;
  }
  BufferWhenSubscriber2.prototype._next = function(value2) {
    this.buffer.push(value2);
  };
  BufferWhenSubscriber2.prototype._complete = function() {
    var buffer2 = this.buffer;
    if (buffer2) {
      this.destination.next(buffer2);
    }
    _super.prototype._complete.call(this);
  };
  BufferWhenSubscriber2.prototype._unsubscribe = function() {
    this.buffer = void 0;
    this.subscribing = false;
  };
  BufferWhenSubscriber2.prototype.notifyNext = function() {
    this.openBuffer();
  };
  BufferWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.subscribing) {
      this.complete();
    } else {
      this.openBuffer();
    }
  };
  BufferWhenSubscriber2.prototype.openBuffer = function() {
    var closingSubscription = this.closingSubscription;
    if (closingSubscription) {
      this.remove(closingSubscription);
      closingSubscription.unsubscribe();
    }
    var buffer2 = this.buffer;
    if (this.buffer) {
      this.destination.next(buffer2);
    }
    this.buffer = [];
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (err) {
      return this.error(err);
    }
    closingSubscription = new Subscription();
    this.closingSubscription = closingSubscription;
    this.add(closingSubscription);
    this.subscribing = true;
    closingSubscription.add(innerSubscribe(closingNotifier, new SimpleInnerSubscriber(this)));
    this.subscribing = false;
  };
  return BufferWhenSubscriber2;
}(SimpleOuterSubscriber);
function catchError(selector) {
  return function catchErrorOperatorFunction(source) {
    var operator = new CatchOperator(selector);
    var caught = source.lift(operator);
    return operator.caught = caught;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function CatchOperator2(selector) {
    this.selector = selector;
  }
  CatchOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
  };
  return CatchOperator2;
}();
var CatchSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CatchSubscriber2, _super);
  function CatchSubscriber2(destination, selector, caught) {
    var _this = _super.call(this, destination) || this;
    _this.selector = selector;
    _this.caught = caught;
    return _this;
  }
  CatchSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var result = void 0;
      try {
        result = this.selector(err, this.caught);
      } catch (err2) {
        _super.prototype.error.call(this, err2);
        return;
      }
      this._unsubscribeAndRecycle();
      var innerSubscriber = new SimpleInnerSubscriber(this);
      this.add(innerSubscriber);
      var innerSubscription = innerSubscribe(result, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        this.add(innerSubscription);
      }
    }
  };
  return CatchSubscriber2;
}(SimpleOuterSubscriber);
function combineAll(project) {
  return function(source) {
    return source.lift(new CombineLatestOperator(project));
  };
}
function combineLatest() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  var project = null;
  if (typeof observables[observables.length - 1] === "function") {
    project = observables.pop();
  }
  if (observables.length === 1 && isArray$1(observables[0])) {
    observables = observables[0].slice();
  }
  return function(source) {
    return source.lift.call(from([source].concat(observables)), new CombineLatestOperator(project));
  };
}
function concat() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(concat$1.apply(void 0, [source].concat(observables)));
  };
}
function concatMap(project, resultSelector) {
  return mergeMap(project, resultSelector, 1);
}
function concatMapTo(innerObservable, resultSelector) {
  return concatMap(function() {
    return innerObservable;
  }, resultSelector);
}
function count(predicate) {
  return function(source) {
    return source.lift(new CountOperator(predicate, source));
  };
}
var CountOperator = /* @__PURE__ */ function() {
  function CountOperator2(predicate, source) {
    this.predicate = predicate;
    this.source = source;
  }
  CountOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
  };
  return CountOperator2;
}();
var CountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(CountSubscriber2, _super);
  function CountSubscriber2(destination, predicate, source) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source;
    _this.count = 0;
    _this.index = 0;
    return _this;
  }
  CountSubscriber2.prototype._next = function(value2) {
    if (this.predicate) {
      this._tryPredicate(value2);
    } else {
      this.count++;
    }
  };
  CountSubscriber2.prototype._tryPredicate = function(value2) {
    var result;
    try {
      result = this.predicate(value2, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (result) {
      this.count++;
    }
  };
  CountSubscriber2.prototype._complete = function() {
    this.destination.next(this.count);
    this.destination.complete();
  };
  return CountSubscriber2;
}(Subscriber);
function debounce(durationSelector) {
  return function(source) {
    return source.lift(new DebounceOperator(durationSelector));
  };
}
var DebounceOperator = /* @__PURE__ */ function() {
  function DebounceOperator2(durationSelector) {
    this.durationSelector = durationSelector;
  }
  DebounceOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
  };
  return DebounceOperator2;
}();
var DebounceSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceSubscriber2, _super);
  function DebounceSubscriber2(destination, durationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.durationSelector = durationSelector;
    _this.hasValue = false;
    return _this;
  }
  DebounceSubscriber2.prototype._next = function(value2) {
    try {
      var result = this.durationSelector.call(this, value2);
      if (result) {
        this._tryNext(value2, result);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  DebounceSubscriber2.prototype._complete = function() {
    this.emitValue();
    this.destination.complete();
  };
  DebounceSubscriber2.prototype._tryNext = function(value2, duration) {
    var subscription = this.durationSubscription;
    this.value = value2;
    this.hasValue = true;
    if (subscription) {
      subscription.unsubscribe();
      this.remove(subscription);
    }
    subscription = innerSubscribe(duration, new SimpleInnerSubscriber(this));
    if (subscription && !subscription.closed) {
      this.add(this.durationSubscription = subscription);
    }
  };
  DebounceSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  };
  DebounceSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  };
  DebounceSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      var value2 = this.value;
      var subscription = this.durationSubscription;
      if (subscription) {
        this.durationSubscription = void 0;
        subscription.unsubscribe();
        this.remove(subscription);
      }
      this.value = void 0;
      this.hasValue = false;
      _super.prototype._next.call(this, value2);
    }
  };
  return DebounceSubscriber2;
}(SimpleOuterSubscriber);
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new DebounceTimeOperator(dueTime, scheduler));
  };
}
var DebounceTimeOperator = /* @__PURE__ */ function() {
  function DebounceTimeOperator2(dueTime, scheduler) {
    this.dueTime = dueTime;
    this.scheduler = scheduler;
  }
  DebounceTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
  };
  return DebounceTimeOperator2;
}();
var DebounceTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DebounceTimeSubscriber2, _super);
  function DebounceTimeSubscriber2(destination, dueTime, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.dueTime = dueTime;
    _this.scheduler = scheduler;
    _this.debouncedSubscription = null;
    _this.lastValue = null;
    _this.hasValue = false;
    return _this;
  }
  DebounceTimeSubscriber2.prototype._next = function(value2) {
    this.clearDebounce();
    this.lastValue = value2;
    this.hasValue = true;
    this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
  };
  DebounceTimeSubscriber2.prototype._complete = function() {
    this.debouncedNext();
    this.destination.complete();
  };
  DebounceTimeSubscriber2.prototype.debouncedNext = function() {
    this.clearDebounce();
    if (this.hasValue) {
      var lastValue = this.lastValue;
      this.lastValue = null;
      this.hasValue = false;
      this.destination.next(lastValue);
    }
  };
  DebounceTimeSubscriber2.prototype.clearDebounce = function() {
    var debouncedSubscription = this.debouncedSubscription;
    if (debouncedSubscription !== null) {
      this.remove(debouncedSubscription);
      debouncedSubscription.unsubscribe();
      this.debouncedSubscription = null;
    }
  };
  return DebounceTimeSubscriber2;
}(Subscriber);
function dispatchNext$1(subscriber) {
  subscriber.debouncedNext();
}
function defaultIfEmpty(defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }
  return function(source) {
    return source.lift(new DefaultIfEmptyOperator(defaultValue));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function DefaultIfEmptyOperator2(defaultValue) {
    this.defaultValue = defaultValue;
  }
  DefaultIfEmptyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
  };
  return DefaultIfEmptyOperator2;
}();
var DefaultIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DefaultIfEmptySubscriber2, _super);
  function DefaultIfEmptySubscriber2(destination, defaultValue) {
    var _this = _super.call(this, destination) || this;
    _this.defaultValue = defaultValue;
    _this.isEmpty = true;
    return _this;
  }
  DefaultIfEmptySubscriber2.prototype._next = function(value2) {
    this.isEmpty = false;
    this.destination.next(value2);
  };
  DefaultIfEmptySubscriber2.prototype._complete = function() {
    if (this.isEmpty) {
      this.destination.next(this.defaultValue);
    }
    this.destination.complete();
  };
  return DefaultIfEmptySubscriber2;
}(Subscriber);
function isDate(value2) {
  return value2 instanceof Date && !isNaN(+value2);
}
function delay(delay2, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  var absoluteDelay = isDate(delay2);
  var delayFor = absoluteDelay ? +delay2 - scheduler.now() : Math.abs(delay2);
  return function(source) {
    return source.lift(new DelayOperator(delayFor, scheduler));
  };
}
var DelayOperator = /* @__PURE__ */ function() {
  function DelayOperator2(delay2, scheduler) {
    this.delay = delay2;
    this.scheduler = scheduler;
  }
  DelayOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
  };
  return DelayOperator2;
}();
var DelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelaySubscriber2, _super);
  function DelaySubscriber2(destination, delay2, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.delay = delay2;
    _this.scheduler = scheduler;
    _this.queue = [];
    _this.active = false;
    _this.errored = false;
    return _this;
  }
  DelaySubscriber2.dispatch = function(state2) {
    var source = state2.source;
    var queue2 = source.queue;
    var scheduler = state2.scheduler;
    var destination = state2.destination;
    while (queue2.length > 0 && queue2[0].time - scheduler.now() <= 0) {
      queue2.shift().notification.observe(destination);
    }
    if (queue2.length > 0) {
      var delay_1 = Math.max(0, queue2[0].time - scheduler.now());
      this.schedule(state2, delay_1);
    } else {
      this.unsubscribe();
      source.active = false;
    }
  };
  DelaySubscriber2.prototype._schedule = function(scheduler) {
    this.active = true;
    var destination = this.destination;
    destination.add(scheduler.schedule(DelaySubscriber2.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler
    }));
  };
  DelaySubscriber2.prototype.scheduleNotification = function(notification) {
    if (this.errored === true) {
      return;
    }
    var scheduler = this.scheduler;
    var message = new DelayMessage(scheduler.now() + this.delay, notification);
    this.queue.push(message);
    if (this.active === false) {
      this._schedule(scheduler);
    }
  };
  DelaySubscriber2.prototype._next = function(value2) {
    this.scheduleNotification(Notification.createNext(value2));
  };
  DelaySubscriber2.prototype._error = function(err) {
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
    this.unsubscribe();
  };
  DelaySubscriber2.prototype._complete = function() {
    this.scheduleNotification(Notification.createComplete());
    this.unsubscribe();
  };
  return DelaySubscriber2;
}(Subscriber);
var DelayMessage = /* @__PURE__ */ function() {
  function DelayMessage2(time, notification) {
    this.time = time;
    this.notification = notification;
  }
  return DelayMessage2;
}();
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
    };
  }
  return function(source) {
    return source.lift(new DelayWhenOperator(delayDurationSelector));
  };
}
var DelayWhenOperator = /* @__PURE__ */ function() {
  function DelayWhenOperator2(delayDurationSelector) {
    this.delayDurationSelector = delayDurationSelector;
  }
  DelayWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
  };
  return DelayWhenOperator2;
}();
var DelayWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DelayWhenSubscriber2, _super);
  function DelayWhenSubscriber2(destination, delayDurationSelector) {
    var _this = _super.call(this, destination) || this;
    _this.delayDurationSelector = delayDurationSelector;
    _this.completed = false;
    _this.delayNotifierSubscriptions = [];
    _this.index = 0;
    return _this;
  }
  DelayWhenSubscriber2.prototype.notifyNext = function(outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.destination.next(outerValue);
    this.removeSubscription(innerSub);
    this.tryComplete();
  };
  DelayWhenSubscriber2.prototype.notifyError = function(error2, innerSub) {
    this._error(error2);
  };
  DelayWhenSubscriber2.prototype.notifyComplete = function(innerSub) {
    var value2 = this.removeSubscription(innerSub);
    if (value2) {
      this.destination.next(value2);
    }
    this.tryComplete();
  };
  DelayWhenSubscriber2.prototype._next = function(value2) {
    var index2 = this.index++;
    try {
      var delayNotifier = this.delayDurationSelector(value2, index2);
      if (delayNotifier) {
        this.tryDelay(delayNotifier, value2);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  DelayWhenSubscriber2.prototype._complete = function() {
    this.completed = true;
    this.tryComplete();
    this.unsubscribe();
  };
  DelayWhenSubscriber2.prototype.removeSubscription = function(subscription) {
    subscription.unsubscribe();
    var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
    if (subscriptionIdx !== -1) {
      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
    }
    return subscription.outerValue;
  };
  DelayWhenSubscriber2.prototype.tryDelay = function(delayNotifier, value2) {
    var notifierSubscription = subscribeToResult(this, delayNotifier, value2);
    if (notifierSubscription && !notifierSubscription.closed) {
      var destination = this.destination;
      destination.add(notifierSubscription);
      this.delayNotifierSubscriptions.push(notifierSubscription);
    }
  };
  DelayWhenSubscriber2.prototype.tryComplete = function() {
    if (this.completed && this.delayNotifierSubscriptions.length === 0) {
      this.destination.complete();
    }
  };
  return DelayWhenSubscriber2;
}(OuterSubscriber);
var SubscriptionDelayObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelayObservable2, _super);
  function SubscriptionDelayObservable2(source, subscriptionDelay) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subscriptionDelay = subscriptionDelay;
    return _this;
  }
  SubscriptionDelayObservable2.prototype._subscribe = function(subscriber) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
  };
  return SubscriptionDelayObservable2;
}(Observable);
var SubscriptionDelaySubscriber = /* @__PURE__ */ function(_super) {
  __extends(SubscriptionDelaySubscriber2, _super);
  function SubscriptionDelaySubscriber2(parent, source) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    _this.source = source;
    _this.sourceSubscribed = false;
    return _this;
  }
  SubscriptionDelaySubscriber2.prototype._next = function(unused) {
    this.subscribeToSource();
  };
  SubscriptionDelaySubscriber2.prototype._error = function(err) {
    this.unsubscribe();
    this.parent.error(err);
  };
  SubscriptionDelaySubscriber2.prototype._complete = function() {
    this.unsubscribe();
    this.subscribeToSource();
  };
  SubscriptionDelaySubscriber2.prototype.subscribeToSource = function() {
    if (!this.sourceSubscribed) {
      this.sourceSubscribed = true;
      this.unsubscribe();
      this.source.subscribe(this.parent);
    }
  };
  return SubscriptionDelaySubscriber2;
}(Subscriber);
function dematerialize() {
  return function dematerializeOperatorFunction(source) {
    return source.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator = /* @__PURE__ */ function() {
  function DeMaterializeOperator2() {
  }
  DeMaterializeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DeMaterializeSubscriber(subscriber));
  };
  return DeMaterializeOperator2;
}();
var DeMaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DeMaterializeSubscriber2, _super);
  function DeMaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  DeMaterializeSubscriber2.prototype._next = function(value2) {
    value2.observe(this.destination);
  };
  return DeMaterializeSubscriber2;
}(Subscriber);
function distinct(keySelector, flushes) {
  return function(source) {
    return source.lift(new DistinctOperator(keySelector, flushes));
  };
}
var DistinctOperator = /* @__PURE__ */ function() {
  function DistinctOperator2(keySelector, flushes) {
    this.keySelector = keySelector;
    this.flushes = flushes;
  }
  DistinctOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
  };
  return DistinctOperator2;
}();
var DistinctSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctSubscriber2, _super);
  function DistinctSubscriber2(destination, keySelector, flushes) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.values = new Set();
    if (flushes) {
      _this.add(innerSubscribe(flushes, new SimpleInnerSubscriber(_this)));
    }
    return _this;
  }
  DistinctSubscriber2.prototype.notifyNext = function() {
    this.values.clear();
  };
  DistinctSubscriber2.prototype.notifyError = function(error2) {
    this._error(error2);
  };
  DistinctSubscriber2.prototype._next = function(value2) {
    if (this.keySelector) {
      this._useKeySelector(value2);
    } else {
      this._finalizeNext(value2, value2);
    }
  };
  DistinctSubscriber2.prototype._useKeySelector = function(value2) {
    var key2;
    var destination = this.destination;
    try {
      key2 = this.keySelector(value2);
    } catch (err) {
      destination.error(err);
      return;
    }
    this._finalizeNext(key2, value2);
  };
  DistinctSubscriber2.prototype._finalizeNext = function(key2, value2) {
    var values = this.values;
    if (!values.has(key2)) {
      values.add(key2);
      this.destination.next(value2);
    }
  };
  return DistinctSubscriber2;
}(SimpleOuterSubscriber);
function distinctUntilChanged(compare, keySelector) {
  return function(source) {
    return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function DistinctUntilChangedOperator2(compare, keySelector) {
    this.compare = compare;
    this.keySelector = keySelector;
  }
  DistinctUntilChangedOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  };
  return DistinctUntilChangedOperator2;
}();
var DistinctUntilChangedSubscriber = /* @__PURE__ */ function(_super) {
  __extends(DistinctUntilChangedSubscriber2, _super);
  function DistinctUntilChangedSubscriber2(destination, compare, keySelector) {
    var _this = _super.call(this, destination) || this;
    _this.keySelector = keySelector;
    _this.hasKey = false;
    if (typeof compare === "function") {
      _this.compare = compare;
    }
    return _this;
  }
  DistinctUntilChangedSubscriber2.prototype.compare = function(x2, y2) {
    return x2 === y2;
  };
  DistinctUntilChangedSubscriber2.prototype._next = function(value2) {
    var key2;
    try {
      var keySelector = this.keySelector;
      key2 = keySelector ? keySelector(value2) : value2;
    } catch (err) {
      return this.destination.error(err);
    }
    var result = false;
    if (this.hasKey) {
      try {
        var compare = this.compare;
        result = compare(this.key, key2);
      } catch (err) {
        return this.destination.error(err);
      }
    } else {
      this.hasKey = true;
    }
    if (!result) {
      this.key = key2;
      this.destination.next(value2);
    }
  };
  return DistinctUntilChangedSubscriber2;
}(Subscriber);
function distinctUntilKeyChanged(key2, compare) {
  return distinctUntilChanged(function(x2, y2) {
    return compare ? compare(x2[key2], y2[key2]) : x2[key2] === y2[key2];
  });
}
function throwIfEmpty(errorFactory) {
  if (errorFactory === void 0) {
    errorFactory = defaultErrorFactory;
  }
  return function(source) {
    return source.lift(new ThrowIfEmptyOperator(errorFactory));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function ThrowIfEmptyOperator2(errorFactory) {
    this.errorFactory = errorFactory;
  }
  ThrowIfEmptyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
  };
  return ThrowIfEmptyOperator2;
}();
var ThrowIfEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrowIfEmptySubscriber2, _super);
  function ThrowIfEmptySubscriber2(destination, errorFactory) {
    var _this = _super.call(this, destination) || this;
    _this.errorFactory = errorFactory;
    _this.hasValue = false;
    return _this;
  }
  ThrowIfEmptySubscriber2.prototype._next = function(value2) {
    this.hasValue = true;
    this.destination.next(value2);
  };
  ThrowIfEmptySubscriber2.prototype._complete = function() {
    if (!this.hasValue) {
      var err = void 0;
      try {
        err = this.errorFactory();
      } catch (e2) {
        err = e2;
      }
      this.destination.error(err);
    } else {
      return this.destination.complete();
    }
  };
  return ThrowIfEmptySubscriber2;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take(count2) {
  return function(source) {
    if (count2 === 0) {
      return empty();
    } else {
      return source.lift(new TakeOperator(count2));
    }
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function TakeOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeSubscriber(subscriber, this.total));
  };
  return TakeOperator2;
}();
var TakeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeSubscriber2, _super);
  function TakeSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  TakeSubscriber2.prototype._next = function(value2) {
    var total = this.total;
    var count2 = ++this.count;
    if (count2 <= total) {
      this.destination.next(value2);
      if (count2 === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  };
  return TakeSubscriber2;
}(Subscriber);
function elementAt(index2, defaultValue) {
  if (index2 < 0) {
    throw new ArgumentOutOfRangeError();
  }
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(filter(function(v2, i2) {
      return i2 === index2;
    }), take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
function endWith() {
  var array2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array2[_i] = arguments[_i];
  }
  return function(source) {
    return concat$1(source, of.apply(void 0, array2));
  };
}
function every(predicate, thisArg) {
  return function(source) {
    return source.lift(new EveryOperator(predicate, thisArg, source));
  };
}
var EveryOperator = /* @__PURE__ */ function() {
  function EveryOperator2(predicate, thisArg, source) {
    this.predicate = predicate;
    this.thisArg = thisArg;
    this.source = source;
  }
  EveryOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
  };
  return EveryOperator2;
}();
var EverySubscriber = /* @__PURE__ */ function(_super) {
  __extends(EverySubscriber2, _super);
  function EverySubscriber2(destination, predicate, thisArg, source) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.source = source;
    _this.index = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }
  EverySubscriber2.prototype.notifyComplete = function(everyValueMatch) {
    this.destination.next(everyValueMatch);
    this.destination.complete();
  };
  EverySubscriber2.prototype._next = function(value2) {
    var result = false;
    try {
      result = this.predicate.call(this.thisArg, value2, this.index++, this.source);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    if (!result) {
      this.notifyComplete(false);
    }
  };
  EverySubscriber2.prototype._complete = function() {
    this.notifyComplete(true);
  };
  return EverySubscriber2;
}(Subscriber);
function exhaust() {
  return function(source) {
    return source.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator = /* @__PURE__ */ function() {
  function SwitchFirstOperator2() {
  }
  SwitchFirstOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SwitchFirstSubscriber(subscriber));
  };
  return SwitchFirstOperator2;
}();
var SwitchFirstSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchFirstSubscriber2, _super);
  function SwitchFirstSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasCompleted = false;
    _this.hasSubscription = false;
    return _this;
  }
  SwitchFirstSubscriber2.prototype._next = function(value2) {
    if (!this.hasSubscription) {
      this.hasSubscription = true;
      this.add(innerSubscribe(value2, new SimpleInnerSubscriber(this)));
    }
  };
  SwitchFirstSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (!this.hasSubscription) {
      this.destination.complete();
    }
  };
  SwitchFirstSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = false;
    if (this.hasCompleted) {
      this.destination.complete();
    }
  };
  return SwitchFirstSubscriber2;
}(SimpleOuterSubscriber);
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a2, i2) {
        return from(project(a2, i2)).pipe(map(function(b2, ii) {
          return resultSelector(a2, b2, i2, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new ExhaustMapOperator(project));
  };
}
var ExhaustMapOperator = /* @__PURE__ */ function() {
  function ExhaustMapOperator2(project) {
    this.project = project;
  }
  ExhaustMapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
  };
  return ExhaustMapOperator2;
}();
var ExhaustMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExhaustMapSubscriber2, _super);
  function ExhaustMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.hasSubscription = false;
    _this.hasCompleted = false;
    _this.index = 0;
    return _this;
  }
  ExhaustMapSubscriber2.prototype._next = function(value2) {
    if (!this.hasSubscription) {
      this.tryNext(value2);
    }
  };
  ExhaustMapSubscriber2.prototype.tryNext = function(value2) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value2, index2);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.hasSubscription = true;
    this._innerSub(result);
  };
  ExhaustMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(result, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  ExhaustMapSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (!this.hasSubscription) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  ExhaustMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  ExhaustMapSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  ExhaustMapSubscriber2.prototype.notifyComplete = function() {
    this.hasSubscription = false;
    if (this.hasCompleted) {
      this.destination.complete();
    }
  };
  return ExhaustMapSubscriber2;
}(SimpleOuterSubscriber);
function expand(project, concurrent, scheduler) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
  return function(source) {
    return source.lift(new ExpandOperator(project, concurrent, scheduler));
  };
}
var ExpandOperator = /* @__PURE__ */ function() {
  function ExpandOperator2(project, concurrent, scheduler) {
    this.project = project;
    this.concurrent = concurrent;
    this.scheduler = scheduler;
  }
  ExpandOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
  };
  return ExpandOperator2;
}();
var ExpandSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ExpandSubscriber2, _super);
  function ExpandSubscriber2(destination, project, concurrent, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.concurrent = concurrent;
    _this.scheduler = scheduler;
    _this.index = 0;
    _this.active = 0;
    _this.hasCompleted = false;
    if (concurrent < Number.POSITIVE_INFINITY) {
      _this.buffer = [];
    }
    return _this;
  }
  ExpandSubscriber2.dispatch = function(arg) {
    var subscriber = arg.subscriber, result = arg.result, value2 = arg.value, index2 = arg.index;
    subscriber.subscribeToProjection(result, value2, index2);
  };
  ExpandSubscriber2.prototype._next = function(value2) {
    var destination = this.destination;
    if (destination.closed) {
      this._complete();
      return;
    }
    var index2 = this.index++;
    if (this.active < this.concurrent) {
      destination.next(value2);
      try {
        var project = this.project;
        var result = project(value2, index2);
        if (!this.scheduler) {
          this.subscribeToProjection(result, value2, index2);
        } else {
          var state2 = { subscriber: this, result, value: value2, index: index2 };
          var destination_1 = this.destination;
          destination_1.add(this.scheduler.schedule(ExpandSubscriber2.dispatch, 0, state2));
        }
      } catch (e2) {
        destination.error(e2);
      }
    } else {
      this.buffer.push(value2);
    }
  };
  ExpandSubscriber2.prototype.subscribeToProjection = function(result, value2, index2) {
    this.active++;
    var destination = this.destination;
    destination.add(innerSubscribe(result, new SimpleInnerSubscriber(this)));
  };
  ExpandSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }
    this.unsubscribe();
  };
  ExpandSubscriber2.prototype.notifyNext = function(innerValue) {
    this._next(innerValue);
  };
  ExpandSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2 && buffer2.length > 0) {
      this._next(buffer2.shift());
    }
    if (this.hasCompleted && this.active === 0) {
      this.destination.complete();
    }
  };
  return ExpandSubscriber2;
}(SimpleOuterSubscriber);
function finalize(callback) {
  return function(source) {
    return source.lift(new FinallyOperator(callback));
  };
}
var FinallyOperator = /* @__PURE__ */ function() {
  function FinallyOperator2(callback) {
    this.callback = callback;
  }
  FinallyOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new FinallySubscriber(subscriber, this.callback));
  };
  return FinallyOperator2;
}();
var FinallySubscriber = /* @__PURE__ */ function(_super) {
  __extends(FinallySubscriber2, _super);
  function FinallySubscriber2(destination, callback) {
    var _this = _super.call(this, destination) || this;
    _this.add(new Subscription(callback));
    return _this;
  }
  return FinallySubscriber2;
}(Subscriber);
function find(predicate, thisArg) {
  if (typeof predicate !== "function") {
    throw new TypeError("predicate is not a function");
  }
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, false, thisArg));
  };
}
var FindValueOperator = /* @__PURE__ */ function() {
  function FindValueOperator2(predicate, source, yieldIndex, thisArg) {
    this.predicate = predicate;
    this.source = source;
    this.yieldIndex = yieldIndex;
    this.thisArg = thisArg;
  }
  FindValueOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
  };
  return FindValueOperator2;
}();
var FindValueSubscriber = /* @__PURE__ */ function(_super) {
  __extends(FindValueSubscriber2, _super);
  function FindValueSubscriber2(destination, predicate, source, yieldIndex, thisArg) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source;
    _this.yieldIndex = yieldIndex;
    _this.thisArg = thisArg;
    _this.index = 0;
    return _this;
  }
  FindValueSubscriber2.prototype.notifyComplete = function(value2) {
    var destination = this.destination;
    destination.next(value2);
    destination.complete();
    this.unsubscribe();
  };
  FindValueSubscriber2.prototype._next = function(value2) {
    var _a2 = this, predicate = _a2.predicate, thisArg = _a2.thisArg;
    var index2 = this.index++;
    try {
      var result = predicate.call(thisArg || this, value2, index2, this.source);
      if (result) {
        this.notifyComplete(this.yieldIndex ? index2 : value2);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  FindValueSubscriber2.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  };
  return FindValueSubscriber2;
}(Subscriber);
function findIndex(predicate, thisArg) {
  return function(source) {
    return source.lift(new FindValueOperator(predicate, source, true, thisArg));
  };
}
function first(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v2, i2) {
      return predicate(v2, i2, source);
    }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function ignoreElements() {
  return function ignoreElementsOperatorFunction(source) {
    return source.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator = /* @__PURE__ */ function() {
  function IgnoreElementsOperator2() {
  }
  IgnoreElementsOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new IgnoreElementsSubscriber(subscriber));
  };
  return IgnoreElementsOperator2;
}();
var IgnoreElementsSubscriber = /* @__PURE__ */ function(_super) {
  __extends(IgnoreElementsSubscriber2, _super);
  function IgnoreElementsSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IgnoreElementsSubscriber2.prototype._next = function(unused) {
  };
  return IgnoreElementsSubscriber2;
}(Subscriber);
function isEmpty() {
  return function(source) {
    return source.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator = /* @__PURE__ */ function() {
  function IsEmptyOperator2() {
  }
  IsEmptyOperator2.prototype.call = function(observer, source) {
    return source.subscribe(new IsEmptySubscriber(observer));
  };
  return IsEmptyOperator2;
}();
var IsEmptySubscriber = /* @__PURE__ */ function(_super) {
  __extends(IsEmptySubscriber2, _super);
  function IsEmptySubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  IsEmptySubscriber2.prototype.notifyComplete = function(isEmpty2) {
    var destination = this.destination;
    destination.next(isEmpty2);
    destination.complete();
  };
  IsEmptySubscriber2.prototype._next = function(value2) {
    this.notifyComplete(false);
  };
  IsEmptySubscriber2.prototype._complete = function() {
    this.notifyComplete(true);
  };
  return IsEmptySubscriber2;
}(Subscriber);
function takeLast(count2) {
  return function takeLastOperatorFunction(source) {
    if (count2 === 0) {
      return empty();
    } else {
      return source.lift(new TakeLastOperator(count2));
    }
  };
}
var TakeLastOperator = /* @__PURE__ */ function() {
  function TakeLastOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeLastOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
  };
  return TakeLastOperator2;
}();
var TakeLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeLastSubscriber2, _super);
  function TakeLastSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.ring = new Array();
    _this.count = 0;
    return _this;
  }
  TakeLastSubscriber2.prototype._next = function(value2) {
    var ring = this.ring;
    var total = this.total;
    var count2 = this.count++;
    if (ring.length < total) {
      ring.push(value2);
    } else {
      var index2 = count2 % total;
      ring[index2] = value2;
    }
  };
  TakeLastSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    var count2 = this.count;
    if (count2 > 0) {
      var total = this.count >= this.total ? this.total : this.count;
      var ring = this.ring;
      for (var i2 = 0; i2 < total; i2++) {
        var idx = count2++ % total;
        destination.next(ring[idx]);
      }
    }
    destination.complete();
  };
  return TakeLastSubscriber2;
}(Subscriber);
function last(predicate, defaultValue) {
  var hasDefaultValue = arguments.length >= 2;
  return function(source) {
    return source.pipe(predicate ? filter(function(v2, i2) {
      return predicate(v2, i2, source);
    }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mapTo(value2) {
  return function(source) {
    return source.lift(new MapToOperator(value2));
  };
}
var MapToOperator = /* @__PURE__ */ function() {
  function MapToOperator2(value2) {
    this.value = value2;
  }
  MapToOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MapToSubscriber(subscriber, this.value));
  };
  return MapToOperator2;
}();
var MapToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MapToSubscriber2, _super);
  function MapToSubscriber2(destination, value2) {
    var _this = _super.call(this, destination) || this;
    _this.value = value2;
    return _this;
  }
  MapToSubscriber2.prototype._next = function(x2) {
    this.destination.next(this.value);
  };
  return MapToSubscriber2;
}(Subscriber);
function materialize() {
  return function materializeOperatorFunction(source) {
    return source.lift(new MaterializeOperator());
  };
}
var MaterializeOperator = /* @__PURE__ */ function() {
  function MaterializeOperator2() {
  }
  MaterializeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MaterializeSubscriber(subscriber));
  };
  return MaterializeOperator2;
}();
var MaterializeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MaterializeSubscriber2, _super);
  function MaterializeSubscriber2(destination) {
    return _super.call(this, destination) || this;
  }
  MaterializeSubscriber2.prototype._next = function(value2) {
    this.destination.next(Notification.createNext(value2));
  };
  MaterializeSubscriber2.prototype._error = function(err) {
    var destination = this.destination;
    destination.next(Notification.createError(err));
    destination.complete();
  };
  MaterializeSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    destination.next(Notification.createComplete());
    destination.complete();
  };
  return MaterializeSubscriber2;
}(Subscriber);
function scan(accumulator, seed) {
  var hasSeed = false;
  if (arguments.length >= 2) {
    hasSeed = true;
  }
  return function scanOperatorFunction(source) {
    return source.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}
var ScanOperator = /* @__PURE__ */ function() {
  function ScanOperator2(accumulator, seed, hasSeed) {
    if (hasSeed === void 0) {
      hasSeed = false;
    }
    this.accumulator = accumulator;
    this.seed = seed;
    this.hasSeed = hasSeed;
  }
  ScanOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
  };
  return ScanOperator2;
}();
var ScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ScanSubscriber2, _super);
  function ScanSubscriber2(destination, accumulator, _seed, hasSeed) {
    var _this = _super.call(this, destination) || this;
    _this.accumulator = accumulator;
    _this._seed = _seed;
    _this.hasSeed = hasSeed;
    _this.index = 0;
    return _this;
  }
  Object.defineProperty(ScanSubscriber2.prototype, "seed", {
    get: function() {
      return this._seed;
    },
    set: function(value2) {
      this.hasSeed = true;
      this._seed = value2;
    },
    enumerable: true,
    configurable: true
  });
  ScanSubscriber2.prototype._next = function(value2) {
    if (!this.hasSeed) {
      this.seed = value2;
      this.destination.next(value2);
    } else {
      return this._tryNext(value2);
    }
  };
  ScanSubscriber2.prototype._tryNext = function(value2) {
    var index2 = this.index++;
    var result;
    try {
      result = this.accumulator(this.seed, value2, index2);
    } catch (err) {
      this.destination.error(err);
    }
    this.seed = result;
    this.destination.next(result);
  };
  return ScanSubscriber2;
}(Subscriber);
function reduce(accumulator, seed) {
  if (arguments.length >= 2) {
    return function reduceOperatorFunctionWithSeed(source) {
      return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
    };
  }
  return function reduceOperatorFunction(source) {
    return pipe(scan(function(acc, value2, index2) {
      return accumulator(acc, value2, index2 + 1);
    }), takeLast(1))(source);
  };
}
function max(comparer) {
  var max2 = typeof comparer === "function" ? function(x2, y2) {
    return comparer(x2, y2) > 0 ? x2 : y2;
  } : function(x2, y2) {
    return x2 > y2 ? x2 : y2;
  };
  return reduce(max2);
}
function merge() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function(source) {
    return source.lift.call(merge$1.apply(void 0, [source].concat(observables)));
  };
}
function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  if (typeof resultSelector === "function") {
    return mergeMap(function() {
      return innerObservable;
    }, resultSelector, concurrent);
  }
  if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return mergeMap(function() {
    return innerObservable;
  }, concurrent);
}
function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }
  return function(source) {
    return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}
var MergeScanOperator = /* @__PURE__ */ function() {
  function MergeScanOperator2(accumulator, seed, concurrent) {
    this.accumulator = accumulator;
    this.seed = seed;
    this.concurrent = concurrent;
  }
  MergeScanOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
  };
  return MergeScanOperator2;
}();
var MergeScanSubscriber = /* @__PURE__ */ function(_super) {
  __extends(MergeScanSubscriber2, _super);
  function MergeScanSubscriber2(destination, accumulator, acc, concurrent) {
    var _this = _super.call(this, destination) || this;
    _this.accumulator = accumulator;
    _this.acc = acc;
    _this.concurrent = concurrent;
    _this.hasValue = false;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }
  MergeScanSubscriber2.prototype._next = function(value2) {
    if (this.active < this.concurrent) {
      var index2 = this.index++;
      var destination = this.destination;
      var ish = void 0;
      try {
        var accumulator = this.accumulator;
        ish = accumulator(this.acc, value2, index2);
      } catch (e2) {
        return destination.error(e2);
      }
      this.active++;
      this._innerSub(ish);
    } else {
      this.buffer.push(value2);
    }
  };
  MergeScanSubscriber2.prototype._innerSub = function(ish) {
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = innerSubscribe(ish, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };
  MergeScanSubscriber2.prototype._complete = function() {
    this.hasCompleted = true;
    if (this.active === 0 && this.buffer.length === 0) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }
      this.destination.complete();
    }
    this.unsubscribe();
  };
  MergeScanSubscriber2.prototype.notifyNext = function(innerValue) {
    var destination = this.destination;
    this.acc = innerValue;
    this.hasValue = true;
    destination.next(innerValue);
  };
  MergeScanSubscriber2.prototype.notifyComplete = function() {
    var buffer2 = this.buffer;
    this.active--;
    if (buffer2.length > 0) {
      this._next(buffer2.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }
      this.destination.complete();
    }
  };
  return MergeScanSubscriber2;
}(SimpleOuterSubscriber);
function min(comparer) {
  var min2 = typeof comparer === "function" ? function(x2, y2) {
    return comparer(x2, y2) < 0 ? x2 : y2;
  } : function(x2, y2) {
    return x2 < y2 ? x2 : y2;
  };
  return reduce(min2);
}
function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === "function") {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory2() {
        return subjectOrSubjectFactory;
      };
    }
    if (typeof selector === "function") {
      return source.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(source, connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function MulticastOperator2(subjectFactory, selector) {
    this.subjectFactory = subjectFactory;
    this.selector = selector;
  }
  MulticastOperator2.prototype.call = function(subscriber, source) {
    var selector = this.selector;
    var subject = this.subjectFactory();
    var subscription = selector(subject).subscribe(subscriber);
    subscription.add(source.subscribe(subject));
    return subscription;
  };
  return MulticastOperator2;
}();
function onErrorResumeNext() {
  var nextSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    nextSources[_i] = arguments[_i];
  }
  if (nextSources.length === 1 && isArray$1(nextSources[0])) {
    nextSources = nextSources[0];
  }
  return function(source) {
    return source.lift(new OnErrorResumeNextOperator(nextSources));
  };
}
var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
  function OnErrorResumeNextOperator2(nextSources) {
    this.nextSources = nextSources;
  }
  OnErrorResumeNextOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
  };
  return OnErrorResumeNextOperator2;
}();
var OnErrorResumeNextSubscriber = /* @__PURE__ */ function(_super) {
  __extends(OnErrorResumeNextSubscriber2, _super);
  function OnErrorResumeNextSubscriber2(destination, nextSources) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.nextSources = nextSources;
    return _this;
  }
  OnErrorResumeNextSubscriber2.prototype.notifyError = function() {
    this.subscribeToNextSource();
  };
  OnErrorResumeNextSubscriber2.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  };
  OnErrorResumeNextSubscriber2.prototype._error = function(err) {
    this.subscribeToNextSource();
    this.unsubscribe();
  };
  OnErrorResumeNextSubscriber2.prototype._complete = function() {
    this.subscribeToNextSource();
    this.unsubscribe();
  };
  OnErrorResumeNextSubscriber2.prototype.subscribeToNextSource = function() {
    var next3 = this.nextSources.shift();
    if (!!next3) {
      var innerSubscriber = new SimpleInnerSubscriber(this);
      var destination = this.destination;
      destination.add(innerSubscriber);
      var innerSubscription = innerSubscribe(next3, innerSubscriber);
      if (innerSubscription !== innerSubscriber) {
        destination.add(innerSubscription);
      }
    } else {
      this.destination.complete();
    }
  };
  return OnErrorResumeNextSubscriber2;
}(SimpleOuterSubscriber);
function pairwise() {
  return function(source) {
    return source.lift(new PairwiseOperator());
  };
}
var PairwiseOperator = /* @__PURE__ */ function() {
  function PairwiseOperator2() {
  }
  PairwiseOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new PairwiseSubscriber(subscriber));
  };
  return PairwiseOperator2;
}();
var PairwiseSubscriber = /* @__PURE__ */ function(_super) {
  __extends(PairwiseSubscriber2, _super);
  function PairwiseSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.hasPrev = false;
    return _this;
  }
  PairwiseSubscriber2.prototype._next = function(value2) {
    var pair;
    if (this.hasPrev) {
      pair = [this.prev, value2];
    } else {
      this.hasPrev = true;
    }
    this.prev = value2;
    if (pair) {
      this.destination.next(pair);
    }
  };
  return PairwiseSubscriber2;
}(Subscriber);
function partition(predicate, thisArg) {
  return function(source) {
    return [
      filter(predicate, thisArg)(source),
      filter(not(predicate, thisArg))(source)
    ];
  };
}
function pluck() {
  var properties = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    properties[_i] = arguments[_i];
  }
  var length = properties.length;
  if (length === 0) {
    throw new Error("list of properties cannot be empty.");
  }
  return function(source) {
    return map(plucker(properties, length))(source);
  };
}
function plucker(props, length) {
  var mapper = function(x2) {
    var currentProp = x2;
    for (var i2 = 0; i2 < length; i2++) {
      var p2 = currentProp != null ? currentProp[props[i2]] : void 0;
      if (p2 !== void 0) {
        currentProp = p2;
      } else {
        return void 0;
      }
    }
    return currentProp;
  };
  return mapper;
}
function publish(selector) {
  return selector ? multicast(function() {
    return new Subject();
  }, selector) : multicast(new Subject());
}
function publishBehavior(value2) {
  return function(source) {
    return multicast(new BehaviorSubject(value2))(source);
  };
}
function publishLast() {
  return function(source) {
    return multicast(new AsyncSubject())(source);
  };
}
function publishReplay(bufferSize, windowTime2, selectorOrScheduler, scheduler) {
  if (selectorOrScheduler && typeof selectorOrScheduler !== "function") {
    scheduler = selectorOrScheduler;
  }
  var selector = typeof selectorOrScheduler === "function" ? selectorOrScheduler : void 0;
  var subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
  return function(source) {
    return multicast(function() {
      return subject;
    }, selector)(source);
  };
}
function race() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function raceOperatorFunction(source) {
    if (observables.length === 1 && isArray$1(observables[0])) {
      observables = observables[0];
    }
    return source.lift.call(race$1.apply(void 0, [source].concat(observables)));
  };
}
function repeat(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    if (count2 === 0) {
      return empty();
    } else if (count2 < 0) {
      return source.lift(new RepeatOperator(-1, source));
    } else {
      return source.lift(new RepeatOperator(count2 - 1, source));
    }
  };
}
var RepeatOperator = /* @__PURE__ */ function() {
  function RepeatOperator2(count2, source) {
    this.count = count2;
    this.source = source;
  }
  RepeatOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
  };
  return RepeatOperator2;
}();
var RepeatSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatSubscriber2, _super);
  function RepeatSubscriber2(destination, count2, source) {
    var _this = _super.call(this, destination) || this;
    _this.count = count2;
    _this.source = source;
    return _this;
  }
  RepeatSubscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      var _a2 = this, source = _a2.source, count2 = _a2.count;
      if (count2 === 0) {
        return _super.prototype.complete.call(this);
      } else if (count2 > -1) {
        this.count = count2 - 1;
      }
      source.subscribe(this._unsubscribeAndRecycle());
    }
  };
  return RepeatSubscriber2;
}(Subscriber);
function repeatWhen(notifier) {
  return function(source) {
    return source.lift(new RepeatWhenOperator(notifier));
  };
}
var RepeatWhenOperator = /* @__PURE__ */ function() {
  function RepeatWhenOperator2(notifier) {
    this.notifier = notifier;
  }
  RepeatWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
  };
  return RepeatWhenOperator2;
}();
var RepeatWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RepeatWhenSubscriber2, _super);
  function RepeatWhenSubscriber2(destination, notifier, source) {
    var _this = _super.call(this, destination) || this;
    _this.notifier = notifier;
    _this.source = source;
    _this.sourceIsBeingSubscribedTo = true;
    return _this;
  }
  RepeatWhenSubscriber2.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = true;
    this.source.subscribe(this);
  };
  RepeatWhenSubscriber2.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === false) {
      return _super.prototype.complete.call(this);
    }
  };
  RepeatWhenSubscriber2.prototype.complete = function() {
    this.sourceIsBeingSubscribedTo = false;
    if (!this.isStopped) {
      if (!this.retries) {
        this.subscribeToRetries();
      }
      if (!this.retriesSubscription || this.retriesSubscription.closed) {
        return _super.prototype.complete.call(this);
      }
      this._unsubscribeAndRecycle();
      this.notifications.next(void 0);
    }
  };
  RepeatWhenSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, notifications = _a2.notifications, retriesSubscription = _a2.retriesSubscription;
    if (notifications) {
      notifications.unsubscribe();
      this.notifications = void 0;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = void 0;
    }
    this.retries = void 0;
  };
  RepeatWhenSubscriber2.prototype._unsubscribeAndRecycle = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;
    _super.prototype._unsubscribeAndRecycle.call(this);
    this._unsubscribe = _unsubscribe;
    return this;
  };
  RepeatWhenSubscriber2.prototype.subscribeToRetries = function() {
    this.notifications = new Subject();
    var retries;
    try {
      var notifier = this.notifier;
      retries = notifier(this.notifications);
    } catch (e2) {
      return _super.prototype.complete.call(this);
    }
    this.retries = retries;
    this.retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
  };
  return RepeatWhenSubscriber2;
}(SimpleOuterSubscriber);
function retry(count2) {
  if (count2 === void 0) {
    count2 = -1;
  }
  return function(source) {
    return source.lift(new RetryOperator(count2, source));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function RetryOperator2(count2, source) {
    this.count = count2;
    this.source = source;
  }
  RetryOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
  };
  return RetryOperator2;
}();
var RetrySubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetrySubscriber2, _super);
  function RetrySubscriber2(destination, count2, source) {
    var _this = _super.call(this, destination) || this;
    _this.count = count2;
    _this.source = source;
    return _this;
  }
  RetrySubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _a2 = this, source = _a2.source, count2 = _a2.count;
      if (count2 === 0) {
        return _super.prototype.error.call(this, err);
      } else if (count2 > -1) {
        this.count = count2 - 1;
      }
      source.subscribe(this._unsubscribeAndRecycle());
    }
  };
  return RetrySubscriber2;
}(Subscriber);
function retryWhen(notifier) {
  return function(source) {
    return source.lift(new RetryWhenOperator(notifier, source));
  };
}
var RetryWhenOperator = /* @__PURE__ */ function() {
  function RetryWhenOperator2(notifier, source) {
    this.notifier = notifier;
    this.source = source;
  }
  RetryWhenOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
  };
  return RetryWhenOperator2;
}();
var RetryWhenSubscriber = /* @__PURE__ */ function(_super) {
  __extends(RetryWhenSubscriber2, _super);
  function RetryWhenSubscriber2(destination, notifier, source) {
    var _this = _super.call(this, destination) || this;
    _this.notifier = notifier;
    _this.source = source;
    return _this;
  }
  RetryWhenSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var errors2 = this.errors;
      var retries = this.retries;
      var retriesSubscription = this.retriesSubscription;
      if (!retries) {
        errors2 = new Subject();
        try {
          var notifier = this.notifier;
          retries = notifier(errors2);
        } catch (e2) {
          return _super.prototype.error.call(this, e2);
        }
        retriesSubscription = innerSubscribe(retries, new SimpleInnerSubscriber(this));
      } else {
        this.errors = void 0;
        this.retriesSubscription = void 0;
      }
      this._unsubscribeAndRecycle();
      this.errors = errors2;
      this.retries = retries;
      this.retriesSubscription = retriesSubscription;
      errors2.next(err);
    }
  };
  RetryWhenSubscriber2.prototype._unsubscribe = function() {
    var _a2 = this, errors2 = _a2.errors, retriesSubscription = _a2.retriesSubscription;
    if (errors2) {
      errors2.unsubscribe();
      this.errors = void 0;
    }
    if (retriesSubscription) {
      retriesSubscription.unsubscribe();
      this.retriesSubscription = void 0;
    }
    this.retries = void 0;
  };
  RetryWhenSubscriber2.prototype.notifyNext = function() {
    var _unsubscribe = this._unsubscribe;
    this._unsubscribe = null;
    this._unsubscribeAndRecycle();
    this._unsubscribe = _unsubscribe;
    this.source.subscribe(this);
  };
  return RetryWhenSubscriber2;
}(SimpleOuterSubscriber);
function sample(notifier) {
  return function(source) {
    return source.lift(new SampleOperator(notifier));
  };
}
var SampleOperator = /* @__PURE__ */ function() {
  function SampleOperator2(notifier) {
    this.notifier = notifier;
  }
  SampleOperator2.prototype.call = function(subscriber, source) {
    var sampleSubscriber = new SampleSubscriber(subscriber);
    var subscription = source.subscribe(sampleSubscriber);
    subscription.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(sampleSubscriber)));
    return subscription;
  };
  return SampleOperator2;
}();
var SampleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleSubscriber2, _super);
  function SampleSubscriber2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.hasValue = false;
    return _this;
  }
  SampleSubscriber2.prototype._next = function(value2) {
    this.value = value2;
    this.hasValue = true;
  };
  SampleSubscriber2.prototype.notifyNext = function() {
    this.emitValue();
  };
  SampleSubscriber2.prototype.notifyComplete = function() {
    this.emitValue();
  };
  SampleSubscriber2.prototype.emitValue = function() {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.value);
    }
  };
  return SampleSubscriber2;
}(SimpleOuterSubscriber);
function sampleTime(period, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return source.lift(new SampleTimeOperator(period, scheduler));
  };
}
var SampleTimeOperator = /* @__PURE__ */ function() {
  function SampleTimeOperator2(period, scheduler) {
    this.period = period;
    this.scheduler = scheduler;
  }
  SampleTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
  };
  return SampleTimeOperator2;
}();
var SampleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SampleTimeSubscriber2, _super);
  function SampleTimeSubscriber2(destination, period, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.period = period;
    _this.scheduler = scheduler;
    _this.hasValue = false;
    _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period }));
    return _this;
  }
  SampleTimeSubscriber2.prototype._next = function(value2) {
    this.lastValue = value2;
    this.hasValue = true;
  };
  SampleTimeSubscriber2.prototype.notifyNext = function() {
    if (this.hasValue) {
      this.hasValue = false;
      this.destination.next(this.lastValue);
    }
  };
  return SampleTimeSubscriber2;
}(Subscriber);
function dispatchNotification(state2) {
  var subscriber = state2.subscriber, period = state2.period;
  subscriber.notifyNext();
  this.schedule(state2, period);
}
function sequenceEqual(compareTo, comparator) {
  return function(source) {
    return source.lift(new SequenceEqualOperator(compareTo, comparator));
  };
}
var SequenceEqualOperator = /* @__PURE__ */ function() {
  function SequenceEqualOperator2(compareTo, comparator) {
    this.compareTo = compareTo;
    this.comparator = comparator;
  }
  SequenceEqualOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
  };
  return SequenceEqualOperator2;
}();
var SequenceEqualSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualSubscriber2, _super);
  function SequenceEqualSubscriber2(destination, compareTo, comparator) {
    var _this = _super.call(this, destination) || this;
    _this.compareTo = compareTo;
    _this.comparator = comparator;
    _this._a = [];
    _this._b = [];
    _this._oneComplete = false;
    _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
    return _this;
  }
  SequenceEqualSubscriber2.prototype._next = function(value2) {
    if (this._oneComplete && this._b.length === 0) {
      this.emit(false);
    } else {
      this._a.push(value2);
      this.checkValues();
    }
  };
  SequenceEqualSubscriber2.prototype._complete = function() {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }
    this.unsubscribe();
  };
  SequenceEqualSubscriber2.prototype.checkValues = function() {
    var _c = this, _a2 = _c._a, _b2 = _c._b, comparator = _c.comparator;
    while (_a2.length > 0 && _b2.length > 0) {
      var a2 = _a2.shift();
      var b2 = _b2.shift();
      var areEqual = false;
      try {
        areEqual = comparator ? comparator(a2, b2) : a2 === b2;
      } catch (e2) {
        this.destination.error(e2);
      }
      if (!areEqual) {
        this.emit(false);
      }
    }
  };
  SequenceEqualSubscriber2.prototype.emit = function(value2) {
    var destination = this.destination;
    destination.next(value2);
    destination.complete();
  };
  SequenceEqualSubscriber2.prototype.nextB = function(value2) {
    if (this._oneComplete && this._a.length === 0) {
      this.emit(false);
    } else {
      this._b.push(value2);
      this.checkValues();
    }
  };
  SequenceEqualSubscriber2.prototype.completeB = function() {
    if (this._oneComplete) {
      this.emit(this._a.length === 0 && this._b.length === 0);
    } else {
      this._oneComplete = true;
    }
  };
  return SequenceEqualSubscriber2;
}(Subscriber);
var SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SequenceEqualCompareToSubscriber2, _super);
  function SequenceEqualCompareToSubscriber2(destination, parent) {
    var _this = _super.call(this, destination) || this;
    _this.parent = parent;
    return _this;
  }
  SequenceEqualCompareToSubscriber2.prototype._next = function(value2) {
    this.parent.nextB(value2);
  };
  SequenceEqualCompareToSubscriber2.prototype._error = function(err) {
    this.parent.error(err);
    this.unsubscribe();
  };
  SequenceEqualCompareToSubscriber2.prototype._complete = function() {
    this.parent.completeB();
    this.unsubscribe();
  };
  return SequenceEqualCompareToSubscriber2;
}(Subscriber);
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(source) {
    return refCount()(multicast(shareSubjectFactory)(source));
  };
}
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var config2;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    config2 = configOrBufferSize;
  } else {
    config2 = {
      bufferSize: configOrBufferSize,
      windowTime: windowTime2,
      refCount: false,
      scheduler
    };
  }
  return function(source) {
    return source.lift(shareReplayOperator(config2));
  };
}
function shareReplayOperator(_a2) {
  var _b2 = _a2.bufferSize, bufferSize = _b2 === void 0 ? Number.POSITIVE_INFINITY : _b2, _c = _a2.windowTime, windowTime2 = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a2.refCount, scheduler = _a2.scheduler;
  var subject;
  var refCount2 = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source) {
    refCount2++;
    var innerSub;
    if (!subject || hasError) {
      hasError = false;
      subject = new ReplaySubject(bufferSize, windowTime2, scheduler);
      innerSub = subject.subscribe(this);
      subscription = source.subscribe({
        next: function(value2) {
          subject.next(value2);
        },
        error: function(err) {
          hasError = true;
          subject.error(err);
        },
        complete: function() {
          isComplete = true;
          subscription = void 0;
          subject.complete();
        }
      });
      if (isComplete) {
        subscription = void 0;
      }
    } else {
      innerSub = subject.subscribe(this);
    }
    this.add(function() {
      refCount2--;
      innerSub.unsubscribe();
      innerSub = void 0;
      if (subscription && !isComplete && useRefCount && refCount2 === 0) {
        subscription.unsubscribe();
        subscription = void 0;
        subject = void 0;
      }
    });
  };
}
function single(predicate) {
  return function(source) {
    return source.lift(new SingleOperator(predicate, source));
  };
}
var SingleOperator = /* @__PURE__ */ function() {
  function SingleOperator2(predicate, source) {
    this.predicate = predicate;
    this.source = source;
  }
  SingleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
  };
  return SingleOperator2;
}();
var SingleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SingleSubscriber2, _super);
  function SingleSubscriber2(destination, predicate, source) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.source = source;
    _this.seenValue = false;
    _this.index = 0;
    return _this;
  }
  SingleSubscriber2.prototype.applySingleValue = function(value2) {
    if (this.seenValue) {
      this.destination.error("Sequence contains more than one element");
    } else {
      this.seenValue = true;
      this.singleValue = value2;
    }
  };
  SingleSubscriber2.prototype._next = function(value2) {
    var index2 = this.index++;
    if (this.predicate) {
      this.tryNext(value2, index2);
    } else {
      this.applySingleValue(value2);
    }
  };
  SingleSubscriber2.prototype.tryNext = function(value2, index2) {
    try {
      if (this.predicate(value2, index2, this.source)) {
        this.applySingleValue(value2);
      }
    } catch (err) {
      this.destination.error(err);
    }
  };
  SingleSubscriber2.prototype._complete = function() {
    var destination = this.destination;
    if (this.index > 0) {
      destination.next(this.seenValue ? this.singleValue : void 0);
      destination.complete();
    } else {
      destination.error(new EmptyError());
    }
  };
  return SingleSubscriber2;
}(Subscriber);
function skip(count2) {
  return function(source) {
    return source.lift(new SkipOperator(count2));
  };
}
var SkipOperator = /* @__PURE__ */ function() {
  function SkipOperator2(total) {
    this.total = total;
  }
  SkipOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SkipSubscriber(subscriber, this.total));
  };
  return SkipOperator2;
}();
var SkipSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipSubscriber2, _super);
  function SkipSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  SkipSubscriber2.prototype._next = function(x2) {
    if (++this.count > this.total) {
      this.destination.next(x2);
    }
  };
  return SkipSubscriber2;
}(Subscriber);
function skipLast(count2) {
  return function(source) {
    return source.lift(new SkipLastOperator(count2));
  };
}
var SkipLastOperator = /* @__PURE__ */ function() {
  function SkipLastOperator2(_skipCount) {
    this._skipCount = _skipCount;
    if (this._skipCount < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  SkipLastOperator2.prototype.call = function(subscriber, source) {
    if (this._skipCount === 0) {
      return source.subscribe(new Subscriber(subscriber));
    } else {
      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
    }
  };
  return SkipLastOperator2;
}();
var SkipLastSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipLastSubscriber2, _super);
  function SkipLastSubscriber2(destination, _skipCount) {
    var _this = _super.call(this, destination) || this;
    _this._skipCount = _skipCount;
    _this._count = 0;
    _this._ring = new Array(_skipCount);
    return _this;
  }
  SkipLastSubscriber2.prototype._next = function(value2) {
    var skipCount = this._skipCount;
    var count2 = this._count++;
    if (count2 < skipCount) {
      this._ring[count2] = value2;
    } else {
      var currentIndex = count2 % skipCount;
      var ring = this._ring;
      var oldValue = ring[currentIndex];
      ring[currentIndex] = value2;
      this.destination.next(oldValue);
    }
  };
  return SkipLastSubscriber2;
}(Subscriber);
function skipUntil(notifier) {
  return function(source) {
    return source.lift(new SkipUntilOperator(notifier));
  };
}
var SkipUntilOperator = /* @__PURE__ */ function() {
  function SkipUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  SkipUntilOperator2.prototype.call = function(destination, source) {
    return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
  };
  return SkipUntilOperator2;
}();
var SkipUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipUntilSubscriber2, _super);
  function SkipUntilSubscriber2(destination, notifier) {
    var _this = _super.call(this, destination) || this;
    _this.hasValue = false;
    var innerSubscriber = new SimpleInnerSubscriber(_this);
    _this.add(innerSubscriber);
    _this.innerSubscription = innerSubscriber;
    var innerSubscription = innerSubscribe(notifier, innerSubscriber);
    if (innerSubscription !== innerSubscriber) {
      _this.add(innerSubscription);
      _this.innerSubscription = innerSubscription;
    }
    return _this;
  }
  SkipUntilSubscriber2.prototype._next = function(value2) {
    if (this.hasValue) {
      _super.prototype._next.call(this, value2);
    }
  };
  SkipUntilSubscriber2.prototype.notifyNext = function() {
    this.hasValue = true;
    if (this.innerSubscription) {
      this.innerSubscription.unsubscribe();
    }
  };
  SkipUntilSubscriber2.prototype.notifyComplete = function() {
  };
  return SkipUntilSubscriber2;
}(SimpleOuterSubscriber);
function skipWhile(predicate) {
  return function(source) {
    return source.lift(new SkipWhileOperator(predicate));
  };
}
var SkipWhileOperator = /* @__PURE__ */ function() {
  function SkipWhileOperator2(predicate) {
    this.predicate = predicate;
  }
  SkipWhileOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
  };
  return SkipWhileOperator2;
}();
var SkipWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SkipWhileSubscriber2, _super);
  function SkipWhileSubscriber2(destination, predicate) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.skipping = true;
    _this.index = 0;
    return _this;
  }
  SkipWhileSubscriber2.prototype._next = function(value2) {
    var destination = this.destination;
    if (this.skipping) {
      this.tryCallPredicate(value2);
    }
    if (!this.skipping) {
      destination.next(value2);
    }
  };
  SkipWhileSubscriber2.prototype.tryCallPredicate = function(value2) {
    try {
      var result = this.predicate(value2, this.index++);
      this.skipping = Boolean(result);
    } catch (err) {
      this.destination.error(err);
    }
  };
  return SkipWhileSubscriber2;
}(Subscriber);
function startWith() {
  var array2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    array2[_i] = arguments[_i];
  }
  var scheduler = array2[array2.length - 1];
  if (isScheduler(scheduler)) {
    array2.pop();
    return function(source) {
      return concat$1(array2, source, scheduler);
    };
  } else {
    return function(source) {
      return concat$1(array2, source);
    };
  }
}
var SubscribeOnObservable = /* @__PURE__ */ function(_super) {
  __extends(SubscribeOnObservable2, _super);
  function SubscribeOnObservable2(source, delayTime, scheduler) {
    if (delayTime === void 0) {
      delayTime = 0;
    }
    if (scheduler === void 0) {
      scheduler = asap;
    }
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.delayTime = delayTime;
    _this.scheduler = scheduler;
    if (!isNumeric(delayTime) || delayTime < 0) {
      _this.delayTime = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== "function") {
      _this.scheduler = asap;
    }
    return _this;
  }
  SubscribeOnObservable2.create = function(source, delay2, scheduler) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (scheduler === void 0) {
      scheduler = asap;
    }
    return new SubscribeOnObservable2(source, delay2, scheduler);
  };
  SubscribeOnObservable2.dispatch = function(arg) {
    var source = arg.source, subscriber = arg.subscriber;
    return this.add(source.subscribe(subscriber));
  };
  SubscribeOnObservable2.prototype._subscribe = function(subscriber) {
    var delay2 = this.delayTime;
    var source = this.source;
    var scheduler = this.scheduler;
    return scheduler.schedule(SubscribeOnObservable2.dispatch, delay2, {
      source,
      subscriber
    });
  };
  return SubscribeOnObservable2;
}(Observable);
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return function subscribeOnOperatorFunction(source) {
    return source.lift(new SubscribeOnOperator(scheduler, delay2));
  };
}
var SubscribeOnOperator = /* @__PURE__ */ function() {
  function SubscribeOnOperator2(scheduler, delay2) {
    this.scheduler = scheduler;
    this.delay = delay2;
  }
  SubscribeOnOperator2.prototype.call = function(subscriber, source) {
    return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
  };
  return SubscribeOnOperator2;
}();
function switchMap(project, resultSelector) {
  if (typeof resultSelector === "function") {
    return function(source) {
      return source.pipe(switchMap(function(a2, i2) {
        return from(project(a2, i2)).pipe(map(function(b2, ii) {
          return resultSelector(a2, b2, i2, ii);
        }));
      }));
    };
  }
  return function(source) {
    return source.lift(new SwitchMapOperator(project));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function SwitchMapOperator2(project) {
    this.project = project;
  }
  SwitchMapOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
  };
  return SwitchMapOperator2;
}();
var SwitchMapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(SwitchMapSubscriber2, _super);
  function SwitchMapSubscriber2(destination, project) {
    var _this = _super.call(this, destination) || this;
    _this.project = project;
    _this.index = 0;
    return _this;
  }
  SwitchMapSubscriber2.prototype._next = function(value2) {
    var result;
    var index2 = this.index++;
    try {
      result = this.project(value2, index2);
    } catch (error2) {
      this.destination.error(error2);
      return;
    }
    this._innerSub(result);
  };
  SwitchMapSubscriber2.prototype._innerSub = function(result) {
    var innerSubscription = this.innerSubscription;
    if (innerSubscription) {
      innerSubscription.unsubscribe();
    }
    var innerSubscriber = new SimpleInnerSubscriber(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    this.innerSubscription = innerSubscribe(result, innerSubscriber);
    if (this.innerSubscription !== innerSubscriber) {
      destination.add(this.innerSubscription);
    }
  };
  SwitchMapSubscriber2.prototype._complete = function() {
    var innerSubscription = this.innerSubscription;
    if (!innerSubscription || innerSubscription.closed) {
      _super.prototype._complete.call(this);
    }
    this.unsubscribe();
  };
  SwitchMapSubscriber2.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  };
  SwitchMapSubscriber2.prototype.notifyComplete = function() {
    this.innerSubscription = void 0;
    if (this.isStopped) {
      _super.prototype._complete.call(this);
    }
  };
  SwitchMapSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  return SwitchMapSubscriber2;
}(SimpleOuterSubscriber);
function switchAll() {
  return switchMap(identity);
}
function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? switchMap(function() {
    return innerObservable;
  }, resultSelector) : switchMap(function() {
    return innerObservable;
  });
}
function takeUntil(notifier) {
  return function(source) {
    return source.lift(new TakeUntilOperator(notifier));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function TakeUntilOperator2(notifier) {
    this.notifier = notifier;
  }
  TakeUntilOperator2.prototype.call = function(subscriber, source) {
    var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
    var notifierSubscription = innerSubscribe(this.notifier, new SimpleInnerSubscriber(takeUntilSubscriber));
    if (notifierSubscription && !takeUntilSubscriber.seenValue) {
      takeUntilSubscriber.add(notifierSubscription);
      return source.subscribe(takeUntilSubscriber);
    }
    return takeUntilSubscriber;
  };
  return TakeUntilOperator2;
}();
var TakeUntilSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeUntilSubscriber2, _super);
  function TakeUntilSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.seenValue = false;
    return _this;
  }
  TakeUntilSubscriber2.prototype.notifyNext = function() {
    this.seenValue = true;
    this.complete();
  };
  TakeUntilSubscriber2.prototype.notifyComplete = function() {
  };
  return TakeUntilSubscriber2;
}(SimpleOuterSubscriber);
function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }
  return function(source) {
    return source.lift(new TakeWhileOperator(predicate, inclusive));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function TakeWhileOperator2(predicate, inclusive) {
    this.predicate = predicate;
    this.inclusive = inclusive;
  }
  TakeWhileOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
  };
  return TakeWhileOperator2;
}();
var TakeWhileSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TakeWhileSubscriber2, _super);
  function TakeWhileSubscriber2(destination, predicate, inclusive) {
    var _this = _super.call(this, destination) || this;
    _this.predicate = predicate;
    _this.inclusive = inclusive;
    _this.index = 0;
    return _this;
  }
  TakeWhileSubscriber2.prototype._next = function(value2) {
    var destination = this.destination;
    var result;
    try {
      result = this.predicate(value2, this.index++);
    } catch (err) {
      destination.error(err);
      return;
    }
    this.nextOrComplete(value2, result);
  };
  TakeWhileSubscriber2.prototype.nextOrComplete = function(value2, predicateResult) {
    var destination = this.destination;
    if (Boolean(predicateResult)) {
      destination.next(value2);
    } else {
      if (this.inclusive) {
        destination.next(value2);
      }
      destination.complete();
    }
  };
  return TakeWhileSubscriber2;
}(Subscriber);
function tap(nextOrObserver, error2, complete) {
  return function tapOperatorFunction(source) {
    return source.lift(new DoOperator(nextOrObserver, error2, complete));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function DoOperator2(nextOrObserver, error2, complete) {
    this.nextOrObserver = nextOrObserver;
    this.error = error2;
    this.complete = complete;
  }
  DoOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
  };
  return DoOperator2;
}();
var TapSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TapSubscriber2, _super);
  function TapSubscriber2(destination, observerOrNext, error2, complete) {
    var _this = _super.call(this, destination) || this;
    _this._tapNext = noop$2;
    _this._tapError = noop$2;
    _this._tapComplete = noop$2;
    _this._tapError = error2 || noop$2;
    _this._tapComplete = complete || noop$2;
    if (isFunction(observerOrNext)) {
      _this._context = _this;
      _this._tapNext = observerOrNext;
    } else if (observerOrNext) {
      _this._context = observerOrNext;
      _this._tapNext = observerOrNext.next || noop$2;
      _this._tapError = observerOrNext.error || noop$2;
      _this._tapComplete = observerOrNext.complete || noop$2;
    }
    return _this;
  }
  TapSubscriber2.prototype._next = function(value2) {
    try {
      this._tapNext.call(this._context, value2);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(value2);
  };
  TapSubscriber2.prototype._error = function(err) {
    try {
      this._tapError.call(this._context, err);
    } catch (err2) {
      this.destination.error(err2);
      return;
    }
    this.destination.error(err);
  };
  TapSubscriber2.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    return this.destination.complete();
  };
  return TapSubscriber2;
}(Subscriber);
var defaultThrottleConfig = {
  leading: true,
  trailing: false
};
function throttle(durationSelector, config2) {
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleOperator(durationSelector, !!config2.leading, !!config2.trailing));
  };
}
var ThrottleOperator = /* @__PURE__ */ function() {
  function ThrottleOperator2(durationSelector, leading, trailing) {
    this.durationSelector = durationSelector;
    this.leading = leading;
    this.trailing = trailing;
  }
  ThrottleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
  };
  return ThrottleOperator2;
}();
var ThrottleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleSubscriber2, _super);
  function ThrottleSubscriber2(destination, durationSelector, _leading, _trailing) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.durationSelector = durationSelector;
    _this._leading = _leading;
    _this._trailing = _trailing;
    _this._hasValue = false;
    return _this;
  }
  ThrottleSubscriber2.prototype._next = function(value2) {
    this._hasValue = true;
    this._sendValue = value2;
    if (!this._throttled) {
      if (this._leading) {
        this.send();
      } else {
        this.throttle(value2);
      }
    }
  };
  ThrottleSubscriber2.prototype.send = function() {
    var _a2 = this, _hasValue = _a2._hasValue, _sendValue = _a2._sendValue;
    if (_hasValue) {
      this.destination.next(_sendValue);
      this.throttle(_sendValue);
    }
    this._hasValue = false;
    this._sendValue = void 0;
  };
  ThrottleSubscriber2.prototype.throttle = function(value2) {
    var duration = this.tryDurationSelector(value2);
    if (!!duration) {
      this.add(this._throttled = innerSubscribe(duration, new SimpleInnerSubscriber(this)));
    }
  };
  ThrottleSubscriber2.prototype.tryDurationSelector = function(value2) {
    try {
      return this.durationSelector(value2);
    } catch (err) {
      this.destination.error(err);
      return null;
    }
  };
  ThrottleSubscriber2.prototype.throttlingDone = function() {
    var _a2 = this, _throttled = _a2._throttled, _trailing = _a2._trailing;
    if (_throttled) {
      _throttled.unsubscribe();
    }
    this._throttled = void 0;
    if (_trailing) {
      this.send();
    }
  };
  ThrottleSubscriber2.prototype.notifyNext = function() {
    this.throttlingDone();
  };
  ThrottleSubscriber2.prototype.notifyComplete = function() {
    this.throttlingDone();
  };
  return ThrottleSubscriber2;
}(SimpleOuterSubscriber);
function throttleTime(duration, scheduler, config2) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  if (config2 === void 0) {
    config2 = defaultThrottleConfig;
  }
  return function(source) {
    return source.lift(new ThrottleTimeOperator(duration, scheduler, config2.leading, config2.trailing));
  };
}
var ThrottleTimeOperator = /* @__PURE__ */ function() {
  function ThrottleTimeOperator2(duration, scheduler, leading, trailing) {
    this.duration = duration;
    this.scheduler = scheduler;
    this.leading = leading;
    this.trailing = trailing;
  }
  ThrottleTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
  };
  return ThrottleTimeOperator2;
}();
var ThrottleTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(ThrottleTimeSubscriber2, _super);
  function ThrottleTimeSubscriber2(destination, duration, scheduler, leading, trailing) {
    var _this = _super.call(this, destination) || this;
    _this.duration = duration;
    _this.scheduler = scheduler;
    _this.leading = leading;
    _this.trailing = trailing;
    _this._hasTrailingValue = false;
    _this._trailingValue = null;
    return _this;
  }
  ThrottleTimeSubscriber2.prototype._next = function(value2) {
    if (this.throttled) {
      if (this.trailing) {
        this._trailingValue = value2;
        this._hasTrailingValue = true;
      }
    } else {
      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
      if (this.leading) {
        this.destination.next(value2);
      } else if (this.trailing) {
        this._trailingValue = value2;
        this._hasTrailingValue = true;
      }
    }
  };
  ThrottleTimeSubscriber2.prototype._complete = function() {
    if (this._hasTrailingValue) {
      this.destination.next(this._trailingValue);
      this.destination.complete();
    } else {
      this.destination.complete();
    }
  };
  ThrottleTimeSubscriber2.prototype.clearThrottle = function() {
    var throttled = this.throttled;
    if (throttled) {
      if (this.trailing && this._hasTrailingValue) {
        this.destination.next(this._trailingValue);
        this._trailingValue = null;
        this._hasTrailingValue = false;
      }
      throttled.unsubscribe();
      this.remove(throttled);
      this.throttled = null;
    }
  };
  return ThrottleTimeSubscriber2;
}(Subscriber);
function dispatchNext(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
function timeInterval(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    return defer(function() {
      return source.pipe(scan(function(_a2, value2) {
        var current = _a2.current;
        return { value: value2, current: scheduler.now(), last: current };
      }, { current: scheduler.now(), value: void 0, last: void 0 }), map(function(_a2) {
        var current = _a2.current, last2 = _a2.last, value2 = _a2.value;
        return new TimeInterval(value2, current - last2);
      }));
    });
  };
}
var TimeInterval = /* @__PURE__ */ function() {
  function TimeInterval2(value2, interval2) {
    this.value = value2;
    this.interval = interval2;
  }
  return TimeInterval2;
}();
function timeoutWith(due, withObservable, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    var absoluteTimeout = isDate(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
    this.waitFor = waitFor;
    this.absoluteTimeout = absoluteTimeout;
    this.withObservable = withObservable;
    this.scheduler = scheduler;
  }
  TimeoutWithOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  };
  return TimeoutWithOperator2;
}();
var TimeoutWithSubscriber = /* @__PURE__ */ function(_super) {
  __extends(TimeoutWithSubscriber2, _super);
  function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.absoluteTimeout = absoluteTimeout;
    _this.waitFor = waitFor;
    _this.withObservable = withObservable;
    _this.scheduler = scheduler;
    _this.scheduleTimeout();
    return _this;
  }
  TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
    var withObservable = subscriber.withObservable;
    subscriber._unsubscribeAndRecycle();
    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
  };
  TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
    var action = this.action;
    if (action) {
      this.action = action.schedule(this, this.waitFor);
    } else {
      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
    }
  };
  TimeoutWithSubscriber2.prototype._next = function(value2) {
    if (!this.absoluteTimeout) {
      this.scheduleTimeout();
    }
    _super.prototype._next.call(this, value2);
  };
  TimeoutWithSubscriber2.prototype._unsubscribe = function() {
    this.action = void 0;
    this.scheduler = null;
    this.withObservable = null;
  };
  return TimeoutWithSubscriber2;
}(SimpleOuterSubscriber);
function timeout(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return timeoutWith(due, throwError(new TimeoutError()), scheduler);
}
function timestamp(scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return map(function(value2) {
    return new Timestamp(value2, scheduler.now());
  });
}
var Timestamp = /* @__PURE__ */ function() {
  function Timestamp2(value2, timestamp2) {
    this.value = value2;
    this.timestamp = timestamp2;
  }
  return Timestamp2;
}();
function toArrayReducer(arr2, item, index2) {
  if (index2 === 0) {
    return [item];
  }
  arr2.push(item);
  return arr2;
}
function toArray() {
  return reduce(toArrayReducer, []);
}
function window$1(windowBoundaries) {
  return function windowOperatorFunction(source) {
    return source.lift(new WindowOperator$1(windowBoundaries));
  };
}
var WindowOperator$1 = /* @__PURE__ */ function() {
  function WindowOperator2(windowBoundaries) {
    this.windowBoundaries = windowBoundaries;
  }
  WindowOperator2.prototype.call = function(subscriber, source) {
    var windowSubscriber = new WindowSubscriber$1(subscriber);
    var sourceSubscription = source.subscribe(windowSubscriber);
    if (!sourceSubscription.closed) {
      windowSubscriber.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(windowSubscriber)));
    }
    return sourceSubscription;
  };
  return WindowOperator2;
}();
var WindowSubscriber$1 = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.window = new Subject();
    destination.next(_this.window);
    return _this;
  }
  WindowSubscriber2.prototype.notifyNext = function() {
    this.openWindow();
  };
  WindowSubscriber2.prototype.notifyError = function(error2) {
    this._error(error2);
  };
  WindowSubscriber2.prototype.notifyComplete = function() {
    this._complete();
  };
  WindowSubscriber2.prototype._next = function(value2) {
    this.window.next(value2);
  };
  WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err);
    this.destination.error(err);
  };
  WindowSubscriber2.prototype._complete = function() {
    this.window.complete();
    this.destination.complete();
  };
  WindowSubscriber2.prototype._unsubscribe = function() {
    this.window = null;
  };
  WindowSubscriber2.prototype.openWindow = function() {
    var prevWindow = this.window;
    if (prevWindow) {
      prevWindow.complete();
    }
    var destination = this.destination;
    var newWindow = this.window = new Subject();
    destination.next(newWindow);
  };
  return WindowSubscriber2;
}(SimpleOuterSubscriber);
function windowCount(windowSize, startWindowEvery) {
  if (startWindowEvery === void 0) {
    startWindowEvery = 0;
  }
  return function windowCountOperatorFunction(source) {
    return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
  };
}
var WindowCountOperator = /* @__PURE__ */ function() {
  function WindowCountOperator2(windowSize, startWindowEvery) {
    this.windowSize = windowSize;
    this.startWindowEvery = startWindowEvery;
  }
  WindowCountOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
  };
  return WindowCountOperator2;
}();
var WindowCountSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowCountSubscriber2, _super);
  function WindowCountSubscriber2(destination, windowSize, startWindowEvery) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.windowSize = windowSize;
    _this.startWindowEvery = startWindowEvery;
    _this.windows = [new Subject()];
    _this.count = 0;
    destination.next(_this.windows[0]);
    return _this;
  }
  WindowCountSubscriber2.prototype._next = function(value2) {
    var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
    var destination = this.destination;
    var windowSize = this.windowSize;
    var windows = this.windows;
    var len2 = windows.length;
    for (var i2 = 0; i2 < len2 && !this.closed; i2++) {
      windows[i2].next(value2);
    }
    var c2 = this.count - windowSize + 1;
    if (c2 >= 0 && c2 % startWindowEvery === 0 && !this.closed) {
      windows.shift().complete();
    }
    if (++this.count % startWindowEvery === 0 && !this.closed) {
      var window_1 = new Subject();
      windows.push(window_1);
      destination.next(window_1);
    }
  };
  WindowCountSubscriber2.prototype._error = function(err) {
    var windows = this.windows;
    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().error(err);
      }
    }
    this.destination.error(err);
  };
  WindowCountSubscriber2.prototype._complete = function() {
    var windows = this.windows;
    if (windows) {
      while (windows.length > 0 && !this.closed) {
        windows.shift().complete();
      }
    }
    this.destination.complete();
  };
  WindowCountSubscriber2.prototype._unsubscribe = function() {
    this.count = 0;
    this.windows = null;
  };
  return WindowCountSubscriber2;
}(Subscriber);
function windowTime(windowTimeSpan) {
  var scheduler = async;
  var windowCreationInterval = null;
  var maxWindowSize = Number.POSITIVE_INFINITY;
  if (isScheduler(arguments[3])) {
    scheduler = arguments[3];
  }
  if (isScheduler(arguments[2])) {
    scheduler = arguments[2];
  } else if (isNumeric(arguments[2])) {
    maxWindowSize = Number(arguments[2]);
  }
  if (isScheduler(arguments[1])) {
    scheduler = arguments[1];
  } else if (isNumeric(arguments[1])) {
    windowCreationInterval = Number(arguments[1]);
  }
  return function windowTimeOperatorFunction(source) {
    return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
  };
}
var WindowTimeOperator = /* @__PURE__ */ function() {
  function WindowTimeOperator2(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    this.windowTimeSpan = windowTimeSpan;
    this.windowCreationInterval = windowCreationInterval;
    this.maxWindowSize = maxWindowSize;
    this.scheduler = scheduler;
  }
  WindowTimeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  };
  return WindowTimeOperator2;
}();
var CountedSubject = /* @__PURE__ */ function(_super) {
  __extends(CountedSubject2, _super);
  function CountedSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._numberOfNextedValues = 0;
    return _this;
  }
  CountedSubject2.prototype.next = function(value2) {
    this._numberOfNextedValues++;
    _super.prototype.next.call(this, value2);
  };
  Object.defineProperty(CountedSubject2.prototype, "numberOfNextedValues", {
    get: function() {
      return this._numberOfNextedValues;
    },
    enumerable: true,
    configurable: true
  });
  return CountedSubject2;
}(Subject);
var WindowTimeSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowTimeSubscriber2, _super);
  function WindowTimeSubscriber2(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.windowTimeSpan = windowTimeSpan;
    _this.windowCreationInterval = windowCreationInterval;
    _this.maxWindowSize = maxWindowSize;
    _this.scheduler = scheduler;
    _this.windows = [];
    var window2 = _this.openWindow();
    if (windowCreationInterval !== null && windowCreationInterval >= 0) {
      var closeState = { subscriber: _this, window: window2, context: null };
      var creationState = { windowTimeSpan, windowCreationInterval, subscriber: _this, scheduler };
      _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
      _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
    } else {
      var timeSpanOnlyState = { subscriber: _this, window: window2, windowTimeSpan };
      _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
    }
    return _this;
  }
  WindowTimeSubscriber2.prototype._next = function(value2) {
    var windows = this.windows;
    var len2 = windows.length;
    for (var i2 = 0; i2 < len2; i2++) {
      var window_1 = windows[i2];
      if (!window_1.closed) {
        window_1.next(value2);
        if (window_1.numberOfNextedValues >= this.maxWindowSize) {
          this.closeWindow(window_1);
        }
      }
    }
  };
  WindowTimeSubscriber2.prototype._error = function(err) {
    var windows = this.windows;
    while (windows.length > 0) {
      windows.shift().error(err);
    }
    this.destination.error(err);
  };
  WindowTimeSubscriber2.prototype._complete = function() {
    var windows = this.windows;
    while (windows.length > 0) {
      var window_2 = windows.shift();
      if (!window_2.closed) {
        window_2.complete();
      }
    }
    this.destination.complete();
  };
  WindowTimeSubscriber2.prototype.openWindow = function() {
    var window2 = new CountedSubject();
    this.windows.push(window2);
    var destination = this.destination;
    destination.next(window2);
    return window2;
  };
  WindowTimeSubscriber2.prototype.closeWindow = function(window2) {
    window2.complete();
    var windows = this.windows;
    windows.splice(windows.indexOf(window2), 1);
  };
  return WindowTimeSubscriber2;
}(Subscriber);
function dispatchWindowTimeSpanOnly(state2) {
  var subscriber = state2.subscriber, windowTimeSpan = state2.windowTimeSpan, window2 = state2.window;
  if (window2) {
    subscriber.closeWindow(window2);
  }
  state2.window = subscriber.openWindow();
  this.schedule(state2, windowTimeSpan);
}
function dispatchWindowCreation(state2) {
  var windowTimeSpan = state2.windowTimeSpan, subscriber = state2.subscriber, scheduler = state2.scheduler, windowCreationInterval = state2.windowCreationInterval;
  var window2 = subscriber.openWindow();
  var action = this;
  var context = { action, subscription: null };
  var timeSpanState = { subscriber, window: window2, context };
  context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
  action.add(context.subscription);
  action.schedule(state2, windowCreationInterval);
}
function dispatchWindowClose(state2) {
  var subscriber = state2.subscriber, window2 = state2.window, context = state2.context;
  if (context && context.action && context.subscription) {
    context.action.remove(context.subscription);
  }
  subscriber.closeWindow(window2);
}
function windowToggle(openings, closingSelector) {
  return function(source) {
    return source.lift(new WindowToggleOperator(openings, closingSelector));
  };
}
var WindowToggleOperator = /* @__PURE__ */ function() {
  function WindowToggleOperator2(openings, closingSelector) {
    this.openings = openings;
    this.closingSelector = closingSelector;
  }
  WindowToggleOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
  };
  return WindowToggleOperator2;
}();
var WindowToggleSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowToggleSubscriber2, _super);
  function WindowToggleSubscriber2(destination, openings, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.openings = openings;
    _this.closingSelector = closingSelector;
    _this.contexts = [];
    _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
    return _this;
  }
  WindowToggleSubscriber2.prototype._next = function(value2) {
    var contexts = this.contexts;
    if (contexts) {
      var len2 = contexts.length;
      for (var i2 = 0; i2 < len2; i2++) {
        contexts[i2].window.next(value2);
      }
    }
  };
  WindowToggleSubscriber2.prototype._error = function(err) {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len2 = contexts.length;
      var index2 = -1;
      while (++index2 < len2) {
        var context_1 = contexts[index2];
        context_1.window.error(err);
        context_1.subscription.unsubscribe();
      }
    }
    _super.prototype._error.call(this, err);
  };
  WindowToggleSubscriber2.prototype._complete = function() {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len2 = contexts.length;
      var index2 = -1;
      while (++index2 < len2) {
        var context_2 = contexts[index2];
        context_2.window.complete();
        context_2.subscription.unsubscribe();
      }
    }
    _super.prototype._complete.call(this);
  };
  WindowToggleSubscriber2.prototype._unsubscribe = function() {
    var contexts = this.contexts;
    this.contexts = null;
    if (contexts) {
      var len2 = contexts.length;
      var index2 = -1;
      while (++index2 < len2) {
        var context_3 = contexts[index2];
        context_3.window.unsubscribe();
        context_3.subscription.unsubscribe();
      }
    }
  };
  WindowToggleSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    if (outerValue === this.openings) {
      var closingNotifier = void 0;
      try {
        var closingSelector = this.closingSelector;
        closingNotifier = closingSelector(innerValue);
      } catch (e2) {
        return this.error(e2);
      }
      var window_1 = new Subject();
      var subscription = new Subscription();
      var context_4 = { window: window_1, subscription };
      this.contexts.push(context_4);
      var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
      if (innerSubscription.closed) {
        this.closeWindow(this.contexts.length - 1);
      } else {
        innerSubscription.context = context_4;
        subscription.add(innerSubscription);
      }
      this.destination.next(window_1);
    } else {
      this.closeWindow(this.contexts.indexOf(outerValue));
    }
  };
  WindowToggleSubscriber2.prototype.notifyError = function(err) {
    this.error(err);
  };
  WindowToggleSubscriber2.prototype.notifyComplete = function(inner) {
    if (inner !== this.openSubscription) {
      this.closeWindow(this.contexts.indexOf(inner.context));
    }
  };
  WindowToggleSubscriber2.prototype.closeWindow = function(index2) {
    if (index2 === -1) {
      return;
    }
    var contexts = this.contexts;
    var context = contexts[index2];
    var window2 = context.window, subscription = context.subscription;
    contexts.splice(index2, 1);
    window2.complete();
    subscription.unsubscribe();
  };
  return WindowToggleSubscriber2;
}(OuterSubscriber);
function windowWhen(closingSelector) {
  return function windowWhenOperatorFunction(source) {
    return source.lift(new WindowOperator(closingSelector));
  };
}
var WindowOperator = /* @__PURE__ */ function() {
  function WindowOperator2(closingSelector) {
    this.closingSelector = closingSelector;
  }
  WindowOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
  };
  return WindowOperator2;
}();
var WindowSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WindowSubscriber2, _super);
  function WindowSubscriber2(destination, closingSelector) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    _this.closingSelector = closingSelector;
    _this.openWindow();
    return _this;
  }
  WindowSubscriber2.prototype.notifyNext = function(_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
    this.openWindow(innerSub);
  };
  WindowSubscriber2.prototype.notifyError = function(error2) {
    this._error(error2);
  };
  WindowSubscriber2.prototype.notifyComplete = function(innerSub) {
    this.openWindow(innerSub);
  };
  WindowSubscriber2.prototype._next = function(value2) {
    this.window.next(value2);
  };
  WindowSubscriber2.prototype._error = function(err) {
    this.window.error(err);
    this.destination.error(err);
    this.unsubscribeClosingNotification();
  };
  WindowSubscriber2.prototype._complete = function() {
    this.window.complete();
    this.destination.complete();
    this.unsubscribeClosingNotification();
  };
  WindowSubscriber2.prototype.unsubscribeClosingNotification = function() {
    if (this.closingNotification) {
      this.closingNotification.unsubscribe();
    }
  };
  WindowSubscriber2.prototype.openWindow = function(innerSub) {
    if (innerSub === void 0) {
      innerSub = null;
    }
    if (innerSub) {
      this.remove(innerSub);
      innerSub.unsubscribe();
    }
    var prevWindow = this.window;
    if (prevWindow) {
      prevWindow.complete();
    }
    var window2 = this.window = new Subject();
    this.destination.next(window2);
    var closingNotifier;
    try {
      var closingSelector = this.closingSelector;
      closingNotifier = closingSelector();
    } catch (e2) {
      this.destination.error(e2);
      this.window.error(e2);
      return;
    }
    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
  };
  return WindowSubscriber2;
}(OuterSubscriber);
function withLatestFrom() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return function(source) {
    var project;
    if (typeof args[args.length - 1] === "function") {
      project = args.pop();
    }
    var observables = args;
    return source.lift(new WithLatestFromOperator(observables, project));
  };
}
var WithLatestFromOperator = /* @__PURE__ */ function() {
  function WithLatestFromOperator2(observables, project) {
    this.observables = observables;
    this.project = project;
  }
  WithLatestFromOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
  };
  return WithLatestFromOperator2;
}();
var WithLatestFromSubscriber = /* @__PURE__ */ function(_super) {
  __extends(WithLatestFromSubscriber2, _super);
  function WithLatestFromSubscriber2(destination, observables, project) {
    var _this = _super.call(this, destination) || this;
    _this.observables = observables;
    _this.project = project;
    _this.toRespond = [];
    var len2 = observables.length;
    _this.values = new Array(len2);
    for (var i2 = 0; i2 < len2; i2++) {
      _this.toRespond.push(i2);
    }
    for (var i2 = 0; i2 < len2; i2++) {
      var observable2 = observables[i2];
      _this.add(subscribeToResult(_this, observable2, void 0, i2));
    }
    return _this;
  }
  WithLatestFromSubscriber2.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
    this.values[outerIndex] = innerValue;
    var toRespond = this.toRespond;
    if (toRespond.length > 0) {
      var found = toRespond.indexOf(outerIndex);
      if (found !== -1) {
        toRespond.splice(found, 1);
      }
    }
  };
  WithLatestFromSubscriber2.prototype.notifyComplete = function() {
  };
  WithLatestFromSubscriber2.prototype._next = function(value2) {
    if (this.toRespond.length === 0) {
      var args = [value2].concat(this.values);
      if (this.project) {
        this._tryProject(args);
      } else {
        this.destination.next(args);
      }
    }
  };
  WithLatestFromSubscriber2.prototype._tryProject = function(args) {
    var result;
    try {
      result = this.project.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }
    this.destination.next(result);
  };
  return WithLatestFromSubscriber2;
}(OuterSubscriber);
function zip() {
  var observables = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }
  return function zipOperatorFunction(source) {
    return source.lift.call(zip$1.apply(void 0, [source].concat(observables)));
  };
}
function zipAll(project) {
  return function(source) {
    return source.lift(new ZipOperator(project));
  };
}
var operators = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  audit,
  auditTime,
  buffer,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  concat,
  concatAll,
  concatMap,
  concatMapTo,
  count,
  debounce,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every,
  exhaust,
  exhaustMap,
  expand,
  filter,
  finalize,
  find,
  findIndex,
  first,
  groupBy,
  ignoreElements,
  isEmpty,
  last,
  map,
  mapTo,
  materialize,
  max,
  merge,
  mergeAll,
  mergeMap,
  flatMap,
  mergeMapTo,
  mergeScan,
  min,
  multicast,
  observeOn,
  onErrorResumeNext,
  pairwise,
  partition,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  reduce,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  refCount,
  sample,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp,
  toArray,
  window: window$1,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll
});
var require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(operators);
var util$3 = {};
var types$1 = {};
Object.defineProperty(types$1, "__esModule", { value: true });
types$1.RegExpString = types$1.IntNumber = types$1.BigIntString = types$1.AddressString = types$1.HexString = types$1.OpaqueType = void 0;
function OpaqueType() {
  return (value2) => value2;
}
types$1.OpaqueType = OpaqueType;
types$1.HexString = OpaqueType();
types$1.AddressString = OpaqueType();
types$1.BigIntString = OpaqueType();
function IntNumber(num) {
  return Math.floor(num);
}
types$1.IntNumber = IntNumber;
types$1.RegExpString = OpaqueType();
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(util$3, "__esModule", { value: true });
util$3.getFavicon = util$3.range = util$3.isBigNumber = util$3.ensureParsedJSONObject = util$3.ensureBN = util$3.ensureRegExpString = util$3.ensureIntNumber = util$3.ensureBuffer = util$3.ensureAddressString = util$3.ensureEvenLengthHexString = util$3.ensureHexString = util$3.isHexString = util$3.prepend0x = util$3.strip0x = util$3.has0xPrefix = util$3.hexStringFromIntNumber = util$3.intNumberFromHexString = util$3.bigIntStringFromBN = util$3.hexStringFromBuffer = util$3.hexStringToUint8Array = util$3.uint8ArrayToHex = util$3.randomBytesHex = void 0;
const bn_js_1$1 = __importDefault$8(bn$1.exports);
const types_1$2 = types$1;
const INT_STRING_REGEX = /^[0-9]*$/;
const HEXADECIMAL_STRING_REGEX = /^[a-f0-9]*$/;
function randomBytesHex(length) {
  return uint8ArrayToHex(crypto.getRandomValues(new Uint8Array(length)));
}
util$3.randomBytesHex = randomBytesHex;
function uint8ArrayToHex(value2) {
  return [...value2].map((b2) => b2.toString(16).padStart(2, "0")).join("");
}
util$3.uint8ArrayToHex = uint8ArrayToHex;
function hexStringToUint8Array(hexString) {
  return new Uint8Array(hexString.match(/.{1,2}/g).map((byte2) => parseInt(byte2, 16)));
}
util$3.hexStringToUint8Array = hexStringToUint8Array;
function hexStringFromBuffer(buf, includePrefix = false) {
  const hex = buf.toString("hex");
  return (0, types_1$2.HexString)(includePrefix ? "0x" + hex : hex);
}
util$3.hexStringFromBuffer = hexStringFromBuffer;
function bigIntStringFromBN(bn2) {
  return (0, types_1$2.BigIntString)(bn2.toString(10));
}
util$3.bigIntStringFromBN = bigIntStringFromBN;
function intNumberFromHexString(hex) {
  return (0, types_1$2.IntNumber)(new bn_js_1$1.default(ensureEvenLengthHexString(hex, false), 16).toNumber());
}
util$3.intNumberFromHexString = intNumberFromHexString;
function hexStringFromIntNumber(num) {
  return (0, types_1$2.HexString)("0x" + new bn_js_1$1.default(num).toString(16));
}
util$3.hexStringFromIntNumber = hexStringFromIntNumber;
function has0xPrefix(str2) {
  return str2.startsWith("0x") || str2.startsWith("0X");
}
util$3.has0xPrefix = has0xPrefix;
function strip0x(hex) {
  if (has0xPrefix(hex)) {
    return hex.slice(2);
  }
  return hex;
}
util$3.strip0x = strip0x;
function prepend0x(hex) {
  if (has0xPrefix(hex)) {
    return "0x" + hex.slice(2);
  }
  return "0x" + hex;
}
util$3.prepend0x = prepend0x;
function isHexString$1(hex) {
  if (typeof hex !== "string") {
    return false;
  }
  const s2 = strip0x(hex).toLowerCase();
  return HEXADECIMAL_STRING_REGEX.test(s2);
}
util$3.isHexString = isHexString$1;
function ensureHexString(hex, includePrefix = false) {
  if (typeof hex === "string") {
    const s2 = strip0x(hex).toLowerCase();
    if (HEXADECIMAL_STRING_REGEX.test(s2)) {
      return (0, types_1$2.HexString)(includePrefix ? "0x" + s2 : s2);
    }
  }
  throw new Error(`"${String(hex)}" is not a hexadecimal string`);
}
util$3.ensureHexString = ensureHexString;
function ensureEvenLengthHexString(hex, includePrefix = false) {
  let h2 = ensureHexString(hex, false);
  if (h2.length % 2 === 1) {
    h2 = (0, types_1$2.HexString)("0" + h2);
  }
  return includePrefix ? (0, types_1$2.HexString)("0x" + h2) : h2;
}
util$3.ensureEvenLengthHexString = ensureEvenLengthHexString;
function ensureAddressString(str2) {
  if (typeof str2 === "string") {
    const s2 = strip0x(str2).toLowerCase();
    if (isHexString$1(s2) && s2.length === 40) {
      return (0, types_1$2.AddressString)(prepend0x(s2));
    }
  }
  throw new Error(`Invalid Ethereum address: ${String(str2)}`);
}
util$3.ensureAddressString = ensureAddressString;
function ensureBuffer(str2) {
  if (buffer$2.Buffer.isBuffer(str2)) {
    return str2;
  }
  if (typeof str2 === "string") {
    if (isHexString$1(str2)) {
      const s2 = ensureEvenLengthHexString(str2, false);
      return buffer$2.Buffer.from(s2, "hex");
    } else {
      return buffer$2.Buffer.from(str2, "utf8");
    }
  }
  throw new Error(`Not binary data: ${String(str2)}`);
}
util$3.ensureBuffer = ensureBuffer;
function ensureIntNumber(num) {
  if (typeof num === "number" && Number.isInteger(num)) {
    return (0, types_1$2.IntNumber)(num);
  }
  if (typeof num === "string") {
    if (INT_STRING_REGEX.test(num)) {
      return (0, types_1$2.IntNumber)(Number(num));
    }
    if (isHexString$1(num)) {
      return (0, types_1$2.IntNumber)(new bn_js_1$1.default(ensureEvenLengthHexString(num, false), 16).toNumber());
    }
  }
  throw new Error(`Not an integer: ${String(num)}`);
}
util$3.ensureIntNumber = ensureIntNumber;
function ensureRegExpString(regExp) {
  if (regExp instanceof RegExp) {
    return (0, types_1$2.RegExpString)(regExp.toString());
  }
  throw new Error(`Not a RegExp: ${String(regExp)}`);
}
util$3.ensureRegExpString = ensureRegExpString;
function ensureBN(val) {
  if (val !== null && (bn_js_1$1.default.isBN(val) || isBigNumber(val))) {
    return new bn_js_1$1.default(val.toString(10), 10);
  }
  if (typeof val === "number") {
    return new bn_js_1$1.default(ensureIntNumber(val));
  }
  if (typeof val === "string") {
    if (INT_STRING_REGEX.test(val)) {
      return new bn_js_1$1.default(val, 10);
    }
    if (isHexString$1(val)) {
      return new bn_js_1$1.default(ensureEvenLengthHexString(val, false), 16);
    }
  }
  throw new Error(`Not an integer: ${String(val)}`);
}
util$3.ensureBN = ensureBN;
function ensureParsedJSONObject(val) {
  if (typeof val === "string") {
    return JSON.parse(val);
  }
  if (typeof val === "object") {
    return val;
  }
  throw new Error(`Not a JSON string or an object: ${String(val)}`);
}
util$3.ensureParsedJSONObject = ensureParsedJSONObject;
function isBigNumber(val) {
  if (val == null || typeof val.constructor !== "function") {
    return false;
  }
  const { constructor } = val;
  return typeof constructor.config === "function" && typeof constructor.EUCLID === "number";
}
util$3.isBigNumber = isBigNumber;
function range(start, stop) {
  return Array.from({ length: stop - start }, (_2, i2) => start + i2);
}
util$3.range = range;
function getFavicon() {
  const el = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]');
  const { protocol, host } = document.location;
  const href = el ? el.getAttribute("href") : null;
  if (!href || href.startsWith("javascript:")) {
    return null;
  }
  if (href.startsWith("http://") || href.startsWith("https://") || href.startsWith("data:")) {
    return href;
  }
  if (href.startsWith("//")) {
    return protocol + href;
  }
  return `${protocol}//${host}${href}`;
}
util$3.getFavicon = getFavicon;
Object.defineProperty(Session$1, "__esModule", { value: true });
Session$1.Session = void 0;
const js_sha256_1 = sha256.exports;
const rxjs_1$4 = require$$1$1;
const operators_1$3 = require$$2$1;
const util_1$6 = util$3;
const STORAGE_KEY_SESSION_ID = "session:id";
const STORAGE_KEY_SESSION_SECRET = "session:secret";
const STORAGE_KEY_SESSION_LINKED = "session:linked";
class Session {
  constructor(storage, id2, secret2, linked) {
    this._storage = storage;
    this._id = id2 || (0, util_1$6.randomBytesHex)(16);
    this._secret = secret2 || (0, util_1$6.randomBytesHex)(32);
    const hash3 = js_sha256_1.sha256.create();
    hash3.update(`${this._id}, ${this._secret} WalletLink`);
    this._key = hash3.hex();
    this._linked = !!linked;
  }
  static load(storage) {
    const id2 = storage.getItem(STORAGE_KEY_SESSION_ID);
    const linked = storage.getItem(STORAGE_KEY_SESSION_LINKED);
    const secret2 = storage.getItem(STORAGE_KEY_SESSION_SECRET);
    if (id2 && secret2) {
      return new Session(storage, id2, secret2, linked === "1");
    }
    return null;
  }
  static clear(storage) {
    storage.removeItem(STORAGE_KEY_SESSION_SECRET);
    storage.removeItem(STORAGE_KEY_SESSION_ID);
    storage.removeItem(STORAGE_KEY_SESSION_LINKED);
  }
  static get persistedSessionIdChange$() {
    return (0, rxjs_1$4.fromEvent)(window, "storage").pipe((0, operators_1$3.filter)((evt) => evt.key === STORAGE_KEY_SESSION_ID), (0, operators_1$3.map)((evt) => ({
      oldValue: evt.oldValue || null,
      newValue: evt.newValue || null
    })));
  }
  static hash(sessionId) {
    const hash3 = js_sha256_1.sha256.create();
    return hash3.update(sessionId).hex();
  }
  get id() {
    return this._id;
  }
  get secret() {
    return this._secret;
  }
  get key() {
    return this._key;
  }
  get linked() {
    return this._linked;
  }
  set linked(val) {
    this._linked = val;
    this.persistLinked();
  }
  save() {
    this._storage.setItem(STORAGE_KEY_SESSION_ID, this._id);
    this._storage.setItem(STORAGE_KEY_SESSION_SECRET, this._secret);
    this.persistLinked();
    return this;
  }
  persistLinked() {
    this._storage.setItem(STORAGE_KEY_SESSION_LINKED, this._linked ? "1" : "0");
  }
}
Session$1.Session = Session;
var WalletLinkRelayAbstract$1 = {};
Object.defineProperty(WalletLinkRelayAbstract$1, "__esModule", { value: true });
WalletLinkRelayAbstract$1.WalletLinkRelayAbstract = WalletLinkRelayAbstract$1.APP_VERSION_KEY = WalletLinkRelayAbstract$1.LOCAL_STORAGE_ADDRESSES_KEY = WalletLinkRelayAbstract$1.WALLET_USER_NAME_KEY = void 0;
const eth_rpc_errors_1$2 = dist$3;
WalletLinkRelayAbstract$1.WALLET_USER_NAME_KEY = "walletUsername";
WalletLinkRelayAbstract$1.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses";
WalletLinkRelayAbstract$1.APP_VERSION_KEY = "AppVersion";
class WalletLinkRelayAbstract {
  async makeEthereumJSONRPCRequest(request, jsonRpcUrl) {
    if (!jsonRpcUrl)
      throw new Error("Error: No jsonRpcUrl provided");
    return window.fetch(jsonRpcUrl, {
      method: "POST",
      body: JSON.stringify(request),
      mode: "cors",
      headers: { "Content-Type": "application/json" }
    }).then((res) => res.json()).then((json2) => {
      if (!json2) {
        throw eth_rpc_errors_1$2.ethErrors.rpc.parse({});
      }
      const response = json2;
      const { error: error2 } = response;
      if (error2) {
        throw (0, eth_rpc_errors_1$2.serializeError)(error2);
      }
      return response;
    });
  }
}
WalletLinkRelayAbstract$1.WalletLinkRelayAbstract = WalletLinkRelayAbstract;
const createKeccakHash = js;
const BN$1 = bn$1.exports;
function zeros(bytes3) {
  return buffer$2.Buffer.allocUnsafe(bytes3).fill(0);
}
function setLength(msg, length, right) {
  const buf = zeros(length);
  msg = toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
}
function setLengthRight(msg, length) {
  return setLength(msg, length, true);
}
function toBuffer(v2) {
  if (!buffer$2.Buffer.isBuffer(v2)) {
    if (Array.isArray(v2)) {
      v2 = buffer$2.Buffer.from(v2);
    } else if (typeof v2 === "string") {
      if (isHexString(v2)) {
        v2 = buffer$2.Buffer.from(padToEven(stripHexPrefix(v2)), "hex");
      } else {
        v2 = buffer$2.Buffer.from(v2);
      }
    } else if (typeof v2 === "number") {
      v2 = intToBuffer(v2);
    } else if (v2 === null || v2 === void 0) {
      v2 = buffer$2.Buffer.allocUnsafe(0);
    } else if (BN$1.isBN(v2)) {
      v2 = v2.toArrayLike(buffer$2.Buffer);
    } else if (v2.toArray) {
      v2 = buffer$2.Buffer.from(v2.toArray());
    } else {
      throw new Error("invalid type");
    }
  }
  return v2;
}
function bufferToHex(buf) {
  buf = toBuffer(buf);
  return "0x" + buf.toString("hex");
}
function keccak(a2, bits) {
  a2 = toBuffer(a2);
  if (!bits)
    bits = 256;
  return createKeccakHash("keccak" + bits).update(a2).digest();
}
function padToEven(str2) {
  return str2.length % 2 ? "0" + str2 : str2;
}
function isHexString(str2) {
  return typeof str2 === "string" && str2.match(/^0x[0-9A-Fa-f]*$/);
}
function stripHexPrefix(str2) {
  if (typeof str2 === "string" && str2.startsWith("0x")) {
    return str2.slice(2);
  }
  return str2;
}
var util$2 = {
  zeros,
  setLength,
  setLengthRight,
  isHexString,
  stripHexPrefix,
  toBuffer,
  bufferToHex,
  keccak
};
const util$1 = util$2;
const BN = bn$1.exports;
function elementaryName(name2) {
  if (name2.startsWith("int[")) {
    return "int256" + name2.slice(3);
  } else if (name2 === "int") {
    return "int256";
  } else if (name2.startsWith("uint[")) {
    return "uint256" + name2.slice(4);
  } else if (name2 === "uint") {
    return "uint256";
  } else if (name2.startsWith("fixed[")) {
    return "fixed128x128" + name2.slice(5);
  } else if (name2 === "fixed") {
    return "fixed128x128";
  } else if (name2.startsWith("ufixed[")) {
    return "ufixed128x128" + name2.slice(6);
  } else if (name2 === "ufixed") {
    return "ufixed128x128";
  }
  return name2;
}
function parseTypeN(type) {
  return parseInt(/^\D+(\d+)$/.exec(type)[1], 10);
}
function parseTypeNxM(type) {
  var tmp = /^\D+(\d+)x(\d+)$/.exec(type);
  return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
}
function parseTypeArray(type) {
  var tmp = type.match(/(.*)\[(.*?)\]$/);
  if (tmp) {
    return tmp[2] === "" ? "dynamic" : parseInt(tmp[2], 10);
  }
  return null;
}
function parseNumber(arg) {
  var type = typeof arg;
  if (type === "string") {
    if (util$1.isHexString(arg)) {
      return new BN(util$1.stripHexPrefix(arg), 16);
    } else {
      return new BN(arg, 10);
    }
  } else if (type === "number") {
    return new BN(arg);
  } else if (arg.toArray) {
    return arg;
  } else {
    throw new Error("Argument is not a number");
  }
}
function encodeSingle(type, arg) {
  var size2, num, ret, i2;
  if (type === "address") {
    return encodeSingle("uint160", parseNumber(arg));
  } else if (type === "bool") {
    return encodeSingle("uint8", arg ? 1 : 0);
  } else if (type === "string") {
    return encodeSingle("bytes", new buffer$2.Buffer(arg, "utf8"));
  } else if (isArray(type)) {
    if (typeof arg.length === "undefined") {
      throw new Error("Not an array?");
    }
    size2 = parseTypeArray(type);
    if (size2 !== "dynamic" && size2 !== 0 && arg.length > size2) {
      throw new Error("Elements exceed array size: " + size2);
    }
    ret = [];
    type = type.slice(0, type.lastIndexOf("["));
    if (typeof arg === "string") {
      arg = JSON.parse(arg);
    }
    for (i2 in arg) {
      ret.push(encodeSingle(type, arg[i2]));
    }
    if (size2 === "dynamic") {
      var length = encodeSingle("uint256", arg.length);
      ret.unshift(length);
    }
    return buffer$2.Buffer.concat(ret);
  } else if (type === "bytes") {
    arg = new buffer$2.Buffer(arg);
    ret = buffer$2.Buffer.concat([encodeSingle("uint256", arg.length), arg]);
    if (arg.length % 32 !== 0) {
      ret = buffer$2.Buffer.concat([ret, util$1.zeros(32 - arg.length % 32)]);
    }
    return ret;
  } else if (type.startsWith("bytes")) {
    size2 = parseTypeN(type);
    if (size2 < 1 || size2 > 32) {
      throw new Error("Invalid bytes<N> width: " + size2);
    }
    return util$1.setLengthRight(arg, 32);
  } else if (type.startsWith("uint")) {
    size2 = parseTypeN(type);
    if (size2 % 8 || size2 < 8 || size2 > 256) {
      throw new Error("Invalid uint<N> width: " + size2);
    }
    num = parseNumber(arg);
    if (num.bitLength() > size2) {
      throw new Error("Supplied uint exceeds width: " + size2 + " vs " + num.bitLength());
    }
    if (num < 0) {
      throw new Error("Supplied uint is negative");
    }
    return num.toArrayLike(buffer$2.Buffer, "be", 32);
  } else if (type.startsWith("int")) {
    size2 = parseTypeN(type);
    if (size2 % 8 || size2 < 8 || size2 > 256) {
      throw new Error("Invalid int<N> width: " + size2);
    }
    num = parseNumber(arg);
    if (num.bitLength() > size2) {
      throw new Error("Supplied int exceeds width: " + size2 + " vs " + num.bitLength());
    }
    return num.toTwos(256).toArrayLike(buffer$2.Buffer, "be", 32);
  } else if (type.startsWith("ufixed")) {
    size2 = parseTypeNxM(type);
    num = parseNumber(arg);
    if (num < 0) {
      throw new Error("Supplied ufixed is negative");
    }
    return encodeSingle("uint256", num.mul(new BN(2).pow(new BN(size2[1]))));
  } else if (type.startsWith("fixed")) {
    size2 = parseTypeNxM(type);
    return encodeSingle("int256", parseNumber(arg).mul(new BN(2).pow(new BN(size2[1]))));
  }
  throw new Error("Unsupported or invalid type: " + type);
}
function isDynamic(type) {
  return type === "string" || type === "bytes" || parseTypeArray(type) === "dynamic";
}
function isArray(type) {
  return type.lastIndexOf("]") === type.length - 1;
}
function rawEncode(types2, values) {
  var output = [];
  var data = [];
  var headLength = 32 * types2.length;
  for (var i2 in types2) {
    var type = elementaryName(types2[i2]);
    var value2 = values[i2];
    var cur = encodeSingle(type, value2);
    if (isDynamic(type)) {
      output.push(encodeSingle("uint256", headLength));
      data.push(cur);
      headLength += cur.length;
    } else {
      output.push(cur);
    }
  }
  return buffer$2.Buffer.concat(output.concat(data));
}
function solidityPack(types2, values) {
  if (types2.length !== values.length) {
    throw new Error("Number of types are not matching the values");
  }
  var size2, num;
  var ret = [];
  for (var i2 = 0; i2 < types2.length; i2++) {
    var type = elementaryName(types2[i2]);
    var value2 = values[i2];
    if (type === "bytes") {
      ret.push(value2);
    } else if (type === "string") {
      ret.push(new buffer$2.Buffer(value2, "utf8"));
    } else if (type === "bool") {
      ret.push(new buffer$2.Buffer(value2 ? "01" : "00", "hex"));
    } else if (type === "address") {
      ret.push(util$1.setLength(value2, 20));
    } else if (type.startsWith("bytes")) {
      size2 = parseTypeN(type);
      if (size2 < 1 || size2 > 32) {
        throw new Error("Invalid bytes<N> width: " + size2);
      }
      ret.push(util$1.setLengthRight(value2, size2));
    } else if (type.startsWith("uint")) {
      size2 = parseTypeN(type);
      if (size2 % 8 || size2 < 8 || size2 > 256) {
        throw new Error("Invalid uint<N> width: " + size2);
      }
      num = parseNumber(value2);
      if (num.bitLength() > size2) {
        throw new Error("Supplied uint exceeds width: " + size2 + " vs " + num.bitLength());
      }
      ret.push(num.toArrayLike(buffer$2.Buffer, "be", size2 / 8));
    } else if (type.startsWith("int")) {
      size2 = parseTypeN(type);
      if (size2 % 8 || size2 < 8 || size2 > 256) {
        throw new Error("Invalid int<N> width: " + size2);
      }
      num = parseNumber(value2);
      if (num.bitLength() > size2) {
        throw new Error("Supplied int exceeds width: " + size2 + " vs " + num.bitLength());
      }
      ret.push(num.toTwos(size2).toArrayLike(buffer$2.Buffer, "be", size2 / 8));
    } else {
      throw new Error("Unsupported or invalid type: " + type);
    }
  }
  return buffer$2.Buffer.concat(ret);
}
function soliditySHA3(types2, values) {
  return util$1.keccak(solidityPack(types2, values));
}
var abi$2 = {
  rawEncode,
  solidityPack,
  soliditySHA3
};
const util = util$2;
const abi$1 = abi$2;
const TYPED_MESSAGE_SCHEMA = {
  type: "object",
  properties: {
    types: {
      type: "object",
      additionalProperties: {
        type: "array",
        items: {
          type: "object",
          properties: {
            name: { type: "string" },
            type: { type: "string" }
          },
          required: ["name", "type"]
        }
      }
    },
    primaryType: { type: "string" },
    domain: { type: "object" },
    message: { type: "object" }
  },
  required: ["types", "primaryType", "domain", "message"]
};
const TypedDataUtils = {
  encodeData(primaryType, data, types2, useV4 = true) {
    const encodedTypes = ["bytes32"];
    const encodedValues = [this.hashType(primaryType, types2)];
    if (useV4) {
      const encodeField = (name2, type, value2) => {
        if (types2[type] !== void 0) {
          return ["bytes32", value2 == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : util.keccak(this.encodeData(type, value2, types2, useV4))];
        }
        if (value2 === void 0)
          throw new Error(`missing value for field ${name2} of type ${type}`);
        if (type === "bytes") {
          return ["bytes32", util.keccak(value2)];
        }
        if (type === "string") {
          if (typeof value2 === "string") {
            value2 = buffer$2.Buffer.from(value2, "utf8");
          }
          return ["bytes32", util.keccak(value2)];
        }
        if (type.lastIndexOf("]") === type.length - 1) {
          const parsedType = type.slice(0, type.lastIndexOf("["));
          const typeValuePairs = value2.map((item) => encodeField(name2, parsedType, item));
          return ["bytes32", util.keccak(abi$1.rawEncode(typeValuePairs.map(([type2]) => type2), typeValuePairs.map(([, value3]) => value3)))];
        }
        return [type, value2];
      };
      for (const field of types2[primaryType]) {
        const [type, value2] = encodeField(field.name, field.type, data[field.name]);
        encodedTypes.push(type);
        encodedValues.push(value2);
      }
    } else {
      for (const field of types2[primaryType]) {
        let value2 = data[field.name];
        if (value2 !== void 0) {
          if (field.type === "bytes") {
            encodedTypes.push("bytes32");
            value2 = util.keccak(value2);
            encodedValues.push(value2);
          } else if (field.type === "string") {
            encodedTypes.push("bytes32");
            if (typeof value2 === "string") {
              value2 = buffer$2.Buffer.from(value2, "utf8");
            }
            value2 = util.keccak(value2);
            encodedValues.push(value2);
          } else if (types2[field.type] !== void 0) {
            encodedTypes.push("bytes32");
            value2 = util.keccak(this.encodeData(field.type, value2, types2, useV4));
            encodedValues.push(value2);
          } else if (field.type.lastIndexOf("]") === field.type.length - 1) {
            throw new Error("Arrays currently unimplemented in encodeData");
          } else {
            encodedTypes.push(field.type);
            encodedValues.push(value2);
          }
        }
      }
    }
    return abi$1.rawEncode(encodedTypes, encodedValues);
  },
  encodeType(primaryType, types2) {
    let result = "";
    let deps = this.findTypeDependencies(primaryType, types2).filter((dep) => dep !== primaryType);
    deps = [primaryType].concat(deps.sort());
    for (const type of deps) {
      const children = types2[type];
      if (!children) {
        throw new Error("No type definition specified: " + type);
      }
      result += type + "(" + types2[type].map(({ name: name2, type: type2 }) => type2 + " " + name2).join(",") + ")";
    }
    return result;
  },
  findTypeDependencies(primaryType, types2, results2 = []) {
    primaryType = primaryType.match(/^\w*/)[0];
    if (results2.includes(primaryType) || types2[primaryType] === void 0) {
      return results2;
    }
    results2.push(primaryType);
    for (const field of types2[primaryType]) {
      for (const dep of this.findTypeDependencies(field.type, types2, results2)) {
        !results2.includes(dep) && results2.push(dep);
      }
    }
    return results2;
  },
  hashStruct(primaryType, data, types2, useV4 = true) {
    return util.keccak(this.encodeData(primaryType, data, types2, useV4));
  },
  hashType(primaryType, types2) {
    return util.keccak(this.encodeType(primaryType, types2));
  },
  sanitizeData(data) {
    const sanitizedData = {};
    for (const key2 in TYPED_MESSAGE_SCHEMA.properties) {
      data[key2] && (sanitizedData[key2] = data[key2]);
    }
    if (sanitizedData.types) {
      sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
    }
    return sanitizedData;
  },
  hash(typedData, useV4 = true) {
    const sanitizedData = this.sanitizeData(typedData);
    const parts = [buffer$2.Buffer.from("1901", "hex")];
    parts.push(this.hashStruct("EIP712Domain", sanitizedData.domain, sanitizedData.types, useV4));
    if (sanitizedData.primaryType !== "EIP712Domain") {
      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
    }
    return util.keccak(buffer$2.Buffer.concat(parts));
  }
};
var ethEip712Util = {
  TYPED_MESSAGE_SCHEMA,
  TypedDataUtils,
  hashForSignTypedDataLegacy: function(msgParams) {
    return typedSignatureHashLegacy(msgParams.data);
  },
  hashForSignTypedData_v3: function(msgParams) {
    return TypedDataUtils.hash(msgParams.data, false);
  },
  hashForSignTypedData_v4: function(msgParams) {
    return TypedDataUtils.hash(msgParams.data);
  }
};
function typedSignatureHashLegacy(typedData) {
  const error2 = new Error("Expect argument to be non-empty array");
  if (typeof typedData !== "object" || !typedData.length)
    throw error2;
  const data = typedData.map(function(e2) {
    return e2.type === "bytes" ? util.toBuffer(e2.value) : e2.value;
  });
  const types2 = typedData.map(function(e2) {
    return e2.type;
  });
  const schema = typedData.map(function(e2) {
    if (!e2.name)
      throw error2;
    return e2.type + " " + e2.name;
  });
  return abi$1.soliditySHA3(["bytes32", "bytes32"], [
    abi$1.soliditySHA3(new Array(typedData.length).fill("string"), schema),
    abi$1.soliditySHA3(types2, data)
  ]);
}
var FilterPolyfill$1 = {};
Object.defineProperty(FilterPolyfill$1, "__esModule", { value: true });
FilterPolyfill$1.filterFromParam = FilterPolyfill$1.FilterPolyfill = void 0;
const types_1$1 = types$1;
const util_1$5 = util$3;
const TIMEOUT = 5 * 60 * 1e3;
const JSONRPC_TEMPLATE = {
  jsonrpc: "2.0",
  id: 0
};
class FilterPolyfill {
  constructor(provider) {
    this.logFilters = new Map();
    this.blockFilters = new Set();
    this.pendingTransactionFilters = new Set();
    this.cursors = new Map();
    this.timeouts = new Map();
    this.nextFilterId = (0, types_1$1.IntNumber)(1);
    this.provider = provider;
  }
  async newFilter(param) {
    const filter2 = filterFromParam(param);
    const id2 = this.makeFilterId();
    const cursor = await this.setInitialCursorPosition(id2, filter2.fromBlock);
    console.log(`Installing new log filter(${id2}):`, filter2, "initial cursor position:", cursor);
    this.logFilters.set(id2, filter2);
    this.setFilterTimeout(id2);
    return (0, util_1$5.hexStringFromIntNumber)(id2);
  }
  async newBlockFilter() {
    const id2 = this.makeFilterId();
    const cursor = await this.setInitialCursorPosition(id2, "latest");
    console.log(`Installing new block filter (${id2}) with initial cursor position:`, cursor);
    this.blockFilters.add(id2);
    this.setFilterTimeout(id2);
    return (0, util_1$5.hexStringFromIntNumber)(id2);
  }
  async newPendingTransactionFilter() {
    const id2 = this.makeFilterId();
    const cursor = await this.setInitialCursorPosition(id2, "latest");
    console.log(`Installing new block filter (${id2}) with initial cursor position:`, cursor);
    this.pendingTransactionFilters.add(id2);
    this.setFilterTimeout(id2);
    return (0, util_1$5.hexStringFromIntNumber)(id2);
  }
  uninstallFilter(filterId) {
    const id2 = (0, util_1$5.intNumberFromHexString)(filterId);
    console.log(`Uninstalling filter (${id2})`);
    this.deleteFilter(id2);
    return true;
  }
  getFilterChanges(filterId) {
    const id2 = (0, util_1$5.intNumberFromHexString)(filterId);
    if (this.timeouts.has(id2)) {
      this.setFilterTimeout(id2);
    }
    if (this.logFilters.has(id2)) {
      return this.getLogFilterChanges(id2);
    } else if (this.blockFilters.has(id2)) {
      return this.getBlockFilterChanges(id2);
    } else if (this.pendingTransactionFilters.has(id2)) {
      return this.getPendingTransactionFilterChanges(id2);
    }
    return Promise.resolve(filterNotFoundError());
  }
  async getFilterLogs(filterId) {
    const id2 = (0, util_1$5.intNumberFromHexString)(filterId);
    const filter2 = this.logFilters.get(id2);
    if (!filter2) {
      return filterNotFoundError();
    }
    return this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [paramFromFilter(filter2)] }));
  }
  makeFilterId() {
    return (0, types_1$1.IntNumber)(++this.nextFilterId);
  }
  sendAsyncPromise(request) {
    return new Promise((resolve2, reject) => {
      this.provider.sendAsync(request, (err, response) => {
        if (err) {
          return reject(err);
        }
        if (Array.isArray(response) || response == null) {
          return reject(new Error(`unexpected response received: ${JSON.stringify(response)}`));
        }
        resolve2(response);
      });
    });
  }
  deleteFilter(id2) {
    console.log(`Deleting filter (${id2})`);
    this.logFilters.delete(id2);
    this.blockFilters.delete(id2);
    this.pendingTransactionFilters.delete(id2);
    this.cursors.delete(id2);
    this.timeouts.delete(id2);
  }
  async getLogFilterChanges(id2) {
    const filter2 = this.logFilters.get(id2);
    const cursorPosition = this.cursors.get(id2);
    if (!cursorPosition || !filter2) {
      return filterNotFoundError();
    }
    const currentBlockHeight = await this.getCurrentBlockHeight();
    const toBlock = filter2.toBlock === "latest" ? currentBlockHeight : filter2.toBlock;
    if (cursorPosition > currentBlockHeight) {
      return emptyResult();
    }
    if (cursorPosition > filter2.toBlock) {
      return emptyResult();
    }
    console.log(`Fetching logs from ${cursorPosition} to ${toBlock} for filter ${id2}`);
    const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getLogs", params: [
      paramFromFilter(Object.assign(Object.assign({}, filter2), { fromBlock: cursorPosition, toBlock }))
    ] }));
    if (Array.isArray(response.result)) {
      const blocks2 = response.result.map((log2) => (0, util_1$5.intNumberFromHexString)(log2.blockNumber || "0x0"));
      const highestBlock = Math.max(...blocks2);
      if (highestBlock && highestBlock > cursorPosition) {
        const newCursorPosition = (0, types_1$1.IntNumber)(highestBlock + 1);
        console.log(`Moving cursor position for filter (${id2}) from ${cursorPosition} to ${newCursorPosition}`);
        this.cursors.set(id2, newCursorPosition);
      }
    }
    return response;
  }
  async getBlockFilterChanges(id2) {
    const cursorPosition = this.cursors.get(id2);
    if (!cursorPosition) {
      return filterNotFoundError();
    }
    const currentBlockHeight = await this.getCurrentBlockHeight();
    if (cursorPosition > currentBlockHeight) {
      return emptyResult();
    }
    console.log(`Fetching blocks from ${cursorPosition} to ${currentBlockHeight} for filter (${id2})`);
    const blocks2 = (await Promise.all((0, util_1$5.range)(cursorPosition, currentBlockHeight + 1).map((i2) => this.getBlockHashByNumber((0, types_1$1.IntNumber)(i2))))).filter((hash3) => !!hash3);
    const newCursorPosition = (0, types_1$1.IntNumber)(cursorPosition + blocks2.length);
    console.log(`Moving cursor position for filter (${id2}) from ${cursorPosition} to ${newCursorPosition}`);
    this.cursors.set(id2, newCursorPosition);
    return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: blocks2 });
  }
  async getPendingTransactionFilterChanges(_id) {
    return Promise.resolve(emptyResult());
  }
  async setInitialCursorPosition(id2, startBlock) {
    const currentBlockHeight = await this.getCurrentBlockHeight();
    const initialCursorPosition = typeof startBlock === "number" && startBlock > currentBlockHeight ? startBlock : currentBlockHeight;
    this.cursors.set(id2, initialCursorPosition);
    return initialCursorPosition;
  }
  setFilterTimeout(id2) {
    const existing = this.timeouts.get(id2);
    if (existing) {
      window.clearTimeout(existing);
    }
    const timeout2 = window.setTimeout(() => {
      console.log(`Filter (${id2}) timed out`);
      this.deleteFilter(id2);
    }, TIMEOUT);
    this.timeouts.set(id2, timeout2);
  }
  async getCurrentBlockHeight() {
    const { result } = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_blockNumber", params: [] }));
    return (0, util_1$5.intNumberFromHexString)((0, util_1$5.ensureHexString)(result));
  }
  async getBlockHashByNumber(blockNumber) {
    const response = await this.sendAsyncPromise(Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { method: "eth_getBlockByNumber", params: [(0, util_1$5.hexStringFromIntNumber)(blockNumber), false] }));
    if (response.result && typeof response.result.hash === "string") {
      return (0, util_1$5.ensureHexString)(response.result.hash);
    }
    return null;
  }
}
FilterPolyfill$1.FilterPolyfill = FilterPolyfill;
function filterFromParam(param) {
  return {
    fromBlock: intBlockHeightFromHexBlockHeight(param.fromBlock),
    toBlock: intBlockHeightFromHexBlockHeight(param.toBlock),
    addresses: param.address === void 0 ? null : Array.isArray(param.address) ? param.address : [param.address],
    topics: param.topics || []
  };
}
FilterPolyfill$1.filterFromParam = filterFromParam;
function paramFromFilter(filter2) {
  const param = {
    fromBlock: hexBlockHeightFromIntBlockHeight(filter2.fromBlock),
    toBlock: hexBlockHeightFromIntBlockHeight(filter2.toBlock),
    topics: filter2.topics
  };
  if (filter2.addresses !== null) {
    param.address = filter2.addresses;
  }
  return param;
}
function intBlockHeightFromHexBlockHeight(value2) {
  if (value2 === void 0 || value2 === "latest" || value2 === "pending") {
    return "latest";
  } else if (value2 === "earliest") {
    return (0, types_1$1.IntNumber)(0);
  } else if ((0, util_1$5.isHexString)(value2)) {
    return (0, util_1$5.intNumberFromHexString)(value2);
  }
  throw new Error(`Invalid block option: ${String(value2)}`);
}
function hexBlockHeightFromIntBlockHeight(value2) {
  if (value2 === "latest") {
    return value2;
  }
  return (0, util_1$5.hexStringFromIntNumber)(value2);
}
function filterNotFoundError() {
  return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { error: { code: -32e3, message: "filter not found" } });
}
function emptyResult() {
  return Object.assign(Object.assign({}, JSONRPC_TEMPLATE), { result: [] });
}
var JSONRPC = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.JSONRPCMethod = void 0;
  (function(JSONRPCMethod) {
    JSONRPCMethod["eth_accounts"] = "eth_accounts";
    JSONRPCMethod["eth_coinbase"] = "eth_coinbase";
    JSONRPCMethod["net_version"] = "net_version";
    JSONRPCMethod["eth_chainId"] = "eth_chainId";
    JSONRPCMethod["eth_uninstallFilter"] = "eth_uninstallFilter";
    JSONRPCMethod["eth_requestAccounts"] = "eth_requestAccounts";
    JSONRPCMethod["eth_sign"] = "eth_sign";
    JSONRPCMethod["eth_ecRecover"] = "eth_ecRecover";
    JSONRPCMethod["personal_sign"] = "personal_sign";
    JSONRPCMethod["personal_ecRecover"] = "personal_ecRecover";
    JSONRPCMethod["eth_signTransaction"] = "eth_signTransaction";
    JSONRPCMethod["eth_sendRawTransaction"] = "eth_sendRawTransaction";
    JSONRPCMethod["eth_sendTransaction"] = "eth_sendTransaction";
    JSONRPCMethod["eth_signTypedData_v1"] = "eth_signTypedData_v1";
    JSONRPCMethod["eth_signTypedData_v2"] = "eth_signTypedData_v2";
    JSONRPCMethod["eth_signTypedData_v3"] = "eth_signTypedData_v3";
    JSONRPCMethod["eth_signTypedData_v4"] = "eth_signTypedData_v4";
    JSONRPCMethod["eth_signTypedData"] = "eth_signTypedData";
    JSONRPCMethod["walletlink_arbitrary"] = "walletlink_arbitrary";
    JSONRPCMethod["wallet_addEthereumChain"] = "wallet_addEthereumChain";
    JSONRPCMethod["wallet_switchEthereumChain"] = "wallet_switchEthereumChain";
    JSONRPCMethod["eth_subscribe"] = "eth_subscribe";
    JSONRPCMethod["eth_unsubscribe"] = "eth_unsubscribe";
    JSONRPCMethod["eth_newFilter"] = "eth_newFilter";
    JSONRPCMethod["eth_newBlockFilter"] = "eth_newBlockFilter";
    JSONRPCMethod["eth_newPendingTransactionFilter"] = "eth_newPendingTransactionFilter";
    JSONRPCMethod["eth_getFilterChanges"] = "eth_getFilterChanges";
    JSONRPCMethod["eth_getFilterLogs"] = "eth_getFilterLogs";
  })(exports2.JSONRPCMethod || (exports2.JSONRPCMethod = {}));
})(JSONRPC);
var SubscriptionManager$1 = {};
Object.defineProperty(SubscriptionManager$1, "__esModule", { value: true });
SubscriptionManager$1.SubscriptionManager = void 0;
const PollingBlockTracker = polling;
const createSubscriptionManager = subscriptionManager;
const noop$1 = () => {
};
class SubscriptionManager {
  constructor(provider) {
    const blockTracker = new PollingBlockTracker({
      provider,
      pollingInterval: 15 * 1e3,
      setSkipCacheFlag: true
    });
    const { events: events2, middleware } = createSubscriptionManager({
      blockTracker,
      provider
    });
    this.events = events2;
    this.subscriptionMiddleware = middleware;
  }
  async handleRequest(request) {
    const result = {};
    await this.subscriptionMiddleware(request, result, noop$1, noop$1);
    return result;
  }
  destroy() {
    this.subscriptionMiddleware.destroy();
  }
}
SubscriptionManager$1.SubscriptionManager = SubscriptionManager;
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(WalletLinkProvider$1, "__esModule", { value: true });
WalletLinkProvider$1.WalletLinkProvider = void 0;
const safe_event_emitter_1 = __importDefault$7(safeEventEmitter);
const bn_js_1 = __importDefault$7(bn$1.exports);
const eth_rpc_errors_1$1 = dist$3;
const WalletLinkAnalytics_1$2 = WalletLinkAnalytics$1;
const EthereumChain_1 = EthereumChain;
const init_1$2 = init;
const Session_1$2 = Session$1;
const WalletLinkRelayAbstract_1$1 = WalletLinkRelayAbstract$1;
const util_1$4 = util$3;
const eth_eip712_util_1 = __importDefault$7(ethEip712Util);
const FilterPolyfill_1 = FilterPolyfill$1;
const JSONRPC_1 = JSONRPC;
const SubscriptionManager_1 = SubscriptionManager$1;
const DEFAULT_CHAIN_ID_KEY = "DefaultChainId";
const DEFAULT_JSON_RPC_URL = "DefaultJsonRpcUrl";
const HAS_CHAIN_BEEN_SWITCHED_KEY = "HasChainBeenSwitched";
const HAS_CHAIN_OVERRIDDEN_FROM_RELAY = "HasChainOverriddenFromRelay";
class WalletLinkProvider extends safe_event_emitter_1.default {
  constructor(options) {
    var _a2;
    super();
    this._filterPolyfill = new FilterPolyfill_1.FilterPolyfill(this);
    this._subscriptionManager = new SubscriptionManager_1.SubscriptionManager(this);
    this._relay = null;
    this._addresses = [];
    this.hasMadeFirstChainChangedEmission = false;
    this._send = this.send.bind(this);
    this._sendAsync = this.sendAsync.bind(this);
    this.setProviderInfo = this.setProviderInfo.bind(this);
    this.updateProviderInfo = this.updateProviderInfo.bind(this);
    this.getChainId = this.getChainId.bind(this);
    this.setAppInfo = this.setAppInfo.bind(this);
    this.enable = this.enable.bind(this);
    this.close = this.close.bind(this);
    this.send = this.send.bind(this);
    this.sendAsync = this.sendAsync.bind(this);
    this.request = this.request.bind(this);
    this._setAddresses = this._setAddresses.bind(this);
    this.scanQRCode = this.scanQRCode.bind(this);
    this.genericRequest = this.genericRequest.bind(this);
    this._jsonRpcUrlFromOpts = options.jsonRpcUrl;
    this._overrideIsMetaMask = options.overrideIsMetaMask;
    this._relayProvider = options.relayProvider;
    this._storage = options.storage;
    this._relayEventManager = options.relayEventManager;
    this._walletLinkAnalytics = options.walletLinkAnalytics ? options.walletLinkAnalytics : new WalletLinkAnalytics_1$2.WalletLinkAnalytics();
    this.isCoinbaseWallet = (_a2 = options.overrideIsCoinbaseWallet) !== null && _a2 !== void 0 ? _a2 : true;
    const chainId = this.getChainId();
    const chainIdStr = (0, util_1$4.prepend0x)(chainId.toString(16));
    this.emit("connect", { chainIdStr });
    const cachedAddresses = this._storage.getItem(WalletLinkRelayAbstract_1$1.LOCAL_STORAGE_ADDRESSES_KEY);
    if (cachedAddresses) {
      const addresses = cachedAddresses.split(" ");
      if (addresses[0] !== "") {
        this._addresses = addresses;
        this.emit("accountsChanged", addresses);
      }
    }
    this._subscriptionManager.events.on("notification", (notification) => {
      this.emit("message", {
        type: notification.method,
        data: notification.params
      });
    });
    if (this._addresses.length > 0) {
      void this.initializeRelay();
    }
    window.addEventListener("message", (event) => {
      var _a3;
      if (event.data.type !== "walletLinkMessage")
        return;
      if (event.data.data.action === "defaultChainChanged") {
        const _chainId = event.data.data.chainId;
        const jsonRpcUrl = (_a3 = event.data.data.jsonRpcUrl) !== null && _a3 !== void 0 ? _a3 : this.jsonRpcUrl;
        this.updateProviderInfo(jsonRpcUrl, Number(_chainId), true);
      }
    });
  }
  get selectedAddress() {
    return this._addresses[0] || void 0;
  }
  get networkVersion() {
    return this.getChainId().toString(10);
  }
  get chainId() {
    return (0, util_1$4.prepend0x)(this.getChainId().toString(16));
  }
  get isWalletLink() {
    return true;
  }
  get isMetaMask() {
    return this._overrideIsMetaMask;
  }
  get host() {
    return this.jsonRpcUrl;
  }
  get connected() {
    return true;
  }
  isConnected() {
    return true;
  }
  get jsonRpcUrl() {
    var _a2;
    return (_a2 = this._storage.getItem(DEFAULT_JSON_RPC_URL)) !== null && _a2 !== void 0 ? _a2 : this._jsonRpcUrlFromOpts;
  }
  set jsonRpcUrl(value2) {
    this._storage.setItem(DEFAULT_JSON_RPC_URL, value2);
  }
  get isChainOverridden() {
    return this._storage.getItem(HAS_CHAIN_OVERRIDDEN_FROM_RELAY) === "true";
  }
  set isChainOverridden(value2) {
    this._storage.setItem(HAS_CHAIN_OVERRIDDEN_FROM_RELAY, value2.toString());
  }
  setProviderInfo(jsonRpcUrl, chainId) {
    if (this.isChainOverridden)
      return;
    this.updateProviderInfo(jsonRpcUrl, this.getChainId(), false);
  }
  updateProviderInfo(jsonRpcUrl, chainId, fromRelay) {
    const hasChainSwitched = this._storage.getItem(HAS_CHAIN_BEEN_SWITCHED_KEY) === "true";
    if (hasChainSwitched && fromRelay)
      return;
    if (fromRelay) {
      this.isChainOverridden = true;
    }
    this.jsonRpcUrl = jsonRpcUrl;
    const originalChainId = this.getChainId();
    this._storage.setItem(DEFAULT_CHAIN_ID_KEY, chainId.toString(10));
    const chainChanged = (0, util_1$4.ensureIntNumber)(chainId) !== originalChainId;
    if (chainChanged || !this.hasMadeFirstChainChangedEmission) {
      this.emit("chainChanged", this.getChainId());
      this.hasMadeFirstChainChangedEmission = true;
    }
  }
  async addEthereumChain(chainId, rpcUrls, blockExplorerUrls, chainName, iconUrls, nativeCurrency) {
    var _a2, _b2;
    const relay = await this.initializeRelay();
    const res = await relay.addEthereumChain(chainId.toString(), rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency).promise;
    if (typeof res.result === "boolean") {
      if (res.result === true) {
        this._storage.setItem(HAS_CHAIN_BEEN_SWITCHED_KEY, "true");
        this.updateProviderInfo(rpcUrls[0], chainId, false);
      }
      return res.result === true;
    }
    if (((_a2 = res.result) === null || _a2 === void 0 ? void 0 : _a2.isApproved) === true) {
      this._storage.setItem(HAS_CHAIN_BEEN_SWITCHED_KEY, "true");
      this.updateProviderInfo(rpcUrls[0], chainId, false);
    }
    return ((_b2 = res.result) === null || _b2 === void 0 ? void 0 : _b2.isApproved) === true;
  }
  async switchEthereumChain(chainId) {
    var _a2;
    if ((0, util_1$4.ensureIntNumber)(chainId) === this.getChainId()) {
      return;
    }
    const relay = await this.initializeRelay();
    const res = await relay.switchEthereumChain(chainId.toString(10)).promise;
    if (res.errorCode) {
      throw eth_rpc_errors_1$1.ethErrors.provider.custom({
        code: res.errorCode
      });
    }
    if (typeof res.result !== "boolean") {
      const switchResponse = res.result;
      if (switchResponse.isApproved && switchResponse.rpcUrl.length > 0) {
        this._storage.setItem(HAS_CHAIN_BEEN_SWITCHED_KEY, "true");
        this.updateProviderInfo(switchResponse.rpcUrl, chainId, false);
      }
    } else {
      if (res.result) {
        this._storage.setItem(HAS_CHAIN_BEEN_SWITCHED_KEY, "true");
        const ethereumChain = EthereumChain_1.EthereumChain.fromChainId(BigInt(chainId));
        const rpcUrl = (_a2 = EthereumChain_1.EthereumChain.rpcUrl(ethereumChain)) !== null && _a2 !== void 0 ? _a2 : "";
        this.updateProviderInfo(rpcUrl, chainId, false);
      }
    }
  }
  setAppInfo(appName, appLogoUrl) {
    void this.initializeRelay().then((relay) => relay.setAppInfo(appName, appLogoUrl));
  }
  async enable() {
    this._walletLinkAnalytics.sendEvent(init_1$2.EVENTS.ETH_ACCOUNTS_STATE, {
      method: "provider::enable",
      addresses_length: this._addresses.length,
      sessionIdHash: this._relay ? Session_1$2.Session.hash(this._relay.session.id) : null
    });
    if (this._addresses.length > 0) {
      return this._addresses;
    }
    return await this._send(JSONRPC_1.JSONRPCMethod.eth_requestAccounts);
  }
  close() {
    void this.initializeRelay().then((relay) => relay.resetAndReload());
  }
  send(requestOrMethod, callbackOrParams) {
    if (typeof requestOrMethod === "string") {
      const method2 = requestOrMethod;
      const params = Array.isArray(callbackOrParams) ? callbackOrParams : callbackOrParams !== void 0 ? [callbackOrParams] : [];
      const request = {
        jsonrpc: "2.0",
        id: 0,
        method: method2,
        params
      };
      return this._sendRequestAsync(request).then((res) => res.result);
    }
    if (typeof callbackOrParams === "function") {
      const request = requestOrMethod;
      const callback = callbackOrParams;
      return this._sendAsync(request, callback);
    }
    if (Array.isArray(requestOrMethod)) {
      const requests = requestOrMethod;
      return requests.map((r2) => this._sendRequest(r2));
    }
    const req = requestOrMethod;
    return this._sendRequest(req);
  }
  sendAsync(request, callback) {
    if (typeof callback !== "function") {
      throw new Error("callback is required");
    }
    if (Array.isArray(request)) {
      const arrayCb = callback;
      this._sendMultipleRequestsAsync(request).then((responses) => arrayCb(null, responses)).catch((err) => arrayCb(err, null));
      return;
    }
    const cb = callback;
    this._sendRequestAsync(request).then((response) => cb(null, response)).catch((err) => cb(err, null));
  }
  async request(args) {
    if (!args || typeof args !== "object" || Array.isArray(args)) {
      throw eth_rpc_errors_1$1.ethErrors.rpc.invalidRequest({
        message: "Expected a single, non-array, object argument.",
        data: args
      });
    }
    const { method: method2, params } = args;
    if (typeof method2 !== "string" || method2.length === 0) {
      throw eth_rpc_errors_1$1.ethErrors.rpc.invalidRequest({
        message: "'args.method' must be a non-empty string.",
        data: args
      });
    }
    if (params !== void 0 && !Array.isArray(params) && (typeof params !== "object" || params === null)) {
      throw eth_rpc_errors_1$1.ethErrors.rpc.invalidRequest({
        message: "'args.params' must be an object or array if provided.",
        data: args
      });
    }
    const newParams = params === void 0 ? [] : params;
    const id2 = this._relayEventManager.makeRequestId();
    const result = await this._sendRequestAsync({
      method: method2,
      params: newParams,
      jsonrpc: "2.0",
      id: id2
    });
    return result.result;
  }
  async scanQRCode(match) {
    const relay = await this.initializeRelay();
    const res = await relay.scanQRCode((0, util_1$4.ensureRegExpString)(match)).promise;
    if (typeof res.result !== "string") {
      throw new Error("result was not a string");
    }
    return res.result;
  }
  async genericRequest(data, action) {
    const relay = await this.initializeRelay();
    const res = await relay.genericRequest(data, action).promise;
    if (typeof res.result !== "string") {
      throw new Error("result was not a string");
    }
    return res.result;
  }
  supportsSubscriptions() {
    return false;
  }
  subscribe() {
    throw new Error("Subscriptions are not supported");
  }
  unsubscribe() {
    throw new Error("Subscriptions are not supported");
  }
  disconnect() {
    return true;
  }
  _sendRequest(request) {
    const response = {
      jsonrpc: "2.0",
      id: request.id
    };
    const { method: method2 } = request;
    response.result = this._handleSynchronousMethods(request);
    if (response.result === void 0) {
      throw new Error(`WalletLink does not support calling ${method2} synchronously without a callback. Please provide a callback parameter to call ${method2} asynchronously.`);
    }
    return response;
  }
  _setAddresses(addresses) {
    if (!Array.isArray(addresses)) {
      throw new Error("addresses is not an array");
    }
    const newAddresses = addresses.map((address) => (0, util_1$4.ensureAddressString)(address));
    if (JSON.stringify(newAddresses) === JSON.stringify(this._addresses)) {
      return;
    }
    this._addresses = newAddresses;
    this.emit("accountsChanged", this._addresses);
    this._storage.setItem(WalletLinkRelayAbstract_1$1.LOCAL_STORAGE_ADDRESSES_KEY, newAddresses.join(" "));
    window.dispatchEvent(new CustomEvent("walletlink:addresses", { detail: this._addresses }));
  }
  _sendRequestAsync(request) {
    return new Promise((resolve2, reject) => {
      try {
        const syncResult = this._handleSynchronousMethods(request);
        if (syncResult !== void 0) {
          return resolve2({
            jsonrpc: "2.0",
            id: request.id,
            result: syncResult
          });
        }
        const filterPromise = this._handleAsynchronousFilterMethods(request);
        if (filterPromise !== void 0) {
          filterPromise.then((res) => resolve2(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
          return;
        }
        const subscriptionPromise = this._handleSubscriptionMethods(request);
        if (subscriptionPromise !== void 0) {
          subscriptionPromise.then((res) => resolve2({
            jsonrpc: "2.0",
            id: request.id,
            result: res.result
          })).catch((err) => reject(err));
          return;
        }
      } catch (err) {
        return reject(err);
      }
      this._handleAsynchronousMethods(request).then((res) => res && resolve2(Object.assign(Object.assign({}, res), { id: request.id }))).catch((err) => reject(err));
    });
  }
  _sendMultipleRequestsAsync(requests) {
    return Promise.all(requests.map((r2) => this._sendRequestAsync(r2)));
  }
  _handleSynchronousMethods(request) {
    const { method: method2 } = request;
    const params = request.params || [];
    switch (method2) {
      case JSONRPC_1.JSONRPCMethod.eth_accounts:
        return this._eth_accounts();
      case JSONRPC_1.JSONRPCMethod.eth_coinbase:
        return this._eth_coinbase();
      case JSONRPC_1.JSONRPCMethod.eth_uninstallFilter:
        return this._eth_uninstallFilter(params);
      case JSONRPC_1.JSONRPCMethod.net_version:
        return this._net_version();
      case JSONRPC_1.JSONRPCMethod.eth_chainId:
        return this._eth_chainId();
      default:
        return void 0;
    }
  }
  async _handleAsynchronousMethods(request) {
    const { method: method2 } = request;
    const params = request.params || [];
    switch (method2) {
      case JSONRPC_1.JSONRPCMethod.eth_requestAccounts:
        return this._eth_requestAccounts();
      case JSONRPC_1.JSONRPCMethod.eth_sign:
        return this._eth_sign(params);
      case JSONRPC_1.JSONRPCMethod.eth_ecRecover:
        return this._eth_ecRecover(params);
      case JSONRPC_1.JSONRPCMethod.personal_sign:
        return this._personal_sign(params);
      case JSONRPC_1.JSONRPCMethod.personal_ecRecover:
        return this._personal_ecRecover(params);
      case JSONRPC_1.JSONRPCMethod.eth_signTransaction:
        return this._eth_signTransaction(params);
      case JSONRPC_1.JSONRPCMethod.eth_sendRawTransaction:
        return this._eth_sendRawTransaction(params);
      case JSONRPC_1.JSONRPCMethod.eth_sendTransaction:
        return this._eth_sendTransaction(params);
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v1:
        return this._eth_signTypedData_v1(params);
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v2:
        return this._throwUnsupportedMethodError();
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v3:
        return this._eth_signTypedData_v3(params);
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData_v4:
      case JSONRPC_1.JSONRPCMethod.eth_signTypedData:
        return this._eth_signTypedData_v4(params);
      case JSONRPC_1.JSONRPCMethod.walletlink_arbitrary:
        return this._walletlink_arbitrary(params);
      case JSONRPC_1.JSONRPCMethod.wallet_addEthereumChain:
        return this._wallet_addEthereumChain(params);
      case JSONRPC_1.JSONRPCMethod.wallet_switchEthereumChain:
        return this._wallet_switchEthereumChain(params);
    }
    const relay = await this.initializeRelay();
    return relay.makeEthereumJSONRPCRequest(request, this.jsonRpcUrl);
  }
  _handleAsynchronousFilterMethods(request) {
    const { method: method2 } = request;
    const params = request.params || [];
    switch (method2) {
      case JSONRPC_1.JSONRPCMethod.eth_newFilter:
        return this._eth_newFilter(params);
      case JSONRPC_1.JSONRPCMethod.eth_newBlockFilter:
        return this._eth_newBlockFilter();
      case JSONRPC_1.JSONRPCMethod.eth_newPendingTransactionFilter:
        return this._eth_newPendingTransactionFilter();
      case JSONRPC_1.JSONRPCMethod.eth_getFilterChanges:
        return this._eth_getFilterChanges(params);
      case JSONRPC_1.JSONRPCMethod.eth_getFilterLogs:
        return this._eth_getFilterLogs(params);
    }
    return void 0;
  }
  _handleSubscriptionMethods(request) {
    switch (request.method) {
      case JSONRPC_1.JSONRPCMethod.eth_subscribe:
      case JSONRPC_1.JSONRPCMethod.eth_unsubscribe:
        return this._subscriptionManager.handleRequest(request);
    }
    return void 0;
  }
  _isKnownAddress(addressString) {
    try {
      const address = (0, util_1$4.ensureAddressString)(addressString);
      return this._addresses.includes(address);
    } catch (_a2) {
    }
    return false;
  }
  _ensureKnownAddress(addressString) {
    if (!this._isKnownAddress(addressString)) {
      throw new Error("Unknown Ethereum address");
    }
  }
  _prepareTransactionParams(tx) {
    const fromAddress = tx.from ? (0, util_1$4.ensureAddressString)(tx.from) : this.selectedAddress;
    if (!fromAddress) {
      throw new Error("Ethereum address is unavailable");
    }
    this._ensureKnownAddress(fromAddress);
    const toAddress = tx.to ? (0, util_1$4.ensureAddressString)(tx.to) : null;
    const weiValue = tx.value != null ? (0, util_1$4.ensureBN)(tx.value) : new bn_js_1.default(0);
    const data = tx.data ? (0, util_1$4.ensureBuffer)(tx.data) : buffer$2.Buffer.alloc(0);
    const nonce = tx.nonce != null ? (0, util_1$4.ensureIntNumber)(tx.nonce) : null;
    const gasPriceInWei = tx.gasPrice != null ? (0, util_1$4.ensureBN)(tx.gasPrice) : null;
    const maxFeePerGas = tx.maxFeePerGas != null ? (0, util_1$4.ensureBN)(tx.maxFeePerGas) : null;
    const maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? (0, util_1$4.ensureBN)(tx.maxPriorityFeePerGas) : null;
    const gasLimit = tx.gas != null ? (0, util_1$4.ensureBN)(tx.gas) : null;
    const chainId = this.getChainId();
    return {
      fromAddress,
      toAddress,
      weiValue,
      data,
      nonce,
      gasPriceInWei,
      maxFeePerGas,
      maxPriorityFeePerGas,
      gasLimit,
      chainId
    };
  }
  _requireAuthorization() {
    if (this._addresses.length === 0) {
      throw eth_rpc_errors_1$1.ethErrors.provider.unauthorized({});
    }
  }
  _throwUnsupportedMethodError() {
    throw eth_rpc_errors_1$1.ethErrors.provider.unsupportedMethod({});
  }
  async _signEthereumMessage(message, address, addPrefix, typedDataJson) {
    this._ensureKnownAddress(address);
    try {
      const relay = await this.initializeRelay();
      const res = await relay.signEthereumMessage(message, address, addPrefix, typedDataJson).promise;
      return { jsonrpc: "2.0", id: 0, result: res.result };
    } catch (err) {
      if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
        throw eth_rpc_errors_1$1.ethErrors.provider.userRejectedRequest("User denied message signature");
      }
      throw err;
    }
  }
  async _ethereumAddressFromSignedMessage(message, signature2, addPrefix) {
    const relay = await this.initializeRelay();
    const res = await relay.ethereumAddressFromSignedMessage(message, signature2, addPrefix).promise;
    return { jsonrpc: "2.0", id: 0, result: res.result };
  }
  _eth_accounts() {
    return this._addresses;
  }
  _eth_coinbase() {
    return this.selectedAddress || null;
  }
  _net_version() {
    return this.getChainId().toString(10);
  }
  _eth_chainId() {
    return (0, util_1$4.hexStringFromIntNumber)(this.getChainId());
  }
  getChainId() {
    const chainIdStr = this._storage.getItem(DEFAULT_CHAIN_ID_KEY) || "1";
    const chainId = parseInt(chainIdStr, 10);
    return (0, util_1$4.ensureIntNumber)(chainId);
  }
  async _eth_requestAccounts() {
    this._walletLinkAnalytics.sendEvent(init_1$2.EVENTS.ETH_ACCOUNTS_STATE, {
      method: "provider::_eth_requestAccounts",
      addresses_length: this._addresses.length,
      sessionIdHash: this._relay ? Session_1$2.Session.hash(this._relay.session.id) : null
    });
    if (this._addresses.length > 0) {
      return Promise.resolve({
        jsonrpc: "2.0",
        id: 0,
        result: this._addresses
      });
    }
    let res;
    try {
      const relay = await this.initializeRelay();
      res = await relay.requestEthereumAccounts().promise;
    } catch (err) {
      if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
        throw eth_rpc_errors_1$1.ethErrors.provider.userRejectedRequest("User denied account authorization");
      }
      throw err;
    }
    if (!res.result) {
      throw new Error("accounts received is empty");
    }
    this._setAddresses(res.result);
    return { jsonrpc: "2.0", id: 0, result: this._addresses };
  }
  _eth_sign(params) {
    this._requireAuthorization();
    const address = (0, util_1$4.ensureAddressString)(params[0]);
    const message = (0, util_1$4.ensureBuffer)(params[1]);
    return this._signEthereumMessage(message, address, false);
  }
  _eth_ecRecover(params) {
    const message = (0, util_1$4.ensureBuffer)(params[0]);
    const signature2 = (0, util_1$4.ensureBuffer)(params[1]);
    return this._ethereumAddressFromSignedMessage(message, signature2, false);
  }
  _personal_sign(params) {
    this._requireAuthorization();
    const message = (0, util_1$4.ensureBuffer)(params[0]);
    const address = (0, util_1$4.ensureAddressString)(params[1]);
    return this._signEthereumMessage(message, address, true);
  }
  _personal_ecRecover(params) {
    const message = (0, util_1$4.ensureBuffer)(params[0]);
    const signature2 = (0, util_1$4.ensureBuffer)(params[1]);
    return this._ethereumAddressFromSignedMessage(message, signature2, true);
  }
  async _eth_signTransaction(params) {
    this._requireAuthorization();
    const tx = this._prepareTransactionParams(params[0] || {});
    try {
      const relay = await this.initializeRelay();
      const res = await relay.signEthereumTransaction(tx).promise;
      return { jsonrpc: "2.0", id: 0, result: res.result };
    } catch (err) {
      if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
        throw eth_rpc_errors_1$1.ethErrors.provider.userRejectedRequest("User denied transaction signature");
      }
      throw err;
    }
  }
  async _eth_sendRawTransaction(params) {
    const signedTransaction = (0, util_1$4.ensureBuffer)(params[0]);
    const relay = await this.initializeRelay();
    const res = await relay.submitEthereumTransaction(signedTransaction, this.getChainId()).promise;
    return { jsonrpc: "2.0", id: 0, result: res.result };
  }
  async _eth_sendTransaction(params) {
    this._requireAuthorization();
    const tx = this._prepareTransactionParams(params[0] || {});
    try {
      const relay = await this.initializeRelay();
      const res = await relay.signAndSubmitEthereumTransaction(tx).promise;
      return { jsonrpc: "2.0", id: 0, result: res.result };
    } catch (err) {
      if (typeof err.message === "string" && err.message.match(/(denied|rejected)/i)) {
        throw eth_rpc_errors_1$1.ethErrors.provider.userRejectedRequest("User denied transaction signature");
      }
      throw err;
    }
  }
  async _eth_signTypedData_v1(params) {
    this._requireAuthorization();
    const typedData = (0, util_1$4.ensureParsedJSONObject)(params[0]);
    const address = (0, util_1$4.ensureAddressString)(params[1]);
    this._ensureKnownAddress(address);
    const message = eth_eip712_util_1.default.hashForSignTypedDataLegacy({ data: typedData });
    const typedDataJSON = JSON.stringify(typedData, null, 2);
    return this._signEthereumMessage(message, address, false, typedDataJSON);
  }
  async _eth_signTypedData_v3(params) {
    this._requireAuthorization();
    const address = (0, util_1$4.ensureAddressString)(params[0]);
    const typedData = (0, util_1$4.ensureParsedJSONObject)(params[1]);
    this._ensureKnownAddress(address);
    const message = eth_eip712_util_1.default.hashForSignTypedData_v3({ data: typedData });
    const typedDataJSON = JSON.stringify(typedData, null, 2);
    return this._signEthereumMessage(message, address, false, typedDataJSON);
  }
  async _eth_signTypedData_v4(params) {
    this._requireAuthorization();
    const address = (0, util_1$4.ensureAddressString)(params[0]);
    const typedData = (0, util_1$4.ensureParsedJSONObject)(params[1]);
    this._ensureKnownAddress(address);
    const message = eth_eip712_util_1.default.hashForSignTypedData_v4({ data: typedData });
    const typedDataJSON = JSON.stringify(typedData, null, 2);
    return this._signEthereumMessage(message, address, false, typedDataJSON);
  }
  async _walletlink_arbitrary(params) {
    const action = params[0];
    const data = params[1];
    if (typeof data !== "string") {
      throw new Error("parameter must be a string");
    }
    if (typeof action !== "object" || action === null) {
      throw new Error("parameter must be an object");
    }
    const result = await this.genericRequest(action, data);
    return { jsonrpc: "2.0", id: 0, result };
  }
  async _wallet_addEthereumChain(params) {
    var _a2, _b2, _c, _d;
    const request = params[0];
    if (((_a2 = request.rpcUrls) === null || _a2 === void 0 ? void 0 : _a2.length) === 0) {
      return {
        jsonrpc: "2.0",
        id: 0,
        error: { code: 2, message: `please pass in at least 1 rpcUrl` }
      };
    }
    if (!request.chainName || request.chainName.trim() === "") {
      throw eth_rpc_errors_1$1.ethErrors.provider.custom({
        code: 0,
        message: "chainName is a required field"
      });
    }
    if (!request.nativeCurrency) {
      throw eth_rpc_errors_1$1.ethErrors.provider.custom({
        code: 0,
        message: "nativeCurrency is a required field"
      });
    }
    const chainIdNumber = parseInt(request.chainId, 16);
    const success = await this.addEthereumChain(chainIdNumber, (_b2 = request.rpcUrls) !== null && _b2 !== void 0 ? _b2 : [], (_c = request.blockExplorerUrls) !== null && _c !== void 0 ? _c : [], request.chainName, (_d = request.iconUrls) !== null && _d !== void 0 ? _d : [], request.nativeCurrency);
    if (success) {
      return { jsonrpc: "2.0", id: 0, result: null };
    } else {
      return {
        jsonrpc: "2.0",
        id: 0,
        error: { code: 2, message: `unable to add ethereum chain` }
      };
    }
  }
  async _wallet_switchEthereumChain(params) {
    const request = params[0];
    await this.switchEthereumChain(parseInt(request.chainId, 16));
    return { jsonrpc: "2.0", id: 0, result: null };
  }
  _eth_uninstallFilter(params) {
    const filterId = (0, util_1$4.ensureHexString)(params[0]);
    return this._filterPolyfill.uninstallFilter(filterId);
  }
  async _eth_newFilter(params) {
    const param = params[0];
    const filterId = await this._filterPolyfill.newFilter(param);
    return { jsonrpc: "2.0", id: 0, result: filterId };
  }
  async _eth_newBlockFilter() {
    const filterId = await this._filterPolyfill.newBlockFilter();
    return { jsonrpc: "2.0", id: 0, result: filterId };
  }
  async _eth_newPendingTransactionFilter() {
    const filterId = await this._filterPolyfill.newPendingTransactionFilter();
    return { jsonrpc: "2.0", id: 0, result: filterId };
  }
  _eth_getFilterChanges(params) {
    const filterId = (0, util_1$4.ensureHexString)(params[0]);
    return this._filterPolyfill.getFilterChanges(filterId);
  }
  _eth_getFilterLogs(params) {
    const filterId = (0, util_1$4.ensureHexString)(params[0]);
    return this._filterPolyfill.getFilterLogs(filterId);
  }
  initializeRelay() {
    if (this._relay) {
      return Promise.resolve(this._relay);
    }
    return this._relayProvider().then((relay) => {
      relay.setAccountsCallback((accounts) => this._setAddresses(accounts));
      relay.setChainCallback((chainId, jsonRpcUrl) => {
        this.updateProviderInfo(jsonRpcUrl, parseInt(chainId, 10), true);
      });
      this._relay = relay;
      return relay;
    });
  }
}
WalletLinkProvider$1.WalletLinkProvider = WalletLinkProvider;
var WalletLink$2 = {};
var ScopedLocalStorage$1 = {};
Object.defineProperty(ScopedLocalStorage$1, "__esModule", { value: true });
ScopedLocalStorage$1.ScopedLocalStorage = void 0;
class ScopedLocalStorage {
  constructor(scope) {
    this.scope = scope;
  }
  setItem(key2, value2) {
    localStorage.setItem(this.scopedKey(key2), value2);
  }
  getItem(key2) {
    return localStorage.getItem(this.scopedKey(key2));
  }
  removeItem(key2) {
    localStorage.removeItem(this.scopedKey(key2));
  }
  clear() {
    const prefix = this.scopedKey("");
    const keysToRemove = [];
    for (let i2 = 0; i2 < localStorage.length; i2++) {
      const key2 = localStorage.key(i2);
      if (typeof key2 === "string" && key2.startsWith(prefix)) {
        keysToRemove.push(key2);
      }
    }
    keysToRemove.forEach((key2) => localStorage.removeItem(key2));
  }
  scopedKey(key2) {
    return `${this.scope}:${key2}`;
  }
}
ScopedLocalStorage$1.ScopedLocalStorage = ScopedLocalStorage;
var WalletLinkSdkUI$1 = {};
var LinkFlow$1 = {};
var n, l$1, u$1, i$2, t$1, r$1, o$1, f$1, e$1 = {}, c$1 = [], s$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function a$1(n2, l2) {
  for (var u2 in l2)
    n2[u2] = l2[u2];
  return n2;
}
function h$1(n2) {
  var l2 = n2.parentNode;
  l2 && l2.removeChild(n2);
}
function v$1(l2, u2, i2) {
  var t2, r2, o2, f2 = {};
  for (o2 in u2)
    o2 == "key" ? t2 = u2[o2] : o2 == "ref" ? r2 = u2[o2] : f2[o2] = u2[o2];
  if (arguments.length > 2 && (f2.children = arguments.length > 3 ? n.call(arguments, 2) : i2), typeof l2 == "function" && l2.defaultProps != null)
    for (o2 in l2.defaultProps)
      f2[o2] === void 0 && (f2[o2] = l2.defaultProps[o2]);
  return y$1(l2, f2, t2, r2, null);
}
function y$1(n2, i2, t2, r2, o2) {
  var f2 = { type: n2, props: i2, key: t2, ref: r2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: o2 == null ? ++u$1 : o2 };
  return o2 == null && l$1.vnode != null && l$1.vnode(f2), f2;
}
function p$1() {
  return { current: null };
}
function d$1(n2) {
  return n2.children;
}
function _$1(n2, l2) {
  this.props = n2, this.context = l2;
}
function k$1(n2, l2) {
  if (l2 == null)
    return n2.__ ? k$1(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u2; l2 < n2.__k.length; l2++)
    if ((u2 = n2.__k[l2]) != null && u2.__e != null)
      return u2.__e;
  return typeof n2.type == "function" ? k$1(n2) : null;
}
function b$1(n2) {
  var l2, u2;
  if ((n2 = n2.__) != null && n2.__c != null) {
    for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++)
      if ((u2 = n2.__k[l2]) != null && u2.__e != null) {
        n2.__e = n2.__c.base = u2.__e;
        break;
      }
    return b$1(n2);
  }
}
function m$1(n2) {
  (!n2.__d && (n2.__d = true) && t$1.push(n2) && !g$1.__r++ || o$1 !== l$1.debounceRendering) && ((o$1 = l$1.debounceRendering) || r$1)(g$1);
}
function g$1() {
  for (var n2; g$1.__r = t$1.length; )
    n2 = t$1.sort(function(n3, l2) {
      return n3.__v.__b - l2.__v.__b;
    }), t$1 = [], n2.some(function(n3) {
      var l2, u2, i2, t2, r2, o2;
      n3.__d && (r2 = (t2 = (l2 = n3).__v).__e, (o2 = l2.__P) && (u2 = [], (i2 = a$1({}, t2)).__v = t2.__v + 1, j$1(o2, t2, i2, l2.__n, o2.ownerSVGElement !== void 0, t2.__h != null ? [r2] : null, u2, r2 == null ? k$1(t2) : r2, t2.__h), z$1(u2, t2), t2.__e != r2 && b$1(t2)));
    });
}
function w$1(n2, l2, u2, i2, t2, r2, o2, f2, s2, a2) {
  var h2, v2, p2, _2, b2, m2, g2, w2 = i2 && i2.__k || c$1, A2 = w2.length;
  for (u2.__k = [], h2 = 0; h2 < l2.length; h2++)
    if ((_2 = u2.__k[h2] = (_2 = l2[h2]) == null || typeof _2 == "boolean" ? null : typeof _2 == "string" || typeof _2 == "number" || typeof _2 == "bigint" ? y$1(null, _2, null, null, _2) : Array.isArray(_2) ? y$1(d$1, { children: _2 }, null, null, null) : _2.__b > 0 ? y$1(_2.type, _2.props, _2.key, null, _2.__v) : _2) != null) {
      if (_2.__ = u2, _2.__b = u2.__b + 1, (p2 = w2[h2]) === null || p2 && _2.key == p2.key && _2.type === p2.type)
        w2[h2] = void 0;
      else
        for (v2 = 0; v2 < A2; v2++) {
          if ((p2 = w2[v2]) && _2.key == p2.key && _2.type === p2.type) {
            w2[v2] = void 0;
            break;
          }
          p2 = null;
        }
      j$1(n2, _2, p2 = p2 || e$1, t2, r2, o2, f2, s2, a2), b2 = _2.__e, (v2 = _2.ref) && p2.ref != v2 && (g2 || (g2 = []), p2.ref && g2.push(p2.ref, null, _2), g2.push(v2, _2.__c || b2, _2)), b2 != null ? (m2 == null && (m2 = b2), typeof _2.type == "function" && _2.__k === p2.__k ? _2.__d = s2 = x$2(_2, s2, n2) : s2 = P(n2, _2, p2, w2, b2, s2), typeof u2.type == "function" && (u2.__d = s2)) : s2 && p2.__e == s2 && s2.parentNode != n2 && (s2 = k$1(p2));
    }
  for (u2.__e = m2, h2 = A2; h2--; )
    w2[h2] != null && (typeof u2.type == "function" && w2[h2].__e != null && w2[h2].__e == u2.__d && (u2.__d = k$1(i2, h2 + 1)), N(w2[h2], w2[h2]));
  if (g2)
    for (h2 = 0; h2 < g2.length; h2++)
      M(g2[h2], g2[++h2], g2[++h2]);
}
function x$2(n2, l2, u2) {
  for (var i2, t2 = n2.__k, r2 = 0; t2 && r2 < t2.length; r2++)
    (i2 = t2[r2]) && (i2.__ = n2, l2 = typeof i2.type == "function" ? x$2(i2, l2, u2) : P(u2, i2, i2, t2, i2.__e, l2));
  return l2;
}
function A$1(n2, l2) {
  return l2 = l2 || [], n2 == null || typeof n2 == "boolean" || (Array.isArray(n2) ? n2.some(function(n3) {
    A$1(n3, l2);
  }) : l2.push(n2)), l2;
}
function P(n2, l2, u2, i2, t2, r2) {
  var o2, f2, e2;
  if (l2.__d !== void 0)
    o2 = l2.__d, l2.__d = void 0;
  else if (u2 == null || t2 != r2 || t2.parentNode == null)
    n:
      if (r2 == null || r2.parentNode !== n2)
        n2.appendChild(t2), o2 = null;
      else {
        for (f2 = r2, e2 = 0; (f2 = f2.nextSibling) && e2 < i2.length; e2 += 2)
          if (f2 == t2)
            break n;
        n2.insertBefore(t2, r2), o2 = r2;
      }
  return o2 !== void 0 ? o2 : t2.nextSibling;
}
function C(n2, l2, u2, i2, t2) {
  var r2;
  for (r2 in u2)
    r2 === "children" || r2 === "key" || r2 in l2 || H(n2, r2, null, u2[r2], i2);
  for (r2 in l2)
    t2 && typeof l2[r2] != "function" || r2 === "children" || r2 === "key" || r2 === "value" || r2 === "checked" || u2[r2] === l2[r2] || H(n2, r2, l2[r2], u2[r2], i2);
}
function $(n2, l2, u2) {
  l2[0] === "-" ? n2.setProperty(l2, u2) : n2[l2] = u2 == null ? "" : typeof u2 != "number" || s$1.test(l2) ? u2 : u2 + "px";
}
function H(n2, l2, u2, i2, t2) {
  var r2;
  n:
    if (l2 === "style")
      if (typeof u2 == "string")
        n2.style.cssText = u2;
      else {
        if (typeof i2 == "string" && (n2.style.cssText = i2 = ""), i2)
          for (l2 in i2)
            u2 && l2 in u2 || $(n2.style, l2, "");
        if (u2)
          for (l2 in u2)
            i2 && u2[l2] === i2[l2] || $(n2.style, l2, u2[l2]);
      }
    else if (l2[0] === "o" && l2[1] === "n")
      r2 = l2 !== (l2 = l2.replace(/Capture$/, "")), l2 = l2.toLowerCase() in n2 ? l2.toLowerCase().slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + r2] = u2, u2 ? i2 || n2.addEventListener(l2, r2 ? T$1 : I, r2) : n2.removeEventListener(l2, r2 ? T$1 : I, r2);
    else if (l2 !== "dangerouslySetInnerHTML") {
      if (t2)
        l2 = l2.replace(/xlink[H:h]/, "h").replace(/sName$/, "s");
      else if (l2 !== "href" && l2 !== "list" && l2 !== "form" && l2 !== "tabIndex" && l2 !== "download" && l2 in n2)
        try {
          n2[l2] = u2 == null ? "" : u2;
          break n;
        } catch (n3) {
        }
      typeof u2 == "function" || (u2 != null && (u2 !== false || l2[0] === "a" && l2[1] === "r") ? n2.setAttribute(l2, u2) : n2.removeAttribute(l2));
    }
}
function I(n2) {
  this.l[n2.type + false](l$1.event ? l$1.event(n2) : n2);
}
function T$1(n2) {
  this.l[n2.type + true](l$1.event ? l$1.event(n2) : n2);
}
function j$1(n2, u2, i2, t2, r2, o2, f2, e2, c2) {
  var s2, h2, v2, y2, p2, k2, b2, m2, g2, x2, A2, P2 = u2.type;
  if (u2.constructor !== void 0)
    return null;
  i2.__h != null && (c2 = i2.__h, e2 = u2.__e = i2.__e, u2.__h = null, o2 = [e2]), (s2 = l$1.__b) && s2(u2);
  try {
    n:
      if (typeof P2 == "function") {
        if (m2 = u2.props, g2 = (s2 = P2.contextType) && t2[s2.__c], x2 = s2 ? g2 ? g2.props.value : s2.__ : t2, i2.__c ? b2 = (h2 = u2.__c = i2.__c).__ = h2.__E : ("prototype" in P2 && P2.prototype.render ? u2.__c = h2 = new P2(m2, x2) : (u2.__c = h2 = new _$1(m2, x2), h2.constructor = P2, h2.render = O), g2 && g2.sub(h2), h2.props = m2, h2.state || (h2.state = {}), h2.context = x2, h2.__n = t2, v2 = h2.__d = true, h2.__h = []), h2.__s == null && (h2.__s = h2.state), P2.getDerivedStateFromProps != null && (h2.__s == h2.state && (h2.__s = a$1({}, h2.__s)), a$1(h2.__s, P2.getDerivedStateFromProps(m2, h2.__s))), y2 = h2.props, p2 = h2.state, v2)
          P2.getDerivedStateFromProps == null && h2.componentWillMount != null && h2.componentWillMount(), h2.componentDidMount != null && h2.__h.push(h2.componentDidMount);
        else {
          if (P2.getDerivedStateFromProps == null && m2 !== y2 && h2.componentWillReceiveProps != null && h2.componentWillReceiveProps(m2, x2), !h2.__e && h2.shouldComponentUpdate != null && h2.shouldComponentUpdate(m2, h2.__s, x2) === false || u2.__v === i2.__v) {
            h2.props = m2, h2.state = h2.__s, u2.__v !== i2.__v && (h2.__d = false), h2.__v = u2, u2.__e = i2.__e, u2.__k = i2.__k, u2.__k.forEach(function(n3) {
              n3 && (n3.__ = u2);
            }), h2.__h.length && f2.push(h2);
            break n;
          }
          h2.componentWillUpdate != null && h2.componentWillUpdate(m2, h2.__s, x2), h2.componentDidUpdate != null && h2.__h.push(function() {
            h2.componentDidUpdate(y2, p2, k2);
          });
        }
        h2.context = x2, h2.props = m2, h2.state = h2.__s, (s2 = l$1.__r) && s2(u2), h2.__d = false, h2.__v = u2, h2.__P = n2, s2 = h2.render(h2.props, h2.state, h2.context), h2.state = h2.__s, h2.getChildContext != null && (t2 = a$1(a$1({}, t2), h2.getChildContext())), v2 || h2.getSnapshotBeforeUpdate == null || (k2 = h2.getSnapshotBeforeUpdate(y2, p2)), A2 = s2 != null && s2.type === d$1 && s2.key == null ? s2.props.children : s2, w$1(n2, Array.isArray(A2) ? A2 : [A2], u2, i2, t2, r2, o2, f2, e2, c2), h2.base = u2.__e, u2.__h = null, h2.__h.length && f2.push(h2), b2 && (h2.__E = h2.__ = null), h2.__e = false;
      } else
        o2 == null && u2.__v === i2.__v ? (u2.__k = i2.__k, u2.__e = i2.__e) : u2.__e = L(i2.__e, u2, i2, t2, r2, o2, f2, c2);
    (s2 = l$1.diffed) && s2(u2);
  } catch (n3) {
    u2.__v = null, (c2 || o2 != null) && (u2.__e = e2, u2.__h = !!c2, o2[o2.indexOf(e2)] = null), l$1.__e(n3, u2, i2);
  }
}
function z$1(n2, u2) {
  l$1.__c && l$1.__c(u2, n2), n2.some(function(u3) {
    try {
      n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
        n3.call(u3);
      });
    } catch (n3) {
      l$1.__e(n3, u3.__v);
    }
  });
}
function L(l2, u2, i2, t2, r2, o2, f2, c2) {
  var s2, a2, v2, y2 = i2.props, p2 = u2.props, d2 = u2.type, _2 = 0;
  if (d2 === "svg" && (r2 = true), o2 != null) {
    for (; _2 < o2.length; _2++)
      if ((s2 = o2[_2]) && "setAttribute" in s2 == !!d2 && (d2 ? s2.localName === d2 : s2.nodeType === 3)) {
        l2 = s2, o2[_2] = null;
        break;
      }
  }
  if (l2 == null) {
    if (d2 === null)
      return document.createTextNode(p2);
    l2 = r2 ? document.createElementNS("http://www.w3.org/2000/svg", d2) : document.createElement(d2, p2.is && p2), o2 = null, c2 = false;
  }
  if (d2 === null)
    y2 === p2 || c2 && l2.data === p2 || (l2.data = p2);
  else {
    if (o2 = o2 && n.call(l2.childNodes), a2 = (y2 = i2.props || e$1).dangerouslySetInnerHTML, v2 = p2.dangerouslySetInnerHTML, !c2) {
      if (o2 != null)
        for (y2 = {}, _2 = 0; _2 < l2.attributes.length; _2++)
          y2[l2.attributes[_2].name] = l2.attributes[_2].value;
      (v2 || a2) && (v2 && (a2 && v2.__html == a2.__html || v2.__html === l2.innerHTML) || (l2.innerHTML = v2 && v2.__html || ""));
    }
    if (C(l2, p2, y2, r2, c2), v2)
      u2.__k = [];
    else if (_2 = u2.props.children, w$1(l2, Array.isArray(_2) ? _2 : [_2], u2, i2, t2, r2 && d2 !== "foreignObject", o2, f2, o2 ? o2[0] : i2.__k && k$1(i2, 0), c2), o2 != null)
      for (_2 = o2.length; _2--; )
        o2[_2] != null && h$1(o2[_2]);
    c2 || ("value" in p2 && (_2 = p2.value) !== void 0 && (_2 !== y2.value || _2 !== l2.value || d2 === "progress" && !_2) && H(l2, "value", _2, y2.value, false), "checked" in p2 && (_2 = p2.checked) !== void 0 && _2 !== l2.checked && H(l2, "checked", _2, y2.checked, false));
  }
  return l2;
}
function M(n2, u2, i2) {
  try {
    typeof n2 == "function" ? n2(u2) : n2.current = u2;
  } catch (n3) {
    l$1.__e(n3, i2);
  }
}
function N(n2, u2, i2) {
  var t2, r2;
  if (l$1.unmount && l$1.unmount(n2), (t2 = n2.ref) && (t2.current && t2.current !== n2.__e || M(t2, null, u2)), (t2 = n2.__c) != null) {
    if (t2.componentWillUnmount)
      try {
        t2.componentWillUnmount();
      } catch (n3) {
        l$1.__e(n3, u2);
      }
    t2.base = t2.__P = null;
  }
  if (t2 = n2.__k)
    for (r2 = 0; r2 < t2.length; r2++)
      t2[r2] && N(t2[r2], u2, typeof n2.type != "function");
  i2 || n2.__e == null || h$1(n2.__e), n2.__e = n2.__d = void 0;
}
function O(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function S(u2, i2, t2) {
  var r2, o2, f2;
  l$1.__ && l$1.__(u2, i2), o2 = (r2 = typeof t2 == "function") ? null : t2 && t2.__k || i2.__k, f2 = [], j$1(i2, u2 = (!r2 && t2 || i2).__k = v$1(d$1, null, [u2]), o2 || e$1, e$1, i2.ownerSVGElement !== void 0, !r2 && t2 ? [t2] : o2 ? null : i2.firstChild ? n.call(i2.childNodes) : null, f2, !r2 && t2 ? t2 : o2 ? o2.__e : i2.firstChild, r2), z$1(f2, u2);
}
function q$1(n2, l2) {
  S(n2, l2, q$1);
}
function B(l2, u2, i2) {
  var t2, r2, o2, f2 = a$1({}, l2.props);
  for (o2 in u2)
    o2 == "key" ? t2 = u2[o2] : o2 == "ref" ? r2 = u2[o2] : f2[o2] = u2[o2];
  return arguments.length > 2 && (f2.children = arguments.length > 3 ? n.call(arguments, 2) : i2), y$1(l2.type, f2, t2 || l2.key, r2 || l2.ref, null);
}
function D(n2, l2) {
  var u2 = { __c: l2 = "__cC" + f$1++, __: n2, Consumer: function(n3, l3) {
    return n3.children(l3);
  }, Provider: function(n3) {
    var u3, i2;
    return this.getChildContext || (u3 = [], (i2 = {})[l2] = this, this.getChildContext = function() {
      return i2;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u3.some(m$1);
    }, this.sub = function(n4) {
      u3.push(n4);
      var l3 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u3.splice(u3.indexOf(n4), 1), l3 && l3.call(n4);
      };
    }), n3.children;
  } };
  return u2.Provider.__ = u2.Consumer.contextType = u2;
}
n = c$1.slice, l$1 = { __e: function(n2, l2) {
  for (var u2, i2, t2; l2 = l2.__; )
    if ((u2 = l2.__c) && !u2.__)
      try {
        if ((i2 = u2.constructor) && i2.getDerivedStateFromError != null && (u2.setState(i2.getDerivedStateFromError(n2)), t2 = u2.__d), u2.componentDidCatch != null && (u2.componentDidCatch(n2), t2 = u2.__d), t2)
          return u2.__E = u2;
      } catch (l3) {
        n2 = l3;
      }
  throw n2;
} }, u$1 = 0, i$2 = function(n2) {
  return n2 != null && n2.constructor === void 0;
}, _$1.prototype.setState = function(n2, l2) {
  var u2;
  u2 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = a$1({}, this.state), typeof n2 == "function" && (n2 = n2(a$1({}, u2), this.props)), n2 && a$1(u2, n2), n2 != null && this.__v && (l2 && this.__h.push(l2), m$1(this));
}, _$1.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), m$1(this));
}, _$1.prototype.render = d$1, t$1 = [], r$1 = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g$1.__r = 0, f$1 = 0;
var preact_module = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  render: S,
  hydrate: q$1,
  createElement: v$1,
  h: v$1,
  Fragment: d$1,
  createRef: p$1,
  get isValidElement() {
    return i$2;
  },
  Component: _$1,
  cloneElement: B,
  createContext: D,
  toChildArray: A$1,
  get options() {
    return l$1;
  }
});
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(preact_module);
var LinkDialog$1 = {};
function toVal(mix) {
  var k2, y2, str2 = "";
  if (typeof mix === "string" || typeof mix === "number") {
    str2 += mix;
  } else if (typeof mix === "object") {
    if (Array.isArray(mix)) {
      for (k2 = 0; k2 < mix.length; k2++) {
        if (mix[k2]) {
          if (y2 = toVal(mix[k2])) {
            str2 && (str2 += " ");
            str2 += y2;
          }
        }
      }
    } else {
      for (k2 in mix) {
        if (mix[k2]) {
          str2 && (str2 += " ");
          str2 += k2;
        }
      }
    }
  }
  return str2;
}
function clsx_m() {
  var i2 = 0, tmp, x2, str2 = "";
  while (i2 < arguments.length) {
    if (tmp = arguments[i2++]) {
      if (x2 = toVal(tmp)) {
        str2 && (str2 += " ");
        str2 += x2;
      }
    }
  }
  return str2;
}
var clsx_m$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": clsx_m
});
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(clsx_m$1);
var t, u, r, o = 0, i$1 = [], c = l$1.__b, f = l$1.__r, e = l$1.diffed, a = l$1.__c, v = l$1.unmount;
function m(t2, r2) {
  l$1.__h && l$1.__h(u, t2, o || r2), o = 0;
  var i2 = u.__H || (u.__H = { __: [], __h: [] });
  return t2 >= i2.__.length && i2.__.push({}), i2.__[t2];
}
function l(n2) {
  return o = 1, p(w, n2);
}
function p(n2, r2, o2) {
  var i2 = m(t++, 2);
  return i2.t = n2, i2.__c || (i2.__ = [o2 ? o2(r2) : w(void 0, r2), function(n3) {
    var t2 = i2.t(i2.__[0], n3);
    i2.__[0] !== t2 && (i2.__ = [t2, i2.__[1]], i2.__c.setState({}));
  }], i2.__c = u), i2.__;
}
function y(r2, o2) {
  var i2 = m(t++, 3);
  !l$1.__s && k(i2.__H, o2) && (i2.__ = r2, i2.__H = o2, u.__H.__h.push(i2));
}
function h(r2, o2) {
  var i2 = m(t++, 4);
  !l$1.__s && k(i2.__H, o2) && (i2.__ = r2, i2.__H = o2, u.__h.push(i2));
}
function s(n2) {
  return o = 5, d(function() {
    return { current: n2 };
  }, []);
}
function _(n2, t2, u2) {
  o = 6, h(function() {
    typeof n2 == "function" ? n2(t2()) : n2 && (n2.current = t2());
  }, u2 == null ? u2 : u2.concat(n2));
}
function d(n2, u2) {
  var r2 = m(t++, 7);
  return k(r2.__H, u2) && (r2.__ = n2(), r2.__H = u2, r2.__h = n2), r2.__;
}
function A(n2, t2) {
  return o = 8, d(function() {
    return n2;
  }, t2);
}
function F(n2) {
  var r2 = u.context[n2.__c], o2 = m(t++, 9);
  return o2.c = n2, r2 ? (o2.__ == null && (o2.__ = true, r2.sub(u)), r2.props.value) : n2.__;
}
function T(t2, u2) {
  l$1.useDebugValue && l$1.useDebugValue(u2 ? u2(t2) : t2);
}
function q(n2) {
  var r2 = m(t++, 10), o2 = l();
  return r2.__ = n2, u.componentDidCatch || (u.componentDidCatch = function(n3) {
    r2.__ && r2.__(n3), o2[1](n3);
  }), [o2[0], function() {
    o2[1](void 0);
  }];
}
function x$1() {
  var t2;
  for (i$1.sort(function(n2, t3) {
    return n2.__v.__b - t3.__v.__b;
  }); t2 = i$1.pop(); )
    if (t2.__P)
      try {
        t2.__H.__h.forEach(g), t2.__H.__h.forEach(j), t2.__H.__h = [];
      } catch (u2) {
        t2.__H.__h = [], l$1.__e(u2, t2.__v);
      }
}
l$1.__b = function(n2) {
  u = null, c && c(n2);
}, l$1.__r = function(n2) {
  f && f(n2), t = 0;
  var r2 = (u = n2.__c).__H;
  r2 && (r2.__h.forEach(g), r2.__h.forEach(j), r2.__h = []);
}, l$1.diffed = function(t2) {
  e && e(t2);
  var o2 = t2.__c;
  o2 && o2.__H && o2.__H.__h.length && (i$1.push(o2) !== 1 && r === l$1.requestAnimationFrame || ((r = l$1.requestAnimationFrame) || function(n2) {
    var t3, u2 = function() {
      clearTimeout(r2), b && cancelAnimationFrame(t3), setTimeout(n2);
    }, r2 = setTimeout(u2, 100);
    b && (t3 = requestAnimationFrame(u2));
  })(x$1)), u = null;
}, l$1.__c = function(t2, u2) {
  u2.some(function(t3) {
    try {
      t3.__h.forEach(g), t3.__h = t3.__h.filter(function(n2) {
        return !n2.__ || j(n2);
      });
    } catch (r2) {
      u2.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), u2 = [], l$1.__e(r2, t3.__v);
    }
  }), a && a(t2, u2);
}, l$1.unmount = function(t2) {
  v && v(t2);
  var u2, r2 = t2.__c;
  r2 && r2.__H && (r2.__H.__.forEach(function(n2) {
    try {
      g(n2);
    } catch (n3) {
      u2 = n3;
    }
  }), u2 && l$1.__e(u2, r2.__v));
};
var b = typeof requestAnimationFrame == "function";
function g(n2) {
  var t2 = u, r2 = n2.__c;
  typeof r2 == "function" && (n2.__c = void 0, r2()), u = t2;
}
function j(n2) {
  var t2 = u;
  n2.__c = n2.__(), u = t2;
}
function k(n2, t2) {
  return !n2 || n2.length !== t2.length || t2.some(function(t3, u2) {
    return t3 !== n2[u2];
  });
}
function w(n2, t2) {
  return typeof t2 == "function" ? t2(n2) : t2;
}
var hooks_module = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  useState: l,
  useReducer: p,
  useEffect: y,
  useLayoutEffect: h,
  useRef: s,
  useImperativeHandle: _,
  useMemo: d,
  useCallback: A,
  useContext: F,
  useDebugValue: T,
  useErrorBoundary: q
});
var require$$2 = /* @__PURE__ */ getAugmentedNamespace(hooks_module);
var LinkDialogCss = {};
Object.defineProperty(LinkDialogCss, "__esModule", { value: true });
LinkDialogCss.default = `.-walletlink-css-reset .-walletlink-link-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-walletlink-css-reset .-walletlink-link-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;background-color:rgba(0,0,0,.33);transition:opacity .25s}.-walletlink-css-reset .-walletlink-link-dialog-backdrop-hidden{opacity:0}.-walletlink-css-reset .-walletlink-link-dialog-box{display:flex;position:relative;flex-direction:column;background-color:#f6f6f6;border-radius:16px;box-shadow:0px 16px 24px rgba(0,0,0,.1),0px 0px 8px rgba(0,0,0,.05);transform:scale(1);transition:opacity .25s,transform .25s;overflow:hidden}.-walletlink-css-reset .-walletlink-link-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-walletlink-css-reset .-walletlink-link-dialog-box-content{padding:24px;text-align:center}.-walletlink-css-reset .-walletlink-link-dialog-box-content h3{display:block;margin-bottom:24px;text-align:left;text-transform:uppercase;font-size:22px;font-weight:bold;line-height:1.2;color:#000}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode{position:relative;display:block;margin-bottom:24px;background-color:#f6f6f6;padding:16px;border-radius:16px;box-shadow:4px 4px 8px rgba(0,0,0,.15),-8px -8px 8px #fff;overflow:hidden}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode-wrapper{display:block;width:232px;height:232px;padding:4px;border-radius:4px;background:#f4f4f4;margin-bottom:16px}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode-wrapper img{display:block;width:224px;height:224px}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode>p{display:block;color:gray;font-weight:bold;font-size:12px;text-align:center}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode-connecting{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(246,246,246,.98)}.-walletlink-css-reset .-walletlink-link-dialog-box-content-qrcode-connecting p{margin-top:16px;color:#333;font-size:12px;font-weight:bold}.-walletlink-css-reset .-walletlink-link-dialog-box-content a{text-align:center;cursor:pointer;transition:color .1s;font-size:14px}.-walletlink-css-reset .-walletlink-link-dialog-box-content a,.-walletlink-css-reset .-walletlink-link-dialog-box-content a:link,.-walletlink-css-reset .-walletlink-link-dialog-box-content a:visited{color:#999}.-walletlink-css-reset .-walletlink-link-dialog-box-content a:hover,.-walletlink-css-reset .-walletlink-link-dialog-box-content a:active{color:#666;text-decoration:underline}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel{position:absolute;-webkit-appearance:none;display:flex;align-items:center;justify-content:center;top:24px;right:24px;width:24px;height:24px;border-radius:12px;background-color:#e7e7e7;cursor:pointer}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x{position:relative;display:block}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x::before,.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x::after{content:"";position:absolute;display:block;top:-1px;left:-7px;width:14px;height:2px;background-color:#999;transition:background-color .2s}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x::before{transform:rotate(45deg)}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel-x::after{transform:rotate(135deg)}.-walletlink-css-reset .-walletlink-link-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x-a,.-walletlink-css-reset .-walletlink-link-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x-b{background-color:#000}.-walletlink-css-reset .-walletlink-link-dialog-container{display:block}.-walletlink-css-reset .-walletlink-link-dialog-container-hidden{display:none}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box{background-color:#2a2a2a}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content h3{color:#ccc}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content-qrcode{background-color:#2a2a2a;box-shadow:4px 4px 8px rgba(0,0,0,.5),-8px -8px 8px #343434}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content-qrcode>p{color:#999}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content-qrcode-connecting{background:rgba(42,42,42,.98)}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content-qrcode-connecting p{color:#ddd}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a:link,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a:visited{color:#888}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a:hover,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-content a:active{color:#aaa}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel{background-color:#333}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel-x::before,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel-x::after{background-color:#aaa}.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x::before,.-walletlink-css-reset .-walletlink-link-dialog-container-dark .-walletlink-link-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x::after{background-color:#eee}`;
var QRCode$2 = {};
function QR8bitByte(data) {
  this.mode = QRMode.MODE_8BIT_BYTE;
  this.data = data;
  this.parsedData = [];
  for (var i2 = 0, l2 = this.data.length; i2 < l2; i2++) {
    var byteArray = [];
    var code2 = this.data.charCodeAt(i2);
    if (code2 > 65536) {
      byteArray[0] = 240 | (code2 & 1835008) >>> 18;
      byteArray[1] = 128 | (code2 & 258048) >>> 12;
      byteArray[2] = 128 | (code2 & 4032) >>> 6;
      byteArray[3] = 128 | code2 & 63;
    } else if (code2 > 2048) {
      byteArray[0] = 224 | (code2 & 61440) >>> 12;
      byteArray[1] = 128 | (code2 & 4032) >>> 6;
      byteArray[2] = 128 | code2 & 63;
    } else if (code2 > 128) {
      byteArray[0] = 192 | (code2 & 1984) >>> 6;
      byteArray[1] = 128 | code2 & 63;
    } else {
      byteArray[0] = code2;
    }
    this.parsedData.push(byteArray);
  }
  this.parsedData = Array.prototype.concat.apply([], this.parsedData);
  if (this.parsedData.length != this.data.length) {
    this.parsedData.unshift(191);
    this.parsedData.unshift(187);
    this.parsedData.unshift(239);
  }
}
QR8bitByte.prototype = {
  getLength: function(buffer2) {
    return this.parsedData.length;
  },
  write: function(buffer2) {
    for (var i2 = 0, l2 = this.parsedData.length; i2 < l2; i2++) {
      buffer2.put(this.parsedData[i2], 8);
    }
  }
};
function QRCodeModel(typeNumber, errorCorrectLevel) {
  this.typeNumber = typeNumber;
  this.errorCorrectLevel = errorCorrectLevel;
  this.modules = null;
  this.moduleCount = 0;
  this.dataCache = null;
  this.dataList = [];
}
QRCodeModel.prototype = { addData: function(data) {
  var newData = new QR8bitByte(data);
  this.dataList.push(newData);
  this.dataCache = null;
}, isDark: function(row, col) {
  if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
    throw new Error(row + "," + col);
  }
  return this.modules[row][col];
}, getModuleCount: function() {
  return this.moduleCount;
}, make: function() {
  this.makeImpl(false, this.getBestMaskPattern());
}, makeImpl: function(test, maskPattern2) {
  this.moduleCount = this.typeNumber * 4 + 17;
  this.modules = new Array(this.moduleCount);
  for (var row = 0; row < this.moduleCount; row++) {
    this.modules[row] = new Array(this.moduleCount);
    for (var col = 0; col < this.moduleCount; col++) {
      this.modules[row][col] = null;
    }
  }
  this.setupPositionProbePattern(0, 0);
  this.setupPositionProbePattern(this.moduleCount - 7, 0);
  this.setupPositionProbePattern(0, this.moduleCount - 7);
  this.setupPositionAdjustPattern();
  this.setupTimingPattern();
  this.setupTypeInfo(test, maskPattern2);
  if (this.typeNumber >= 7) {
    this.setupTypeNumber(test);
  }
  if (this.dataCache == null) {
    this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
  }
  this.mapData(this.dataCache, maskPattern2);
}, setupPositionProbePattern: function(row, col) {
  for (var r2 = -1; r2 <= 7; r2++) {
    if (row + r2 <= -1 || this.moduleCount <= row + r2)
      continue;
    for (var c2 = -1; c2 <= 7; c2++) {
      if (col + c2 <= -1 || this.moduleCount <= col + c2)
        continue;
      if (0 <= r2 && r2 <= 6 && (c2 == 0 || c2 == 6) || 0 <= c2 && c2 <= 6 && (r2 == 0 || r2 == 6) || 2 <= r2 && r2 <= 4 && 2 <= c2 && c2 <= 4) {
        this.modules[row + r2][col + c2] = true;
      } else {
        this.modules[row + r2][col + c2] = false;
      }
    }
  }
}, getBestMaskPattern: function() {
  var minLostPoint = 0;
  var pattern = 0;
  for (var i2 = 0; i2 < 8; i2++) {
    this.makeImpl(true, i2);
    var lostPoint = QRUtil.getLostPoint(this);
    if (i2 == 0 || minLostPoint > lostPoint) {
      minLostPoint = lostPoint;
      pattern = i2;
    }
  }
  return pattern;
}, createMovieClip: function(target_mc, instance_name, depth) {
  var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
  var cs = 1;
  this.make();
  for (var row = 0; row < this.modules.length; row++) {
    var y2 = row * cs;
    for (var col = 0; col < this.modules[row].length; col++) {
      var x2 = col * cs;
      var dark = this.modules[row][col];
      if (dark) {
        qr_mc.beginFill(0, 100);
        qr_mc.moveTo(x2, y2);
        qr_mc.lineTo(x2 + cs, y2);
        qr_mc.lineTo(x2 + cs, y2 + cs);
        qr_mc.lineTo(x2, y2 + cs);
        qr_mc.endFill();
      }
    }
  }
  return qr_mc;
}, setupTimingPattern: function() {
  for (var r2 = 8; r2 < this.moduleCount - 8; r2++) {
    if (this.modules[r2][6] != null) {
      continue;
    }
    this.modules[r2][6] = r2 % 2 == 0;
  }
  for (var c2 = 8; c2 < this.moduleCount - 8; c2++) {
    if (this.modules[6][c2] != null) {
      continue;
    }
    this.modules[6][c2] = c2 % 2 == 0;
  }
}, setupPositionAdjustPattern: function() {
  var pos = QRUtil.getPatternPosition(this.typeNumber);
  for (var i2 = 0; i2 < pos.length; i2++) {
    for (var j2 = 0; j2 < pos.length; j2++) {
      var row = pos[i2];
      var col = pos[j2];
      if (this.modules[row][col] != null) {
        continue;
      }
      for (var r2 = -2; r2 <= 2; r2++) {
        for (var c2 = -2; c2 <= 2; c2++) {
          if (r2 == -2 || r2 == 2 || c2 == -2 || c2 == 2 || r2 == 0 && c2 == 0) {
            this.modules[row + r2][col + c2] = true;
          } else {
            this.modules[row + r2][col + c2] = false;
          }
        }
      }
    }
  }
}, setupTypeNumber: function(test) {
  var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
  for (var i2 = 0; i2 < 18; i2++) {
    var mod = !test && (bits >> i2 & 1) == 1;
    this.modules[Math.floor(i2 / 3)][i2 % 3 + this.moduleCount - 8 - 3] = mod;
  }
  for (var i2 = 0; i2 < 18; i2++) {
    var mod = !test && (bits >> i2 & 1) == 1;
    this.modules[i2 % 3 + this.moduleCount - 8 - 3][Math.floor(i2 / 3)] = mod;
  }
}, setupTypeInfo: function(test, maskPattern2) {
  var data = this.errorCorrectLevel << 3 | maskPattern2;
  var bits = QRUtil.getBCHTypeInfo(data);
  for (var i2 = 0; i2 < 15; i2++) {
    var mod = !test && (bits >> i2 & 1) == 1;
    if (i2 < 6) {
      this.modules[i2][8] = mod;
    } else if (i2 < 8) {
      this.modules[i2 + 1][8] = mod;
    } else {
      this.modules[this.moduleCount - 15 + i2][8] = mod;
    }
  }
  for (var i2 = 0; i2 < 15; i2++) {
    var mod = !test && (bits >> i2 & 1) == 1;
    if (i2 < 8) {
      this.modules[8][this.moduleCount - i2 - 1] = mod;
    } else if (i2 < 9) {
      this.modules[8][15 - i2 - 1 + 1] = mod;
    } else {
      this.modules[8][15 - i2 - 1] = mod;
    }
  }
  this.modules[this.moduleCount - 8][8] = !test;
}, mapData: function(data, maskPattern2) {
  var inc = -1;
  var row = this.moduleCount - 1;
  var bitIndex = 7;
  var byteIndex = 0;
  for (var col = this.moduleCount - 1; col > 0; col -= 2) {
    if (col == 6)
      col--;
    while (true) {
      for (var c2 = 0; c2 < 2; c2++) {
        if (this.modules[row][col - c2] == null) {
          var dark = false;
          if (byteIndex < data.length) {
            dark = (data[byteIndex] >>> bitIndex & 1) == 1;
          }
          var mask = QRUtil.getMask(maskPattern2, row, col - c2);
          if (mask) {
            dark = !dark;
          }
          this.modules[row][col - c2] = dark;
          bitIndex--;
          if (bitIndex == -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc;
      if (row < 0 || this.moduleCount <= row) {
        row -= inc;
        inc = -inc;
        break;
      }
    }
  }
} };
QRCodeModel.PAD0 = 236;
QRCodeModel.PAD1 = 17;
QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
  var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
  var buffer2 = new QRBitBuffer();
  for (var i2 = 0; i2 < dataList.length; i2++) {
    var data = dataList[i2];
    buffer2.put(data.mode, 4);
    buffer2.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
    data.write(buffer2);
  }
  var totalDataCount = 0;
  for (var i2 = 0; i2 < rsBlocks.length; i2++) {
    totalDataCount += rsBlocks[i2].dataCount;
  }
  if (buffer2.getLengthInBits() > totalDataCount * 8) {
    throw new Error("code length overflow. (" + buffer2.getLengthInBits() + ">" + totalDataCount * 8 + ")");
  }
  if (buffer2.getLengthInBits() + 4 <= totalDataCount * 8) {
    buffer2.put(0, 4);
  }
  while (buffer2.getLengthInBits() % 8 != 0) {
    buffer2.putBit(false);
  }
  while (true) {
    if (buffer2.getLengthInBits() >= totalDataCount * 8) {
      break;
    }
    buffer2.put(QRCodeModel.PAD0, 8);
    if (buffer2.getLengthInBits() >= totalDataCount * 8) {
      break;
    }
    buffer2.put(QRCodeModel.PAD1, 8);
  }
  return QRCodeModel.createBytes(buffer2, rsBlocks);
};
QRCodeModel.createBytes = function(buffer2, rsBlocks) {
  var offset = 0;
  var maxDcCount = 0;
  var maxEcCount = 0;
  var dcdata = new Array(rsBlocks.length);
  var ecdata = new Array(rsBlocks.length);
  for (var r2 = 0; r2 < rsBlocks.length; r2++) {
    var dcCount = rsBlocks[r2].dataCount;
    var ecCount = rsBlocks[r2].totalCount - dcCount;
    maxDcCount = Math.max(maxDcCount, dcCount);
    maxEcCount = Math.max(maxEcCount, ecCount);
    dcdata[r2] = new Array(dcCount);
    for (var i2 = 0; i2 < dcdata[r2].length; i2++) {
      dcdata[r2][i2] = 255 & buffer2.buffer[i2 + offset];
    }
    offset += dcCount;
    var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
    var rawPoly = new QRPolynomial(dcdata[r2], rsPoly.getLength() - 1);
    var modPoly = rawPoly.mod(rsPoly);
    ecdata[r2] = new Array(rsPoly.getLength() - 1);
    for (var i2 = 0; i2 < ecdata[r2].length; i2++) {
      var modIndex = i2 + modPoly.getLength() - ecdata[r2].length;
      ecdata[r2][i2] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
    }
  }
  var totalCodeCount = 0;
  for (var i2 = 0; i2 < rsBlocks.length; i2++) {
    totalCodeCount += rsBlocks[i2].totalCount;
  }
  var data = new Array(totalCodeCount);
  var index2 = 0;
  for (var i2 = 0; i2 < maxDcCount; i2++) {
    for (var r2 = 0; r2 < rsBlocks.length; r2++) {
      if (i2 < dcdata[r2].length) {
        data[index2++] = dcdata[r2][i2];
      }
    }
  }
  for (var i2 = 0; i2 < maxEcCount; i2++) {
    for (var r2 = 0; r2 < rsBlocks.length; r2++) {
      if (i2 < ecdata[r2].length) {
        data[index2++] = ecdata[r2][i2];
      }
    }
  }
  return data;
};
var QRMode = { MODE_NUMBER: 1 << 0, MODE_ALPHA_NUM: 1 << 1, MODE_8BIT_BYTE: 1 << 2, MODE_KANJI: 1 << 3 };
var QRErrorCorrectLevel = { L: 1, M: 0, Q: 3, H: 2 };
var QRMaskPattern = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 };
var QRUtil = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0, G18: 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0, G15_MASK: 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1, getBCHTypeInfo: function(data) {
  var d2 = data << 10;
  while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
    d2 ^= QRUtil.G15 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G15);
  }
  return (data << 10 | d2) ^ QRUtil.G15_MASK;
}, getBCHTypeNumber: function(data) {
  var d2 = data << 12;
  while (QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
    d2 ^= QRUtil.G18 << QRUtil.getBCHDigit(d2) - QRUtil.getBCHDigit(QRUtil.G18);
  }
  return data << 12 | d2;
}, getBCHDigit: function(data) {
  var digit = 0;
  while (data != 0) {
    digit++;
    data >>>= 1;
  }
  return digit;
}, getPatternPosition: function(typeNumber) {
  return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
}, getMask: function(maskPattern2, i2, j2) {
  switch (maskPattern2) {
    case QRMaskPattern.PATTERN000:
      return (i2 + j2) % 2 == 0;
    case QRMaskPattern.PATTERN001:
      return i2 % 2 == 0;
    case QRMaskPattern.PATTERN010:
      return j2 % 3 == 0;
    case QRMaskPattern.PATTERN011:
      return (i2 + j2) % 3 == 0;
    case QRMaskPattern.PATTERN100:
      return (Math.floor(i2 / 2) + Math.floor(j2 / 3)) % 2 == 0;
    case QRMaskPattern.PATTERN101:
      return i2 * j2 % 2 + i2 * j2 % 3 == 0;
    case QRMaskPattern.PATTERN110:
      return (i2 * j2 % 2 + i2 * j2 % 3) % 2 == 0;
    case QRMaskPattern.PATTERN111:
      return (i2 * j2 % 3 + (i2 + j2) % 2) % 2 == 0;
    default:
      throw new Error("bad maskPattern:" + maskPattern2);
  }
}, getErrorCorrectPolynomial: function(errorCorrectLength) {
  var a2 = new QRPolynomial([1], 0);
  for (var i2 = 0; i2 < errorCorrectLength; i2++) {
    a2 = a2.multiply(new QRPolynomial([1, QRMath.gexp(i2)], 0));
  }
  return a2;
}, getLengthInBits: function(mode2, type) {
  if (1 <= type && type < 10) {
    switch (mode2) {
      case QRMode.MODE_NUMBER:
        return 10;
      case QRMode.MODE_ALPHA_NUM:
        return 9;
      case QRMode.MODE_8BIT_BYTE:
        return 8;
      case QRMode.MODE_KANJI:
        return 8;
      default:
        throw new Error("mode:" + mode2);
    }
  } else if (type < 27) {
    switch (mode2) {
      case QRMode.MODE_NUMBER:
        return 12;
      case QRMode.MODE_ALPHA_NUM:
        return 11;
      case QRMode.MODE_8BIT_BYTE:
        return 16;
      case QRMode.MODE_KANJI:
        return 10;
      default:
        throw new Error("mode:" + mode2);
    }
  } else if (type < 41) {
    switch (mode2) {
      case QRMode.MODE_NUMBER:
        return 14;
      case QRMode.MODE_ALPHA_NUM:
        return 13;
      case QRMode.MODE_8BIT_BYTE:
        return 16;
      case QRMode.MODE_KANJI:
        return 12;
      default:
        throw new Error("mode:" + mode2);
    }
  } else {
    throw new Error("type:" + type);
  }
}, getLostPoint: function(qrCode) {
  var moduleCount = qrCode.getModuleCount();
  var lostPoint = 0;
  for (var row = 0; row < moduleCount; row++) {
    for (var col = 0; col < moduleCount; col++) {
      var sameCount = 0;
      var dark = qrCode.isDark(row, col);
      for (var r2 = -1; r2 <= 1; r2++) {
        if (row + r2 < 0 || moduleCount <= row + r2) {
          continue;
        }
        for (var c2 = -1; c2 <= 1; c2++) {
          if (col + c2 < 0 || moduleCount <= col + c2) {
            continue;
          }
          if (r2 == 0 && c2 == 0) {
            continue;
          }
          if (dark == qrCode.isDark(row + r2, col + c2)) {
            sameCount++;
          }
        }
      }
      if (sameCount > 5) {
        lostPoint += 3 + sameCount - 5;
      }
    }
  }
  for (var row = 0; row < moduleCount - 1; row++) {
    for (var col = 0; col < moduleCount - 1; col++) {
      var count2 = 0;
      if (qrCode.isDark(row, col))
        count2++;
      if (qrCode.isDark(row + 1, col))
        count2++;
      if (qrCode.isDark(row, col + 1))
        count2++;
      if (qrCode.isDark(row + 1, col + 1))
        count2++;
      if (count2 == 0 || count2 == 4) {
        lostPoint += 3;
      }
    }
  }
  for (var row = 0; row < moduleCount; row++) {
    for (var col = 0; col < moduleCount - 6; col++) {
      if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) && qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) && qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) && qrCode.isDark(row, col + 6)) {
        lostPoint += 40;
      }
    }
  }
  for (var col = 0; col < moduleCount; col++) {
    for (var row = 0; row < moduleCount - 6; row++) {
      if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) && qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) && qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) && qrCode.isDark(row + 6, col)) {
        lostPoint += 40;
      }
    }
  }
  var darkCount = 0;
  for (var col = 0; col < moduleCount; col++) {
    for (var row = 0; row < moduleCount; row++) {
      if (qrCode.isDark(row, col)) {
        darkCount++;
      }
    }
  }
  var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
  lostPoint += ratio * 10;
  return lostPoint;
} };
var QRMath = { glog: function(n2) {
  if (n2 < 1) {
    throw new Error("glog(" + n2 + ")");
  }
  return QRMath.LOG_TABLE[n2];
}, gexp: function(n2) {
  while (n2 < 0) {
    n2 += 255;
  }
  while (n2 >= 256) {
    n2 -= 255;
  }
  return QRMath.EXP_TABLE[n2];
}, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) };
for (var i = 0; i < 8; i++) {
  QRMath.EXP_TABLE[i] = 1 << i;
}
for (var i = 8; i < 256; i++) {
  QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
}
for (var i = 0; i < 255; i++) {
  QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
}
function QRPolynomial(num, shift) {
  if (num.length == void 0) {
    throw new Error(num.length + "/" + shift);
  }
  var offset = 0;
  while (offset < num.length && num[offset] == 0) {
    offset++;
  }
  this.num = new Array(num.length - offset + shift);
  for (var i2 = 0; i2 < num.length - offset; i2++) {
    this.num[i2] = num[i2 + offset];
  }
}
QRPolynomial.prototype = { get: function(index2) {
  return this.num[index2];
}, getLength: function() {
  return this.num.length;
}, multiply: function(e2) {
  var num = new Array(this.getLength() + e2.getLength() - 1);
  for (var i2 = 0; i2 < this.getLength(); i2++) {
    for (var j2 = 0; j2 < e2.getLength(); j2++) {
      num[i2 + j2] ^= QRMath.gexp(QRMath.glog(this.get(i2)) + QRMath.glog(e2.get(j2)));
    }
  }
  return new QRPolynomial(num, 0);
}, mod: function(e2) {
  if (this.getLength() - e2.getLength() < 0) {
    return this;
  }
  var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e2.get(0));
  var num = new Array(this.getLength());
  for (var i2 = 0; i2 < this.getLength(); i2++) {
    num[i2] = this.get(i2);
  }
  for (var i2 = 0; i2 < e2.getLength(); i2++) {
    num[i2] ^= QRMath.gexp(QRMath.glog(e2.get(i2)) + ratio);
  }
  return new QRPolynomial(num, 0).mod(e2);
} };
function QRRSBlock(totalCount, dataCount) {
  this.totalCount = totalCount;
  this.dataCount = dataCount;
}
QRRSBlock.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]];
QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
  var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
  if (rsBlock == void 0) {
    throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
  }
  var length = rsBlock.length / 3;
  var list = [];
  for (var i2 = 0; i2 < length; i2++) {
    var count2 = rsBlock[i2 * 3 + 0];
    var totalCount = rsBlock[i2 * 3 + 1];
    var dataCount = rsBlock[i2 * 3 + 2];
    for (var j2 = 0; j2 < count2; j2++) {
      list.push(new QRRSBlock(totalCount, dataCount));
    }
  }
  return list;
};
QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
  switch (errorCorrectLevel) {
    case QRErrorCorrectLevel.L:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
    case QRErrorCorrectLevel.M:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
    case QRErrorCorrectLevel.Q:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
    case QRErrorCorrectLevel.H:
      return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
    default:
      return void 0;
  }
};
function QRBitBuffer() {
  this.buffer = [];
  this.length = 0;
}
QRBitBuffer.prototype = { get: function(index2) {
  var bufIndex = Math.floor(index2 / 8);
  return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) == 1;
}, put: function(num, length) {
  for (var i2 = 0; i2 < length; i2++) {
    this.putBit((num >>> length - i2 - 1 & 1) == 1);
  }
}, getLengthInBits: function() {
  return this.length;
}, putBit: function(bit) {
  var bufIndex = Math.floor(this.length / 8);
  if (this.buffer.length <= bufIndex) {
    this.buffer.push(0);
  }
  if (bit) {
    this.buffer[bufIndex] |= 128 >>> this.length % 8;
  }
  this.length++;
} };
var QRCodeLimitLength = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
function QRCode$1(options) {
  this.options = {
    padding: 4,
    width: 256,
    height: 256,
    typeNumber: 4,
    color: "#000000",
    background: "#ffffff",
    ecl: "M",
    image: {
      svg: "",
      width: 0,
      height: 0
    }
  };
  if (typeof options === "string") {
    options = {
      content: options
    };
  }
  if (options) {
    for (var i2 in options) {
      this.options[i2] = options[i2];
    }
  }
  if (typeof this.options.content !== "string") {
    throw new Error("Expected 'content' as string!");
  }
  if (this.options.content.length === 0) {
    throw new Error("Expected 'content' to be non-empty!");
  }
  if (!(this.options.padding >= 0)) {
    throw new Error("Expected 'padding' value to be non-negative!");
  }
  if (!(this.options.width > 0) || !(this.options.height > 0)) {
    throw new Error("Expected 'width' or 'height' value to be higher than zero!");
  }
  function _getErrorCorrectLevel(ecl2) {
    switch (ecl2) {
      case "L":
        return QRErrorCorrectLevel.L;
      case "M":
        return QRErrorCorrectLevel.M;
      case "Q":
        return QRErrorCorrectLevel.Q;
      case "H":
        return QRErrorCorrectLevel.H;
      default:
        throw new Error("Unknwon error correction level: " + ecl2);
    }
  }
  function _getTypeNumber(content2, ecl2) {
    var length = _getUTF8Length(content2);
    var type2 = 1;
    var limit = 0;
    for (var i3 = 0, len2 = QRCodeLimitLength.length; i3 <= len2; i3++) {
      var table = QRCodeLimitLength[i3];
      if (!table) {
        throw new Error("Content too long: expected " + limit + " but got " + length);
      }
      switch (ecl2) {
        case "L":
          limit = table[0];
          break;
        case "M":
          limit = table[1];
          break;
        case "Q":
          limit = table[2];
          break;
        case "H":
          limit = table[3];
          break;
        default:
          throw new Error("Unknwon error correction level: " + ecl2);
      }
      if (length <= limit) {
        break;
      }
      type2++;
    }
    if (type2 > QRCodeLimitLength.length) {
      throw new Error("Content too long");
    }
    return type2;
  }
  function _getUTF8Length(content2) {
    var result = encodeURI(content2).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
    return result.length + (result.length != content2 ? 3 : 0);
  }
  var content = this.options.content;
  var type = _getTypeNumber(content, this.options.ecl);
  var ecl = _getErrorCorrectLevel(this.options.ecl);
  this.qrcode = new QRCodeModel(type, ecl);
  this.qrcode.addData(content);
  this.qrcode.make();
}
QRCode$1.prototype.svg = function(opt) {
  var options = this.options || {};
  var modules = this.qrcode.modules;
  if (typeof opt == "undefined") {
    opt = { container: options.container || "svg" };
  }
  var pretty = typeof options.pretty != "undefined" ? !!options.pretty : true;
  var indent2 = pretty ? "  " : "";
  var EOL = pretty ? "\r\n" : "";
  var width = options.width;
  var height = options.height;
  var length = modules.length;
  var xsize = width / (length + 2 * options.padding);
  var ysize = height / (length + 2 * options.padding);
  var join = typeof options.join != "undefined" ? !!options.join : false;
  var swap = typeof options.swap != "undefined" ? !!options.swap : false;
  var xmlDeclaration = typeof options.xmlDeclaration != "undefined" ? !!options.xmlDeclaration : true;
  var predefined = typeof options.predefined != "undefined" ? !!options.predefined : false;
  var defs = predefined ? indent2 + '<defs><path id="qrmodule" d="M0 0 h' + ysize + " v" + xsize + ' H0 z" style="fill:' + options.color + ';shape-rendering:crispEdges;" /></defs>' + EOL : "";
  var bgrect = indent2 + '<rect x="0" y="0" width="' + width + '" height="' + height + '" style="fill:' + options.background + ';shape-rendering:crispEdges;"/>' + EOL;
  var modrect = "";
  var pathdata = "";
  for (var y2 = 0; y2 < length; y2++) {
    for (var x2 = 0; x2 < length; x2++) {
      var module2 = modules[x2][y2];
      if (module2) {
        var px = x2 * xsize + options.padding * xsize;
        var py = y2 * ysize + options.padding * ysize;
        if (swap) {
          var t2 = px;
          px = py;
          py = t2;
        }
        if (join) {
          var w2 = xsize + px;
          var h2 = ysize + py;
          px = Number.isInteger(px) ? Number(px) : px.toFixed(2);
          py = Number.isInteger(py) ? Number(py) : py.toFixed(2);
          w2 = Number.isInteger(w2) ? Number(w2) : w2.toFixed(2);
          h2 = Number.isInteger(h2) ? Number(h2) : h2.toFixed(2);
          pathdata += "M" + px + "," + py + " V" + h2 + " H" + w2 + " V" + py + " H" + px + " Z ";
        } else if (predefined) {
          modrect += indent2 + '<use x="' + px.toString() + '" y="' + py.toString() + '" href="#qrmodule" />' + EOL;
        } else {
          modrect += indent2 + '<rect x="' + px.toString() + '" y="' + py.toString() + '" width="' + xsize + '" height="' + ysize + '" style="fill:' + options.color + ';shape-rendering:crispEdges;"/>' + EOL;
        }
      }
    }
  }
  if (join) {
    modrect = indent2 + '<path x="0" y="0" style="fill:' + options.color + ';shape-rendering:crispEdges;" d="' + pathdata + '" />';
  }
  let imgSvg = "";
  if (this.options.image !== void 0 && this.options.image.svg) {
    const imgWidth = width * this.options.image.width / 100;
    const imgHeight = height * this.options.image.height / 100;
    const imgX = width / 2 - imgWidth / 2;
    const imgY = height / 2 - imgHeight / 2;
    imgSvg += `<svg x="${imgX}" y="${imgY}" width="${imgWidth}" height="${imgHeight}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`;
    imgSvg += this.options.image.svg + EOL;
    imgSvg += "</svg>";
  }
  var svg = "";
  switch (opt.container) {
    case "svg":
      if (xmlDeclaration) {
        svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
      }
      svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + width + '" height="' + height + '">' + EOL;
      svg += defs + bgrect + modrect;
      svg += imgSvg;
      svg += "</svg>";
      break;
    case "svg-viewbox":
      if (xmlDeclaration) {
        svg += '<?xml version="1.0" standalone="yes"?>' + EOL;
      }
      svg += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + width + " " + height + '">' + EOL;
      svg += defs + bgrect + modrect;
      svg += imgSvg;
      svg += "</svg>";
      break;
    case "g":
      svg += '<g width="' + width + '" height="' + height + '">' + EOL;
      svg += defs + bgrect + modrect;
      svg += imgSvg;
      svg += "</g>";
      break;
    default:
      svg += (defs + bgrect + modrect + imgSvg).replace(/^\s+/, "");
      break;
  }
  return svg;
};
var qrcodeSvg = QRCode$1;
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(QRCode$2, "__esModule", { value: true });
QRCode$2.QRCode = void 0;
const preact_1$5 = require$$1;
const hooks_1$3 = require$$2;
const qrcode_svg_1 = __importDefault$6(qrcodeSvg);
const QRCode = (props) => {
  const [svg, setSvg] = (0, hooks_1$3.useState)("");
  (0, hooks_1$3.useEffect)(() => {
    var _a2, _b2;
    const qrcode2 = new qrcode_svg_1.default({
      content: props.content,
      background: props.bgColor || "#ffffff",
      color: props.fgColor || "#000000",
      container: "svg",
      ecl: "M",
      width: (_a2 = props.width) !== null && _a2 !== void 0 ? _a2 : 256,
      height: (_b2 = props.height) !== null && _b2 !== void 0 ? _b2 : 256,
      padding: 0,
      image: props.image
    });
    const base64 = buffer$2.Buffer.from(qrcode2.svg(), "utf8").toString("base64");
    setSvg(`data:image/svg+xml;base64,${base64}`);
  });
  return svg ? (0, preact_1$5.h)("img", { src: svg, alt: "QR Code" }) : null;
};
QRCode$2.QRCode = QRCode;
var Spinner$1 = {};
var SpinnerCss = {};
Object.defineProperty(SpinnerCss, "__esModule", { value: true });
SpinnerCss.default = `.-walletlink-css-reset .-walletlink-spinner{display:inline-block}.-walletlink-css-reset .-walletlink-spinner svg{display:inline-block;animation:2s linear infinite -walletlink-spinner-svg}.-walletlink-css-reset .-walletlink-spinner svg circle{animation:1.9s ease-in-out infinite both -walletlink-spinner-circle;display:block;fill:transparent;stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -walletlink-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -walletlink-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}`;
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(Spinner$1, "__esModule", { value: true });
Spinner$1.Spinner = void 0;
const preact_1$4 = require$$1;
const Spinner_css_1 = __importDefault$5(SpinnerCss);
const Spinner = (props) => {
  var _a2;
  const size2 = (_a2 = props.size) !== null && _a2 !== void 0 ? _a2 : 64;
  const color = props.color || "#000";
  return (0, preact_1$4.h)("div", { class: "-walletlink-spinner" }, (0, preact_1$4.h)("style", null, Spinner_css_1.default), (0, preact_1$4.h)("svg", { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", style: { width: size2, height: size2 } }, (0, preact_1$4.h)("circle", { style: { cx: 50, cy: 50, r: 45, stroke: color } })));
};
Spinner$1.Spinner = Spinner;
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(LinkDialog$1, "__esModule", { value: true });
LinkDialog$1.LinkDialog = void 0;
const clsx_1$2 = __importDefault$4(require$$0);
const preact_1$3 = require$$1;
const hooks_1$2 = require$$2;
const LinkDialog_css_1 = __importDefault$4(LinkDialogCss);
const QRCode_1$1 = QRCode$2;
const Spinner_1$1 = Spinner$1;
const LinkDialog = (props) => {
  const [isContainerHidden, setContainerHidden] = (0, hooks_1$2.useState)(!props.isOpen);
  const [isDialogHidden, setDialogHidden] = (0, hooks_1$2.useState)(!props.isOpen);
  (0, hooks_1$2.useEffect)(() => {
    const { isOpen } = props;
    const timers = [
      window.setTimeout(() => {
        setDialogHidden(!isOpen);
      }, 10)
    ];
    if (isOpen) {
      setContainerHidden(false);
    } else {
      timers.push(window.setTimeout(() => {
        setContainerHidden(true);
      }, 360));
    }
    return () => {
      timers.forEach(window.clearTimeout);
    };
  }, [props.isOpen]);
  return (0, preact_1$3.h)("div", { class: (0, clsx_1$2.default)("-walletlink-link-dialog-container", props.darkMode && "-walletlink-link-dialog-container-dark", isContainerHidden && "-walletlink-link-dialog-container-hidden") }, (0, preact_1$3.h)("style", null, LinkDialog_css_1.default), (0, preact_1$3.h)("div", { class: (0, clsx_1$2.default)("-walletlink-link-dialog-backdrop", isDialogHidden && "-walletlink-link-dialog-backdrop-hidden") }), (0, preact_1$3.h)("div", { class: "-walletlink-link-dialog" }, (0, preact_1$3.h)("div", { class: (0, clsx_1$2.default)("-walletlink-link-dialog-box", isDialogHidden && "-walletlink-link-dialog-box-hidden") }, (0, preact_1$3.h)(ScanQRCode, { darkMode: props.darkMode, version: props.version, sessionId: props.sessionId, sessionSecret: props.sessionSecret, walletLinkUrl: props.walletLinkUrl, isConnected: props.isConnected, isParentConnection: props.isParentConnection }), props.onCancel && (0, preact_1$3.h)(CancelButton$1, { onClick: props.onCancel }))));
};
LinkDialog$1.LinkDialog = LinkDialog;
const ScanQRCode = (props) => {
  const serverUrl = window.encodeURIComponent(props.walletLinkUrl);
  const sessionIdKey = props.isParentConnection ? "parent-id" : "id";
  const qrUrl = `${props.walletLinkUrl}/#/link?${sessionIdKey}=${props.sessionId}&secret=${props.sessionSecret}&server=${serverUrl}&v=1`;
  return (0, preact_1$3.h)("div", { class: "-walletlink-link-dialog-box-content" }, (0, preact_1$3.h)("h3", null, "Scan to", (0, preact_1$3.h)("br", null), " Connect"), (0, preact_1$3.h)("div", { class: "-walletlink-link-dialog-box-content-qrcode" }, (0, preact_1$3.h)("div", { class: "-walletlink-link-dialog-box-content-qrcode-wrapper" }, (0, preact_1$3.h)(QRCode_1$1.QRCode, { content: qrUrl, width: 224, height: 224, fgColor: "#000", bgColor: "transparent" })), (0, preact_1$3.h)("input", { type: "hidden", value: qrUrl }), !props.isConnected && (0, preact_1$3.h)("div", { class: "-walletlink-link-dialog-box-content-qrcode-connecting" }, (0, preact_1$3.h)(Spinner_1$1.Spinner, { size: 128, color: props.darkMode ? "#fff" : "#000" }), (0, preact_1$3.h)("p", null, "Connecting...")), (0, preact_1$3.h)("p", { title: `WalletLink v${props.version}` }, "Powered by WalletLink")), (0, preact_1$3.h)("a", { href: `${props.walletLinkUrl}/#/wallets`, target: "_blank", rel: "noopener" }, "Don\u2019t have a wallet app?"));
};
const CancelButton$1 = (props) => (0, preact_1$3.h)("button", { class: "-walletlink-link-dialog-box-cancel", onClick: props.onClick }, (0, preact_1$3.h)("div", { class: "-walletlink-link-dialog-box-cancel-x" }));
var TryExtensionLinkDialog$1 = {};
var globeIconSvg = {};
Object.defineProperty(globeIconSvg, "__esModule", { value: true });
globeIconSvg.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTggMEMzLjU4IDAgMCAzLjU4IDAgOHMzLjU4IDggOCA4IDgtMy41OCA4LTgtMy41OC04LTgtOFptNS45MSA3aC0xLjk0Yy0uMS0xLjU3LS40Mi0zLS45MS00LjE1IDEuNDguODggMi41NSAyLjM4IDIuODUgNC4xNVpNOCAxNGMtLjQ1IDAtMS43Mi0xLjc3LTEuOTUtNWgzLjljLS4yMyAzLjIzLTEuNSA1LTEuOTUgNVpNNi4wNSA3QzYuMjggMy43NyA3LjU1IDIgOCAyYy40NSAwIDEuNzIgMS43NyAxLjk1IDVoLTMuOVpNNC45NCAyLjg1QzQuNDYgNCA0LjEzIDUuNDMgNC4wMyA3SDIuMDljLjMtMS43NyAxLjM3LTMuMjcgMi44NS00LjE1Wk0yLjA5IDloMS45NGMuMSAxLjU3LjQyIDMgLjkxIDQuMTVBNS45OTggNS45OTggMCAwIDEgMi4wOSA5Wm04Ljk3IDQuMTVjLjQ4LTEuMTUuODEtMi41OC45MS00LjE1aDEuOTRhNS45OTggNS45OTggMCAwIDEtMi44NSA0LjE1WiIgZmlsbD0iIzE2NTJGMCIvPjwvc3ZnPg==`;
var linkIconSvg = {};
Object.defineProperty(linkIconSvg, "__esModule", { value: true });
linkIconSvg.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTciIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE1LjYzNSAyLjExN2EzLjg4OSAzLjg4OSAwIDAgMC01LjUyMSAwTDYuODkgNS4zMzVBMy44OTQgMy44OTQgMCAwIDAgNS44IDguNzM5Yy4wODMuNTA2LjI2OCAxLjAxMS41NTMgMS40NjYuMTUxLjI1My4zMzYuNDcyLjUzNy42OTFsLjYyMS42MjQgMS4xNDEtMS4xNDYtLjYyLS42MjRhMi4xMDUgMi4xMDUgMCAwIDEtLjQ4Ny0uNzQxIDIuMzQgMi4zNCAwIDAgMSAuNTAzLTIuNTFsMy4yMDYtMy4yMmEyLjI5MyAyLjI5MyAwIDAgMSAzLjIzOSAwYy44OS44OTQuODkgMi4zNDMgMCAzLjI1M2wtMS41MjcgMS41MzNjLjIzNC42NC4zMzUgMS4zMzEuMzAyIDIuMDA1bDIuMzgzLTIuMzkyYzEuNTEtMS41MzQgMS40OTMtNC4wMjgtLjAxNy01LjU2MVoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBkPSJNMTEuMjcxIDcuNzQ1YTMuMTMgMy4xMyAwIDAgMC0uNTU0LS42OWwtLjYyLS42MjQtMS4xNDIgMS4xNDYuNjIxLjYyM2MuMjE4LjIyLjM4Ni40ODkuNDg3Ljc1OC4zMzUuODI2LjE2NyAxLjgyLS41MDQgMi40OTRsLTMuMjA1IDMuMjE5YTIuMjkzIDIuMjkzIDAgMCAxLTMuMjQgMCAyLjMxNiAyLjMxNiAwIDAgMSAwLTMuMjUybDEuNTI4LTEuNTM0YTQuODE1IDQuODE1IDAgMCAxLS4yODUtMi4wMDVsLTIuMzgzIDIuMzkzYTMuOTI3IDMuOTI3IDAgMCAwIDAgNS41NDQgMy45MDkgMy45MDkgMCAwIDAgNS41MzggMGwzLjIwNS0zLjIxOWEzLjk1OCAzLjk1OCAwIDAgMCAxLjA5MS0zLjQwNCA0LjIxMSA0LjIxMSAwIDAgMC0uNTM3LTEuNDQ5WiIgZmlsbD0iIzE2NTJGMCIvPjwvc3ZnPg==`;
var lockIconSvg = {};
Object.defineProperty(lockIconSvg, "__esModule", { value: true });
lockIconSvg.default = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEgN3Y5aDE0VjdIMVptNy41IDQuMzlWMTRoLTF2LTIuNjFjLS40NC0uMTktLjc1LS42My0uNzUtMS4xNGExLjI1IDEuMjUgMCAwIDEgMi41IDBjMCAuNTEtLjMxLjk1LS43NSAxLjE0Wk01LjY3IDZWNC4zM0M1LjY3IDMuMDUgNi43MSAyIDggMnMyLjMzIDEuMDUgMi4zMyAyLjMzVjZoMlY0LjMzQzEyLjMzIDEuOTQgMTAuMzkgMCA4IDBTMy42NyAxLjk0IDMuNjcgNC4zM1Y2aDJaIiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
var QRLogo = {};
Object.defineProperty(QRLogo, "__esModule", { value: true });
QRLogo.default = `<svg width="100" height="100" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="50" cy="50" r="50" fill="white"/>
<circle cx="49.9996" cy="49.9996" r="43.6363" fill="#1B53E4"/>
<circle cx="49.9996" cy="49.9996" r="43.6363" stroke="white"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M19.3379 49.9484C19.3379 66.8508 33.04 80.553 49.9425 80.553C66.8449 80.553 80.5471 66.8508 80.5471 49.9484C80.5471 33.0459 66.8449 19.3438 49.9425 19.3438C33.04 19.3438 19.3379 33.0459 19.3379 49.9484ZM44.0817 40.0799C41.8725 40.0799 40.0817 41.8708 40.0817 44.0799V55.8029C40.0817 58.012 41.8725 59.8029 44.0817 59.8029H55.8046C58.0138 59.8029 59.8046 58.012 59.8046 55.8029V44.0799C59.8046 41.8708 58.0138 40.0799 55.8046 40.0799H44.0817Z" fill="white"/>
</svg>

`;
var TryExtensionLinkDialogCss = {};
Object.defineProperty(TryExtensionLinkDialogCss, "__esModule", { value: true });
TryExtensionLinkDialogCss.default = `.-walletlink-css-reset .-walletlink-extension-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-walletlink-css-reset .-walletlink-extension-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;background-color:rgba(0,0,0,.5);transition:opacity .25s}.-walletlink-css-reset .-walletlink-extension-dialog-backdrop-hidden{opacity:0}.-walletlink-css-reset .-walletlink-extension-dialog-box{display:flex;position:relative;max-width:500px;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-walletlink-css-reset .-walletlink-extension-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-walletlink-css-reset .-walletlink-extension-dialog-box-top{display:flex;flex-direction:row;background-color:#fff;border-radius:8px;overflow:hidden;min-height:300px}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-install-region{display:flex;flex-basis:50%;flex-direction:column;justify-content:center;padding:32px}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-install-region button{display:block;border-radius:8px;background-color:#1652f0;color:#fff;width:90%;min-width:fit-content;height:44px;margin-top:16px;font-size:16px;padding-left:16px;padding-right:16px;cursor:pointer;font-weight:500;text-align:center}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-info-region{display:flex;flex-basis:50%;flex-direction:column;justify-content:center;background-color:#fafbfc}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-description{display:flex;flex-direction:row;align-items:center;padding-top:14px;padding-bottom:14px;padding-left:24px;padding-right:32px}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-description-icon-wrapper{display:block;position:relative;width:40px;height:40px;flex-shrink:0;flex-grow:0;border-radius:20px;background-color:#fff;box-shadow:0px 0px 8px rgba(0,0,0,.04),0px 16px 24px rgba(0,0,0,.06)}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-description-icon-wrapper img{position:absolute;top:0;bottom:0;left:0;right:0;margin:auto}.-walletlink-css-reset .-walletlink-extension-dialog-box-top-description-text{margin-left:16px;flex-grow:1;font-size:13px;line-height:19px;color:#000;align-self:center}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom{display:flex;flex-direction:row;overflow:hidden;border-radius:8px;background-color:#fff;margin-top:8px}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-description-region{display:flex;flex-direction:column;justify-content:center;padding:32px;flex-grow:1}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-description{font-size:13px;line-height:19px;margin-top:12px;color:#aaa}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-description a{font-size:inherit;line-height:inherit;color:#1652f0;cursor:pointer}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-region{position:relative;flex-shrink:0;display:flex;flex-direction:column;justify-content:center;padding-left:24px;padding-right:24px;padding-top:16px;padding-bottom:16px}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-wrapper{position:relative;display:block;padding:8px;border-radius:8px;box-shadow:0px 4px 12px rgba(0,0,0,.1)}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-wrapper img{display:block}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background-color:rgba(255,255,255,.95)}.-walletlink-css-reset .-walletlink-extension-dialog-box-bottom-qr-connecting>p{font-size:12px;font-weight:bold;color:#000;margin-top:16px}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel{position:absolute;-webkit-appearance:none;display:flex;align-items:center;justify-content:center;top:16px;right:16px;width:24px;height:24px;border-radius:12px;background-color:#fafbfc;cursor:pointer}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x{position:relative;display:block;cursor:pointer}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x::before,.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x::after{content:"";position:absolute;display:block;top:-1px;left:-7px;width:14px;height:1px;background-color:#000;transition:background-color .2s}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x::before{transform:rotate(45deg)}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel-x::after{transform:rotate(135deg)}.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x-a,.-walletlink-css-reset .-walletlink-extension-dialog-box-cancel:hover .-walletlink-link-dialog-box-cancel-x-b{background-color:#000}.-walletlink-css-reset .-walletlink-extension-dialog-container{display:block}.-walletlink-css-reset .-walletlink-extension-dialog-container-hidden{display:none}.-walletlink-css-reset .-walletlink-extension-dialog h2{display:block;text-align:left;font-size:22px;font-weight:600;line-height:28px;color:#000}`;
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(TryExtensionLinkDialog$1, "__esModule", { value: true });
TryExtensionLinkDialog$1.TryExtensionLinkDialog = void 0;
const clsx_1$1 = __importDefault$3(require$$0);
const preact_1$2 = require$$1;
const hooks_1$1 = require$$2;
const globe_icon_svg_1 = __importDefault$3(globeIconSvg);
const link_icon_svg_1 = __importDefault$3(linkIconSvg);
const lock_icon_svg_1 = __importDefault$3(lockIconSvg);
const QRLogo_1 = __importDefault$3(QRLogo);
const QRCode_1 = QRCode$2;
const Spinner_1 = Spinner$1;
const TryExtensionLinkDialog_css_1 = __importDefault$3(TryExtensionLinkDialogCss);
const TryExtensionLinkDialog = (props) => {
  const [isContainerHidden, setContainerHidden] = (0, hooks_1$1.useState)(!props.isOpen);
  const [isDialogHidden, setDialogHidden] = (0, hooks_1$1.useState)(!props.isOpen);
  (0, hooks_1$1.useEffect)(() => {
    const { isOpen } = props;
    const timers = [
      window.setTimeout(() => {
        setDialogHidden(!isOpen);
      }, 10)
    ];
    if (isOpen) {
      setContainerHidden(false);
    } else {
      timers.push(window.setTimeout(() => {
        setContainerHidden(true);
      }, 360));
    }
    return () => {
      timers.forEach(window.clearTimeout);
    };
  }, [props.isOpen]);
  return (0, preact_1$2.h)("div", { class: (0, clsx_1$1.default)("-walletlink-extension-dialog-container", isContainerHidden && "-walletlink-extension-dialog-container-hidden") }, (0, preact_1$2.h)("style", null, TryExtensionLinkDialog_css_1.default), (0, preact_1$2.h)("div", { class: (0, clsx_1$1.default)("-walletlink-extension-dialog-backdrop", isDialogHidden && "-walletlink-extension-dialog-backdrop-hidden") }), (0, preact_1$2.h)("div", { class: "-walletlink-extension-dialog" }, (0, preact_1$2.h)("div", { class: (0, clsx_1$1.default)("-walletlink-extension-dialog-box", isDialogHidden && "-walletlink-extension-dialog-box-hidden") }, (0, preact_1$2.h)(TryExtensionBox, { onInstallClick: () => {
    window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank");
  } }), !props.connectDisabled ? (0, preact_1$2.h)(ScanQRBox, { darkMode: props.darkMode, version: props.version, sessionId: props.sessionId, sessionSecret: props.sessionSecret, walletLinkUrl: props.walletLinkUrl, isConnected: props.isConnected, isParentConnection: props.isParentConnection }) : null, props.onCancel && (0, preact_1$2.h)(CancelButton, { onClick: props.onCancel }))));
};
TryExtensionLinkDialog$1.TryExtensionLinkDialog = TryExtensionLinkDialog;
const TryExtensionBox = (props) => {
  return (0, preact_1$2.h)("div", { class: "-walletlink-extension-dialog-box-top" }, (0, preact_1$2.h)("div", { class: "-walletlink-extension-dialog-box-top-install-region" }, (0, preact_1$2.h)("h2", null, "Try the Coinbase Wallet extension"), (0, preact_1$2.h)("button", { onClick: props.onInstallClick }, "Install")), (0, preact_1$2.h)("div", { class: "-walletlink-extension-dialog-box-top-info-region" }, (0, preact_1$2.h)(DescriptionItem, { icon: link_icon_svg_1.default, text: "Connect to crypto apps with one click" }), (0, preact_1$2.h)(DescriptionItem, { icon: lock_icon_svg_1.default, text: "Your private key is stored securely" }), (0, preact_1$2.h)(DescriptionItem, { icon: globe_icon_svg_1.default, text: "Works with Ethereum, Polygon, and more" })));
};
const ScanQRBox = (props) => {
  const serverUrl = window.encodeURIComponent(props.walletLinkUrl);
  const sessionIdKey = props.isParentConnection ? "parent-id" : "id";
  const qrUrl = `${props.walletLinkUrl}/#/link?${sessionIdKey}=${props.sessionId}&secret=${props.sessionSecret}&server=${serverUrl}&v=1`;
  return (0, preact_1$2.h)("div", { class: "-walletlink-extension-dialog-box-bottom" }, (0, preact_1$2.h)("div", { class: "-walletlink-extension-dialog-box-bottom-description-region" }, (0, preact_1$2.h)("h2", null, "Or scan to connect"), (0, preact_1$2.h)("body", { class: "-walletlink-extension-dialog-box-bottom-description" }, "Open ", (0, preact_1$2.h)("a", { href: "https://wallet.coinbase.com/" }, "Coinbase Wallet"), " on your mobile phone and scan")), (0, preact_1$2.h)("div", { class: "-walletlink-extension-dialog-box-bottom-qr-region" }, (0, preact_1$2.h)("div", { class: "-walletlink-extension-dialog-box-bottom-qr-wrapper" }, (0, preact_1$2.h)(QRCode_1.QRCode, { content: qrUrl, width: 150, height: 150, fgColor: "#000", bgColor: "transparent", image: {
    svg: QRLogo_1.default,
    width: 34,
    height: 34
  } })), (0, preact_1$2.h)("input", { type: "hidden", value: qrUrl }), !props.isConnected && (0, preact_1$2.h)("div", { class: "-walletlink-extension-dialog-box-bottom-qr-connecting" }, (0, preact_1$2.h)(Spinner_1.Spinner, { size: 36, color: "#000" }), (0, preact_1$2.h)("p", null, "Connecting..."))));
};
const DescriptionItem = (props) => {
  return (0, preact_1$2.h)("div", { class: "-walletlink-extension-dialog-box-top-description" }, (0, preact_1$2.h)("div", { class: "-walletlink-extension-dialog-box-top-description-icon-wrapper" }, (0, preact_1$2.h)("img", { src: props.icon })), (0, preact_1$2.h)("body", { class: "-walletlink-extension-dialog-box-top-description-text" }, props.text));
};
const CancelButton = (props) => (0, preact_1$2.h)("button", { class: "-walletlink-extension-dialog-box-cancel", onClick: props.onClick }, (0, preact_1$2.h)("div", { class: "-walletlink-extension-dialog-box-cancel-x" }));
Object.defineProperty(LinkFlow$1, "__esModule", { value: true });
LinkFlow$1.LinkFlow = void 0;
const preact_1$1 = require$$1;
const rxjs_1$3 = require$$1$1;
const operators_1$2 = require$$2$1;
const LinkDialog_1 = LinkDialog$1;
const TryExtensionLinkDialog_1 = TryExtensionLinkDialog$1;
class LinkFlow {
  constructor(options) {
    this.extensionUI$ = new rxjs_1$3.BehaviorSubject({});
    this.subscriptions = new rxjs_1$3.Subscription();
    this.isConnected = false;
    this.isOpen = false;
    this.onCancel = null;
    this.root = null;
    this.connectDisabled = false;
    this.darkMode = options.darkMode;
    this.version = options.version;
    this.sessionId = options.sessionId;
    this.sessionSecret = options.sessionSecret;
    this.walletLinkUrl = options.walletLinkUrl;
    this.isParentConnection = options.isParentConnection;
    this.connected$ = options.connected$;
    fetch("https://api.wallet.coinbase.com/rpc/v2/getFeatureFlags").then((res) => res.json()).then((json2) => {
      const enabled = json2.result.desktop.extension_ui;
      if (typeof enabled === "undefined") {
        this.extensionUI$.next({ value: false });
      } else {
        this.extensionUI$.next({ value: enabled });
      }
    }).catch((err) => {
      console.error("Couldn't fetch feature flags - ", err);
      this.extensionUI$.next({ value: false });
    });
  }
  attach(el) {
    this.root = document.createElement("div");
    this.root.className = "-walletlink-link-flow-root";
    el.appendChild(this.root);
    this.render();
    this.subscriptions.add(this.connected$.subscribe((v2) => {
      if (this.isConnected !== v2) {
        this.isConnected = v2;
        this.render();
      }
    }));
  }
  detach() {
    var _a2;
    if (!this.root) {
      return;
    }
    this.subscriptions.unsubscribe();
    (0, preact_1$1.render)(null, this.root);
    (_a2 = this.root.parentElement) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.root);
  }
  setConnectDisabled(connectDisabled) {
    this.connectDisabled = connectDisabled;
  }
  open(options) {
    this.isOpen = true;
    this.onCancel = options.onCancel;
    this.render();
  }
  close() {
    this.isOpen = false;
    this.onCancel = null;
    this.render();
  }
  render() {
    if (!this.root) {
      return;
    }
    const subscription = this.extensionUI$.pipe((0, operators_1$2.first)((enabled) => enabled.value !== void 0)).subscribe((enabled) => {
      if (!this.root) {
        return;
      }
      (0, preact_1$1.render)(enabled.value ? (0, preact_1$1.h)(TryExtensionLinkDialog_1.TryExtensionLinkDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, walletLinkUrl: this.walletLinkUrl, isOpen: this.isOpen, isConnected: this.isConnected, isParentConnection: this.isParentConnection, onCancel: this.onCancel, connectDisabled: this.connectDisabled }) : (0, preact_1$1.h)(LinkDialog_1.LinkDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, walletLinkUrl: this.walletLinkUrl, isOpen: this.isOpen, isConnected: this.isConnected, isParentConnection: this.isParentConnection, onCancel: this.onCancel }), this.root);
    });
    this.subscriptions.add(subscription);
  }
}
LinkFlow$1.LinkFlow = LinkFlow;
var Snackbar$1 = {};
var SnackbarCss = {};
Object.defineProperty(SnackbarCss, "__esModule", { value: true });
SnackbarCss.default = `.-walletlink-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-walletlink-css-reset .-gear-container *{user-select:none}.-walletlink-css-reset .-gear-container svg{opacity:0;position:absolute}.-walletlink-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-walletlink-css-reset .-walletlink-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-walletlink-css-reset .-walletlink-snackbar *{user-select:none}.-walletlink-css-reset .-walletlink-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-walletlink-css-reset .-walletlink-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-walletlink-css-reset .-walletlink-snackbar-instance-header *{cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-walletlink-css-reset .-walletlink-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-walletlink-css-reset .-walletlink-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-walletlink-css-reset .-walletlink-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-walletlink-css-reset .-walletlink-snackbar-instance-expanded .-walletlink-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}`;
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(Snackbar$1, "__esModule", { value: true });
Snackbar$1.Snackbar = void 0;
const clsx_1 = __importDefault$2(require$$0);
const preact_1 = require$$1;
const hooks_1 = require$$2;
const Snackbar_css_1 = __importDefault$2(SnackbarCss);
const cblogo = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+`;
const gearIcon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=`;
class Snackbar {
  constructor(options) {
    this.items = new Map();
    this.nextItemKey = 0;
    this.root = null;
    this.darkMode = options.darkMode;
  }
  attach(el) {
    this.root = document.createElement("div");
    this.root.className = "-walletlink-snackbar-root";
    el.appendChild(this.root);
    this.render();
  }
  presentItem(itemProps) {
    const key2 = this.nextItemKey++;
    this.items.set(key2, itemProps);
    this.render();
    return () => {
      this.items.delete(key2);
      this.render();
    };
  }
  clear() {
    this.items.clear();
    this.render();
  }
  render() {
    if (!this.root) {
      return;
    }
    (0, preact_1.render)((0, preact_1.h)("div", null, (0, preact_1.h)(SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([key2, itemProps]) => (0, preact_1.h)(SnackbarInstance, Object.assign({}, itemProps, { key: key2 }))))), this.root);
  }
}
Snackbar$1.Snackbar = Snackbar;
const SnackbarContainer = (props) => (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-snackbar-container") }, (0, preact_1.h)("style", null, Snackbar_css_1.default), (0, preact_1.h)("div", { class: "-walletlink-snackbar" }, props.children));
const SnackbarInstance = ({ message, menuItems }) => {
  const [hidden, setHidden] = (0, hooks_1.useState)(true);
  const [expanded, setExpanded] = (0, hooks_1.useState)(false);
  (0, hooks_1.useEffect)(() => {
    const timers = [
      window.setTimeout(() => {
        setHidden(false);
      }, 1),
      window.setTimeout(() => {
        setExpanded(true);
      }, 1e4)
    ];
    return () => {
      timers.forEach(window.clearTimeout);
    };
  });
  const toggleExpanded = () => {
    setExpanded(!expanded);
  };
  return (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-snackbar-instance", hidden && "-walletlink-snackbar-instance-hidden", expanded && "-walletlink-snackbar-instance-expanded") }, (0, preact_1.h)("div", { class: "-walletlink-snackbar-instance-header", onClick: toggleExpanded }, (0, preact_1.h)("img", { src: cblogo, class: "-walletlink-snackbar-instance-header-cblogo" }), (0, preact_1.h)("div", { class: "-walletlink-snackbar-instance-header-message" }, message), (0, preact_1.h)("div", { class: "-gear-container" }, !expanded && (0, preact_1.h)("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, (0, preact_1.h)("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })), (0, preact_1.h)("img", { src: gearIcon, class: "-gear-icon", title: "Expand" }))), menuItems && menuItems.length > 0 && (0, preact_1.h)("div", { class: "-walletlink-snackbar-instance-menu" }, menuItems.map((action, i2) => (0, preact_1.h)("div", { class: (0, clsx_1.default)("-walletlink-snackbar-instance-menu-item", action.isRed && "-walletlink-snackbar-instance-menu-item-is-red"), onClick: action.onClick, key: i2 }, (0, preact_1.h)("svg", { width: action.svgWidth, height: action.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, (0, preact_1.h)("path", { "fill-rule": action.defaultFillRule, "clip-rule": action.defaultClipRule, d: action.path, fill: "#AAAAAA" })), (0, preact_1.h)("span", { class: (0, clsx_1.default)("-walletlink-snackbar-instance-menu-item-info", action.isRed && "-walletlink-snackbar-instance-menu-item-info-is-red") }, action.info)))));
};
var cssReset = {};
var cssResetCss = {};
Object.defineProperty(cssResetCss, "__esModule", { value: true });
cssResetCss.default = `@namespace svg "http://www.w3.org/2000/svg";.-walletlink-css-reset,.-walletlink-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;bottom:auto;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;content:normal;counter-increment:none;counter-reset:none;cursor:auto;direction:ltr;display:block;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;left:auto;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;max-height:none;max-width:none;min-height:0;min-width:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";right:auto;tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;top:auto;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;width:auto;word-spacing:normal;z-index:auto}.-walletlink-css-reset *{box-sizing:border-box;display:initial;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-walletlink-css-reset [class*=container]{margin:0;padding:0}.-walletlink-css-reset style{display:none}`;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(cssReset, "__esModule", { value: true });
cssReset.injectCssReset = void 0;
const cssReset_css_1 = __importDefault$1(cssResetCss);
function injectCssReset() {
  const styleEl = document.createElement("style");
  styleEl.type = "text/css";
  styleEl.appendChild(document.createTextNode(cssReset_css_1.default));
  document.documentElement.appendChild(styleEl);
}
cssReset.injectCssReset = injectCssReset;
var WalletLinkUI$1 = {};
Object.defineProperty(WalletLinkUI$1, "__esModule", { value: true });
WalletLinkUI$1.WalletLinkUI = void 0;
class WalletLinkUI {
  constructor(_2) {
  }
  setConnectDisabled(_2) {
  }
}
WalletLinkUI$1.WalletLinkUI = WalletLinkUI;
Object.defineProperty(WalletLinkSdkUI$1, "__esModule", { value: true });
WalletLinkSdkUI$1.WalletLinkSdkUI = void 0;
const LinkFlow_1 = LinkFlow$1;
const Snackbar_1 = Snackbar$1;
const cssReset_1 = cssReset;
const WalletLinkUI_1 = WalletLinkUI$1;
class WalletLinkSdkUI extends WalletLinkUI_1.WalletLinkUI {
  constructor(options) {
    super(options);
    this.attached = false;
    this.snackbar = new Snackbar_1.Snackbar({
      darkMode: options.darkMode
    });
    this.linkFlow = new LinkFlow_1.LinkFlow({
      darkMode: options.darkMode,
      version: options.version,
      sessionId: options.session.id,
      sessionSecret: options.session.secret,
      walletLinkUrl: options.walletLinkUrl,
      connected$: options.connected$,
      isParentConnection: false
    });
  }
  attach() {
    if (this.attached) {
      throw new Error("WalletLinkUI is already attached");
    }
    const el = document.documentElement;
    const container = document.createElement("div");
    container.className = "-walletlink-css-reset";
    el.appendChild(container);
    this.linkFlow.attach(container);
    this.snackbar.attach(container);
    this.attached = true;
    (0, cssReset_1.injectCssReset)();
  }
  setConnectDisabled(connectDisabled) {
    this.linkFlow.setConnectDisabled(connectDisabled);
  }
  addEthereumChain(options) {
  }
  switchEthereumChain(options) {
  }
  requestEthereumAccounts(options) {
    this.linkFlow.open({ onCancel: options.onCancel });
  }
  hideRequestEthereumAccounts() {
    this.linkFlow.close();
  }
  signEthereumMessage(_2) {
  }
  signEthereumTransaction(_2) {
  }
  submitEthereumTransaction(_2) {
  }
  ethereumAddressFromSignedMessage(_2) {
  }
  showConnecting(options) {
    const snackbarProps = {
      message: "Confirm on phone",
      menuItems: [
        {
          isRed: true,
          info: "Cancel transaction",
          svgWidth: "11",
          svgHeight: "11",
          path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
          defaultFillRule: "inherit",
          defaultClipRule: "inherit",
          onClick: options.onCancel
        },
        {
          isRed: false,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: options.onResetConnection
        }
      ]
    };
    return this.snackbar.presentItem(snackbarProps);
  }
  reloadUI() {
    document.location.reload();
  }
  inlineAccountsResponse() {
    return false;
  }
  inlineAddEthereumChain(chainId) {
    return false;
  }
  inlineSwitchEthereumChain() {
    return false;
  }
  isStandalone() {
    return false;
  }
}
WalletLinkSdkUI$1.WalletLinkSdkUI = WalletLinkSdkUI;
var WalletLinkRelay$1 = {};
var bindDecorator = {};
Object.defineProperty(bindDecorator, "__esModule", { value: true });
var constants;
(function(constants2) {
  constants2.typeOfFunction = "function";
  constants2.boolTrue = true;
})(constants || (constants = {}));
function bind(target, propertyKey, descriptor) {
  if (!descriptor || typeof descriptor.value !== constants.typeOfFunction) {
    throw new TypeError("Only methods can be decorated with @bind. <" + propertyKey + "> is not a method!");
  }
  return {
    configurable: constants.boolTrue,
    get: function() {
      var bound = descriptor.value.bind(this);
      Object.defineProperty(this, propertyKey, {
        value: bound,
        configurable: constants.boolTrue,
        writable: constants.boolTrue
      });
      return bound;
    }
  };
}
bindDecorator.bind = bind;
bindDecorator.default = bind;
var WalletLinkConnection$1 = {};
var ClientMessage = {};
Object.defineProperty(ClientMessage, "__esModule", { value: true });
ClientMessage.ClientMessagePublishEvent = ClientMessage.ClientMessageSetSessionConfig = ClientMessage.ClientMessageGetSessionConfig = ClientMessage.ClientMessageIsLinked = ClientMessage.ClientMessageHostSession = void 0;
function ClientMessageHostSession(params) {
  return Object.assign({ type: "HostSession" }, params);
}
ClientMessage.ClientMessageHostSession = ClientMessageHostSession;
function ClientMessageIsLinked(params) {
  return Object.assign({ type: "IsLinked" }, params);
}
ClientMessage.ClientMessageIsLinked = ClientMessageIsLinked;
function ClientMessageGetSessionConfig(params) {
  return Object.assign({ type: "GetSessionConfig" }, params);
}
ClientMessage.ClientMessageGetSessionConfig = ClientMessageGetSessionConfig;
function ClientMessageSetSessionConfig(params) {
  return Object.assign({ type: "SetSessionConfig" }, params);
}
ClientMessage.ClientMessageSetSessionConfig = ClientMessageSetSessionConfig;
function ClientMessagePublishEvent(params) {
  return Object.assign({ type: "PublishEvent" }, params);
}
ClientMessage.ClientMessagePublishEvent = ClientMessagePublishEvent;
var RxWebSocket = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.RxWebSocket = exports2.ConnectionState = void 0;
  const rxjs_12 = require$$1$1;
  const operators_12 = require$$2$1;
  var ConnectionState;
  (function(ConnectionState2) {
    ConnectionState2[ConnectionState2["DISCONNECTED"] = 0] = "DISCONNECTED";
    ConnectionState2[ConnectionState2["CONNECTING"] = 1] = "CONNECTING";
    ConnectionState2[ConnectionState2["CONNECTED"] = 2] = "CONNECTED";
  })(ConnectionState = exports2.ConnectionState || (exports2.ConnectionState = {}));
  class RxWebSocket2 {
    constructor(url2, WebSocketClass = WebSocket) {
      this.WebSocketClass = WebSocketClass;
      this.webSocket = null;
      this.connectionStateSubject = new rxjs_12.BehaviorSubject(ConnectionState.DISCONNECTED);
      this.incomingDataSubject = new rxjs_12.Subject();
      this.url = url2.replace(/^http/, "ws");
    }
    connect() {
      if (this.webSocket) {
        return (0, rxjs_12.throwError)(new Error("webSocket object is not null"));
      }
      return new rxjs_12.Observable((obs) => {
        let webSocket;
        try {
          this.webSocket = webSocket = new this.WebSocketClass(this.url);
        } catch (err) {
          obs.error(err);
          return;
        }
        this.connectionStateSubject.next(ConnectionState.CONNECTING);
        webSocket.onclose = (evt) => {
          this.clearWebSocket();
          obs.error(new Error(`websocket error ${evt.code}: ${evt.reason}`));
          this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
        };
        webSocket.onopen = (_2) => {
          obs.next();
          obs.complete();
          this.connectionStateSubject.next(ConnectionState.CONNECTED);
        };
        webSocket.onmessage = (evt) => {
          this.incomingDataSubject.next(evt.data);
        };
      }).pipe((0, operators_12.take)(1));
    }
    disconnect() {
      const { webSocket } = this;
      if (!webSocket) {
        return;
      }
      this.clearWebSocket();
      this.connectionStateSubject.next(ConnectionState.DISCONNECTED);
      try {
        webSocket.close();
      } catch (_a2) {
      }
    }
    get connectionState$() {
      return this.connectionStateSubject.asObservable();
    }
    get incomingData$() {
      return this.incomingDataSubject.asObservable();
    }
    get incomingJSONData$() {
      return this.incomingData$.pipe((0, operators_12.flatMap)((m2) => {
        let j2;
        try {
          j2 = JSON.parse(m2);
        } catch (err) {
          return (0, rxjs_12.empty)();
        }
        return (0, rxjs_12.of)(j2);
      }));
    }
    sendData(data) {
      const { webSocket } = this;
      if (!webSocket) {
        throw new Error("websocket is not connected");
      }
      webSocket.send(data);
    }
    clearWebSocket() {
      const { webSocket } = this;
      if (!webSocket) {
        return;
      }
      this.webSocket = null;
      webSocket.onclose = null;
      webSocket.onerror = null;
      webSocket.onmessage = null;
      webSocket.onopen = null;
    }
  }
  exports2.RxWebSocket = RxWebSocket2;
})(RxWebSocket);
var ServerMessage = {};
Object.defineProperty(ServerMessage, "__esModule", { value: true });
ServerMessage.isServerMessageFail = void 0;
function isServerMessageFail(msg) {
  return msg && msg.type === "Fail" && typeof msg.id === "number" && typeof msg.sessionId === "string" && typeof msg.error === "string";
}
ServerMessage.isServerMessageFail = isServerMessageFail;
Object.defineProperty(WalletLinkConnection$1, "__esModule", { value: true });
WalletLinkConnection$1.WalletLinkConnection = void 0;
const rxjs_1$2 = require$$1$1;
const operators_1$1 = require$$2$1;
const init_1$1 = init;
const Session_1$1 = Session$1;
const types_1 = types$1;
const ClientMessage_1 = ClientMessage;
const RxWebSocket_1 = RxWebSocket;
const ServerMessage_1 = ServerMessage;
const HEARTBEAT_INTERVAL = 1e4;
const REQUEST_TIMEOUT = 6e4;
class WalletLinkConnection {
  constructor(sessionId, sessionKey, serverUrl, walletLinkAnalytics, WebSocketClass = WebSocket) {
    this.sessionId = sessionId;
    this.sessionKey = sessionKey;
    this.subscriptions = new rxjs_1$2.Subscription();
    this.destroyed = false;
    this.lastHeartbeatResponse = 0;
    this.nextReqId = (0, types_1.IntNumber)(1);
    this.connectedSubject = new rxjs_1$2.BehaviorSubject(false);
    this.linkedSubject = new rxjs_1$2.BehaviorSubject(false);
    this.sessionConfigSubject = new rxjs_1$2.ReplaySubject(1);
    const ws = new RxWebSocket_1.RxWebSocket(serverUrl + "/rpc", WebSocketClass);
    this.ws = ws;
    this.walletLinkAnalytics = walletLinkAnalytics;
    this.subscriptions.add(ws.connectionState$.pipe((0, operators_1$1.tap)((state2) => this.walletLinkAnalytics.sendEvent(init_1$1.EVENTS.CONNECTED_STATE_CHANGE, {
      state: state2,
      sessionIdHash: Session_1$1.Session.hash(sessionId)
    })), (0, operators_1$1.skip)(1), (0, operators_1$1.filter)((cs) => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed), (0, operators_1$1.delay)(5e3), (0, operators_1$1.filter)((_2) => !this.destroyed), (0, operators_1$1.flatMap)((_2) => ws.connect()), (0, operators_1$1.retry)()).subscribe());
    this.subscriptions.add(ws.connectionState$.pipe((0, operators_1$1.skip)(2), (0, operators_1$1.switchMap)((cs) => (0, rxjs_1$2.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, this.authenticate().pipe((0, operators_1$1.tap)((_2) => this.sendIsLinked()), (0, operators_1$1.tap)((_2) => this.sendGetSessionConfig()), (0, operators_1$1.map)((_2) => true)), (0, rxjs_1$2.of)(false))), (0, operators_1$1.distinctUntilChanged)(), (0, operators_1$1.catchError)((_2) => (0, rxjs_1$2.of)(false))).subscribe((connected) => this.connectedSubject.next(connected)));
    this.subscriptions.add(ws.connectionState$.pipe((0, operators_1$1.skip)(1), (0, operators_1$1.switchMap)((cs) => (0, rxjs_1$2.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED, (0, rxjs_1$2.timer)(0, HEARTBEAT_INTERVAL)))).subscribe((i2) => i2 === 0 ? this.updateLastHeartbeat() : this.heartbeat()));
    this.subscriptions.add(ws.incomingData$.pipe((0, operators_1$1.filter)((m2) => m2 === "h")).subscribe((_2) => this.updateLastHeartbeat()));
    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1$1.filter)((m2) => ["IsLinkedOK", "Linked"].includes(m2.type))).subscribe((m2) => {
      const msg = m2;
      this.walletLinkAnalytics.sendEvent(init_1$1.EVENTS.LINKED, {
        sessionIdHash: Session_1$1.Session.hash(sessionId),
        linked: msg.linked,
        type: m2.type,
        onlineGuests: msg.onlineGuests
      });
      this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);
    }));
    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1$1.filter)((m2) => ["GetSessionConfigOK", "SessionConfigUpdated"].includes(m2.type))).subscribe((m2) => {
      const msg = m2;
      this.walletLinkAnalytics.sendEvent(init_1$1.EVENTS.SESSION_CONFIG_RECEIVED, {
        sessionIdHash: Session_1$1.Session.hash(sessionId),
        metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : void 0
      });
      this.sessionConfigSubject.next({
        webhookId: msg.webhookId,
        webhookUrl: msg.webhookUrl,
        metadata: msg.metadata
      });
    }));
  }
  connect() {
    if (this.destroyed) {
      throw new Error("instance is destroyed");
    }
    this.walletLinkAnalytics.sendEvent(init_1$1.EVENTS.STARTED_CONNECTING, {
      sessionIdHash: Session_1$1.Session.hash(this.sessionId)
    });
    this.ws.connect().subscribe();
  }
  destroy() {
    this.subscriptions.unsubscribe();
    this.ws.disconnect();
    this.walletLinkAnalytics.sendEvent(init_1$1.EVENTS.DISCONNECTED, {
      sessionIdHash: Session_1$1.Session.hash(this.sessionId)
    });
    this.destroyed = true;
  }
  get isDestroyed() {
    return this.destroyed;
  }
  get connected$() {
    return this.connectedSubject.asObservable();
  }
  get onceConnected$() {
    return this.connected$.pipe((0, operators_1$1.filter)((v2) => v2), (0, operators_1$1.take)(1), (0, operators_1$1.map)(() => void 0));
  }
  get linked$() {
    return this.linkedSubject.asObservable();
  }
  get onceLinked$() {
    return this.linked$.pipe((0, operators_1$1.filter)((v2) => v2), (0, operators_1$1.take)(1), (0, operators_1$1.map)(() => void 0));
  }
  get sessionConfig$() {
    return this.sessionConfigSubject.asObservable();
  }
  get incomingEvent$() {
    return this.ws.incomingJSONData$.pipe((0, operators_1$1.filter)((m2) => {
      if (m2.type !== "Event") {
        return false;
      }
      const sme = m2;
      return typeof sme.sessionId === "string" && typeof sme.eventId === "string" && typeof sme.event === "string" && typeof sme.data === "string";
    }), (0, operators_1$1.map)((m2) => m2));
  }
  setSessionMetadata(key2, value2) {
    const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({
      id: (0, types_1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId,
      metadata: { [key2]: value2 }
    });
    return this.onceConnected$.pipe((0, operators_1$1.flatMap)((_2) => this.makeRequest(message)), (0, operators_1$1.map)((res) => {
      if ((0, ServerMessage_1.isServerMessageFail)(res)) {
        throw new Error(res.error || "failed to set session metadata");
      }
    }));
  }
  publishEvent(event, data, callWebhook = false) {
    const message = (0, ClientMessage_1.ClientMessagePublishEvent)({
      id: (0, types_1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId,
      event,
      data,
      callWebhook
    });
    return this.onceLinked$.pipe((0, operators_1$1.flatMap)((_2) => this.makeRequest(message)), (0, operators_1$1.map)((res) => {
      if ((0, ServerMessage_1.isServerMessageFail)(res)) {
        throw new Error(res.error || "failed to publish event");
      }
      return res.eventId;
    }));
  }
  sendData(message) {
    this.ws.sendData(JSON.stringify(message));
  }
  updateLastHeartbeat() {
    this.lastHeartbeatResponse = Date.now();
  }
  heartbeat() {
    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {
      this.ws.disconnect();
      return;
    }
    try {
      this.ws.sendData("h");
    } catch (_a2) {
    }
  }
  makeRequest(message, timeout2 = REQUEST_TIMEOUT) {
    const reqId = message.id;
    try {
      this.sendData(message);
    } catch (err) {
      return (0, rxjs_1$2.throwError)(err);
    }
    return this.ws.incomingJSONData$.pipe((0, operators_1$1.timeoutWith)(timeout2, (0, rxjs_1$2.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1$1.filter)((m2) => m2.id === reqId), (0, operators_1$1.take)(1));
  }
  authenticate() {
    const msg = (0, ClientMessage_1.ClientMessageHostSession)({
      id: (0, types_1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId,
      sessionKey: this.sessionKey
    });
    return this.makeRequest(msg).pipe((0, operators_1$1.map)((res) => {
      if ((0, ServerMessage_1.isServerMessageFail)(res)) {
        throw new Error(res.error || "failed to authentcate");
      }
    }));
  }
  sendIsLinked() {
    const msg = (0, ClientMessage_1.ClientMessageIsLinked)({
      id: (0, types_1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId
    });
    this.sendData(msg);
  }
  sendGetSessionConfig() {
    const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({
      id: (0, types_1.IntNumber)(this.nextReqId++),
      sessionId: this.sessionId
    });
    this.sendData(msg);
  }
}
WalletLinkConnection$1.WalletLinkConnection = WalletLinkConnection;
var aes256gcm$1 = {};
Object.defineProperty(aes256gcm$1, "__esModule", { value: true });
aes256gcm$1.decrypt = aes256gcm$1.encrypt = void 0;
const rxjs_1$1 = require$$1$1;
const util_1$3 = util$3;
async function encrypt(plainText, secret2) {
  if (secret2.length !== 64)
    throw Error(`secret must be 256 bits`);
  const ivBytes = crypto.getRandomValues(new Uint8Array(12));
  const secretKey = await crypto.subtle.importKey("raw", (0, util_1$3.hexStringToUint8Array)(secret2), { "name": "aes-gcm" }, false, ["encrypt", "decrypt"]);
  const enc = new TextEncoder();
  const encryptedResult = await window.crypto.subtle.encrypt({
    name: "AES-GCM",
    iv: ivBytes
  }, secretKey, enc.encode(plainText));
  const tagLength = 16;
  const authTag = encryptedResult.slice(encryptedResult.byteLength - tagLength);
  const encryptedPlaintext = encryptedResult.slice(0, encryptedResult.byteLength - tagLength);
  const authTagBytes = new Uint8Array(authTag);
  const encryptedPlaintextBytes = new Uint8Array(encryptedPlaintext);
  const concatted = new Uint8Array([...ivBytes, ...authTagBytes, ...encryptedPlaintextBytes]);
  return (0, util_1$3.uint8ArrayToHex)(concatted);
}
aes256gcm$1.encrypt = encrypt;
function decrypt(cipherText, secret2) {
  if (secret2.length !== 64)
    throw Error(`secret must be 256 bits`);
  return new rxjs_1$1.Observable((subscriber) => {
    void async function() {
      const secretKey = await crypto.subtle.importKey("raw", (0, util_1$3.hexStringToUint8Array)(secret2), { "name": "aes-gcm" }, false, ["encrypt", "decrypt"]);
      const encrypted = (0, util_1$3.hexStringToUint8Array)(cipherText);
      const ivBytes = encrypted.slice(0, 12);
      const authTagBytes = encrypted.slice(12, 28);
      const encryptedPlaintextBytes = encrypted.slice(28);
      const concattedBytes = new Uint8Array([...encryptedPlaintextBytes, ...authTagBytes]);
      const algo = {
        name: "AES-GCM",
        iv: new Uint8Array(ivBytes)
      };
      try {
        const decrypted = await window.crypto.subtle.decrypt(algo, secretKey, concattedBytes);
        const decoder = new TextDecoder();
        subscriber.next(decoder.decode(decrypted));
        subscriber.complete();
      } catch (err) {
        subscriber.error(err);
      }
    }();
  });
}
aes256gcm$1.decrypt = decrypt;
var Web3Method = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Web3Method = void 0;
  (function(Web3Method2) {
    Web3Method2["requestEthereumAccounts"] = "requestEthereumAccounts";
    Web3Method2["signEthereumMessage"] = "signEthereumMessage";
    Web3Method2["signEthereumTransaction"] = "signEthereumTransaction";
    Web3Method2["submitEthereumTransaction"] = "submitEthereumTransaction";
    Web3Method2["ethereumAddressFromSignedMessage"] = "ethereumAddressFromSignedMessage";
    Web3Method2["scanQRCode"] = "scanQRCode";
    Web3Method2["generic"] = "generic";
    Web3Method2["childRequestEthereumAccounts"] = "childRequestEthereumAccounts";
    Web3Method2["addEthereumChain"] = "addEthereumChain";
    Web3Method2["switchEthereumChain"] = "switchEthereumChain";
  })(exports2.Web3Method || (exports2.Web3Method = {}));
})(Web3Method);
var Web3RequestCanceledMessage$1 = {};
var RelayMessage = {};
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.RelayMessageType = void 0;
  (function(RelayMessageType) {
    RelayMessageType["SESSION_ID_REQUEST"] = "SESSION_ID_REQUEST";
    RelayMessageType["SESSION_ID_RESPONSE"] = "SESSION_ID_RESPONSE";
    RelayMessageType["LINKED"] = "LINKED";
    RelayMessageType["UNLINKED"] = "UNLINKED";
    RelayMessageType["WEB3_REQUEST"] = "WEB3_REQUEST";
    RelayMessageType["WEB3_REQUEST_CANCELED"] = "WEB3_REQUEST_CANCELED";
    RelayMessageType["WEB3_RESPONSE"] = "WEB3_RESPONSE";
  })(exports2.RelayMessageType || (exports2.RelayMessageType = {}));
})(RelayMessage);
Object.defineProperty(Web3RequestCanceledMessage$1, "__esModule", { value: true });
Web3RequestCanceledMessage$1.Web3RequestCanceledMessage = void 0;
const RelayMessage_1$2 = RelayMessage;
function Web3RequestCanceledMessage(id2) {
  return { type: RelayMessage_1$2.RelayMessageType.WEB3_REQUEST_CANCELED, id: id2 };
}
Web3RequestCanceledMessage$1.Web3RequestCanceledMessage = Web3RequestCanceledMessage;
var Web3RequestMessage$1 = {};
Object.defineProperty(Web3RequestMessage$1, "__esModule", { value: true });
Web3RequestMessage$1.Web3RequestMessage = void 0;
const RelayMessage_1$1 = RelayMessage;
function Web3RequestMessage(params) {
  return Object.assign({ type: RelayMessage_1$1.RelayMessageType.WEB3_REQUEST }, params);
}
Web3RequestMessage$1.Web3RequestMessage = Web3RequestMessage;
var Web3Response = {};
Object.defineProperty(Web3Response, "__esModule", { value: true });
Web3Response.EthereumAddressFromSignedMessageResponse = Web3Response.SubmitEthereumTransactionResponse = Web3Response.SignEthereumTransactionResponse = Web3Response.SignEthereumMessageResponse = Web3Response.isRequestEthereumAccountsResponse = Web3Response.RequestEthereumAccountsResponse = Web3Response.SwitchEthereumChainResponse = Web3Response.AddEthereumChainResponse = Web3Response.ErrorResponse = void 0;
const Web3Method_1$1 = Web3Method;
function ErrorResponse(method2, errorMessage, errorCode) {
  return { method: method2, errorMessage, errorCode };
}
Web3Response.ErrorResponse = ErrorResponse;
function AddEthereumChainResponse(addResponse) {
  return {
    method: Web3Method_1$1.Web3Method.addEthereumChain,
    result: addResponse
  };
}
Web3Response.AddEthereumChainResponse = AddEthereumChainResponse;
function SwitchEthereumChainResponse(switchResponse) {
  return {
    method: Web3Method_1$1.Web3Method.switchEthereumChain,
    result: switchResponse
  };
}
Web3Response.SwitchEthereumChainResponse = SwitchEthereumChainResponse;
function RequestEthereumAccountsResponse(addresses) {
  return { method: Web3Method_1$1.Web3Method.requestEthereumAccounts, result: addresses };
}
Web3Response.RequestEthereumAccountsResponse = RequestEthereumAccountsResponse;
function isRequestEthereumAccountsResponse(res) {
  return res && res.method === Web3Method_1$1.Web3Method.requestEthereumAccounts;
}
Web3Response.isRequestEthereumAccountsResponse = isRequestEthereumAccountsResponse;
function SignEthereumMessageResponse(signature2) {
  return { method: Web3Method_1$1.Web3Method.signEthereumMessage, result: signature2 };
}
Web3Response.SignEthereumMessageResponse = SignEthereumMessageResponse;
function SignEthereumTransactionResponse(signedData) {
  return { method: Web3Method_1$1.Web3Method.signEthereumTransaction, result: signedData };
}
Web3Response.SignEthereumTransactionResponse = SignEthereumTransactionResponse;
function SubmitEthereumTransactionResponse(txHash) {
  return { method: Web3Method_1$1.Web3Method.submitEthereumTransaction, result: txHash };
}
Web3Response.SubmitEthereumTransactionResponse = SubmitEthereumTransactionResponse;
function EthereumAddressFromSignedMessageResponse(address) {
  return {
    method: Web3Method_1$1.Web3Method.ethereumAddressFromSignedMessage,
    result: address
  };
}
Web3Response.EthereumAddressFromSignedMessageResponse = EthereumAddressFromSignedMessageResponse;
var Web3ResponseMessage$1 = {};
Object.defineProperty(Web3ResponseMessage$1, "__esModule", { value: true });
Web3ResponseMessage$1.isWeb3ResponseMessage = Web3ResponseMessage$1.Web3ResponseMessage = void 0;
const RelayMessage_1 = RelayMessage;
function Web3ResponseMessage(params) {
  return Object.assign({ type: RelayMessage_1.RelayMessageType.WEB3_RESPONSE }, params);
}
Web3ResponseMessage$1.Web3ResponseMessage = Web3ResponseMessage;
function isWeb3ResponseMessage(msg) {
  return msg && msg.type === RelayMessage_1.RelayMessageType.WEB3_RESPONSE;
}
Web3ResponseMessage$1.isWeb3ResponseMessage = isWeb3ResponseMessage;
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  Object.defineProperty(o2, k22, { enumerable: true, get: function() {
    return m2[k2];
  } });
} : function(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o2, v2) {
  Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
} : function(o2, v2) {
  o2["default"] = v2;
});
var __decorate = commonjsGlobal && commonjsGlobal.__decorate || function(decorators, target, key2, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key2, desc);
  else
    for (var i2 = decorators.length - 1; i2 >= 0; i2--)
      if (d2 = decorators[i2])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key2, r2) : d2(target, key2)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key2, r2), r2;
};
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
        __createBinding(result, mod, k2);
  }
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(WalletLinkRelay$1, "__esModule", { value: true });
WalletLinkRelay$1.WalletLinkRelay = void 0;
const bind_decorator_1 = __importDefault(bindDecorator);
const rxjs_1 = require$$1$1;
const operators_1 = require$$2$1;
const WalletLinkAnalytics_1$1 = WalletLinkAnalytics$1;
const WalletLinkConnection_1 = WalletLinkConnection$1;
const init_1 = init;
const util_1$2 = util$3;
const aes256gcm = __importStar(aes256gcm$1);
const Session_1 = Session$1;
const WalletLinkRelayAbstract_1 = WalletLinkRelayAbstract$1;
const Web3Method_1 = Web3Method;
const Web3RequestCanceledMessage_1 = Web3RequestCanceledMessage$1;
const Web3RequestMessage_1 = Web3RequestMessage$1;
const Web3Response_1 = Web3Response;
const Web3ResponseMessage_1 = Web3ResponseMessage$1;
const eth_rpc_errors_1 = dist$3;
class WalletLinkRelay extends WalletLinkRelayAbstract_1.WalletLinkRelayAbstract {
  constructor(options) {
    super();
    this.accountsCallback = null;
    this.chainCallback = null;
    this.appName = "";
    this.appLogoUrl = null;
    this.subscriptions = new rxjs_1.Subscription();
    this.walletLinkUrl = options.walletLinkUrl;
    this.storage = options.storage;
    this._session = Session_1.Session.load(options.storage) || new Session_1.Session(options.storage).save();
    this.relayEventManager = options.relayEventManager;
    this.walletLinkAnalytics = options.walletLinkAnalytics ? options.walletLinkAnalytics : new WalletLinkAnalytics_1$1.WalletLinkAnalytics();
    this.connection = new WalletLinkConnection_1.WalletLinkConnection(this._session.id, this._session.key, this.walletLinkUrl, this.walletLinkAnalytics);
    this.subscriptions.add(this.connection.incomingEvent$.pipe((0, operators_1.filter)((m2) => m2.event === "Web3Response")).subscribe({ next: this.handleIncomingEvent }));
    this.subscriptions.add(this.connection.linked$.pipe((0, operators_1.skip)(1), (0, operators_1.tap)((linked) => {
      var _a2;
      this.isLinked = linked;
      const cachedAddresses = this.storage.getItem(WalletLinkRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);
      if (cachedAddresses) {
        const addresses = cachedAddresses.split(" ");
        if (addresses[0] !== "" && !linked) {
          const sessionIdHash = Session_1.Session.hash(this._session.id);
          (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.UNLINKED_ERROR_STATE, { sessionIdHash });
        }
      }
    })).subscribe());
    this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => !!c2.metadata && c2.metadata.__destroyed === "1")).subscribe(() => {
      var _a2;
      const alreadyDestroyed = this.connection.isDestroyed;
      (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.METADATA_DESTROYED, {
        alreadyDestroyed,
        sessionIdHash: Session_1.Session.hash(this._session.id)
      });
      return this.resetAndReload();
    }));
    this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.WalletUsername !== void 0)).pipe((0, operators_1.mergeMap)((c2) => aes256gcm.decrypt(c2.metadata.WalletUsername, this._session.secret))).subscribe({
      next: (walletUsername) => {
        this.storage.setItem(WalletLinkRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);
      },
      error: () => {
        var _a2;
        (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "username"
        });
      }
    }));
    this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.AppVersion !== void 0)).pipe((0, operators_1.mergeMap)((c2) => aes256gcm.decrypt(c2.metadata.AppVersion, this._session.secret))).subscribe({
      next: (appVersion) => {
        this.storage.setItem(WalletLinkRelayAbstract_1.APP_VERSION_KEY, appVersion);
      },
      error: () => {
        var _a2;
        (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "appversion"
        });
      }
    }));
    this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.ChainId !== void 0 && c2.metadata.JsonRpcUrl !== void 0)).pipe((0, operators_1.mergeMap)((c2) => (0, rxjs_1.zip)(aes256gcm.decrypt(c2.metadata.ChainId, this._session.secret), aes256gcm.decrypt(c2.metadata.JsonRpcUrl, this._session.secret)))).pipe((0, operators_1.distinctUntilChanged)()).subscribe({
      next: ([chainId, jsonRpcUrl]) => {
        if (this.chainCallback) {
          this.chainCallback(chainId, jsonRpcUrl);
        }
      },
      error: () => {
        var _a2;
        (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "chainId|jsonRpcUrl"
        });
      }
    }));
    this.subscriptions.add(this.connection.sessionConfig$.pipe((0, operators_1.filter)((c2) => c2.metadata && c2.metadata.EthereumAddress !== void 0)).pipe((0, operators_1.mergeMap)((c2) => aes256gcm.decrypt(c2.metadata.EthereumAddress, this._session.secret))).subscribe({
      next: (selectedAddress) => {
        if (this.accountsCallback) {
          this.accountsCallback([selectedAddress]);
        }
        if (WalletLinkRelay.accountRequestCallbackIds.size > 0) {
          Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach((id2) => {
            const message = (0, Web3ResponseMessage_1.Web3ResponseMessage)({
              id: id2,
              response: (0, Web3Response_1.RequestEthereumAccountsResponse)([
                selectedAddress
              ])
            });
            this.invokeCallback(Object.assign(Object.assign({}, message), { id: id2 }));
          });
          WalletLinkRelay.accountRequestCallbackIds.clear();
        }
      },
      error: () => {
        var _a2;
        (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
          message: "Had error decrypting",
          value: "selectedAddress"
        });
      }
    }));
    this.ui = options.walletLinkUIConstructor({
      walletLinkUrl: options.walletLinkUrl,
      version: options.version,
      darkMode: options.darkMode,
      session: this._session,
      connected$: this.connection.connected$
    });
    this.connection.connect();
  }
  attachUI() {
    this.ui.attach();
  }
  resetAndReload() {
    this.connection.setSessionMetadata("__destroyed", "1").pipe((0, operators_1.timeout)(1e3), (0, operators_1.catchError)((_2) => (0, rxjs_1.of)(null))).subscribe((_2) => {
      var _a2, _b2;
      try {
        this.subscriptions.unsubscribe();
      } catch (err) {
        (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
          message: "Had error unsubscribing"
        });
      }
      (_b2 = this.walletLinkAnalytics) === null || _b2 === void 0 ? void 0 : _b2.sendEvent(init_1.EVENTS.SESSION_STATE_CHANGE, {
        method: "relay::resetAndReload",
        sessionMetadataChange: "__destroyed, 1",
        sessionIdHash: Session_1.Session.hash(this._session.id)
      });
      this.connection.destroy();
      this.storage.clear();
      this.ui.reloadUI();
    }, (err) => {
      var _a2;
      (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.FAILURE, {
        method: "relay::resetAndReload",
        message: `faled to reset and relod with ${err}`,
        sessionIdHash: Session_1.Session.hash(this._session.id)
      });
    });
  }
  setAppInfo(appName, appLogoUrl) {
    this.appName = appName;
    this.appLogoUrl = appLogoUrl;
  }
  getStorageItem(key2) {
    return this.storage.getItem(key2);
  }
  get session() {
    return this._session;
  }
  setStorageItem(key2, value2) {
    this.storage.setItem(key2, value2);
  }
  signEthereumMessage(message, address, addPrefix, typedDataJson) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.signEthereumMessage,
      params: {
        message: (0, util_1$2.hexStringFromBuffer)(message, true),
        address,
        addPrefix,
        typedDataJson: typedDataJson || null
      }
    });
  }
  ethereumAddressFromSignedMessage(message, signature2, addPrefix) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
      params: {
        message: (0, util_1$2.hexStringFromBuffer)(message, true),
        signature: (0, util_1$2.hexStringFromBuffer)(signature2, true),
        addPrefix
      }
    });
  }
  signEthereumTransaction(params) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.signEthereumTransaction,
      params: {
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        weiValue: (0, util_1$2.bigIntStringFromBN)(params.weiValue),
        data: (0, util_1$2.hexStringFromBuffer)(params.data, true),
        nonce: params.nonce,
        gasPriceInWei: params.gasPriceInWei ? (0, util_1$2.bigIntStringFromBN)(params.gasPriceInWei) : null,
        maxFeePerGas: params.gasPriceInWei ? (0, util_1$2.bigIntStringFromBN)(params.gasPriceInWei) : null,
        maxPriorityFeePerGas: params.gasPriceInWei ? (0, util_1$2.bigIntStringFromBN)(params.gasPriceInWei) : null,
        gasLimit: params.gasLimit ? (0, util_1$2.bigIntStringFromBN)(params.gasLimit) : null,
        chainId: params.chainId,
        shouldSubmit: false
      }
    });
  }
  signAndSubmitEthereumTransaction(params) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.signEthereumTransaction,
      params: {
        fromAddress: params.fromAddress,
        toAddress: params.toAddress,
        weiValue: (0, util_1$2.bigIntStringFromBN)(params.weiValue),
        data: (0, util_1$2.hexStringFromBuffer)(params.data, true),
        nonce: params.nonce,
        gasPriceInWei: params.gasPriceInWei ? (0, util_1$2.bigIntStringFromBN)(params.gasPriceInWei) : null,
        maxFeePerGas: params.maxFeePerGas ? (0, util_1$2.bigIntStringFromBN)(params.maxFeePerGas) : null,
        maxPriorityFeePerGas: params.maxPriorityFeePerGas ? (0, util_1$2.bigIntStringFromBN)(params.maxPriorityFeePerGas) : null,
        gasLimit: params.gasLimit ? (0, util_1$2.bigIntStringFromBN)(params.gasLimit) : null,
        chainId: params.chainId,
        shouldSubmit: true
      }
    });
  }
  submitEthereumTransaction(signedTransaction, chainId) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.submitEthereumTransaction,
      params: {
        signedTransaction: (0, util_1$2.hexStringFromBuffer)(signedTransaction, true),
        chainId
      }
    });
  }
  scanQRCode(regExp) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.scanQRCode,
      params: { regExp }
    });
  }
  genericRequest(data, action) {
    return this.sendRequest({
      method: Web3Method_1.Web3Method.generic,
      params: {
        action,
        data
      }
    });
  }
  sendGenericMessage(request) {
    return this.sendRequest(request);
  }
  sendRequest(request) {
    let hideSnackbarItem = null;
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = () => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
        id: id2,
        response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
      }));
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    const promise = new Promise((resolve2, reject) => {
      if (!this.ui.isStandalone()) {
        hideSnackbarItem = this.ui.showConnecting({
          onCancel: cancel,
          onResetConnection: this.resetAndReload
        });
      }
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve2(response);
      });
      if (this.ui.isStandalone()) {
        this.sendRequestStandalone(id2, request);
      } else {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return { promise, cancel };
  }
  setConnectDisabled(disabled) {
    this.ui.setConnectDisabled(disabled);
  }
  setAccountsCallback(accountsCallback) {
    this.accountsCallback = accountsCallback;
  }
  setChainCallback(chainCallback) {
    this.chainCallback = chainCallback;
  }
  publishWeb3RequestEvent(id2, request) {
    const message = (0, Web3RequestMessage_1.Web3RequestMessage)({ id: id2, request });
    this.subscriptions.add(this.publishEvent("Web3Request", message, true).subscribe({
      error: (err) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: message.id,
          response: {
            method: message.request.method,
            errorMessage: err.message
          }
        }));
      }
    }));
  }
  publishWeb3RequestCanceledEvent(id2) {
    const message = (0, Web3RequestCanceledMessage_1.Web3RequestCanceledMessage)(id2);
    this.subscriptions.add(this.publishEvent("Web3RequestCanceled", message, false).subscribe());
  }
  publishEvent(event, message, callWebhook) {
    const secret2 = this.session.secret;
    return new rxjs_1.Observable((subscriber) => {
      void aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), { origin: location.origin })), secret2).then((encrypted) => {
        subscriber.next(encrypted);
        subscriber.complete();
      });
    }).pipe((0, operators_1.mergeMap)((encrypted) => {
      return this.connection.publishEvent(event, encrypted, callWebhook);
    }));
  }
  handleIncomingEvent(event) {
    try {
      this.subscriptions.add(aes256gcm.decrypt(event.data, this.session.secret).pipe((0, operators_1.map)((c2) => JSON.parse(c2))).subscribe({
        next: (json2) => {
          const message = (0, Web3ResponseMessage_1.isWeb3ResponseMessage)(json2) ? json2 : null;
          if (!message) {
            return;
          }
          this.handleWeb3ResponseMessage(message);
        },
        error: () => {
          var _a2;
          (_a2 = this.walletLinkAnalytics) === null || _a2 === void 0 ? void 0 : _a2.sendEvent(init_1.EVENTS.GENERAL_ERROR, {
            message: "Had error decrypting",
            value: "incomingEvent"
          });
        }
      }));
    } catch (_a2) {
      return;
    }
  }
  handleWeb3ResponseMessage(message) {
    const { response } = message;
    if ((0, Web3Response_1.isRequestEthereumAccountsResponse)(response)) {
      Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach((id2) => this.invokeCallback(Object.assign(Object.assign({}, message), { id: id2 })));
      WalletLinkRelay.accountRequestCallbackIds.clear();
      return;
    }
    this.invokeCallback(message);
  }
  invokeCallback(message) {
    const callback = this.relayEventManager.callbacks.get(message.id);
    if (callback) {
      callback(message.response);
      this.relayEventManager.callbacks.delete(message.id);
    }
  }
  requestEthereumAccounts() {
    let request = {
      method: Web3Method_1.Web3Method.requestEthereumAccounts,
      params: {
        appName: this.appName,
        appLogoUrl: this.appLogoUrl || null
      }
    };
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = () => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
        id: id2,
        response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
      }));
    };
    const promise = new Promise((resolve2, reject) => {
      var _a2;
      this.relayEventManager.callbacks.set(id2, (response) => {
        this.ui.hideRequestEthereumAccounts();
        if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve2(response);
      });
      const userAgent = ((_a2 = window === null || window === void 0 ? void 0 : window.navigator) === null || _a2 === void 0 ? void 0 : _a2.userAgent) || null;
      if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
        window.location.href = `https://go.cb-w.com/xoXnYwQimhb?cb_url=${window.location.href}`;
        return;
      }
      if (this.ui.inlineAccountsResponse()) {
        const onAccounts = (accounts) => {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response: (0, Web3Response_1.RequestEthereumAccountsResponse)(accounts)
          }));
        };
        this.ui.requestEthereumAccounts({
          onCancel: cancel,
          onAccounts
        });
      } else {
        this.ui.requestEthereumAccounts({
          onCancel: cancel
        });
      }
      WalletLinkRelay.accountRequestCallbackIds.add(id2);
      if (!this.ui.inlineAccountsResponse() && !this.ui.isStandalone()) {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return { promise, cancel };
  }
  addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {
    let request = {
      method: Web3Method_1.Web3Method.addEthereumChain,
      params: {
        chainId,
        rpcUrls,
        blockExplorerUrls,
        chainName,
        iconUrls,
        nativeCurrency
      }
    };
    let hideSnackbarItem = null;
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = () => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
        id: id2,
        response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
      }));
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    if (!this.ui.inlineAddEthereumChain(chainId)) {
      hideSnackbarItem = this.ui.showConnecting({
        onCancel: cancel,
        onResetConnection: this.resetAndReload
      });
    }
    const promise = new Promise((resolve2, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve2(response);
      });
      const _cancel = () => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.AddEthereumChainResponse)({ isApproved: false, rpcUrl: "" })
        }));
      };
      const approve = (rpcUrl) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.AddEthereumChainResponse)({ isApproved: true, rpcUrl })
        }));
      };
      if (this.ui.inlineAddEthereumChain(chainId)) {
        this.ui.addEthereumChain({
          onCancel: _cancel,
          onApprove: approve,
          chainId: request.params.chainId,
          rpcUrls: request.params.rpcUrls,
          blockExplorerUrls: request.params.blockExplorerUrls,
          chainName: request.params.chainName,
          iconUrls: request.params.iconUrls,
          nativeCurrency: request.params.nativeCurrency
        });
      }
      if (!this.ui.inlineAddEthereumChain(chainId) && !this.ui.isStandalone()) {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return { promise, cancel };
  }
  switchEthereumChain(chainId) {
    let request = {
      method: Web3Method_1.Web3Method.switchEthereumChain,
      params: {
        chainId
      }
    };
    let hideSnackbarItem = null;
    const id2 = (0, util_1$2.randomBytesHex)(8);
    const cancel = () => {
      this.publishWeb3RequestCanceledEvent(id2);
      this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
        id: id2,
        response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
      }));
      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
    };
    if (!this.ui.inlineSwitchEthereumChain()) {
      hideSnackbarItem = this.ui.showConnecting({
        onCancel: cancel,
        onResetConnection: this.resetAndReload
      });
    }
    const promise = new Promise((resolve2, reject) => {
      this.relayEventManager.callbacks.set(id2, (response) => {
        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
        if (response.errorMessage && response.errorCode) {
          return reject(eth_rpc_errors_1.ethErrors.provider.custom({
            code: response.errorCode,
            message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`
          }));
        } else if (response.errorMessage) {
          return reject(new Error(response.errorMessage));
        }
        resolve2(response);
      });
      const _cancel = (errorCode) => {
        if (errorCode) {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response: (0, Web3Response_1.ErrorResponse)(Web3Method_1.Web3Method.switchEthereumChain, "unsupported chainId", errorCode)
          }));
        } else {
          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
            id: id2,
            response: (0, Web3Response_1.SwitchEthereumChainResponse)({
              isApproved: false,
              rpcUrl: ""
            })
          }));
        }
      };
      const approve = (rpcUrl) => {
        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
          id: id2,
          response: (0, Web3Response_1.SwitchEthereumChainResponse)({
            isApproved: true,
            rpcUrl
          })
        }));
      };
      this.ui.switchEthereumChain({
        onCancel: _cancel,
        onApprove: approve,
        chainId: request.params.chainId
      });
      if (!this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone()) {
        this.publishWeb3RequestEvent(id2, request);
      }
    });
    return { promise, cancel };
  }
  sendRequestStandalone(id2, request) {
    const _cancel = () => {
      this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
        id: id2,
        response: (0, Web3Response_1.ErrorResponse)(request.method, "User rejected request")
      }));
    };
    const onSuccess = (response) => {
      this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({
        id: id2,
        response
      }));
    };
    switch (request.method) {
      case Web3Method_1.Web3Method.signEthereumMessage:
        this.ui.signEthereumMessage({
          request,
          onSuccess,
          onCancel: _cancel
        });
        break;
      case Web3Method_1.Web3Method.signEthereumTransaction:
        this.ui.signEthereumTransaction({
          request,
          onSuccess,
          onCancel: _cancel
        });
        break;
      case Web3Method_1.Web3Method.submitEthereumTransaction:
        this.ui.submitEthereumTransaction({
          request,
          onSuccess,
          onCancel: _cancel
        });
        break;
      case Web3Method_1.Web3Method.ethereumAddressFromSignedMessage:
        this.ui.ethereumAddressFromSignedMessage({
          request,
          onSuccess
        });
        break;
      default:
        _cancel();
        break;
    }
  }
}
WalletLinkRelay.accountRequestCallbackIds = new Set();
__decorate([
  bind_decorator_1.default
], WalletLinkRelay.prototype, "resetAndReload", null);
__decorate([
  bind_decorator_1.default
], WalletLinkRelay.prototype, "handleIncomingEvent", null);
WalletLinkRelay$1.WalletLinkRelay = WalletLinkRelay;
var WalletLinkRelayEventManager$1 = {};
Object.defineProperty(WalletLinkRelayEventManager$1, "__esModule", { value: true });
WalletLinkRelayEventManager$1.WalletLinkRelayEventManager = void 0;
const util_1$1 = util$3;
class WalletLinkRelayEventManager {
  constructor() {
    this._nextRequestId = 0;
    this.callbacks = new Map();
  }
  makeRequestId() {
    this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
    const id2 = this._nextRequestId;
    const idStr = (0, util_1$1.prepend0x)(id2.toString(16));
    const callback = this.callbacks.get(idStr);
    if (callback) {
      this.callbacks.delete(idStr);
    }
    return id2;
  }
}
WalletLinkRelayEventManager$1.WalletLinkRelayEventManager = WalletLinkRelayEventManager;
const name = "walletlink";
const version$2 = "2.4.1";
const description = "WalletLink JavaScript SDK";
const keywords = [
  "cipher",
  "cipherbrowser",
  "coinbase",
  "coinbasewallet",
  "eth",
  "ether",
  "ethereum",
  "etherium",
  "injection",
  "toshi",
  "wallet",
  "walletlink",
  "web3"
];
const main = "dist/index.js";
const types = "dist/index.d.ts";
const repository = "https://github.com/walletlink/walletlink.git";
const author = "Coinbase, Inc.";
const license = "Apache-2.0";
const scripts = {
  tsc: "tsc --noEmit --pretty",
  test: "yarn build-npm && karma start",
  build: "node compile-assets.js && webpack --config webpack.config.js",
  "build-chrome": "webpack --config webpack.config.chrome.js",
  "build-npm": "tsc -p ./tsconfig.build.json",
  "build:dev": "export WALLETLINK_URL='http://localhost:3000'; yarn build && yarn build-chrome",
  "build:dev:watch": "nodemon -e 'ts,tsx,js,json,css,scss,svg' --ignore 'src/**/*-css.ts' --ignore 'src/**/*-svg.ts' --watch src/ --watch chrome/ --exec 'yarn build:dev'",
  "build:prod": `yarn build && yarn build-chrome && yarn build-npm && cp ./package.json ../README.md ../LICENSE build/npm && cp -a src/vendor-js build/npm/dist && sed -i.bak 's|  "private": true,||g' build/npm/package.json && rm -f build/npm/package.json.bak`,
  lint: "eslint ./src --ext .ts,.tsx",
  "lint:watch": "nodemon -e ts,tsx,js,json,css,scss,svg --watch src/ --exec 'yarn tsc && yarn lint'"
};
const dependencies = {
  "@metamask/safe-event-emitter": "2.0.0",
  "bind-decorator": "^1.0.11",
  "bn.js": "^5.1.1",
  clsx: "^1.1.0",
  "eth-block-tracker": "4.4.3",
  "eth-json-rpc-filters": "4.2.2",
  "eth-rpc-errors": "4.0.2",
  "js-sha256": "0.9.0",
  "json-rpc-engine": "6.1.0",
  keccak: "^3.0.1",
  preact: "^10.5.9",
  rxjs: "^6.6.3",
  "stream-browserify": "^3.0.0"
};
const devDependencies = {
  "@types/bn.js": "^4.11.6",
  "@types/node": "^14.14.20",
  "@typescript-eslint/eslint-plugin": "^5.7.0",
  "@typescript-eslint/eslint-plugin-tslint": "^5.7.0",
  "@typescript-eslint/parser": "^5.7.0",
  browserify: "17.0.0",
  "copy-webpack-plugin": "^6.4.1",
  "core-js": "^3.8.2",
  eslint: "^8.4.1",
  "eslint-config-prettier": "^8.3.0",
  "eslint-plugin-import": "^2.25.3",
  "eslint-plugin-preact": "^0.1.0",
  "eslint-plugin-prettier": "^4.0.0",
  "eslint-plugin-simple-import-sort": "^7.0.0",
  jasmine: "3.8.0",
  karma: "^6.3.2",
  "karma-browserify": "8.1.0",
  "karma-chrome-launcher": "^3.1.0",
  "karma-jasmine": "^4.0.1",
  nodemon: "^2.0.6",
  prettier: "^2.5.1",
  "raw-loader": "^4.0.2",
  "regenerator-runtime": "^0.13.7",
  sass: "^1.32.0",
  svgo: "^2.8.0",
  "ts-jest": "^26.4.4",
  "ts-loader": "^8.0.13",
  tslib: "^2.0.3",
  typescript: "^4.1.3",
  watchify: "4.0.0",
  webpack: "^5.49.0",
  "webpack-cli": "^3.3.12",
  "whatwg-fetch": "^3.5.0"
};
const engines = {
  node: ">= 10.0.0"
};
const jest = {
  transform: {
    "^.+\\.tsx?$": "ts-jest"
  },
  testEnvironment: "node",
  testPathIgnorePatterns: [
    "<rootDir>/dist/",
    "<rootDir>/node_modules/"
  ],
  testRegex: "(/__tests__/.*|\\.(test|spec))\\.(ts|tsx|js)$",
  moduleFileExtensions: [
    "ts",
    "js",
    "json"
  ]
};
var require$$7 = {
  name,
  version: version$2,
  description,
  keywords,
  main,
  types,
  repository,
  author,
  license,
  scripts,
  dependencies,
  devDependencies,
  engines,
  jest
};
Object.defineProperty(WalletLink$2, "__esModule", { value: true });
WalletLink$2.WalletLink = void 0;
const WalletLinkAnalytics_1 = WalletLinkAnalytics$1;
const ScopedLocalStorage_1 = ScopedLocalStorage$1;
const WalletLinkProvider_1 = WalletLinkProvider$1;
const WalletLinkSdkUI_1 = WalletLinkSdkUI$1;
const WalletLinkRelay_1 = WalletLinkRelay$1;
const WalletLinkRelayEventManager_1 = WalletLinkRelayEventManager$1;
const util_1 = util$3;
const WALLETLINK_URL = "https://www.walletlink.org";
const WALLETLINK_VERSION = require$$7.version;
class WalletLink$1 {
  constructor(options) {
    var _a2;
    this._appName = "";
    this._appLogoUrl = null;
    this._relay = null;
    this._relayEventManager = null;
    const walletLinkUrl = options.walletLinkUrl || WALLETLINK_URL;
    let walletLinkUIConstructor;
    if (!options.walletLinkUIConstructor) {
      walletLinkUIConstructor = (opts) => new WalletLinkSdkUI_1.WalletLinkSdkUI(opts);
    } else {
      walletLinkUIConstructor = options.walletLinkUIConstructor;
    }
    if (typeof options.overrideIsMetaMask === "undefined") {
      this._overrideIsMetaMask = false;
    } else {
      this._overrideIsMetaMask = options.overrideIsMetaMask;
    }
    this._overrideIsCoinbaseWallet = (_a2 = options.overrideIsCoinbaseWallet) !== null && _a2 !== void 0 ? _a2 : true;
    this._walletLinkAnalytics = options.walletLinkAnalytics ? options.walletLinkAnalytics : new WalletLinkAnalytics_1.WalletLinkAnalytics();
    const u2 = new URL(walletLinkUrl);
    const walletLinkOrigin = `${u2.protocol}//${u2.host}`;
    this._storage = new ScopedLocalStorage_1.ScopedLocalStorage(`-walletlink:${walletLinkOrigin}`);
    this._storage.setItem("version", WalletLink$1.VERSION);
    if (typeof window.walletLinkExtension !== "undefined") {
      return;
    }
    this._relayEventManager = new WalletLinkRelayEventManager_1.WalletLinkRelayEventManager();
    this._relay = new WalletLinkRelay_1.WalletLinkRelay({
      walletLinkUrl,
      version: WALLETLINK_VERSION,
      darkMode: !!options.darkMode,
      walletLinkUIConstructor,
      storage: this._storage,
      relayEventManager: this._relayEventManager,
      walletLinkAnalytics: this._walletLinkAnalytics
    });
    this.setAppInfo(options.appName, options.appLogoUrl);
    this._relay.attachUI();
  }
  makeWeb3Provider(jsonRpcUrl = "", chainId = 1) {
    if (typeof window.walletLinkExtension !== "undefined") {
      if (typeof window.walletLinkExtension.isCipher !== "boolean" || !window.walletLinkExtension.isCipher) {
        window.walletLinkExtension.setProviderInfo(jsonRpcUrl, chainId);
      }
      return window.walletLinkExtension;
    }
    const relay = this._relay;
    if (!relay || !this._relayEventManager || !this._storage) {
      throw new Error("Relay not initialized, should never happen");
    }
    if (!jsonRpcUrl)
      relay.setConnectDisabled(true);
    return new WalletLinkProvider_1.WalletLinkProvider({
      relayProvider: () => Promise.resolve(relay),
      relayEventManager: this._relayEventManager,
      storage: this._storage,
      jsonRpcUrl,
      chainId,
      walletLinkAnalytics: this._walletLinkAnalytics,
      overrideIsMetaMask: this._overrideIsMetaMask,
      overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet
    });
  }
  setAppInfo(appName, appLogoUrl) {
    var _a2;
    this._appName = appName || "DApp";
    this._appLogoUrl = appLogoUrl || (0, util_1.getFavicon)();
    if (typeof window.walletLinkExtension !== "undefined") {
      if (typeof window.walletLinkExtension.isCipher !== "boolean" || !window.walletLinkExtension.isCipher) {
        window.walletLinkExtension.setAppInfo(this._appName, this._appLogoUrl);
      }
    } else {
      (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.setAppInfo(this._appName, this._appLogoUrl);
    }
  }
  disconnect() {
    var _a2;
    if (typeof window.walletLinkExtension !== "undefined") {
      window.walletLinkExtension.close();
    } else {
      (_a2 = this._relay) === null || _a2 === void 0 ? void 0 : _a2.resetAndReload();
    }
  }
}
WalletLink$2.WalletLink = WalletLink$1;
WalletLink$1.VERSION = WALLETLINK_VERSION;
(function(exports2) {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.WalletLink = exports2.WalletLinkProvider = void 0;
  const WalletLinkProvider_12 = WalletLinkProvider$1;
  const WalletLink_1 = WalletLink$2;
  var WalletLinkProvider_2 = WalletLinkProvider$1;
  Object.defineProperty(exports2, "WalletLinkProvider", { enumerable: true, get: function() {
    return WalletLinkProvider_2.WalletLinkProvider;
  } });
  var WalletLink_2 = WalletLink$2;
  Object.defineProperty(exports2, "WalletLink", { enumerable: true, get: function() {
    return WalletLink_2.WalletLink;
  } });
  exports2.default = WalletLink_1.WalletLink;
  if (typeof window !== "undefined") {
    window.WalletLink = WalletLink_1.WalletLink;
    window.WalletLinkProvider = WalletLinkProvider_12.WalletLinkProvider;
  }
})(dist);
var WalletLink = /* @__PURE__ */ getDefaultExportFromCjs(dist);
const version$1 = "networks/5.5.2";
const logger$4 = new Logger(version$1);
function isRenetworkable(value2) {
  return value2 && typeof value2.renetwork === "function";
}
function ethDefaultProvider(network) {
  const func = function(providers, options) {
    if (options == null) {
      options = {};
    }
    const providerList = [];
    if (providers.InfuraProvider) {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error2) {
      }
    }
    if (providers.EtherscanProvider) {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error2) {
      }
    }
    if (providers.AlchemyProvider) {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error2) {
      }
    }
    if (providers.PocketProvider) {
      const skip2 = ["goerli", "ropsten", "rinkeby"];
      try {
        const provider = new providers.PocketProvider(network);
        if (provider.network && skip2.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error2) {
      }
    }
    if (providers.CloudflareProvider) {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error2) {
      }
    }
    if (providerList.length === 0) {
      return null;
    }
    if (providers.FallbackProvider) {
      let quorum = 1;
      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }
      return new providers.FallbackProvider(providerList, quorum);
    }
    return providerList[0];
  };
  func.renetwork = function(network2) {
    return ethDefaultProvider(network2);
  };
  return func;
}
function etcDefaultProvider(url2, network) {
  const func = function(providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url2, network);
    }
    return null;
  };
  func.renetwork = function(network2) {
    return etcDefaultProvider(url2, network2);
  };
  return func;
}
const homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
const networks = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead,
  mainnet: homestead,
  morden: { chainId: 2, name: "morden" },
  ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: { chainId: 137, name: "matic" },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: { chainId: 10, name: "optimism" },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function getNetwork(network) {
  if (network == null) {
    return null;
  }
  if (typeof network === "number") {
    for (const name2 in networks) {
      const standard2 = networks[name2];
      if (standard2.chainId === network) {
        return {
          name: standard2.name,
          chainId: standard2.chainId,
          ensAddress: standard2.ensAddress || null,
          _defaultProvider: standard2._defaultProvider || null
        };
      }
    }
    return {
      chainId: network,
      name: "unknown"
    };
  }
  if (typeof network === "string") {
    const standard2 = networks[network];
    if (standard2 == null) {
      return null;
    }
    return {
      name: standard2.name,
      chainId: standard2.chainId,
      ensAddress: standard2.ensAddress,
      _defaultProvider: standard2._defaultProvider || null
    };
  }
  const standard = networks[network.name];
  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger$4.throwArgumentError("invalid network chainId", "network", network);
    }
    return network;
  }
  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger$4.throwArgumentError("network chainId mismatch", "network", network);
  }
  let defaultProvider = network._defaultProvider || null;
  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  }
  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}
var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
var ALPHABET_MAP = {};
for (var z = 0; z < ALPHABET.length; z++) {
  var x = ALPHABET.charAt(z);
  if (ALPHABET_MAP[x] !== void 0)
    throw new TypeError(x + " is ambiguous");
  ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
  var b2 = pre >> 25;
  return (pre & 33554431) << 5 ^ -(b2 >> 0 & 1) & 996825010 ^ -(b2 >> 1 & 1) & 642813549 ^ -(b2 >> 2 & 1) & 513874426 ^ -(b2 >> 3 & 1) & 1027748829 ^ -(b2 >> 4 & 1) & 705979059;
}
function prefixChk(prefix) {
  var chk = 1;
  for (var i2 = 0; i2 < prefix.length; ++i2) {
    var c2 = prefix.charCodeAt(i2);
    if (c2 < 33 || c2 > 126)
      return "Invalid prefix (" + prefix + ")";
    chk = polymodStep(chk) ^ c2 >> 5;
  }
  chk = polymodStep(chk);
  for (i2 = 0; i2 < prefix.length; ++i2) {
    var v2 = prefix.charCodeAt(i2);
    chk = polymodStep(chk) ^ v2 & 31;
  }
  return chk;
}
function encode(prefix, words2, LIMIT) {
  LIMIT = LIMIT || 90;
  if (prefix.length + 7 + words2.length > LIMIT)
    throw new TypeError("Exceeds length limit");
  prefix = prefix.toLowerCase();
  var chk = prefixChk(prefix);
  if (typeof chk === "string")
    throw new Error(chk);
  var result = prefix + "1";
  for (var i2 = 0; i2 < words2.length; ++i2) {
    var x2 = words2[i2];
    if (x2 >> 5 !== 0)
      throw new Error("Non 5-bit word");
    chk = polymodStep(chk) ^ x2;
    result += ALPHABET.charAt(x2);
  }
  for (i2 = 0; i2 < 6; ++i2) {
    chk = polymodStep(chk);
  }
  chk ^= 1;
  for (i2 = 0; i2 < 6; ++i2) {
    var v2 = chk >> (5 - i2) * 5 & 31;
    result += ALPHABET.charAt(v2);
  }
  return result;
}
function __decode(str2, LIMIT) {
  LIMIT = LIMIT || 90;
  if (str2.length < 8)
    return str2 + " too short";
  if (str2.length > LIMIT)
    return "Exceeds length limit";
  var lowered = str2.toLowerCase();
  var uppered = str2.toUpperCase();
  if (str2 !== lowered && str2 !== uppered)
    return "Mixed-case string " + str2;
  str2 = lowered;
  var split = str2.lastIndexOf("1");
  if (split === -1)
    return "No separator character for " + str2;
  if (split === 0)
    return "Missing prefix for " + str2;
  var prefix = str2.slice(0, split);
  var wordChars = str2.slice(split + 1);
  if (wordChars.length < 6)
    return "Data too short";
  var chk = prefixChk(prefix);
  if (typeof chk === "string")
    return chk;
  var words2 = [];
  for (var i2 = 0; i2 < wordChars.length; ++i2) {
    var c2 = wordChars.charAt(i2);
    var v2 = ALPHABET_MAP[c2];
    if (v2 === void 0)
      return "Unknown character " + c2;
    chk = polymodStep(chk) ^ v2;
    if (i2 + 6 >= wordChars.length)
      continue;
    words2.push(v2);
  }
  if (chk !== 1)
    return "Invalid checksum for " + str2;
  return { prefix, words: words2 };
}
function decodeUnsafe() {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
}
function decode(str2) {
  var res = __decode.apply(null, arguments);
  if (typeof res === "object")
    return res;
  throw new Error(res);
}
function convert(data, inBits, outBits, pad2) {
  var value2 = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];
  for (var i2 = 0; i2 < data.length; ++i2) {
    value2 = value2 << inBits | data[i2];
    bits += inBits;
    while (bits >= outBits) {
      bits -= outBits;
      result.push(value2 >> bits & maxV);
    }
  }
  if (pad2) {
    if (bits > 0) {
      result.push(value2 << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits)
      return "Excess padding";
    if (value2 << outBits - bits & maxV)
      return "Non-zero padding";
  }
  return result;
}
function toWordsUnsafe(bytes3) {
  var res = convert(bytes3, 8, 5, true);
  if (Array.isArray(res))
    return res;
}
function toWords(bytes3) {
  var res = convert(bytes3, 8, 5, true);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
function fromWordsUnsafe(words2) {
  var res = convert(words2, 5, 8, false);
  if (Array.isArray(res))
    return res;
}
function fromWords(words2) {
  var res = convert(words2, 5, 8, false);
  if (Array.isArray(res))
    return res;
  throw new Error(res);
}
var bech32 = {
  decodeUnsafe,
  decode,
  encode,
  toWordsUnsafe,
  toWords,
  fromWordsUnsafe,
  fromWords
};
const version = "providers/5.5.2";
const logger$3 = new Logger(version);
class Formatter {
  constructor() {
    logger$3.checkNew(new.target, Formatter);
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash3 = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number2 = this.number.bind(this);
    const type = this.type.bind(this);
    const strictData = (v2) => {
      return this.data(v2, true);
    };
    formats.transaction = {
      hash: hash3,
      type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash3, null),
      blockNumber: Formatter.allowNull(number2, null),
      transactionIndex: Formatter.allowNull(number2, null),
      confirmations: Formatter.allowNull(number2, null),
      from: address,
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number2,
      data,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number2),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number2),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number2),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number2,
      blockNumber: number2,
      transactionHash: hash3,
      address,
      topics: Formatter.arrayOf(hash3),
      data,
      logIndex: number2,
      blockHash: hash3
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number2,
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data),
      blockHash: hash3,
      transactionHash: hash3,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number2,
      confirmations: Formatter.allowNull(number2, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number2),
      type
    };
    formats.block = {
      hash: hash3,
      parentHash: hash3,
      number: number2,
      timestamp: number2,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: address,
      extraData: data,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash3)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = shallowCopy(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, void 0),
      toBlock: Formatter.allowNull(blockTag, void 0),
      blockHash: Formatter.allowNull(hash3, void 0),
      address: Formatter.allowNull(address, void 0),
      topics: Formatter.allowNull(this.topics.bind(this), void 0)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number2),
      blockHash: Formatter.allowNull(hash3),
      transactionIndex: number2,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address,
      data: Formatter.allowFalsish(data, "0x"),
      topics: Formatter.arrayOf(hash3),
      transactionHash: hash3,
      logIndex: number2
    };
    return formats;
  }
  accessList(accessList) {
    return accessListify(accessList || []);
  }
  number(number2) {
    if (number2 === "0x") {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  type(number2) {
    if (number2 === "0x" || number2 == null) {
      return 0;
    }
    return BigNumber.from(number2).toNumber();
  }
  bigNumber(value2) {
    return BigNumber.from(value2);
  }
  boolean(value2) {
    if (typeof value2 === "boolean") {
      return value2;
    }
    if (typeof value2 === "string") {
      value2 = value2.toLowerCase();
      if (value2 === "true") {
        return true;
      }
      if (value2 === "false") {
        return false;
      }
    }
    throw new Error("invalid boolean - " + value2);
  }
  hex(value2, strict) {
    if (typeof value2 === "string") {
      if (!strict && value2.substring(0, 2) !== "0x") {
        value2 = "0x" + value2;
      }
      if (isHexString$5(value2)) {
        return value2.toLowerCase();
      }
    }
    return logger$3.throwArgumentError("invalid hash", "value", value2);
  }
  data(value2, strict) {
    const result = this.hex(value2, strict);
    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value2);
    }
    return result;
  }
  address(value2) {
    return getAddress(value2);
  }
  callAddress(value2) {
    if (!isHexString$5(value2, 32)) {
      return null;
    }
    const address = getAddress(hexDataSlice(value2, 12));
    return address === AddressZero ? null : address;
  }
  contractAddress(value2) {
    return getContractAddress(value2);
  }
  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    if (blockTag === "earliest") {
      return "0x0";
    }
    if (blockTag === "latest" || blockTag === "pending") {
      return blockTag;
    }
    if (typeof blockTag === "number" || isHexString$5(blockTag)) {
      return hexValue(blockTag);
    }
    throw new Error("invalid blockTag");
  }
  hash(value2, strict) {
    const result = this.hex(value2, strict);
    if (hexDataLength(result) !== 32) {
      return logger$3.throwArgumentError("invalid hash", "value", value2);
    }
    return result;
  }
  difficulty(value2) {
    if (value2 == null) {
      return null;
    }
    const v2 = BigNumber.from(value2);
    try {
      return v2.toNumber();
    } catch (error2) {
    }
    return null;
  }
  uint256(value2) {
    if (!isHexString$5(value2)) {
      throw new Error("invalid uint256");
    }
    return hexZeroPad(value2, 32);
  }
  _block(value2, format2) {
    if (value2.author != null && value2.miner == null) {
      value2.miner = value2.author;
    }
    const difficulty = value2._difficulty != null ? value2._difficulty : value2.difficulty;
    const result = Formatter.check(format2, value2);
    result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
    return result;
  }
  block(value2) {
    return this._block(value2, this.formats.block);
  }
  blockWithTransactions(value2) {
    return this._block(value2, this.formats.blockWithTransactions);
  }
  transactionRequest(value2) {
    return Formatter.check(this.formats.transactionRequest, value2);
  }
  transactionResponse(transaction) {
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    }
    if (transaction.to && BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    }
    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    }
    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }
    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }
    const result = Formatter.check(this.formats.transaction, transaction);
    if (transaction.chainId != null) {
      let chainId = transaction.chainId;
      if (isHexString$5(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId;
      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }
      if (isHexString$5(chainId)) {
        chainId = BigNumber.from(chainId).toNumber();
      }
      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;
        if (chainId < 0) {
          chainId = 0;
        }
        chainId = parseInt(chainId);
      }
      if (typeof chainId !== "number") {
        chainId = 0;
      }
      result.chainId = chainId;
    }
    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }
    return result;
  }
  transaction(value2) {
    return parse$1(value2);
  }
  receiptLog(value2) {
    return Formatter.check(this.formats.receiptLog, value2);
  }
  receipt(value2) {
    const result = Formatter.check(this.formats.receipt, value2);
    if (result.root != null) {
      if (result.root.length <= 4) {
        const value3 = BigNumber.from(result.root).toNumber();
        if (value3 === 0 || value3 === 1) {
          if (result.status != null && result.status !== value3) {
            logger$3.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
          }
          result.status = value3;
          delete result.root;
        } else {
          logger$3.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        logger$3.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }
    if (result.status != null) {
      result.byzantium = true;
    }
    return result;
  }
  topics(value2) {
    if (Array.isArray(value2)) {
      return value2.map((v2) => this.topics(v2));
    } else if (value2 != null) {
      return this.hash(value2, true);
    }
    return null;
  }
  filter(value2) {
    return Formatter.check(this.formats.filter, value2);
  }
  filterLog(value2) {
    return Formatter.check(this.formats.filterLog, value2);
  }
  static check(format2, object2) {
    const result = {};
    for (const key2 in format2) {
      try {
        const value2 = format2[key2](object2[key2]);
        if (value2 !== void 0) {
          result[key2] = value2;
        }
      } catch (error2) {
        error2.checkKey = key2;
        error2.checkValue = object2[key2];
        throw error2;
      }
    }
    return result;
  }
  static allowNull(format2, nullValue) {
    return function(value2) {
      if (value2 == null) {
        return nullValue;
      }
      return format2(value2);
    };
  }
  static allowFalsish(format2, replaceValue) {
    return function(value2) {
      if (!value2) {
        return replaceValue;
      }
      return format2(value2);
    };
  }
  static arrayOf(format2) {
    return function(array2) {
      if (!Array.isArray(array2)) {
        throw new Error("not an array");
      }
      const result = [];
      array2.forEach(function(value2) {
        result.push(format2(value2));
      });
      return result;
    };
  }
}
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$2 = new Logger(version);
function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }
  if (hexDataLength(topic) !== 32) {
    logger$2.throwArgumentError("invalid topic", "topic", topic);
  }
  return topic.toLowerCase();
}
function serializeTopics(topics) {
  topics = topics.slice();
  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }
  return topics.map((topic) => {
    if (Array.isArray(topic)) {
      const unique = {};
      topic.forEach((topic2) => {
        unique[checkTopic(topic2)] = true;
      });
      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}
function deserializeTopics(data) {
  if (data === "") {
    return [];
  }
  return data.split(/&/g).map((topic) => {
    if (topic === "") {
      return [];
    }
    const comps = topic.split("|").map((topic2) => {
      return topic2 === "null" ? null : topic2;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}
function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();
    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }
    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger$2.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }
  throw new Error("invalid event - " + eventName);
}
function getTime() {
  return new Date().getTime();
}
function stall(duration) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, duration);
  });
}
const PollableEvents = ["block", "network", "pending", "poll"];
class Event {
  constructor(tag, listener, once3) {
    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once3);
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const comps = this.tag.split(":");
    if (comps[0] !== "tx") {
      return null;
    }
    return comps[1];
  }
  get filter() {
    const comps = this.tag.split(":");
    if (comps[0] !== "filter") {
      return null;
    }
    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter2 = {};
    if (topics.length > 0) {
      filter2.topics = topics;
    }
    if (address && address !== "*") {
      filter2.address = address;
    }
    return filter2;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }
}
const coinInfos = {
  "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
  "60": { symbol: "eth", ilk: "eth" },
  "61": { symbol: "etc", ilk: "eth" },
  "700": { symbol: "xdai", ilk: "eth" }
};
function bytes32ify(value2) {
  return hexZeroPad(BigNumber.from(value2).toHexString(), 32);
}
function base58Encode(data) {
  return Base58.encode(concat$2([data, hexDataSlice(sha256$3(sha256$3(data)), 0, 4)]));
}
const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
const matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result) {
  try {
    return toUtf8String(_parseBytes(result));
  } catch (error2) {
  }
  return null;
}
function _parseBytes(result) {
  if (result === "0x") {
    return null;
  }
  const offset = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();
  const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length);
}
function getIpfsLink(link) {
  return `https://gateway.ipfs.io/ipfs/${link.substring(7)}`;
}
class Resolver {
  constructor(provider, address, name2, resolvedAddress) {
    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name2);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }
  _fetchBytes(selector, parameters) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const tx = {
        to: this.address,
        data: hexConcat([selector, namehash(this.name), parameters || "0x"])
      };
      try {
        return _parseBytes(yield this.provider.call(tx));
      } catch (error2) {
        if (error2.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        return null;
      }
    });
  }
  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];
    if (coinInfo == null) {
      logger$2.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }
    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }
    const bytes3 = arrayify(hexBytes);
    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);
        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat$2([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    }
    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (p2sh) {
        const length = parseInt(p2sh[1], 16);
        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode(concat$2([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    }
    if (coinInfo.prefix != null) {
      const length = bytes3[1];
      let version2 = bytes3[0];
      if (version2 === 0) {
        if (length !== 20 && length !== 32) {
          version2 = -1;
        }
      } else {
        version2 = -1;
      }
      if (version2 >= 0 && bytes3.length === 2 + length && length >= 1 && length <= 75) {
        const words2 = bech32.toWords(bytes3.slice(2));
        words2.unshift(version2);
        return bech32.encode(coinInfo.prefix, words2);
      }
    }
    return null;
  }
  getAddress(coinType) {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      }
      if (coinType === 60) {
        try {
          const transaction = {
            to: this.address,
            data: "0x3b3b57de" + namehash(this.name).substring(2)
          };
          const hexBytes2 = yield this.provider.call(transaction);
          if (hexBytes2 === "0x" || hexBytes2 === HashZero) {
            return null;
          }
          return this.provider.formatter.callAddress(hexBytes2);
        } catch (error2) {
          if (error2.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error2;
        }
      }
      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const address = this._getAddress(coinType, hexBytes);
      if (address == null) {
        logger$2.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType,
          data: hexBytes
        });
      }
      return address;
    });
  }
  getAvatar() {
    return __awaiter$2(this, void 0, void 0, function* () {
      const linkage = [{ type: "name", content: this.name }];
      try {
        const avatar = yield this.getText("avatar");
        if (avatar == null) {
          return null;
        }
        for (let i2 = 0; i2 < matchers.length; i2++) {
          const match = avatar.match(matchers[i2]);
          if (match == null) {
            continue;
          }
          const scheme = match[1].toLowerCase();
          switch (scheme) {
            case "https":
              linkage.push({ type: "url", content: avatar });
              return { linkage, url: avatar };
            case "data":
              linkage.push({ type: "data", content: avatar });
              return { linkage, url: avatar };
            case "ipfs":
              linkage.push({ type: "ipfs", content: avatar });
              return { linkage, url: getIpfsLink(avatar) };
            case "erc721":
            case "erc1155": {
              const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              linkage.push({ type: scheme, content: avatar });
              const owner = this._resolvedAddress || (yield this.getAddress());
              const comps = (match[2] || "").split("/");
              if (comps.length !== 2) {
                return null;
              }
              const addr = yield this.provider.formatter.address(comps[0]);
              const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
              if (scheme === "erc721") {
                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                }));
                if (owner !== tokenOwner) {
                  return null;
                }
                linkage.push({ type: "owner", content: tokenOwner });
              } else if (scheme === "erc1155") {
                const balance = BigNumber.from(yield this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                }));
                if (balance.isZero()) {
                  return null;
                }
                linkage.push({ type: "balance", content: balance.toString() });
              }
              const tx = {
                to: this.provider.formatter.address(comps[0]),
                data: hexConcat([selector, tokenId])
              };
              let metadataUrl = _parseString(yield this.provider.call(tx));
              if (metadataUrl == null) {
                return null;
              }
              linkage.push({ type: "metadata-url", content: metadataUrl });
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
              }
              const metadata = yield fetchJson(metadataUrl);
              if (!metadata) {
                return null;
              }
              linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
              let imageUrl = metadata.image;
              if (typeof imageUrl !== "string") {
                return null;
              }
              if (imageUrl.match(/^(https:\/\/|data:)/i)) {
              } else {
                const ipfs = imageUrl.match(matcherIpfs);
                if (ipfs == null) {
                  return null;
                }
                linkage.push({ type: "url-ipfs", content: imageUrl });
                imageUrl = getIpfsLink(imageUrl);
              }
              linkage.push({ type: "url", content: imageUrl });
              return { linkage, url: imageUrl };
            }
          }
        }
      } catch (error2) {
      }
      return null;
    });
  }
  getContentHash() {
    return __awaiter$2(this, void 0, void 0, function* () {
      const hexBytes = yield this._fetchBytes("0xbc1c58d1");
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (ipfs) {
        const length = parseInt(ipfs[3], 16);
        if (ipfs[4].length === length * 2) {
          return "ipfs://" + Base58.encode("0x" + ipfs[1]);
        }
      }
      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz://" + swarm[1];
        }
      }
      return logger$2.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }
  getText(key2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let keyBytes = toUtf8Bytes(key2);
      keyBytes = concat$2([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
      if (keyBytes.length % 32 !== 0) {
        keyBytes = concat$2([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
      }
      const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }
      return toUtf8String(hexBytes);
    });
  }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends Provider {
  constructor(network) {
    logger$2.checkNew(new.target, Provider);
    super();
    this._events = [];
    this._emitted = { block: -2 };
    this.formatter = new.target.getFormatter();
    defineReadOnly(this, "anyNetwork", network === "any");
    if (this.anyNetwork) {
      network = this.detectNetwork();
    }
    if (network instanceof Promise) {
      this._networkPromise = network;
      network.catch((error2) => {
      });
      this._ready().catch((error2) => {
      });
    } else {
      const knownNetwork = getStatic(new.target, "getNetwork")(network);
      if (knownNetwork) {
        defineReadOnly(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger$2.throwArgumentError("invalid network", "network", network);
      }
    }
    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._pollingInterval = 4e3;
    this._fastQueryDate = 0;
  }
  _ready() {
    return __awaiter$2(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;
        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error2) {
          }
        }
        if (network == null) {
          network = yield this.detectNetwork();
        }
        if (!network) {
          logger$2.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
        }
        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            defineReadOnly(this, "_network", network);
          }
          this.emit("network", network, null);
        }
      }
      return this._network;
    });
  }
  get ready() {
    return poll(() => {
      return this._ready().then((network) => {
        return network;
      }, (error2) => {
        if (error2.code === Logger.errors.NETWORK_ERROR && error2.event === "noNetwork") {
          return void 0;
        }
        throw error2;
      });
    });
  }
  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new Formatter();
    }
    return defaultFormatter;
  }
  static getNetwork(network) {
    return getNetwork(network == null ? "homestead" : network);
  }
  _getInternalBlockNumber(maxAge) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this._ready();
      if (maxAge > 0) {
        while (this._internalBlockNumber) {
          const internalBlockNumber = this._internalBlockNumber;
          try {
            const result = yield internalBlockNumber;
            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            }
            break;
          } catch (error2) {
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }
      const reqTime = getTime();
      const checkInternalBlockNumber = resolveProperties({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((network) => null, (error2) => error2)
      }).then(({ blockNumber, networkError }) => {
        if (networkError) {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
          throw networkError;
        }
        const respTime = getTime();
        blockNumber = BigNumber.from(blockNumber).toNumber();
        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }
        this._maxInternalBlockNumber = blockNumber;
        this._setFastBlockNumber(blockNumber);
        return { blockNumber, reqTime, respTime };
      });
      this._internalBlockNumber = checkInternalBlockNumber;
      checkInternalBlockNumber.catch((error2) => {
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }
  poll() {
    return __awaiter$2(this, void 0, void 0, function* () {
      const pollId = nextPollId++;
      const runners = [];
      let blockNumber = null;
      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error2) {
        this.emit("error", error2);
        return;
      }
      this._setFastBlockNumber(blockNumber);
      this.emit("poll", pollId, blockNumber);
      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      }
      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }
      if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
        logger$2.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger$2.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
          blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        for (let i2 = this._emitted.block + 1; i2 <= blockNumber; i2++) {
          this.emit("block", i2);
        }
      }
      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach((key2) => {
          if (key2 === "block") {
            return;
          }
          const eventBlockNumber = this._emitted[key2];
          if (eventBlockNumber === "pending") {
            return;
          }
          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key2];
          }
        });
      }
      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      }
      this._events.forEach((event) => {
        switch (event.type) {
          case "tx": {
            const hash3 = event.hash;
            let runner = this.getTransactionReceipt(hash3).then((receipt) => {
              if (!receipt || receipt.blockNumber == null) {
                return null;
              }
              this._emitted["t:" + hash3] = receipt.blockNumber;
              this.emit(hash3, receipt);
              return null;
            }).catch((error2) => {
              this.emit("error", error2);
            });
            runners.push(runner);
            break;
          }
          case "filter": {
            const filter2 = event.filter;
            filter2.fromBlock = this._lastBlockNumber + 1;
            filter2.toBlock = blockNumber;
            const runner = this.getLogs(filter2).then((logs) => {
              if (logs.length === 0) {
                return;
              }
              logs.forEach((log2) => {
                this._emitted["b:" + log2.blockHash] = log2.blockNumber;
                this._emitted["t:" + log2.transactionHash] = log2.blockNumber;
                this.emit(filter2, log2);
              });
            }).catch((error2) => {
              this.emit("error", error2);
            });
            runners.push(runner);
            break;
          }
        }
      });
      this._lastBlockNumber = blockNumber;
      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch((error2) => {
        this.emit("error", error2);
      });
      return;
    });
  }
  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;
    if (this.polling) {
      this.poll();
    }
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return __awaiter$2(this, void 0, void 0, function* () {
      return logger$2.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return __awaiter$2(this, void 0, void 0, function* () {
      const network = yield this._ready();
      const currentNetwork = yield this.detectNetwork();
      if (network.chainId !== currentNetwork.chainId) {
        if (this.anyNetwork) {
          this._network = currentNetwork;
          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null;
          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }
        const error2 = logger$2.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error2);
        throw error2;
      }
      return network;
    });
  }
  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
      this._setFastBlockNumber(blockNumber);
    }, (error2) => {
    });
    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(value2) {
    if (value2 && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);
      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll();
          this._bootstrapPoll = setTimeout(() => {
            if (!this._poller) {
              this.poll();
            }
            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value2 && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(value2) {
    if (typeof value2 !== "number" || value2 <= 0 || parseInt(String(value2)) != value2) {
      throw new Error("invalid polling interval");
    }
    this._pollingInterval = value2;
    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }
  _getFastBlockNumber() {
    const now = getTime();
    if (now - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now;
      this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }
        return this._fastBlockNumber;
      });
    }
    return this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(blockNumber) {
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    }
    this._fastQueryDate = getTime();
    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }
  waitForTransaction(transactionHash, confirmations, timeout2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout2 || 0, null);
    });
  }
  _waitForTransaction(transactionHash, confirmations, timeout2, replaceable) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash);
      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      }
      return new Promise((resolve2, reject) => {
        const cancelFuncs = [];
        let done2 = false;
        const alreadyDone = function() {
          if (done2) {
            return true;
          }
          done2 = true;
          cancelFuncs.forEach((func) => {
            func();
          });
          return false;
        };
        const minedHandler = (receipt2) => {
          if (receipt2.confirmations < confirmations) {
            return;
          }
          if (alreadyDone()) {
            return;
          }
          resolve2(receipt2);
        };
        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });
        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;
          const replaceHandler = (blockNumber) => __awaiter$2(this, void 0, void 0, function* () {
            if (done2) {
              return;
            }
            yield stall(1e3);
            this.getTransactionCount(replaceable.from).then((nonce) => __awaiter$2(this, void 0, void 0, function* () {
              if (done2) {
                return;
              }
              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                {
                  const mined = yield this.getTransaction(transactionHash);
                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                }
                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;
                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }
                while (scannedBlock <= blockNumber) {
                  if (done2) {
                    return;
                  }
                  const block = yield this.getBlockWithTransactions(scannedBlock);
                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti];
                    if (tx.hash === transactionHash) {
                      return;
                    }
                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done2) {
                        return;
                      }
                      const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                      if (alreadyDone()) {
                        return;
                      }
                      let reason = "replaced";
                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      }
                      reject(logger$2.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt: receipt2
                      }));
                      return;
                    }
                  }
                  scannedBlock++;
                }
              }
              if (done2) {
                return;
              }
              this.once("block", replaceHandler);
            }), (error2) => {
              if (done2) {
                return;
              }
              this.once("block", replaceHandler);
            });
          });
          if (done2) {
            return;
          }
          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }
        if (typeof timeout2 === "number" && timeout2 > 0) {
          const timer2 = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }
            reject(logger$2.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout: timeout2 }));
          }, timeout2);
          if (timer2.unref) {
            timer2.unref();
          }
          cancelFuncs.push(() => {
            clearTimeout(timer2);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return __awaiter$2(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});
      try {
        return BigNumber.from(result);
      } catch (error2) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error: error2
        });
      }
    });
  }
  getBalance(addressOrName, blockTag) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);
      try {
        return BigNumber.from(result);
      } catch (error2) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error: error2
        });
      }
    });
  }
  getTransactionCount(addressOrName, blockTag) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);
      try {
        return BigNumber.from(result).toNumber();
      } catch (error2) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error: error2
        });
      }
    });
  }
  getCode(addressOrName, blockTag) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);
      try {
        return hexlify(result);
      } catch (error2) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error: error2
        });
      }
    });
  }
  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then((p2) => hexValue(p2))
      });
      const result = yield this.perform("getStorageAt", params);
      try {
        return hexlify(result);
      } catch (error2) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error: error2
        });
      }
    });
  }
  _wrapTransaction(tx, hash3, startBlock) {
    if (hash3 != null && hexDataLength(hash3) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }
    const result = tx;
    if (hash3 != null && tx.hash !== hash3) {
      logger$2.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash3 });
    }
    result.wait = (confirms, timeout2) => __awaiter$2(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }
      if (timeout2 == null) {
        timeout2 = 0;
      }
      let replacement = void 0;
      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }
      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout2, replacement);
      if (receipt == null && confirms === 0) {
        return null;
      }
      this._emitted["t:" + tx.hash] = receipt.blockNumber;
      if (receipt.status === 0) {
        logger$2.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt
        });
      }
      return receipt;
    });
    return result;
  }
  sendTransaction(signedTransaction) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then((t2) => hexlify(t2));
      const tx = this.formatter.transaction(signedTransaction);
      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }
      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const hash3 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
        return this._wrapTransaction(tx, hash3, blockNumber);
      } catch (error2) {
        error2.transaction = tx;
        error2.transactionHash = tx.hash;
        throw error2;
      }
    });
  }
  _getTransactionRequest(transaction) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? this._getAddress(v2) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? BigNumber.from(v2) : null);
      });
      ["type"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 != null ? v2 : null);
      });
      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }
      ["data"].forEach((key2) => {
        if (values[key2] == null) {
          return;
        }
        tx[key2] = Promise.resolve(values[key2]).then((v2) => v2 ? hexlify(v2) : null);
      });
      return this.formatter.transactionRequest(yield resolveProperties(tx));
    });
  }
  _getFilter(filter2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      filter2 = yield filter2;
      const result = {};
      if (filter2.address != null) {
        result.address = this._getAddress(filter2.address);
      }
      ["blockHash", "topics"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = filter2[key2];
      });
      ["fromBlock", "toBlock"].forEach((key2) => {
        if (filter2[key2] == null) {
          return;
        }
        result[key2] = this._getBlockTag(filter2[key2]);
      });
      return this.formatter.filter(yield resolveProperties(result));
    });
  }
  call(transaction, blockTag) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("call", params);
      try {
        return hexlify(result);
      } catch (error2) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "call",
          params,
          result,
          error: error2
        });
      }
    });
  }
  estimateGas(transaction) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);
      try {
        return BigNumber.from(result);
      } catch (error2) {
        return logger$2.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error: error2
        });
      }
    });
  }
  _getAddress(addressOrName) {
    return __awaiter$2(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;
      if (typeof addressOrName !== "string") {
        logger$2.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }
      const address = yield this.resolveName(addressOrName);
      if (address == null) {
        logger$2.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }
      return address;
    });
  }
  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag;
      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };
      if (isHexString$5(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
          if (isHexString$5(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error2) {
          logger$2.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }
      return poll(() => __awaiter$2(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params);
        if (block == null) {
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          }
          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          }
          return void 0;
        }
        if (includeTransactions) {
          let blockNumber2 = null;
          for (let i2 = 0; i2 < block.transactions.length; i2++) {
            const tx = block.transactions[i2];
            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber2 == null) {
                blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              }
              let confirmations = blockNumber2 - tx.blockNumber + 1;
              if (confirmations <= 0) {
                confirmations = 1;
              }
              tx.confirmations = confirmations;
            }
          }
          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
          return blockWithTxs;
        }
        return this.formatter.block(block);
      }), { oncePoll: this });
    });
  }
  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }
  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }
  getTransaction(transactionHash) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$2(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        const tx = this.formatter.transactionResponse(result);
        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - tx.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          tx.confirmations = confirmations;
        }
        return this._wrapTransaction(tx);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(transactionHash) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = { transactionHash: this.formatter.hash(transactionHash, true) };
      return poll(() => __awaiter$2(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);
        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }
          return void 0;
        }
        if (result.blockHash == null) {
          return void 0;
        }
        const receipt = this.formatter.receipt(result);
        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          let confirmations = blockNumber - receipt.blockNumber + 1;
          if (confirmations <= 0) {
            confirmations = 1;
          }
          receipt.confirmations = confirmations;
        }
        return receipt;
      }), { oncePoll: this });
    });
  }
  getLogs(filter2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield resolveProperties({ filter: this._getFilter(filter2) });
      const logs = yield this.perform("getLogs", params);
      logs.forEach((log2) => {
        if (log2.removed == null) {
          log2.removed = false;
        }
      });
      return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }
  getEtherPrice() {
    return __awaiter$2(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(blockTag) {
    return __awaiter$2(this, void 0, void 0, function* () {
      blockTag = yield blockTag;
      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger$2.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }
        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;
        if (blockNumber < 0) {
          blockNumber = 0;
        }
        return this.formatter.blockTag(blockNumber);
      }
      return this.formatter.blockTag(blockTag);
    });
  }
  getResolver(name2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      try {
        const address = yield this._getResolver(name2);
        if (address == null) {
          return null;
        }
        return new Resolver(this, address, name2);
      } catch (error2) {
        if (error2.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error2;
      }
    });
  }
  _getResolver(name2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const network = yield this.getNetwork();
      if (!network.ensAddress) {
        logger$2.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation: "ENS", network: network.name });
      }
      const transaction = {
        to: network.ensAddress,
        data: "0x0178b8bf" + namehash(name2).substring(2)
      };
      try {
        return this.formatter.callAddress(yield this.call(transaction));
      } catch (error2) {
        if (error2.code === Logger.errors.CALL_EXCEPTION) {
          return null;
        }
        throw error2;
      }
    });
  }
  resolveName(name2) {
    return __awaiter$2(this, void 0, void 0, function* () {
      name2 = yield name2;
      try {
        return Promise.resolve(this.formatter.address(name2));
      } catch (error2) {
        if (isHexString$5(name2)) {
          throw error2;
        }
      }
      if (typeof name2 !== "string") {
        logger$2.throwArgumentError("invalid ENS name", "name", name2);
      }
      const resolver = yield this.getResolver(name2);
      if (!resolver) {
        return null;
      }
      return yield resolver.getAddress();
    });
  }
  lookupAddress(address) {
    return __awaiter$2(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddress = yield this._getResolver(reverseName);
      if (!resolverAddress) {
        return null;
      }
      let bytes3 = arrayify(yield this.call({
        to: resolverAddress,
        data: "0x691f3431" + namehash(reverseName).substring(2)
      }));
      if (bytes3.length < 32 || !BigNumber.from(bytes3.slice(0, 32)).eq(32)) {
        return null;
      }
      bytes3 = bytes3.slice(32);
      if (bytes3.length < 32) {
        return null;
      }
      const length = BigNumber.from(bytes3.slice(0, 32)).toNumber();
      bytes3 = bytes3.slice(32);
      if (length > bytes3.length) {
        return null;
      }
      const name2 = toUtf8String(bytes3.slice(0, length));
      const addr = yield this.resolveName(name2);
      if (addr != address) {
        return null;
      }
      return name2;
    });
  }
  getAvatar(nameOrAddress) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let resolver = null;
      if (isHexString$5(nameOrAddress)) {
        const address = this.formatter.address(nameOrAddress);
        const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(reverseName);
        if (!resolverAddress) {
          return null;
        }
        resolver = new Resolver(this, resolverAddress, "_", address);
      } else {
        resolver = yield this.getResolver(nameOrAddress);
        if (!resolver) {
          return null;
        }
      }
      const avatar = yield resolver.getAvatar();
      if (avatar == null) {
        return null;
      }
      return avatar.url;
    });
  }
  perform(method2, params) {
    return logger$2.throwError(method2 + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method2 });
  }
  _startEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _stopEvent(event) {
    this.polling = this._events.filter((e2) => e2.pollable()).length > 0;
  }
  _addEventListener(eventName, listener, once3) {
    const event = new Event(getEventTag(eventName), listener, once3);
    this._events.push(event);
    this._startEvent(event);
    return this;
  }
  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }
  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }
  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag) {
        return true;
      }
      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;
      if (event.once) {
        stopped.push(event);
        return false;
      }
      return true;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return result;
  }
  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => {
      return event.tag === eventTag;
    }).length;
  }
  listeners(eventName) {
    if (eventName == null) {
      return this._events.map((event) => event.listener);
    }
    let eventTag = getEventTag(eventName);
    return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
  }
  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }
    const stopped = [];
    let found = false;
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter((event) => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }
      if (found) {
        return true;
      }
      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
  removeAllListeners(eventName) {
    let stopped = [];
    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        stopped.push(event);
        return false;
      });
    }
    stopped.forEach((event) => {
      this._stopEvent(event);
    });
    return this;
  }
}
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const logger$1 = new Logger(version);
const errorGas = ["call", "estimateGas"];
function checkError(method2, error2, params) {
  if (method2 === "call" && error2.code === Logger.errors.SERVER_ERROR) {
    const e2 = error2.error;
    if (e2 && e2.message.match("reverted") && isHexString$5(e2.data)) {
      return e2.data;
    }
    logger$1.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
      error: error2,
      data: "0x"
    });
  }
  let message = error2.message;
  if (error2.code === Logger.errors.SERVER_ERROR && error2.error && typeof error2.error.message === "string") {
    message = error2.error.message;
  } else if (typeof error2.body === "string") {
    message = error2.body;
  } else if (typeof error2.responseText === "string") {
    message = error2.responseText;
  }
  message = (message || "").toLowerCase();
  const transaction = params.transaction || params.signedTransaction;
  if (message.match(/insufficient funds|base fee exceeds gas limit/)) {
    logger$1.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error: error2,
      method: method2,
      transaction
    });
  }
  if (message.match(/nonce too low/)) {
    logger$1.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error: error2,
      method: method2,
      transaction
    });
  }
  if (message.match(/replacement transaction underpriced/)) {
    logger$1.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error: error2,
      method: method2,
      transaction
    });
  }
  if (message.match(/only replay-protected/)) {
    logger$1.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error: error2,
      method: method2,
      transaction
    });
  }
  if (errorGas.indexOf(method2) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
    logger$1.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error: error2,
      method: method2,
      transaction
    });
  }
  throw error2;
}
function timer(timeout2) {
  return new Promise(function(resolve2) {
    setTimeout(resolve2, timeout2);
  });
}
function getResult(payload) {
  if (payload.error) {
    const error2 = new Error(payload.error.message);
    error2.code = payload.error.code;
    error2.data = payload.error.data;
    throw error2;
  }
  return payload.result;
}
function getLowerCase(value2) {
  if (value2) {
    return value2.toLowerCase();
  }
  return value2;
}
const _constructorGuard = {};
class JsonRpcSigner extends Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    logger$1.checkNew(new.target, JsonRpcSigner);
    super();
    if (constructorGuard !== _constructorGuard) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }
    defineReadOnly(this, "provider", provider);
    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }
    if (typeof addressOrIndex === "string") {
      defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
      defineReadOnly(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(this, "_index", addressOrIndex);
      defineReadOnly(this, "_address", null);
    } else {
      logger$1.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }
  connect(provider) {
    return logger$1.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }
  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }
    return this.provider.send("eth_accounts", []).then((accounts) => {
      if (accounts.length <= this._index) {
        logger$1.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }
      return this.provider.formatter.address(accounts[this._index]);
    });
  }
  sendUncheckedTransaction(transaction) {
    transaction = shallowCopy(transaction);
    const fromAddress = this.getAddress().then((address) => {
      if (address) {
        address = address.toLowerCase();
      }
      return address;
    });
    if (transaction.gasLimit == null) {
      const estimate = shallowCopy(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }
    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter$1(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }
        const address = yield this.provider.resolveName(to);
        if (address == null) {
          logger$1.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }
        return address;
      }));
    }
    return resolveProperties({
      tx: resolveProperties(transaction),
      sender: fromAddress
    }).then(({ tx, sender }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger$1.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }
      const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
      return this.provider.send("eth_sendTransaction", [hexTx]).then((hash3) => {
        return hash3;
      }, (error2) => {
        return checkError("sendTransaction", error2, hexTx);
      });
    });
  }
  signTransaction(transaction) {
    return logger$1.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(transaction) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
      const hash3 = yield this.sendUncheckedTransaction(transaction);
      try {
        return yield poll(() => __awaiter$1(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash3);
          if (tx === null) {
            return void 0;
          }
          return this.provider._wrapTransaction(tx, hash3, blockNumber);
        }), { oncePoll: this.provider });
      } catch (error2) {
        error2.transactionHash = hash3;
        throw error2;
      }
    });
  }
  signMessage(message) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("personal_sign", [hexlify(data), address.toLowerCase()]);
    });
  }
  _legacySignMessage(message) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? toUtf8Bytes(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data)]);
    });
  }
  _signTypedData(domain2, types2, value2) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const populated = yield TypedDataEncoder.resolveNames(domain2, types2, value2, (name2) => {
        return this.provider.resolveName(name2);
      });
      const address = yield this.getAddress();
      return yield this.provider.send("eth_signTypedData_v4", [
        address.toLowerCase(),
        JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types2, populated.value))
      ]);
    });
  }
  unlock(password) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then((hash3) => {
      return {
        hash: hash3,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: (confirmations) => {
          return this.provider.waitForTransaction(hash3, confirmations);
        }
      };
    });
  }
}
const allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
class JsonRpcProvider extends BaseProvider {
  constructor(url2, network) {
    logger$1.checkNew(new.target, JsonRpcProvider);
    let networkOrReady = network;
    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve2, reject) => {
        setTimeout(() => {
          this.detectNetwork().then((network2) => {
            resolve2(network2);
          }, (error2) => {
            reject(error2);
          });
        }, 0);
      });
    }
    super(networkOrReady);
    if (!url2) {
      url2 = getStatic(this.constructor, "defaultUrl")();
    }
    if (typeof url2 === "string") {
      defineReadOnly(this, "connection", Object.freeze({
        url: url2
      }));
    } else {
      defineReadOnly(this, "connection", Object.freeze(shallowCopy(url2)));
    }
    this._nextId = 42;
  }
  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }
    return this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork();
      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }
    return this._cache["detectNetwork"];
  }
  _uncachedDetectNetwork() {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;
      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error2) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error3) {
        }
      }
      if (chainId != null) {
        const getNetwork2 = getStatic(this.constructor, "getNetwork");
        try {
          return getNetwork2(BigNumber.from(chainId).toNumber());
        } catch (error2) {
          return logger$1.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
            chainId,
            event: "invalidNetwork",
            serverError: error2
          });
        }
      }
      return logger$1.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
  }
  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((accounts) => {
      return accounts.map((a2) => this.formatter.address(a2));
    });
  }
  send(method2, params) {
    const request = {
      method: method2,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: deepCopy(request),
      provider: this
    });
    const cache2 = ["eth_chainId", "eth_blockNumber"].indexOf(method2) >= 0;
    if (cache2 && this._cache[method2]) {
      return this._cache[method2];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error2) => {
      this.emit("debug", {
        action: "response",
        error: error2,
        request,
        provider: this
      });
      throw error2;
    });
    if (cache2) {
      this._cache[method2] = result;
      setTimeout(() => {
        this._cache[method2] = null;
      }, 0);
    }
    return result;
  }
  prepareRequest(method2, params) {
    switch (method2) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), params.position, params.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];
      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }
        return null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];
      case "call": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
      }
      case "estimateGas": {
        const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
        return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
      }
      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }
        return ["eth_getLogs", [params.filter]];
    }
    return null;
  }
  perform(method2, params) {
    return __awaiter$1(this, void 0, void 0, function* () {
      if (method2 === "call" || method2 === "estimateGas") {
        const tx = params.transaction;
        if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();
            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              params = shallowCopy(params);
              params.transaction = shallowCopy(tx);
              delete params.transaction.type;
            }
          }
        }
      }
      const args = this.prepareRequest(method2, params);
      if (args == null) {
        logger$1.throwError(method2 + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method2 });
      }
      try {
        return yield this.send(args[0], args[1]);
      } catch (error2) {
        return checkError(method2, error2, params);
      }
    });
  }
  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }
    super._startEvent(event);
  }
  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }
    const self2 = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function(filterId) {
      function poll2() {
        self2.send("eth_getFilterChanges", [filterId]).then(function(hashes) {
          if (self2._pendingFilter != pendingFilter) {
            return null;
          }
          let seq = Promise.resolve();
          hashes.forEach(function(hash3) {
            self2._emitted["t:" + hash3.toLowerCase()] = "pending";
            seq = seq.then(function() {
              return self2.getTransaction(hash3).then(function(tx) {
                self2.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function() {
            return timer(1e3);
          });
        }).then(function() {
          if (self2._pendingFilter != pendingFilter) {
            self2.send("eth_uninstallFilter", [filterId]);
            return;
          }
          setTimeout(function() {
            poll2();
          }, 0);
          return null;
        }).catch((error2) => {
        });
      }
      poll2();
      return filterId;
    }).catch((error2) => {
    });
  }
  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }
    super._stopEvent(event);
  }
  static hexlifyTransaction(transaction, allowExtra) {
    const allowed = shallowCopy(allowedTransactionKeys);
    if (allowExtra) {
      for (const key2 in allowExtra) {
        if (allowExtra[key2]) {
          allowed[key2] = true;
        }
      }
    }
    checkProperties(transaction, allowed);
    const result = {};
    ["gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      const value2 = hexValue(transaction[key2]);
      if (key2 === "gasLimit") {
        key2 = "gas";
      }
      result[key2] = value2;
    });
    ["from", "to", "data"].forEach(function(key2) {
      if (transaction[key2] == null) {
        return;
      }
      result[key2] = hexlify(transaction[key2]);
    });
    if (transaction.accessList) {
      result["accessList"] = accessListify(transaction.accessList);
    }
    return result;
  }
}
const logger = new Logger(version);
let _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function(method2, params) {
    const request = {
      method: method2,
      params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve2, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: deepCopy(request),
        provider: this
      });
      sendFunc(request, (error2, response) => {
        if (error2) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error: error2,
            request,
            provider: this
          });
          return reject(error2);
        }
        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });
        if (response.error) {
          const error3 = new Error(response.error.message);
          error3.code = response.error.code;
          error3.data = response.error.data;
          return reject(error3);
        }
        resolve2(response.result);
      });
    });
  };
}
function buildEip1193Fetcher(provider) {
  return function(method2, params) {
    if (params == null) {
      params = [];
    }
    const request = { method: method2, params };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: deepCopy(request),
      provider: this
    });
    return provider.request(request).then((response) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, (error2) => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error: error2,
        provider: this
      });
      throw error2;
    });
  };
}
class Web3Provider extends JsonRpcProvider {
  constructor(provider, network) {
    logger.checkNew(new.target, Web3Provider);
    if (provider == null) {
      logger.throwArgumentError("missing provider", "provider", provider);
    }
    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider2 = null;
    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";
      if (!path && provider.isMetaMask) {
        path = "metamask";
      }
      subprovider2 = provider;
      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }
        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger.throwArgumentError("unsupported provider", "provider", provider);
      }
      if (!path) {
        path = "unknown:";
      }
    }
    super(path, network);
    defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    defineReadOnly(this, "provider", subprovider2);
  }
  send(method2, params) {
    return this.jsonRpcFetchFunc(method2, params);
  }
}
new Logger(version);
var ChainId;
(function(ChainId2) {
  ChainId2[ChainId2["Hardhat"] = 31337] = "Hardhat";
  ChainId2[ChainId2["Mainnet"] = 1] = "Mainnet";
  ChainId2[ChainId2["Ropsten"] = 3] = "Ropsten";
  ChainId2[ChainId2["Rinkeby"] = 4] = "Rinkeby";
  ChainId2[ChainId2["Goerli"] = 5] = "Goerli";
  ChainId2[ChainId2["Kovan"] = 42] = "Kovan";
  ChainId2[ChainId2["xDai"] = 100] = "xDai";
  ChainId2[ChainId2["Rinkarby"] = 421611] = "Rinkarby";
  ChainId2[ChainId2["Arbitrum"] = 42161] = "Arbitrum";
  ChainId2[ChainId2["Polygon"] = 137] = "Polygon";
})(ChainId || (ChainId = {}));
({
  [ChainId.Hardhat]: "Hardhat",
  [ChainId.Mainnet]: "Mainnet",
  [ChainId.Ropsten]: "Ropsten",
  [ChainId.Kovan]: "Kovan",
  [ChainId.Rinkeby]: "Rinkeby",
  [ChainId.Goerli]: "Goerli",
  [ChainId.xDai]: "xDai",
  [ChainId.Rinkarby]: "Rinkarby",
  [ChainId.Arbitrum]: "Arbitrum",
  [ChainId.Polygon]: "Polygon"
});
const NETWORK_DETAILS = {
  [ChainId.Arbitrum]: {
    chainId: "0x" + ChainId.Arbitrum.toString(16),
    chainName: "Arbitrum",
    nativeCurrency: {
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: ["https://arb1.arbitrum.io/rpc"],
    blockExplorerUrls: ["https://arbiscan.io"]
  },
  [ChainId.Rinkarby]: {
    chainId: "0x" + ChainId.Rinkarby.toString(16),
    chainName: "RinkArby",
    nativeCurrency: {
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: ["https://rinkeby.arbitrum.io/rpc"],
    blockExplorerUrls: ["https://rinkeby-explorer.arbitrum.io"]
  },
  [ChainId.xDai]: {
    chainId: "0x" + ChainId.xDai.toString(16),
    chainName: "xDAI",
    nativeCurrency: {
      symbol: "xDAI",
      decimals: 18
    },
    rpcUrls: ["https://rpc.xdaichain.com"],
    blockExplorerUrls: ["https://blockscout.com/poa/xdai"]
  },
  [ChainId.Polygon]: {
    chainId: "0x" + ChainId.Polygon.toString(16),
    chainName: "Polygon Mainnet",
    nativeCurrency: {
      symbol: "MATIC",
      decimals: 18
    },
    rpcUrls: ["https://polygon-rpc.com/"],
    blockExplorerUrls: ["https://polygonscan.com/"]
  }
};
var contractName = "ERC20";
var abi = [
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_spender",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_from",
        type: "address"
      },
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "balance",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        name: "_to",
        type: "address"
      },
      {
        name: "_value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "_owner",
        type: "address"
      },
      {
        name: "_spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    payable: true,
    stateMutability: "payable",
    type: "fallback"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  }
];
var bytecode = "0x608060405234801561001057600080fd5b506105dd806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a5576000357c01000000000000000000000000000000000000000000000000000000009004806370a082311161007857806370a0823114610166578063a457c2d71461018c578063a9059cbb146101b8578063dd62ed3e146101e4576100a5565b8063095ea7b3146100aa57806318160ddd146100ea57806323b872dd14610104578063395093511461013a575b600080fd5b6100d6600480360360408110156100c057600080fd5b50600160a060020a038135169060200135610212565b604080519115158252519081900360200190f35b6100f2610290565b60408051918252519081900360200190f35b6100d66004803603606081101561011a57600080fd5b50600160a060020a03813581169160208101359091169060400135610296565b6100d66004803603604081101561015057600080fd5b50600160a060020a03813516906020013561035f565b6100f26004803603602081101561017c57600080fd5b5035600160a060020a031661040f565b6100d6600480360360408110156101a257600080fd5b50600160a060020a03813516906020013561042a565b6100d6600480360360408110156101ce57600080fd5b50600160a060020a038135169060200135610475565b6100f2600480360360408110156101fa57600080fd5b50600160a060020a038135811691602001351661048b565b6000600160a060020a038316151561022957600080fd5b336000818152600160209081526040808320600160a060020a03881680855290835292819020869055805186815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a350600192915050565b60025490565b600160a060020a03831660009081526001602090815260408083203384529091528120546102ca908363ffffffff6104b616565b600160a060020a03851660009081526001602090815260408083203384529091529020556102f98484846104cb565b600160a060020a0384166000818152600160209081526040808320338085529083529281902054815190815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a35060019392505050565b6000600160a060020a038316151561037657600080fd5b336000908152600160209081526040808320600160a060020a03871684529091529020546103aa908363ffffffff61059816565b336000818152600160209081526040808320600160a060020a0389168085529083529281902085905580519485525191937f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929081900390910190a350600192915050565b600160a060020a031660009081526020819052604090205490565b6000600160a060020a038316151561044157600080fd5b336000908152600160209081526040808320600160a060020a03871684529091529020546103aa908363ffffffff6104b616565b60006104823384846104cb565b50600192915050565b600160a060020a03918216600090815260016020908152604080832093909416825291909152205490565b6000828211156104c557600080fd5b50900390565b600160a060020a03821615156104e057600080fd5b600160a060020a038316600090815260208190526040902054610509908263ffffffff6104b616565b600160a060020a03808516600090815260208190526040808220939093559084168152205461053e908263ffffffff61059816565b600160a060020a038084166000818152602081815260409182902094909455805185815290519193928716927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef92918290030190a3505050565b6000828201838110156105aa57600080fd5b939250505056fea165627a7a72305820722c0187518ce2856a424bdba350d5a263c8f98fcb19cb4cc161372bc3b794c90029";
var deployedBytecode = "0x608060405234801561001057600080fd5b50600436106100a5576000357c01000000000000000000000000000000000000000000000000000000009004806370a082311161007857806370a0823114610166578063a457c2d71461018c578063a9059cbb146101b8578063dd62ed3e146101e4576100a5565b8063095ea7b3146100aa57806318160ddd146100ea57806323b872dd14610104578063395093511461013a575b600080fd5b6100d6600480360360408110156100c057600080fd5b50600160a060020a038135169060200135610212565b604080519115158252519081900360200190f35b6100f2610290565b60408051918252519081900360200190f35b6100d66004803603606081101561011a57600080fd5b50600160a060020a03813581169160208101359091169060400135610296565b6100d66004803603604081101561015057600080fd5b50600160a060020a03813516906020013561035f565b6100f26004803603602081101561017c57600080fd5b5035600160a060020a031661040f565b6100d6600480360360408110156101a257600080fd5b50600160a060020a03813516906020013561042a565b6100d6600480360360408110156101ce57600080fd5b50600160a060020a038135169060200135610475565b6100f2600480360360408110156101fa57600080fd5b50600160a060020a038135811691602001351661048b565b6000600160a060020a038316151561022957600080fd5b336000818152600160209081526040808320600160a060020a03881680855290835292819020869055805186815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a350600192915050565b60025490565b600160a060020a03831660009081526001602090815260408083203384529091528120546102ca908363ffffffff6104b616565b600160a060020a03851660009081526001602090815260408083203384529091529020556102f98484846104cb565b600160a060020a0384166000818152600160209081526040808320338085529083529281902054815190815290519293927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929181900390910190a35060019392505050565b6000600160a060020a038316151561037657600080fd5b336000908152600160209081526040808320600160a060020a03871684529091529020546103aa908363ffffffff61059816565b336000818152600160209081526040808320600160a060020a0389168085529083529281902085905580519485525191937f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925929081900390910190a350600192915050565b600160a060020a031660009081526020819052604090205490565b6000600160a060020a038316151561044157600080fd5b336000908152600160209081526040808320600160a060020a03871684529091529020546103aa908363ffffffff6104b616565b60006104823384846104cb565b50600192915050565b600160a060020a03918216600090815260016020908152604080832093909416825291909152205490565b6000828211156104c557600080fd5b50900390565b600160a060020a03821615156104e057600080fd5b600160a060020a038316600090815260208190526040902054610509908263ffffffff6104b616565b600160a060020a03808516600090815260208190526040808220939093559084168152205461053e908263ffffffff61059816565b600160a060020a038084166000818152602081815260409182902094909455805185815290519193928716927fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef92918290030190a3505050565b6000828201838110156105aa57600080fd5b939250505056fea165627a7a72305820722c0187518ce2856a424bdba350d5a263c8f98fcb19cb4cc161372bc3b794c90029";
var compiler = {
  name: "solc",
  version: "0.5.4+commit.9549d8ff.Emscripten.clang"
};
var ERC20 = {
  contractName,
  abi,
  bytecode,
  deployedBytecode,
  compiler
};
new Interface(ERC20.abi);
const boardOpen = ref(false);
function useBoard() {
  const open2 = () => {
    boardOpen.value = true;
  };
  const close = () => {
    boardOpen.value = false;
  };
  return {
    boardOpen,
    open: open2,
    close
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value2) {
    return value2 instanceof P2 ? value2 : new P2(function(resolve2) {
      resolve2(value2);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function checkChainId(chainId) {
  if (chainId in ChainId) {
    return true;
  }
  return false;
}
function shortenAddress(address) {
  if (utils$r.isAddress(address)) {
    return address.slice(0, 6) + "..." + address.slice(-4);
  } else {
    return "";
  }
}
function displayEther(balance, fixed = 2) {
  return (+utils$r.formatEther(balance)).toFixed(fixed);
}
class Metamask {
  static check() {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = yield dist$6();
      return provider ? true : false;
    });
  }
  static connect() {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = yield dist$6();
      yield provider.request({
        method: "eth_requestAccounts",
        params: [{ eth_accounts: {} }]
      });
      return provider;
    });
  }
  static switchChain(provider, chainId) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: "0x" + chainId.toString(16) }]
        });
      } catch (err) {
        try {
          if (err.code === 4902 && checkChainId(chainId)) {
            yield Metamask.addChain(provider, NETWORK_DETAILS[chainId]);
            return;
          }
        } catch (err2) {
          throw new Error(`Failed to add new chain: ${err2.message}`);
        }
        throw new Error(`Failed to switch chain: ${err.message}`);
      }
    });
  }
  static addChain(provider, networkDetails) {
    return __awaiter(this, void 0, void 0, function* () {
      return provider.request({
        method: "wallet_addEthereumChain",
        params: [networkDetails]
      });
    });
  }
}
class Walletconnect {
  static check() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!WalletConnectProvider) {
        console.warn('Walletconnect unavailable: please add below script to enable the feature: <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.6.5/dist/umd/index.min.js"><\/script>');
        return false;
      }
      return true;
    });
  }
  static connect(infuraId, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = new WalletConnectProvider(Object.assign({ infuraId }, options));
      return new Promise((resolve2, reject) => __awaiter(this, void 0, void 0, function* () {
        provider.wc.on("disconnect", (err, payload) => {
          if (!provider.connected) {
            console.log(err, payload);
            reject(new Error("User rejected the request."));
          }
        });
        try {
          yield provider.enable();
        } catch (e2) {
          reject(new Error(e2));
          return;
        }
        resolve2(provider);
      }));
    });
  }
}
class Walletlink {
  static check() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!WalletLink) {
        console.warn("WalletLink unavailable");
        return false;
      }
      return true;
    });
  }
  static connect(infuraId, appName) {
    return __awaiter(this, void 0, void 0, function* () {
      const walletLink = new WalletLink({ appName });
      const provider = walletLink.makeWeb3Provider(`https://mainnet.infura.io/v3/${infuraId}`);
      return new Promise((resolve2, reject) => __awaiter(this, void 0, void 0, function* () {
        provider.on("disconnect", (err, payload) => {
          if (!provider.connected) {
            console.log(err, payload);
            reject(new Error("User rejected the request."));
          }
        });
        try {
          yield provider.enable();
        } catch (e2) {
          reject(new Error(e2.message));
          return;
        }
        resolve2(provider);
      }));
    });
  }
}
const isActivated = ref(false);
const provider$2 = ref(null);
const signer$1 = ref(null);
const network$1 = ref(null);
const address$1 = ref("");
const balance$1 = ref(BigInt(0));
const deactivate = () => {
  isActivated.value = false;
  provider$2.value = null;
  signer$1.value = null;
  network$1.value = null;
  address$1.value = "";
  balance$1.value = BigInt(0);
};
function activate(walletProvider) {
  return __awaiter(this, void 0, void 0, function* () {
    if (!walletProvider)
      throw new Error("Failed to activate: missing provider");
    const _provider = new Web3Provider(walletProvider);
    const _signer = _provider.getSigner();
    const _network = yield _provider.getNetwork();
    const _address = yield _signer.getAddress();
    const _balance = yield _signer.getBalance();
    provider$2.value = markRaw(_provider);
    signer$1.value = markRaw(_signer);
    network$1.value = _network;
    address$1.value = _address;
    balance$1.value = _balance.toBigInt();
    isActivated.value = true;
  });
}
function useEthers() {
  const chainId = computed(() => {
    var _a2;
    return (_a2 = network$1.value) === null || _a2 === void 0 ? void 0 : _a2.chainId;
  });
  return {
    isActivated,
    provider: provider$2,
    signer: signer$1,
    network: network$1,
    address: address$1,
    balance: balance$1,
    chainId,
    activate,
    deactivate
  };
}
const provider$1 = ref(null);
const status = ref("none");
const walletName = ref("none");
const error = ref("");
const onDisconnectCallback = ref(null);
const onAccountsChangedCallback = ref(null);
const onChainChangedCallback = ref(null);
function useWallet(options = { library: "ethers" }) {
  const { activate: activate2, deactivate: deactivate2 } = useEthers();
  function clear2() {
    provider$1.value = null;
    status.value = "none";
    walletName.value = "none";
    error.value = "";
    onDisconnectCallback.value = null;
    onAccountsChangedCallback.value = null;
    onChainChangedCallback.value = null;
    options.library === "ethers" && deactivate2();
  }
  function connect(_walletName, infuraAPI, appName) {
    return __awaiter(this, void 0, void 0, function* () {
      let _provider = null;
      error.value = "";
      try {
        status.value = "connecting";
        switch (_walletName) {
          case "metamask":
            _provider = yield Metamask.connect();
            if (!_provider.isConnected)
              throw new Error("metamask is not connected");
            break;
          case "walletconnect":
            if (!infuraAPI)
              throw new Error("You should provide infuraAPI for connecting WalletConnect");
            _provider = yield Walletconnect.connect(infuraAPI);
            if (!_provider.connected)
              throw new Error("walletconnect is not connected");
            break;
          case "walletlink":
            if (!infuraAPI)
              throw new Error("You should provide infuraAPI for connecting WalletLink");
            if (!appName)
              throw new Error("You should provide an app name for connecting WalletLink");
            _provider = yield Walletlink.connect(infuraAPI, appName);
            if (!_provider.isConnected)
              throw new Error("walletlink is not connected");
            break;
          default:
            throw new Error("Connect Error: wallet name not found");
        }
      } catch (err) {
        clear2();
        error.value = `Failed to connect: ${err.message}`;
        return;
      }
      provider$1.value = markRaw(_provider);
      walletName.value = _walletName;
      status.value = "connected";
      subscribeDisconnect();
      subscribeAccountsChanged();
      subscribeChainChanged();
      try {
        options.library === "ethers" && (yield activate2(provider$1.value));
      } catch (err) {
        clear2();
        error.value = `Failed to load data: ${err.message}`;
        return;
      }
    });
  }
  function disconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      if (walletName.value === "walletconnect") {
        try {
          yield provider$1.value.disconnect();
        } catch (err) {
          console.error(err.message);
        }
      }
      clear2();
      onDisconnectCallback.value && onDisconnectCallback.value("Disconnect from Dapp");
    });
  }
  function subscribeDisconnect() {
    switch (walletName.value) {
      case "metamask":
        provider$1.value.on("disconnect", (err) => {
          clear2();
          onDisconnectCallback.value && onDisconnectCallback.value(err.message);
        });
        break;
      case "walletconnect":
        provider$1.value.on("disconnect", (code2, reason) => {
          clear2();
          onDisconnectCallback.value && onDisconnectCallback.value(`${code2}: ${reason}`);
        });
        break;
      case "walletlink":
        provider$1.value.on("disconnect", (err) => {
          clear2();
          onDisconnectCallback.value && onDisconnectCallback.value(err.message);
        });
        break;
    }
  }
  function subscribeAccountsChanged() {
    switch (walletName.value) {
      case "metamask":
        provider$1.value.on("accountsChanged", (accounts) => __awaiter(this, void 0, void 0, function* () {
          try {
            options.library === "ethers" && (yield activate2(provider$1.value));
            onAccountsChangedCallback.value && onAccountsChangedCallback.value(accounts);
          } catch (err) {
            error.value = `Failed when changing account: ${err.message}`;
            return;
          }
        }));
        break;
      case "walletconnect":
        provider$1.value.on("accountsChanged", (accounts) => __awaiter(this, void 0, void 0, function* () {
          try {
            options.library === "ethers" && (yield activate2(provider$1.value));
            onAccountsChangedCallback.value && onAccountsChangedCallback.value(accounts);
          } catch (err) {
            error.value = `Failed when changing account: ${err.message}`;
            return;
          }
        }));
        break;
      case "walletlink":
        provider$1.value.on("accountsChanged", (accounts) => __awaiter(this, void 0, void 0, function* () {
          try {
            options.library === "ethers" && (yield activate2(provider$1.value));
            onAccountsChangedCallback.value && onAccountsChangedCallback.value(accounts);
          } catch (err) {
            error.value = `Failed when changing account: ${err.message}`;
            return;
          }
        }));
        break;
    }
  }
  function subscribeChainChanged() {
    switch (walletName.value) {
      case "metamask":
        provider$1.value.on("chainChanged", (hexChainId) => __awaiter(this, void 0, void 0, function* () {
          if (!provider$1.value) {
            error.value = `Failed when changing chain: missing provider`;
            return;
          }
          try {
            const chainId = parseInt(hexChainId, 16);
            options.library === "ethers" && (yield activate2(provider$1.value));
            onChainChangedCallback.value && onChainChangedCallback.value(chainId);
          } catch (err) {
            error.value = `Failed when changing chain: ${err.message}`;
            return;
          }
        }));
        break;
      case "walletconnect":
        provider$1.value.on("chainChanged", (chainId) => __awaiter(this, void 0, void 0, function* () {
          if (!provider$1.value) {
            error.value = `Failed when changing chain: missing provider`;
            return;
          }
          try {
            options.library === "ethers" && (yield activate2(provider$1.value));
            onChainChangedCallback.value && onChainChangedCallback.value(chainId);
          } catch (err) {
            error.value = `Failed when changing chain: ${err.message}`;
            return;
          }
        }));
        break;
      case "walletlink":
        provider$1.value.on("chainChanged", (hexChainId) => __awaiter(this, void 0, void 0, function* () {
          if (!provider$1.value) {
            error.value = `Failed when changing chain: missing provider`;
            return;
          }
          try {
            const chainId = parseInt(hexChainId, 16);
            options.library === "ethers" && (yield activate2(provider$1.value));
            onChainChangedCallback.value && onChainChangedCallback.value(chainId);
          } catch (err) {
            error.value = `Failed when changing chain: ${err.message}`;
            return;
          }
        }));
        break;
    }
  }
  function onDisconnect(callback) {
    onDisconnectCallback.value = callback;
  }
  function onAccountsChanged(callback) {
    onAccountsChangedCallback.value = callback;
  }
  function onChainChanged(callback) {
    onChainChangedCallback.value = callback;
  }
  const isConnected = computed(() => {
    if (status.value === "connected")
      return true;
    else
      return false;
  });
  return {
    provider: provider$1,
    status,
    walletName,
    error,
    isConnected,
    connect,
    disconnect,
    onDisconnect,
    onAccountsChanged,
    onChainChanged
  };
}
useEthers();
const clickOutside = {
  beforeMount: (el, binding) => {
    el.clickOutsideEvent = (event) => {
      event.stopPropagation();
      if (event.target !== el && !el.contains(event.target)) {
        binding.value(event);
      }
    };
    const clickHandler = "ontouchstart" in document.documentElement ? "touchstart" : "click";
    setTimeout(() => {
      document.addEventListener(clickHandler, el.clickOutsideEvent);
    }, 0);
  },
  unmounted: (el) => {
    const clickOutsideEvent = el.clickOutsideEvent;
    delete el.clickOutsideEvent;
    const clickHandler = "ontouchstart" in document.documentElement ? "touchstart" : "click";
    document.removeEventListener(clickHandler, clickOutsideEvent);
  }
};
var script$4 = defineComponent({
  emits: ["close"],
  props: {
    modalOpen: {
      type: Boolean,
      required: true
    }
  },
  setup(props, { emit: emit2 }) {
    const closeModal = () => {
      emit2("close");
    };
    watch(() => props.modalOpen, (value2) => {
      if (value2) {
        document.body.style.overflow = "hidden";
      } else {
        document.body.style.overflow = "";
      }
    });
    return {
      closeModal
    };
  }
});
pushScopeId("data-v-701ac82d");
const _hoisted_1$4 = {
  key: 0,
  class: "modal"
};
const _hoisted_2$4 = { class: "modal-inner" };
const _hoisted_3$3 = { class: "modal-content" };
popScopeId();
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Teleport, { to: "body" }, [
    createVNode(Transition, { name: "modal-animation" }, {
      default: withCtx(() => [
        _ctx.modalOpen ? (openBlock(), createElementBlock("div", _hoisted_1$4, [
          createBaseVNode("div", _hoisted_2$4, [
            createBaseVNode("div", _hoisted_3$3, [
              createCommentVNode(" Modal Content "),
              renderSlot(_ctx.$slots, "default")
            ])
          ])
        ])) : createCommentVNode("v-if", true)
      ]),
      _: 3
    })
  ]);
}
function styleInject(css, ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var insertAt = ref2.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
var css_248z$1 = "\n.modal[data-v-701ac82d] {\n  position: fixed;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n  min-width: 100%;\n  height: 100%;\n  background-color: rgba(107, 114, 128, 0.7);\n  left: 0px;\n  top: 0px;\n  z-index: 50;\n}\n.modal-inner[data-v-701ac82d] {\n  display: flex;\n  background: #ffffff;\n  border-radius: 1rem;\n  box-shadow: rgba(255, 255, 255, 0.1) 0px 1px 1px 0px inset,\n    rgba(50, 50, 93, 0.25) 0px 50px 100px -20px,\n    rgba(0, 0, 0, 0.3) 0px 30px 60px -30px;\n}\n.modal-animation-enter-active[data-v-701ac82d],\n.modal-animation-leave-active[data-v-701ac82d] {\n  transition: opacity 0.3s cubic-bezier(0.52, 0.02, 0.19, 1.02);\n}\n.modal-animation-enter-from[data-v-701ac82d],\n.modal-animation-leave-to[data-v-701ac82d] {\n  opacity: 0;\n}\n";
styleInject(css_248z$1);
script$4.render = render$4;
script$4.__scopeId = "data-v-701ac82d";
script$4.__file = "src/components/Modal.vue";
const _hoisted_1$3 = {
  height: "246",
  viewBox: "0 0 400 246",
  width: "400",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$3 = /* @__PURE__ */ createBaseVNode("path", {
  d: "m81.9180572 48.3416816c65.2149658-63.8508884 170.9493158-63.8508884 236.1642788 0l7.848727 7.6845565c3.260748 3.1925442 3.260748 8.3686816 0 11.5612272l-26.848927 26.2873374c-1.630375 1.5962734-4.273733 1.5962734-5.904108 0l-10.800779-10.5748639c-45.495589-44.5439756-119.258514-44.5439756-164.754105 0l-11.566741 11.3248068c-1.630376 1.5962721-4.273735 1.5962721-5.904108 0l-26.8489263-26.2873375c-3.2607483-3.1925456-3.2607483-8.3686829 0-11.5612272zm291.6903948 54.3649934 23.895596 23.395862c3.260732 3.19253 3.260751 8.368636.000041 11.561187l-107.746894 105.494845c-3.260726 3.192568-8.547443 3.192604-11.808214.000083-.000013-.000013-.000029-.000029-.000042-.000043l-76.472191-74.872762c-.815187-.798136-2.136867-.798136-2.952053 0-.000006.000005-.00001.00001-.000015.000014l-76.470562 74.872708c-3.260715 3.192576-8.547434 3.19263-11.808215.000116-.000019-.000018-.000039-.000037-.000059-.000058l-107.74989297-105.496247c-3.26074695-3.192544-3.26074695-8.368682 0-11.561226l23.89563947-23.395823c3.260747-3.1925446 8.5474652-3.1925446 11.8082136 0l76.4733029 74.873809c.815188.798136 2.136866.798136 2.952054 0 .000012-.000012.000023-.000023.000035-.000032l76.469471-74.873777c3.260673-3.1926181 8.547392-3.1927378 11.808214-.000267.000046.000045.000091.00009.000135.000135l76.473203 74.873909c.815186.798135 2.136866.798135 2.952053 0l76.471967-74.872433c3.260748-3.1925458 8.547465-3.1925458 11.808213 0z",
  fill: "#3b99fc"
}, null, -1);
const _hoisted_3$2 = [
  _hoisted_2$3
];
function render$3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3, _hoisted_3$2);
}
const script$3 = {};
script$3.render = render$3;
script$3.__file = "src/components/logos/WalletConnect.vue";
const _hoisted_1$2 = {
  height: "355",
  viewBox: "0 0 397 355",
  width: "397",
  xmlns: "http://www.w3.org/2000/svg"
};
const _hoisted_2$2 = /* @__PURE__ */ createStaticVNode('<g fill="none" fill-rule="evenodd" transform="translate(-1 -1)"><path d="m114.622644 327.195472 52.004717 13.810198v-18.05949l4.245283-4.249292h29.716982v21.246459 14.872523h-31.839624l-39.268868-16.997169z" fill="#cdbdb2"></path><path d="m199.528305 327.195472 50.943397 13.810198v-18.05949l4.245283-4.249292h29.716981v21.246459 14.872523h-31.839623l-39.268868-16.997169z" fill="#cdbdb2" transform="matrix(-1 0 0 1 483.96227 0)"></path><path d="m170.872644 287.889523-4.245283 35.056657 5.306604-4.249292h55.18868l6.367925 4.249292-4.245284-35.056657-8.490565-5.311615-42.452832 1.062323z" fill="#393939"></path><path d="m142.216984 50.9915022 25.471698 59.4900858 11.674528 173.158643h41.391511l12.735849-173.158643 23.349056-59.4900858z" fill="#f89c35"></path><path d="m30.7783023 181.657226-29.71698153 86.048161 74.29245393-4.249293h47.7594343v-37.181303l-2.122641-76.487253-10.613208 8.498583z" fill="#f89d35"></path><path d="m87.0283032 191.218134 87.0283028 2.124646-9.551886 44.617563-41.391511-10.623229z" fill="#d87c30"></path><path d="m87.0283032 192.280457 36.0849058 33.994334v33.994334z" fill="#ea8d3a"></path><path d="m123.113209 227.337114 42.452831 10.623229 13.79717 45.679888-9.551886 5.311615-46.698115-27.620398z" fill="#f89d35"></path><path d="m123.113209 261.331448-8.490565 65.864024 56.25-39.305949z" fill="#eb8f35"></path><path d="m174.056606 193.34278 5.306604 90.297451-15.919812-46.211049z" fill="#ea8e3a"></path><path d="m74.2924539 262.393771 48.8207551-1.062323-8.490565 65.864024z" fill="#d87c30"></path><path d="m24.4103777 355.878193 90.2122663-28.682721-40.3301901-64.801701-73.23113313 5.311616z" fill="#eb8f35"></path><path d="m167.688682 110.481588-45.636793 38.243627-35.0235858 42.492919 87.0283028 3.186969z" fill="#e8821e"></path><path d="m114.622644 327.195472 56.25-39.305949-4.245283 33.994334v19.121813l-38.207548-7.43626z" fill="#dfcec3"></path><path d="m229.245286 327.195472 55.18868-39.305949-4.245283 33.994334v19.121813l-38.207548-7.43626z" fill="#dfcec3" transform="matrix(-1 0 0 1 513.679252 0)"></path><path d="m132.665096 212.464593-11.674528 24.433427 41.39151-10.623229z" fill="#393939" transform="matrix(-1 0 0 1 283.372646 0)"></path><path d="m23.349057 1.06232296 144.339625 109.41926504-24.410378-59.4900858z" fill="#e88f35"></path><path d="m23.349057 1.06232296-19.10377392 58.42776294 10.61320772 63.7393781-7.42924541 4.249292 10.61320771 9.560906-8.49056617 7.436261 11.67452847 10.623229-7.4292454 6.373938 16.9811323 21.246459 79.5990577-24.433428c38.915096-31.161473 58.018869-47.096318 57.311322-47.804533-.707548-.708215-48.820756-37.1813036-144.339625-109.41926504z" fill="#8e5a30"></path><g transform="matrix(-1 0 0 1 399.056611 0)"><path d="m30.7783023 181.657226-29.71698153 86.048161 74.29245393-4.249293h47.7594343v-37.181303l-2.122641-76.487253-10.613208 8.498583z" fill="#f89d35"></path><path d="m87.0283032 191.218134 87.0283028 2.124646-9.551886 44.617563-41.391511-10.623229z" fill="#d87c30"></path><path d="m87.0283032 192.280457 36.0849058 33.994334v33.994334z" fill="#ea8d3a"></path><path d="m123.113209 227.337114 42.452831 10.623229 13.79717 45.679888-9.551886 5.311615-46.698115-27.620398z" fill="#f89d35"></path><path d="m123.113209 261.331448-8.490565 65.864024 55.18868-38.243626z" fill="#eb8f35"></path><path d="m174.056606 193.34278 5.306604 90.297451-15.919812-46.211049z" fill="#ea8e3a"></path><path d="m74.2924539 262.393771 48.8207551-1.062323-8.490565 65.864024z" fill="#d87c30"></path><path d="m24.4103777 355.878193 90.2122663-28.682721-40.3301901-64.801701-73.23113313 5.311616z" fill="#eb8f35"></path><path d="m167.688682 110.481588-45.636793 38.243627-35.0235858 42.492919 87.0283028 3.186969z" fill="#e8821e"></path><path d="m132.665096 212.464593-11.674528 24.433427 41.39151-10.623229z" fill="#393939" transform="matrix(-1 0 0 1 283.372646 0)"></path><path d="m23.349057 1.06232296 144.339625 109.41926504-24.410378-59.4900858z" fill="#e88f35"></path><path d="m23.349057 1.06232296-19.10377392 58.42776294 10.61320772 63.7393781-7.42924541 4.249292 10.61320771 9.560906-8.49056617 7.436261 11.67452847 10.623229-7.4292454 6.373938 16.9811323 21.246459 79.5990577-24.433428c38.915096-31.161473 58.018869-47.096318 57.311322-47.804533-.707548-.708215-48.820756-37.1813036-144.339625-109.41926504z" fill="#8e5a30"></path></g></g>', 1);
const _hoisted_3$1 = [
  _hoisted_2$2
];
function render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2, _hoisted_3$1);
}
const script$2 = {};
script$2.render = render$2;
script$2.__file = "src/components/logos/MetaMask.vue";
const _hoisted_1$1 = {
  viewBox: "0 0 128 128",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
const _hoisted_2$1 = /* @__PURE__ */ createStaticVNode('<defs><circle id="a" cx="59.928" cy="59.928" r="59.928"></circle><linearGradient x1="50%" y1="0%" x2="50%" y2="100%" id="c"><stop stop-color="#2E66F8" offset="0%"></stop><stop stop-color="#124ADB" offset="100%"></stop></linearGradient></defs><g fill="none" fill-rule="evenodd"><path fill="#FFF" fill-rule="nonzero" d="M0 0h128v128H0z"></path><path fill="#FFF" fill-rule="nonzero" d="M0 0h128v128H0z"></path><path d="M0 0h128v128H0z"></path><path d="M19 64c0 24.853 20.147 45 45 45s45-20.147 45-45-20.147-45-45-45-45 20.147-45 45zm33.5-14.5a3 3 0 0 0-3 3v23a3 3 0 0 0 3 3h23a3 3 0 0 0 3-3v-23a3 3 0 0 0-3-3h-23z" fill="#FFF"></path><g transform="translate(4 4)"><mask id="b" fill="#fff"><use xlink:href="#a"></use></mask><g mask="url(#b)"><path d="M0 0h119.856v119.856H0z"></path><rect fill="url(#c)" fill-rule="nonzero" width="119.856" height="119.856" rx="48"></rect><path d="M24.97 59.928c0 19.307 15.651 34.958 34.958 34.958s34.958-15.651 34.958-34.958S79.235 24.97 59.928 24.97 24.97 40.62 24.97 59.928zm26.024-11.264a2.33 2.33 0 0 0-2.33 2.33v17.868a2.33 2.33 0 0 0 2.33 2.33h17.868a2.33 2.33 0 0 0 2.33-2.33V50.994a2.33 2.33 0 0 0-2.33-2.33H50.994z" fill="#FFF"></path></g></g></g>', 2);
const _hoisted_4$1 = [
  _hoisted_2$1
];
function render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1, _hoisted_4$1);
}
const script$1 = {};
script$1.render = render$1;
script$1.__file = "src/components/logos/WalletLink.vue";
var script = defineComponent({
  components: {
    Modal: script$4,
    MetaMaskIcon: script$2,
    WalletConnectIcon: script$3,
    WalletLinkIcon: script$1
  },
  inject: ["infuraId"],
  setup() {
    const { boardOpen: boardOpen2, close } = useBoard();
    const { connect, status: status2 } = useWallet();
    const metamaskDisabled = ref(true);
    const walletconnectDisabled = ref(true);
    const walletlinkDisabled = ref(true);
    const infuraId = inject("infuraId");
    const appName = inject("appName");
    onMounted(() => __awaiter(this, void 0, void 0, function* () {
      if (yield Metamask.check()) {
        metamaskDisabled.value = false;
      }
      if (infuraId && (yield Walletconnect.check())) {
        walletconnectDisabled.value = false;
      }
      if (infuraId && appName && (yield Walletlink.check())) {
        walletlinkDisabled.value = false;
      }
    }));
    const loadingOpen = ref(false);
    const openLoading = () => {
      loadingOpen.value = true;
    };
    const closeLoading = () => {
      loadingOpen.value = false;
    };
    const connectWallet = (wallet) => __awaiter(this, void 0, void 0, function* () {
      try {
        switch (wallet) {
          case "metamask":
            yield connectMetamask();
            break;
          case "walletconnect":
            yield connectWalletconnect();
            break;
          case "walletlink":
            yield connectWalletlink();
            break;
        }
      } catch (e2) {
        console.error(e2.message);
      } finally {
        closeLoading();
      }
    });
    const connectMetamask = () => __awaiter(this, void 0, void 0, function* () {
      if (metamaskDisabled.value)
        return;
      close();
      openLoading();
      yield connect("metamask");
    });
    const connectWalletconnect = () => __awaiter(this, void 0, void 0, function* () {
      if (walletconnectDisabled.value)
        return;
      close();
      openLoading();
      yield connect("walletconnect", infuraId);
    });
    const connectWalletlink = () => __awaiter(this, void 0, void 0, function* () {
      if (walletlinkDisabled.value)
        return;
      close();
      openLoading();
      yield connect("walletlink", infuraId, appName);
    });
    return {
      status: status2,
      boardOpen: boardOpen2,
      metamaskDisabled,
      walletconnectDisabled,
      walletlinkDisabled,
      close,
      connectWallet,
      loadingOpen,
      openLoading,
      closeLoading
    };
  }
});
pushScopeId("data-v-e1ee1034");
const _hoisted_1 = { class: "item" };
const _hoisted_2 = /* @__PURE__ */ createBaseVNode("div", null, "MetaMask", -1);
const _hoisted_3 = /* @__PURE__ */ createBaseVNode("div", { class: "line" }, null, -1);
const _hoisted_4 = { class: "item" };
const _hoisted_5 = /* @__PURE__ */ createBaseVNode("div", null, "WalletConnect", -1);
const _hoisted_6 = /* @__PURE__ */ createBaseVNode("div", { class: "line" }, null, -1);
const _hoisted_7 = { class: "item" };
const _hoisted_8 = /* @__PURE__ */ createBaseVNode("div", null, "Coinbase Wallet", -1);
const _hoisted_9 = {
  key: 0,
  class: "loading-modal"
};
const _hoisted_10 = /* @__PURE__ */ createBaseVNode("p", null, "Pending Call Request", -1);
const _hoisted_11 = /* @__PURE__ */ createBaseVNode("p", null, "Approve or reject request using your wallet", -1);
const _hoisted_12 = [
  _hoisted_10,
  _hoisted_11
];
const _hoisted_13 = { key: 1 };
popScopeId();
function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_MetaMaskIcon = resolveComponent("MetaMaskIcon");
  const _component_WalletConnectIcon = resolveComponent("WalletConnectIcon");
  const _component_WalletLinkIcon = resolveComponent("WalletLinkIcon");
  const _component_Modal = resolveComponent("Modal");
  const _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createElementBlock(Fragment$1, null, [
    createVNode(_component_Modal, {
      modalOpen: _ctx.boardOpen,
      onClose: _ctx.close
    }, {
      default: withCtx(() => [
        withDirectives(createBaseVNode("div", null, [
          createBaseVNode("div", {
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.connectWallet("metamask")),
            class: normalizeClass(["wallet-item", _ctx.metamaskDisabled ? "wallet-disabled" : ""])
          }, [
            createBaseVNode("div", _hoisted_1, [
              createVNode(_component_MetaMaskIcon, { class: "logo" }),
              _hoisted_2
            ])
          ], 2),
          _hoisted_3,
          createBaseVNode("div", {
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.connectWallet("walletconnect")),
            class: normalizeClass(["wallet-item", _ctx.walletconnectDisabled ? "wallet-disabled" : ""])
          }, [
            createBaseVNode("div", _hoisted_4, [
              createVNode(_component_WalletConnectIcon, { class: "logo" }),
              _hoisted_5
            ])
          ], 2),
          _hoisted_6,
          createBaseVNode("div", {
            onClick: _cache[2] || (_cache[2] = ($event) => _ctx.connectWallet("walletlink")),
            class: normalizeClass(["wallet-item", _ctx.walletlinkDisabled ? "wallet-disabled" : ""])
          }, [
            createBaseVNode("div", _hoisted_7, [
              createVNode(_component_WalletLinkIcon, { class: "logo" }),
              _hoisted_8
            ])
          ], 2)
        ], 512), [
          [_directive_click_outside, _ctx.close]
        ])
      ]),
      _: 1
    }, 8, ["modalOpen", "onClose"]),
    createVNode(_component_Modal, { modalOpen: _ctx.loadingOpen }, {
      default: withCtx(() => [
        _ctx.status === "connecting" ? (openBlock(), createElementBlock("div", _hoisted_9, _hoisted_12)) : createCommentVNode("v-if", true),
        createCommentVNode(" loading between connected to isActivated "),
        _ctx.status === "connected" ? (openBlock(), createElementBlock("div", _hoisted_13)) : createCommentVNode("v-if", true)
      ]),
      _: 1
    }, 8, ["modalOpen"])
  ], 64);
}
var css_248z = "\n.wallet-item[data-v-e1ee1034] {\n  display: flex;\n  justify-content: center;\n  padding-top: 1rem;\n  padding-bottom: 0.6rem;\n  padding-left: 1rem;\n  padding-right: 1rem;\n  margin: 0.5rem;\n  border-radius: 0.75rem;\n  cursor: pointer;\n}\n.wallet-item[data-v-e1ee1034]:hover {\n  background-color: rgba(243, 244, 246, 0.664);\n}\n@media (min-width: 640px) {\n.wallet-item[data-v-e1ee1034] {\n    width: 24rem;\n}\n}\n.item[data-v-e1ee1034] {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  font-size: 1.5rem;\n  line-height: 2rem;\n}\n.item[data-v-e1ee1034] > :not([hidden]) ~ :not([hidden]) {\n  margin-top: 1rem;\n  margin-bottom: 1rem;\n}\n.line[data-v-e1ee1034] {\n  color: #e5e7eb;\n  border-width: 0px;\n  border-bottom-width: 1px;\n  border-style: solid;\n}\n.logo[data-v-e1ee1034] {\n  width: 50px;\n  height: 50px;\n}\n.wallet-disabled[data-v-e1ee1034] {\n  opacity: 0.5;\n}\n.wallet-disabled[data-v-e1ee1034]:hover {\n  background-color: rgba(255, 255, 255, 0.623);\n  cursor: default;\n}\n.loading-modal[data-v-e1ee1034] {\n  width: 20rem;\n  padding: 2.5rem;\n  text-align: center;\n}\n.loading-modal > p[data-v-e1ee1034]:first-child {\n  font-size: 1.25rem;\n  line-height: 1.75rem;\n}\n@media (min-width: 640px) {\n.loading-modal[data-v-e1ee1034] {\n    width: auto;\n}\n}\n";
styleInject(css_248z);
script.render = render;
script.__scopeId = "data-v-e1ee1034";
script.__file = "src/components/Board.vue";
const VueDapp = {
  install(app, options) {
    if (!(options === null || options === void 0 ? void 0 : options.infuraId)) {
      console.warn('For enabling WalletConnect and WalletLink, you should provide infura ID in plugin options like "app.use(VueDapp, { infuraId: "<your-id>" })"');
    }
    if (!(options === null || options === void 0 ? void 0 : options.appName)) {
      console.warn('For enabling WalletLink, you should provide the App Name in plugin options like "app.use(VueDapp, { appName: "<your-app-name>" })"');
    }
    app.directive("click-outside", clickOutside);
    app.component("vdapp-board", script);
    app.component("vdapp-modal", script$4);
    app.provide("infuraId", options === null || options === void 0 ? void 0 : options.infuraId);
    app.provide("appName", options === null || options === void 0 ? void 0 : options.appName);
  }
};
var browser = { exports: {} };
var process$1 = browser.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e2) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e2) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e2) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e3) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e2) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e3) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout2 = runTimeout(cleanUpNextTick);
  draining = true;
  var len2 = queue.length;
  while (len2) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len2) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len2 = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout2);
}
process$1.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      args[i2 - 1] = arguments[i2];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array2) {
  this.fun = fun;
  this.array = array2;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process$1.title = "browser";
process$1.browser = true;
process$1.env = {};
process$1.argv = [];
process$1.version = "";
process$1.versions = {};
function noop() {
}
process$1.on = noop;
process$1.addListener = noop;
process$1.once = noop;
process$1.off = noop;
process$1.removeListener = noop;
process$1.removeAllListeners = noop;
process$1.emit = noop;
process$1.prependListener = noop;
process$1.prependOnceListener = noop;
process$1.listeners = function(name2) {
  return [];
};
process$1.binding = function(name2) {
  throw new Error("process.binding is not supported");
};
process$1.cwd = function() {
  return "/";
};
process$1.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process$1.umask = function() {
  return 0;
};
var process$2 = browser.exports;
export { useEthers as A, shortenAddress as B, displayEther as C, pushScopeId as D, popScopeId as E, useBoard as F, process$2 as G, buffer$2 as H, util$7 as I, createApp as J, createRouter as K, createWebHashHistory as L, useMouse as M, NProgress as N, useCounter as O, onMounted as P, getCurrentInstance as Q, watchEffect as R, Fragment$1 as S, renderList as T, createCommentVNode as U, VueDapp as V, createI18n as a, createPinia as b, createHead as c, defineStore as d, computed as e, defineComponent as f, useHead as g, useI18n as h, resolveComponent as i, createElementBlock as j, createBaseVNode as k, unref as l, withKeys as m, createVNode as n, withCtx as o, openBlock as p, createTextVNode as q, ref as r, createStaticVNode as s, toDisplayString$1 as t, useRouter as u, vModelText as v, withDirectives as w, useDark as x, useToggle as y, createBlock as z };
